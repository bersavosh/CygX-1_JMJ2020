SUBROUTINE lightcurve(nphase,nmaxphase,xmod,ymodu,ymodb,ymodv,ymodr,ymodi,  &
   ymodj,ymodh,ymodk,ymods1,ymods2,ymods3,ymodd,rv1,rv2,drv1,drv2,obsparm,  &
   ifastflag,nrvphase,xrvmod,fracs1,fracs2,fracs3,fracs4,fracs5,fracs6,  &
   fracs7,fracs8,ncycle,ttimes,tseps,rv3,parmstring,planetparm,dynparm,  &
   fill1,fill2,omega1,omega2,dphase,q,finc,teff1,teff2,tgrav1,tgrav2,  &
   betarim,rinner,router,tdisk,xi,alb1,alb2,rlx,period,fm,separ,gamma,wave,  &
   dbolx,dboly,dwavex,dwavey,t3,g3,sa3,density,sw1,sw2,sw3,t0,ecc,argper,  &
   pshift,sw5,sw6,sw7,sw8,sw9,primmass,primk,primrad,ratrad,frac1,frac2,  &
   ecosw,temprat,bigi,bigbeta,sw23,sw24,sw25,sw26,sw27,sw28,sw29,sw30,  &
   contam,tconj,beam1,beam2,ocose,osine,omegadot,contams0,contams1,contams2,  &
   contams3,sw47,sw48,sw49,gaplow,gaphigh,p2tconj,p2period,p2t0,p2ecos,  &
   p2esin,p2incl,p2omega,p2q,p2ratrad,p3tconj,p3period,p3t0,p3ecos,p3esin,  &
   p3incl,p3omega,p3q,p3ratrad,p4tconj,p4period,p4t0,p4ecos,p4esin,p4incl,  &
   p4omega,p4q,p4ratrad,p5tconj,p5period,p5t0,p5ecos,p5esin,p5incl,p5omega,  &
   p5q,p5ratrad,p6tconj,p6period,p6t0,p6ecos,p6esin,p6incl,p6omega,p6q,  &
   p6ratrad,p7tconj,p7period,p7t0,p7ecos,p7esin,p7incl,p7omega,p7q,p7ratrad,  &
   p8tconj,p8period,p8t0,p8ecos,p8esin,p8incl,p8omega,p8q,p8ratrad,xsc,ysc,  &
   spot1parm,spot2parm,spotdparm,nalph1,nbet1,nalph2,nbet2,ntheta,nradius,  &
   nref,idraw,iecheck,iidint,iatm,ism1,ilaw,icnu,icnb,icnv,icnr,icni,icnj,  &
   icnh,icnk,icnrv1,icnrv2,irvfilt,isw1,isw2,isw3,isw4,ikeep,isynch,isw5,  &
   isw6,isw7,isw8,isw9,idark1,idark2,isw12,isw13,isw21,isw22,isw23,isw24,  &
   isw25,isw26,isw27,isw28,isw29,isw30,isw31,isw32,isw33,isw34,nsc,  &
   compfracs,tertperiod,tertt0,tertecos,tertesin,tertincl,tertomega,tertq,  &
   tertconj,tertratrad,hh,sw72,sw73,nmxeclipse,tdur1,tdur2,ioutflag,sw80,  &
   sw81,sw82,sw83,sw84,sw85,isw80,isw81,isw82,isw83,isw84,isw85,isw86,isw87,  &
   isw88,isw89,ymods4,ymods5,arrsobx,arrsoby,montemax,rv4,sdarkint1,  &
   sdarkint2,sdarkint3,sdarkint4,sdarkint5,atmt,atmg,atmmu,atmint1,atmint2,  &
   atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,tmin,nlines,nmu,nalph3,  &
   nbet3,itconj,it1,it2,it3,it4,ndynwin,dynwinlow,dynwinhigh,p1mtc,p1ptc,  &
   p2mtc,p2ptc,p3mtc,p3ptc,p4mtc,p4ptc,p5mtc,p5ptc,p6mtc,p6ptc,p7mtc,p7ptc,  &
   p8mtc,p8ptc,pbmtc,pbptc,bigi2,bigi3,bigi4,bigbeta2,bigbeta3,bigbeta4,  &
   bin2q,bn2massdff,bn2masssum,bn2raddiff,bn2radsum,bin2ratrad,g10,g6,g7,g8,  &
   g9,massdiff,masssum,omega3,omega4,omega5,omega6,omega7,omega8,omega9,  &
   omega10,raddiff,radsum,rk3,rk4,rk5,rk6,rk7,rk8,rk9,rk10,sdarkint6,  &
   sdarkint7,sdarkint8,sdarkint9,sdarkint10,secmass,secrad,t10,t6,t7,t8,t9,  &
   nseg,isw100,iunit,fracsum,fracdiff,bin2m3,bin2m4,bin2r3,bin2r4,sqecos,  &
   sqesin,sqtertecos,sqtertesin,sqp2ecos,sqp2esin,sqp3ecos,sqp3esin,  &
   sqp4ecos,sqp4esin,sqp5ecos,sqp5esin,sqp6ecos,sqp6esin,sqp7ecos,sqp7esin,  &
   sqp8ecos,sqp8esin,angsum1,angdiff1,angsum2,angdiff2,angsum3,angdiff3,  &
   angsum4,angdiff4,angsum5,angdiff5,angsum6,angdiff6,angsum7,angdiff7,  &
   angsum8,angdiff8,imag,newparmstr,fillsum,filldiff,binqtc,p1qtc,p2qtc,  &
   p3qtc,p4qtc,p5qtc,p6qtc,p7qtc,p8qtc,tbinoff,t1off,t2off,t3off,t4off,  &
   t5off,t6off,t7off,t8off,inopt,fracstring,drv3,drv4,drv5,rv5,orbitparm,  &
   iversion,tesscontam,tessfilt,tessbin,maxlines,maxmu)        
!
!   October 6, 1999
!
!   This subroutine will call all of the needed subroutines
!   to set up geometry, etc.
!
!   obsparm(1) = mass of star 1      (solar)
!   obsparm(2) = radius of star 1    (solar)
!   obsparm(3) = gravity of star 1   (log cgs)
!   obsparm(4) = V_rot*sin(i) star 1 (km/sec)
!   obsparm(5) = mass of star 2      (solar)
!   obsparm(6) = radius of star 2    (solar)
!   obsparm(7) = gravity of star 2   (log cgs)
!   obsparm(8) = V_rot*sin(i) star 2 (km/sec)
!   obsparm(9) = duration of X-ray eclipse (degrees)
!   obsparm(10) = K_1 (km/sec)
!   obsparm(11) = K_2 (km/sec)
!   obsparm(12) = finc (deg)
!   obsparm(13) = Q
!   obsparm(14) = ecc
!   obsparm(15) = argper (deg)
!   obsparm(16) = Teff1
!   obsparm(17) = Teff2
!   obsparm(18) = (R1+R2)/separ
!   obsparm(19) = Teff3 (t3)
!   obsparm(20) = mass of star 3      (solar)
!   obsparm(21) = radius of star 3    (solar)
!   obsparm(22) = mass of star 4      (solar)
!   obsparm(23) = radius of star 4    (solar)
!   obsparm(24) = mass of star 5      (solar)
!   obsparm(25) = radius of star 5    (solar)
!
!
!   UPDATE September 11, 2001
!
!   Add the X-ray eclipse duration in degrees (if any) to obsparm(9).
!
!   **************************************************
!
!   February 5, 2001
!
!   This major revision includes the generalization to eccentric
!   orbits.
!
   USE accur
   USE getpie
   USE constants

   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: maxlines
   INTEGER, INTENT(IN)                      :: maxmu
   INTEGER, INTENT(IN)                      :: nmxeclipse
   INTEGER, INTENT(OUT)                     :: nphase
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN)                      :: montemax
   REAL(KIND=dp), INTENT(OUT)               :: xmod(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodu(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodb(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodv(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodr(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodi(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodj(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodh(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodk(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods2(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods3(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodd(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: rv1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: rv2(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv2(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: obsparm(25)
   INTEGER, INTENT(IN OUT)                  :: ifastflag
   INTEGER, INTENT(OUT)                     :: nrvphase
   REAL(KIND=dp), INTENT(OUT)               :: xrvmod(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: fracs1(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs2(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs3(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs4(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs5(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs6(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs7(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs8(nmaxphase,4)
   INTEGER, INTENT(OUT)                     :: ncycle(40)
   REAL(KIND=dp), INTENT(OUT)               :: ttimes(40,nmxeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: tseps(40,nmxeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: rv3(nmaxphase)
   CHARACTER (LEN=1000), INTENT(OUT)        :: parmstring
   CHARACTER (LEN=3000), INTENT(OUT)        :: planetparm
   CHARACTER (LEN=1700), INTENT(OUT)        :: dynparm
   REAL(KIND=dp), INTENT(IN OUT)            :: fill1
   REAL(KIND=dp), INTENT(IN OUT)            :: fill2
   REAL(KIND=dp), INTENT(IN OUT)            :: omega1
   REAL(KIND=dp), INTENT(IN OUT)            :: omega2
   REAL(KIND=dp), INTENT(IN OUT)            :: dphase
   REAL(KIND=dp), INTENT(IN OUT)            :: q
   REAL(KIND=dp), INTENT(IN OUT)            :: finc
   REAL(KIND=dp), INTENT(IN OUT)            :: teff1
   REAL(KIND=dp), INTENT(IN OUT)            :: teff2
   REAL(KIND=dp), INTENT(IN OUT)            :: tgrav1
   REAL(KIND=dp), INTENT(IN OUT)            :: tgrav2
   REAL(KIND=dp), INTENT(IN OUT)            :: betarim
   REAL(KIND=dp), INTENT(IN OUT)            :: rinner
   REAL(KIND=dp), INTENT(IN OUT)            :: router
   REAL(KIND=dp), INTENT(IN OUT)            :: tdisk
   REAL(KIND=dp), INTENT(IN OUT)            :: xi
   REAL(KIND=dp), INTENT(IN OUT)            :: alb1
   REAL(KIND=dp), INTENT(IN OUT)            :: alb2
   REAL(KIND=dp), INTENT(IN OUT)            :: rlx
   REAL(KIND=dp), INTENT(IN OUT)            :: period
   REAL(KIND=dp), INTENT(IN OUT)            :: fm
   REAL(KIND=dp), INTENT(IN OUT)            :: separ
   REAL(KIND=dp), INTENT(IN OUT)            :: gamma
   REAL(KIND=dp), INTENT(IN OUT)            :: wave(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: dbolx(8,2)
   REAL(KIND=dp), INTENT(IN OUT)            :: dboly(8,2)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: t3
   REAL(KIND=dp), INTENT(IN OUT)            :: g3
   REAL(KIND=dp), INTENT(IN OUT)            :: sa3
   REAL(KIND=dp), INTENT(IN OUT)            :: density
   REAL(KIND=dp), INTENT(IN OUT)            :: sw1
   REAL(KIND=dp), INTENT(IN OUT)            :: sw2
   REAL(KIND=dp), INTENT(IN OUT)            :: sw3
   REAL(KIND=dp), INTENT(IN OUT)            :: t0
   REAL(KIND=dp), INTENT(IN OUT)            :: ecc
   REAL(KIND=dp), INTENT(IN OUT)            :: argper
   REAL(KIND=dp), INTENT(IN OUT)            :: pshift
   REAL(KIND=dp), INTENT(IN OUT)            :: sw5
   REAL(KIND=dp), INTENT(IN OUT)            :: sw6
   REAL(KIND=dp), INTENT(IN OUT)            :: sw7
   REAL(KIND=dp), INTENT(IN OUT)            :: sw8
   REAL(KIND=dp), INTENT(IN OUT)            :: sw9
   REAL(KIND=dp), INTENT(IN OUT)            :: primmass
   REAL(KIND=dp), INTENT(IN OUT)            :: primk
   REAL(KIND=dp), INTENT(IN OUT)            :: primrad
   REAL(KIND=dp), INTENT(IN OUT)            :: ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: frac1
   REAL(KIND=dp), INTENT(IN OUT)            :: frac2
   REAL(KIND=dp), INTENT(IN OUT)            :: ecosw
   REAL(KIND=dp), INTENT(IN OUT)            :: temprat
   REAL(KIND=dp), INTENT(IN OUT)            :: bigi
   REAL(KIND=dp), INTENT(IN OUT)            :: bigbeta
   REAL(KIND=dp), INTENT(IN OUT)            :: sw23
   REAL(KIND=dp), INTENT(IN OUT)            :: sw24
   REAL(KIND=dp), INTENT(IN OUT)            :: sw25
   REAL(KIND=dp), INTENT(IN OUT)            :: sw26
   REAL(KIND=dp), INTENT(IN OUT)            :: sw27
   REAL(KIND=dp), INTENT(IN OUT)            :: sw28
   REAL(KIND=dp), INTENT(IN OUT)            :: sw29
   REAL(KIND=dp), INTENT(IN OUT)            :: sw30
   REAL(KIND=dp), INTENT(IN OUT)            :: contam
   REAL(KIND=dp), INTENT(IN OUT)            :: tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: beam1
   REAL(KIND=dp), INTENT(IN OUT)            :: beam2
   REAL(KIND=dp), INTENT(IN OUT)            :: ocose
   REAL(KIND=dp), INTENT(IN OUT)            :: osine
   REAL(KIND=dp), INTENT(IN OUT)            :: omegadot
   REAL(KIND=dp), INTENT(IN OUT)            :: contams0
   REAL(KIND=dp), INTENT(IN OUT)            :: contams1
   REAL(KIND=dp), INTENT(IN OUT)            :: contams2
   REAL(KIND=dp), INTENT(IN OUT)            :: contams3
   REAL(KIND=dp), INTENT(IN OUT)            :: sw47
   REAL(KIND=dp), INTENT(IN OUT)            :: sw48
   REAL(KIND=dp), INTENT(IN OUT)            :: sw49
   REAL(KIND=dp), INTENT(IN OUT)            :: gaplow(9999)
   REAL(KIND=dp), INTENT(IN OUT)            :: gaphigh(9999)
   REAL(KIND=dp), INTENT(IN OUT)            :: p2tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p2period
   REAL(KIND=dp), INTENT(IN OUT)            :: p2t0
   REAL(KIND=dp), INTENT(IN OUT)            :: p2ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p2esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p2incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p2omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p2q
   REAL(KIND=dp), INTENT(IN OUT)            :: p2ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p3tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p3period
   REAL(KIND=dp), INTENT(IN OUT)            :: p3t0
   REAL(KIND=dp), INTENT(IN OUT)            :: p3ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p3esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p3incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p3omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p3q
   REAL(KIND=dp), INTENT(IN OUT)            :: p3ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p4tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p4period
   REAL(KIND=dp), INTENT(IN OUT)            :: p4t0
   REAL(KIND=dp), INTENT(IN OUT)            :: p4ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p4esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p4incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p4omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p4q
   REAL(KIND=dp), INTENT(IN OUT)            :: p4ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p5tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p5period
   REAL(KIND=dp), INTENT(IN OUT)            :: p5t0
   REAL(KIND=dp), INTENT(IN OUT)            :: p5ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p5esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p5incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p5omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p5q
   REAL(KIND=dp), INTENT(IN OUT)            :: p5ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p6tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p6period
   REAL(KIND=dp), INTENT(IN OUT)            :: p6t0
   REAL(KIND=dp), INTENT(IN OUT)            :: p6ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p6esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p6incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p6omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p6q
   REAL(KIND=dp), INTENT(IN OUT)            :: p6ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p7tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p7period
   REAL(KIND=dp), INTENT(IN OUT)            :: p7t0
   REAL(KIND=dp), INTENT(IN OUT)            :: p7ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p7esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p7incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p7omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p7q
   REAL(KIND=dp), INTENT(IN OUT)            :: p7ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p8tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p8period
   REAL(KIND=dp), INTENT(IN OUT)            :: p8t0
   REAL(KIND=dp), INTENT(IN OUT)            :: p8ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p8esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p8incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p8omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p8q
   REAL(KIND=dp), INTENT(IN OUT)            :: p8ratrad
   REAL(KIND=dp), INTENT(IN)                :: xsc(9999)
   REAL(KIND=dp), INTENT(IN)                :: ysc(9999)
   REAL(KIND=dp), INTENT(IN OUT)            :: spot1parm(2,4)
   REAL(KIND=dp), INTENT(IN OUT)            :: spot2parm(2,4)
   REAL(KIND=dp), INTENT(IN OUT)            :: spotdparm(2,4)
   INTEGER, INTENT(IN OUT)                  :: nalph1
   INTEGER, INTENT(IN OUT)                  :: nbet1
   INTEGER, INTENT(IN OUT)                  :: nalph2
   INTEGER, INTENT(IN OUT)                  :: nbet2
   INTEGER, INTENT(IN OUT)                  :: ntheta
   INTEGER, INTENT(IN OUT)                  :: nradius
   INTEGER, INTENT(IN OUT)                  :: nref
   INTEGER, INTENT(IN OUT)                  :: idraw
   INTEGER, INTENT(IN OUT)                  :: iecheck
   INTEGER, INTENT(IN OUT)                  :: iidint
   INTEGER, INTENT(IN OUT)                  :: iatm
   INTEGER, INTENT(IN OUT)                  :: ism1
   INTEGER, INTENT(IN OUT)                  :: ilaw
   INTEGER, INTENT(IN OUT)                  :: icnu
   INTEGER, INTENT(IN OUT)                  :: icnb
   INTEGER, INTENT(IN OUT)                  :: icnv
   INTEGER, INTENT(IN OUT)                  :: icnr
   INTEGER, INTENT(IN OUT)                  :: icni
   INTEGER, INTENT(IN OUT)                  :: icnj
   INTEGER, INTENT(IN OUT)                  :: icnh
   INTEGER, INTENT(IN OUT)                  :: icnk
   INTEGER, INTENT(IN OUT)                  :: icnrv1
   INTEGER, INTENT(IN OUT)                  :: icnrv2
   INTEGER, INTENT(IN OUT)                  :: irvfilt
   INTEGER, INTENT(IN OUT)                  :: isw1
   INTEGER, INTENT(IN OUT)                  :: isw2
   INTEGER, INTENT(IN OUT)                  :: isw3
   INTEGER, INTENT(IN OUT)                  :: isw4
   INTEGER, INTENT(IN OUT)                  :: ikeep
   INTEGER, INTENT(IN OUT)                  :: isynch
   INTEGER, INTENT(IN OUT)                  :: isw5
   INTEGER, INTENT(IN OUT)                  :: isw6
   INTEGER, INTENT(IN OUT)                  :: isw7
   INTEGER, INTENT(IN OUT)                  :: isw8
   INTEGER, INTENT(IN OUT)                  :: isw9
   INTEGER, INTENT(IN OUT)                  :: idark1
   INTEGER, INTENT(IN OUT)                  :: idark2
   INTEGER, INTENT(IN OUT)                  :: isw12
   INTEGER, INTENT(IN OUT)                  :: isw13
   INTEGER, INTENT(IN OUT)                  :: isw21
   INTEGER, INTENT(IN OUT)                  :: isw22
   INTEGER, INTENT(IN OUT)                  :: isw23
   INTEGER, INTENT(IN OUT)                  :: isw24
   INTEGER, INTENT(IN OUT)                  :: isw25
   INTEGER, INTENT(IN OUT)                  :: isw26
   INTEGER, INTENT(IN OUT)                  :: isw27
   INTEGER, INTENT(IN OUT)                  :: isw28
   INTEGER, INTENT(IN OUT)                  :: isw29
   INTEGER, INTENT(IN OUT)                  :: isw30
   INTEGER, INTENT(IN)                      :: isw31
   INTEGER, INTENT(IN OUT)                  :: isw32
   INTEGER, INTENT(IN OUT)                  :: isw33
   INTEGER, INTENT(IN OUT)                  :: isw34
   INTEGER, INTENT(IN)                      :: nsc
   REAL(KIND=dp), INTENT(IN OUT)            :: compfracs(8,3)
   REAL(KIND=dp), INTENT(IN OUT)            :: tertperiod
   REAL(KIND=dp), INTENT(IN OUT)            :: tertt0
   REAL(KIND=dp), INTENT(IN OUT)            :: tertecos
   REAL(KIND=dp), INTENT(IN OUT)            :: tertesin
   REAL(KIND=dp), INTENT(IN OUT)            :: tertincl
   REAL(KIND=dp), INTENT(IN OUT)            :: tertomega
   REAL(KIND=dp), INTENT(IN OUT)            :: tertq
   REAL(KIND=dp), INTENT(IN OUT)            :: tertconj
   REAL(KIND=dp), INTENT(IN OUT)            :: tertratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: hh
   REAL(KIND=dp), INTENT(IN OUT)            :: sw72
   REAL(KIND=dp), INTENT(IN OUT)            :: sw73
   REAL(KIND=dp), INTENT(OUT)               :: tdur1(40,nmxeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: tdur2(40,nmxeclipse)
   INTEGER, INTENT(IN OUT)                  :: ioutflag
   REAL(KIND=dp), INTENT(IN OUT)            :: sw80
   REAL(KIND=dp), INTENT(IN OUT)            :: sw81
   REAL(KIND=dp), INTENT(IN OUT)            :: sw82
   REAL(KIND=dp), INTENT(IN OUT)            :: sw83
   REAL(KIND=dp), INTENT(IN OUT)            :: sw84
   REAL(KIND=dp), INTENT(IN OUT)            :: sw85
   INTEGER, INTENT(IN OUT)                  :: isw80
   INTEGER, INTENT(IN OUT)                  :: isw81
   INTEGER, INTENT(IN OUT)                  :: isw82
   INTEGER, INTENT(IN OUT)                  :: isw83
   INTEGER, INTENT(IN OUT)                  :: isw84
   INTEGER, INTENT(IN OUT)                  :: isw85
   INTEGER, INTENT(IN OUT)                  :: isw86
   INTEGER, INTENT(IN)                      :: isw87
   INTEGER, INTENT(IN OUT)                  :: isw88
   INTEGER, INTENT(IN OUT)                  :: isw89
   REAL(KIND=dp), INTENT(OUT)               :: ymods4(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods5(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: arrsobx(montemax)
   REAL(KIND=dp), INTENT(OUT)               :: arrsoby(montemax)
   REAL(KIND=dp), INTENT(OUT)               :: rv4(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint1(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint2(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint3(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint4(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint5(8)
   REAL(KIND=dp), INTENT(IN)                :: atmt(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmg(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmmu(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint1(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint2(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint3(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint4(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint5(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint6(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint7(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint8(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: tmin
   INTEGER, INTENT(IN)                      :: nlines
   INTEGER, INTENT(IN)                      :: nmu(maxlines)
   INTEGER, INTENT(IN OUT)                  :: nalph3
   INTEGER, INTENT(IN OUT)                  :: nbet3
   INTEGER, INTENT(IN OUT)                  :: itconj
   INTEGER, INTENT(IN OUT)                  :: it1
   INTEGER, INTENT(IN OUT)                  :: it2
   INTEGER, INTENT(IN OUT)                  :: it3
   INTEGER, INTENT(IN OUT)                  :: it4
   INTEGER, INTENT(IN)                      :: ndynwin
   REAL(KIND=dp), INTENT(IN)                :: dynwinlow(1000)
   REAL(KIND=dp), INTENT(IN)                :: dynwinhigh(1000)
   REAL(KIND=dp), INTENT(IN OUT)            :: p1mtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p1ptc
   REAL(KIND=dp), INTENT(IN OUT)            :: p2mtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p2ptc
   REAL(KIND=dp), INTENT(IN OUT)            :: p3mtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p3ptc
   REAL(KIND=dp), INTENT(IN OUT)            :: p4mtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p4ptc
   REAL(KIND=dp), INTENT(IN OUT)            :: p5mtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p5ptc
   REAL(KIND=dp), INTENT(IN OUT)            :: p6mtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p6ptc
   REAL(KIND=dp), INTENT(IN OUT)            :: p7mtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p7ptc
   REAL(KIND=dp), INTENT(IN OUT)            :: p8mtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p8ptc
   REAL(KIND=dp), INTENT(IN OUT)            :: pbmtc
   REAL(KIND=dp), INTENT(IN OUT)            :: pbptc
   REAL(KIND=dp), INTENT(IN OUT)            :: bigi2
   REAL(KIND=dp), INTENT(IN OUT)            :: bigi3
   REAL(KIND=dp), INTENT(IN OUT)            :: bigi4
   REAL(KIND=dp), INTENT(IN OUT)            :: bigbeta2
   REAL(KIND=dp), INTENT(IN OUT)            :: bigbeta3
   REAL(KIND=dp), INTENT(IN OUT)            :: bigbeta4
   REAL(KIND=dp), INTENT(IN OUT)            :: bin2q
   REAL(KIND=dp), INTENT(IN OUT)            :: bn2massdff
   REAL(KIND=dp), INTENT(IN OUT)            :: bn2masssum
   REAL(KIND=dp), INTENT(IN OUT)            :: bn2raddiff
   REAL(KIND=dp), INTENT(IN OUT)            :: bn2radsum
   REAL(KIND=dp), INTENT(IN OUT)            :: bin2ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: g10
   REAL(KIND=dp), INTENT(IN OUT)            :: g6
   REAL(KIND=dp), INTENT(IN OUT)            :: g7
   REAL(KIND=dp), INTENT(IN OUT)            :: g8
   REAL(KIND=dp), INTENT(IN OUT)            :: g9
   REAL(KIND=dp), INTENT(IN OUT)            :: massdiff
   REAL(KIND=dp), INTENT(IN OUT)            :: masssum
   REAL(KIND=dp), INTENT(IN OUT)            :: omega3
   REAL(KIND=dp), INTENT(IN OUT)            :: omega4
   REAL(KIND=dp), INTENT(IN OUT)            :: omega5
   REAL(KIND=dp), INTENT(IN OUT)            :: omega6
   REAL(KIND=dp), INTENT(IN OUT)            :: omega7
   REAL(KIND=dp), INTENT(IN OUT)            :: omega8
   REAL(KIND=dp), INTENT(IN OUT)            :: omega9
   REAL(KIND=dp), INTENT(IN OUT)            :: omega10
   REAL(KIND=dp), INTENT(IN OUT)            :: raddiff
   REAL(KIND=dp), INTENT(IN OUT)            :: radsum
   REAL(KIND=dp), INTENT(IN OUT)            :: rk3
   REAL(KIND=dp), INTENT(IN OUT)            :: rk4
   REAL(KIND=dp), INTENT(IN OUT)            :: rk5
   REAL(KIND=dp), INTENT(IN OUT)            :: rk6
   REAL(KIND=dp), INTENT(IN OUT)            :: rk7
   REAL(KIND=dp), INTENT(IN OUT)            :: rk8
   REAL(KIND=dp), INTENT(IN OUT)            :: rk9
   REAL(KIND=dp), INTENT(IN OUT)            :: rk10
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint6(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint7(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint8(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint9(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint10(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: secmass
   REAL(KIND=dp), INTENT(IN OUT)            :: secrad
   REAL(KIND=dp), INTENT(IN OUT)            :: t10
   REAL(KIND=dp), INTENT(IN OUT)            :: t6
   REAL(KIND=dp), INTENT(IN OUT)            :: t7
   REAL(KIND=dp), INTENT(IN OUT)            :: t8
   REAL(KIND=dp), INTENT(IN OUT)            :: t9
   INTEGER, INTENT(IN OUT)                  :: nseg
   INTEGER, INTENT(IN OUT)                  :: isw100
   INTEGER, INTENT(IN)                      :: iunit
   REAL(KIND=dp), INTENT(IN OUT)            :: fracsum
   REAL(KIND=dp), INTENT(IN OUT)            :: fracdiff
   REAL(KIND=dp), INTENT(IN OUT)            :: bin2m3
   REAL(KIND=dp), INTENT(IN OUT)            :: bin2m4
   REAL(KIND=dp), INTENT(IN OUT)            :: bin2r3
   REAL(KIND=dp), INTENT(IN OUT)            :: bin2r4
   REAL(KIND=dp), INTENT(IN OUT)            :: sqecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqesin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqtertecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqtertesin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp2ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp2esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp3ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp3esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp4ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp4esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp5ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp5esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp6ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp6esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp7ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp7esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp8ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp8esin
   REAL(KIND=dp), INTENT(IN OUT)            :: angsum1
   REAL(KIND=dp), INTENT(IN OUT)            :: angdiff1
   REAL(KIND=dp), INTENT(IN OUT)            :: angsum2
   REAL(KIND=dp), INTENT(IN OUT)            :: angdiff2
   REAL(KIND=dp), INTENT(IN OUT)            :: angsum3
   REAL(KIND=dp), INTENT(IN OUT)            :: angdiff3
   REAL(KIND=dp), INTENT(IN OUT)            :: angsum4
   REAL(KIND=dp), INTENT(IN OUT)            :: angdiff4
   REAL(KIND=dp), INTENT(IN OUT)            :: angsum5
   REAL(KIND=dp), INTENT(IN OUT)            :: angdiff5
   REAL(KIND=dp), INTENT(IN OUT)            :: angsum6
   REAL(KIND=dp), INTENT(IN OUT)            :: angdiff6
   REAL(KIND=dp), INTENT(IN OUT)            :: angsum7
   REAL(KIND=dp), INTENT(IN OUT)            :: angdiff7
   REAL(KIND=dp), INTENT(IN OUT)            :: angsum8
   REAL(KIND=dp), INTENT(IN OUT)            :: angdiff8
   INTEGER, INTENT(IN)                      :: imag
   CHARACTER (LEN=4000), INTENT(OUT)        :: newparmstr
   REAL(KIND=dp), INTENT(IN OUT)            :: fillsum
   REAL(KIND=dp), INTENT(IN OUT)            :: filldiff
   REAL(KIND=dp), INTENT(IN OUT)            :: binqtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p1qtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p2qtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p3qtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p4qtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p5qtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p6qtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p7qtc
   REAL(KIND=dp), INTENT(IN OUT)            :: p8qtc
   REAL(KIND=dp), INTENT(IN OUT)            :: tbinoff
   REAL(KIND=dp), INTENT(IN OUT)            :: t1off
   REAL(KIND=dp), INTENT(IN OUT)            :: t2off
   REAL(KIND=dp), INTENT(IN OUT)            :: t3off
   REAL(KIND=dp), INTENT(IN OUT)            :: t4off
   REAL(KIND=dp), INTENT(IN OUT)            :: t5off
   REAL(KIND=dp), INTENT(IN OUT)            :: t6off
   REAL(KIND=dp), INTENT(IN OUT)            :: t7off
   REAL(KIND=dp), INTENT(IN OUT)            :: t8off
   INTEGER, INTENT(IN)                      :: inopt
   CHARACTER (LEN=350), INTENT(OUT)         :: fracstring
   REAL(KIND=dp), INTENT(OUT)               :: drv3(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv4(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv5(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: rv5(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: orbitparm(27)
   INTEGER, INTENT(IN)                      :: iversion
   REAL(KIND=dp), INTENT(IN)                :: tesscontam
   INTEGER, INTENT(IN)                      :: tessfilt
   REAL(KIND=dp), INTENT(IN)                :: tessbin
!
!   integer scalars
!
   INTEGER :: i,i3flag,ialfmax,ialfmin,ialign,ialphmax1,ialphmax2,ialphmax3
   INTEGER :: ibetmax1,ibetmax2,ibetmax3,icount,icounttime,icountx,idcheck
   INTEGER :: ididscale3,idoatmskip,idobbskip,ieccatmskip,ieccbbskip,iesave,igr
   INTEGER :: igrav,ii,ij,ijk,ik,ilength1,iloopin,iloopout,iloopp,ina1save
   INTEGER :: ina2save,inb1save,inb2save,ionephase,ioutflagsave,ioverlap
   INTEGER :: ioverlap1,ioverlap2,ipstep,iseason,isimp,iskip1,iskip2,ispot1
   INTEGER :: ispot2,ispotd,ispotprof,isquare,itide,itoggle,iusepot,iverb,ivrt
   INTEGER :: ivsave,ixecl,jj,jjj,jk,jkl,kk,lengthtime,ll,montecarlo,nbody
   INTEGER :: ndhoriz,ndtop,ndumsky1,ndumsky2,ndyn,neclipse1,neclipse2,neclipse3
   INTEGER :: neclipsed,newNdyn,ngap,nhoriz1,nhoriz2,nhoriz3,nloopin,nloopout
   INTEGER :: nloopp,nprim,nrmax,nsec,nsky1,nsky2,nsky3,nskydisk,nskyedge,nstep
   INTEGER :: nthetamax,ntime,ntop2,ntotal                                      
!
!   real scalars
!
   REAL(KIND=dp) :: argrad,ave1,ave11,ave12,ave2,ave21,ave22,axisscale,bdist
   REAL(KIND=dp) :: bdist1,bige,bigenew,bin2separ,compare1,compare2,darkbol2
   REAL(KIND=dp) :: ddd2,ddum,delta,delvel1,delvel2,dflux,dfluxb,dfluxh,dfluxi
   REAL(KIND=dp) :: dfluxj,dfluxk,dfluxr,dfluxu,dfluxv,diff1,diff2,diskrad
   REAL(KIND=dp) :: diskthick,dop1,dop2,dppp,dummyphase,ecan,em,emnew,emphase
   REAL(KIND=dp) :: eshift,extphase,fdiff,fflag,fillper1,fillper2,finccos
   REAL(KIND=dp) :: finccos2,fincr,fincsin,fincsin2,flimbx,flimby,flux1,flux2
   REAL(KIND=dp) :: flux3,fluxb1,fluxb2,fluxb3,fluxh1,fluxh2,fluxh3,fluxi1
   REAL(KIND=dp) :: fluxi2,fluxi3,fluxj1,fluxj2,fluxj3,fluxk1,fluxk2,fluxk3
   REAL(KIND=dp) :: fluxlat,fluxr1,fluxr2,fluxr3,fluxu1,fluxu2,fluxu3,fluxv1
   REAL(KIND=dp) :: fluxv2,fluxv3,g4,g5,gp1,gp2,gpole1,gpole2,gscale1,gscale2
   REAL(KIND=dp) :: gscale3,htrc,hutfac,hutfac2,lambda,obsph1,obsph2,onephase
   REAL(KIND=dp) :: otemp1,otemp2,overq,pconj,pconj2,pdiff1,pervol1,pervol2
   REAL(KIND=dp) :: phase,phasein,phaseout,phaser,phimis,phin,phout,phper,phper2
   REAL(KIND=dp) :: pot1,pot2,pots1,pots2,pp,ppp,pppp,pstart,pstartout,pstep
   REAL(KIND=dp) :: pstop,pstopout,pup,qqq,qsave,qtemp,r1,r2,radfill1,radfill2
   REAL(KIND=dp) :: rdepth,redge,reff1,reff10,reff2,reff3,reff4,reff5,reff6
   REAL(KIND=dp) :: reff7,reff8,reff9,regg1,regg2,reper,rl1,rl2,rldint1,rldint2
   REAL(KIND=dp) :: rldint3,rm1,rm2,rnu,rnunew,rocheradius,rpole1,rpole2,rrr
   REAL(KIND=dp) :: rsper,sa1,sa2,savedphase,savephimis,savethetamis,sf2,size1
   REAL(KIND=dp) :: smet,ssa3,ssref,sss,stepr,stepz,tdiff,teff4,teff5,temphh
   REAL(KIND=dp) :: tend,tertarg,tertargrad,tertbdist,tertecc,tertmass,tertphase
   REAL(KIND=dp) :: tertppp,tertrnu,tertsep,tertxcen,tertycen,thetamis,thetatan
   REAL(KIND=dp) :: tidephi,togglephase,tomrad,total_mass,tp1ecos,tp1esin
   REAL(KIND=dp) :: tp2ecos,tp2esin,tp3ecos,tp3esin,tp4ecos,tp4esin,tp5ecos
   REAL(KIND=dp) :: tp5esin,tp6ecos,tp6esin,tp7ecos,tp7esin,tp8ecos,tp8esin
   REAL(KIND=dp) :: tpole1,tpole2,trc,tref,tshift,tstart,tstep,tstop,tt1,tt2
   REAL(KIND=dp) :: tteff2,ttiny,ttte,tttt,usepot1,usepot2,vel1,vel2,vrot1,vrot2
   REAL(KIND=dp) :: vrot3,vrot4,www,x0,xhmax,xhmax1,xhmax2,xhmin,xhmin1,xhmin2
   REAL(KIND=dp) :: xmc,xp,xtran,xx,xxoff,xxoff1,yhmax,yhmax1,yhmax2,yhmin
   REAL(KIND=dp) :: yhmin1,yhmin2,yp,ytran,yy,yyoff,yyoff1,zz                   
!
!   Arrays associated with the dynamical integrator.
!
   REAL(KIND=dp), ALLOCATABLE :: body01pos_x(:),body01pos_y(:),body01pos_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body01vel_x(:),body01vel_y(:),body01vel_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body02pos_x(:),body02pos_y(:),body02pos_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body02vel_x(:),body02vel_y(:),body02vel_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body03pos_x(:),body03pos_y(:),body03pos_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body03vel_x(:),body03vel_y(:),body03vel_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body04pos_x(:),body04pos_y(:),body04pos_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body04vel_x(:),body04vel_y(:),body04vel_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body05pos_x(:),body05pos_y(:),body05pos_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body05vel_x(:),body05vel_y(:),body05vel_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body06pos_x(:),body06pos_y(:),body06pos_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body06vel_x(:),body06vel_y(:),body06vel_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body07pos_x(:),body07pos_y(:),body07pos_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body07vel_x(:),body07vel_y(:),body07vel_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body08pos_x(:),body08pos_y(:),body08pos_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body08vel_x(:),body08vel_y(:),body08vel_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body09pos_x(:),body09pos_y(:),body09pos_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body09vel_x(:),body09vel_y(:),body09vel_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body10pos_x(:),body10pos_y(:),body10pos_z(:)
   REAL(KIND=dp), ALLOCATABLE :: body10vel_x(:),body10vel_y(:),body10vel_z(:)
   REAL(KIND=dp), ALLOCATABLE :: odetime(:),timearray(:)                       
!
!   integer arrays associated with the stars
!   when using Roche geometry
!
   INTEGER, ALLOCATABLE :: ibetlim1(:),ibetlim2(:),ibetlim3(:),iedgehor1(:)
   INTEGER, ALLOCATABLE :: iedgehor2(:),iedgehor3(:),iedgestar1(:)
   INTEGER, ALLOCATABLE :: iedgestar2(:)
   INTEGER, ALLOCATABLE :: iedgestar3(:),mmdx1(:,:),mmdx2(:,:),mmdx3(:,:) 
!
!   real arrays associated with the stars when
!   using Roche geometry
!
   REAL(KIND=dp), ALLOCATABLE :: coprat1(:),coprat2(:),delphi1(:),delphi2(:)
   REAL(KIND=dp), ALLOCATABLE :: delphi3(:),delphie1(:),delphie2(:),delphie3(:)
   REAL(KIND=dp), ALLOCATABLE :: dumxsky1(:),dumxsky2(:),dumysky1(:),dumysky2(:)
   REAL(KIND=dp), ALLOCATABLE :: flum1(:),flum2(:),flum3(:),g1(:),g2(:)
   REAL(KIND=dp), ALLOCATABLE :: gradx1(:),gradx2(:),gradx3(:),grady1(:)
   REAL(KIND=dp), ALLOCATABLE :: grady2(:),grady3(:),gradz1(:),gradz2(:)
   REAL(KIND=dp), ALLOCATABLE :: gradz3(:),grav3(:),gthird(:),phiar1(:)
   REAL(KIND=dp), ALLOCATABLE :: phiar2(:),phiar3(:),phihor1(:,:),phihor2(:,:)
   REAL(KIND=dp), ALLOCATABLE :: phihor3(:,:),phistart1(:),phistart2(:)
   REAL(KIND=dp), ALLOCATABLE :: phistart3(:),projarray1(:),projarray2(:)
   REAL(KIND=dp), ALLOCATABLE :: projarray3(:),rad1(:),rad2(:),rad3(:),ratio1(:)
   REAL(KIND=dp), ALLOCATABLE :: ratio2(:),rinty1(:),rinty2(:),rinty3(:)
   REAL(KIND=dp), ALLOCATABLE :: rpol1(:),rpol2(:),saveinty1(:),saveinty2(:)
   REAL(KIND=dp), ALLOCATABLE :: saveinty3(:),surf1(:),surf2(:),surf3(:)
   REAL(KIND=dp), ALLOCATABLE :: temp1(:),temp2(:),temp3(:),tempold1(:)
   REAL(KIND=dp), ALLOCATABLE :: tempold2(:),toldspot1(:),toldspot2(:),visib1(:)
   REAL(KIND=dp), ALLOCATABLE :: visib2(:),visib3(:),x1(:),x2(:),x3(:)
   REAL(KIND=dp), ALLOCATABLE :: xhoriz1(:),xhoriz2(:),xhoriz3(:),xsky1(:)
   REAL(KIND=dp), ALLOCATABLE :: xsky2(:),xsky3(:),xtop2horiz(:),y1(:),y2(:)
   REAL(KIND=dp), ALLOCATABLE :: y3(:),yhoriz1(:),yhoriz2(:),yhoriz3(:),ysky1(:)
   REAL(KIND=dp), ALLOCATABLE :: ysky2(:),ysky3(:),ytop2horiz(:),z1(:),z2(:)
   REAL(KIND=dp), ALLOCATABLE :: z3(:)                                         
!
!   real arrays associated with the disk
!
   REAL(KIND=dp), ALLOCATABLE :: dinty(:),diskproj(:),drad(:),dtemp(:),dtopx(:)
   REAL(KIND=dp), ALLOCATABLE :: dtopy(:),dvisib(:),dx(:),dxhoriz(:),dy(:)
   REAL(KIND=dp), ALLOCATABLE :: dyhoriz(:),dz(:),edgeproj(:),einty(:),evisib(:)
   REAL(KIND=dp), ALLOCATABLE :: savedinty(:),saveeinty(:),tedge(:),xedge(:)
   REAL(KIND=dp), ALLOCATABLE :: xskydisk(:),xskyedge(:),yedge(:),yskydisk(:)
   REAL(KIND=dp), ALLOCATABLE :: yskyedge(:),zedge(:),zskydisk(:)         
!
   REAL(KIND=dp), ALLOCATABLE ::  xecx(:),xecy(:)
!
!   real arrays
!
   REAL(KIND=dp), DIMENSION(4) :: xend1,xend2
   REAL(KIND=dp), DIMENSION(6) :: timeinterp
   REAL(KIND=dp), DIMENSION(8) :: corr1,corr2,darkint1,darkint2,darkint3
   REAL(KIND=dp), DIMENSION(8) :: darkint4,darkint5,fifth,flux3keep,fourth
   REAL(KIND=dp), DIMENSION(8) :: gimvel,refflux1,refflux2,rlatflux,third
   REAL(KIND=dp), DIMENSION(8) :: thirdkeep,zdcorr             
!
   REAL(KIND=dp), DIMENSION(9) :: a_arr,a_fin,a_init,argper_arr,argper_fin
   REAL(KIND=dp), DIMENSION(9) :: argper_init,ecc_arr,ecc_fin,ecc_init,f_arr
   REAL(KIND=dp), DIMENSION(9) :: f_fin,f_init,inc_arr,inc_fin,inc_init,long_arr
   REAL(KIND=dp), DIMENSION(9) :: ma_arr,ma_fin,ma_init,omega_fin,omega_init
   REAL(KIND=dp), DIMENSION(9) :: p_arr,p_fin,p_init,tconj_arr,tconj_fin
   REAL(KIND=dp), DIMENSION(9) :: tconj_init
   REAL(KIND=dp), DIMENSION(10) :: rmass,rrad,rrau 
   REAL(KIND=dp), DIMENSION(20) :: tideparm
   REAL(KIND=dp), DIMENSION(30) ::  dynpp,dynqq
   REAL(KIND=dp), DIMENSION(2,30) :: posarray,velarray
   REAL(KIND=dp), DIMENSION(10,6) :: ribcinp
   REAL(KIND=dp), DIMENSION(6,60,2) ::  zzq  
   REAL(KIND=dp), DIMENSION(nmxeclipse) :: eprim,esec
   REAL(KIND=dp), DIMENSION(nmxeclipse) :: durprim1,dursec1
   REAL(KIND=dp), DIMENSION(nmxeclipse) :: durprim2,dursec2
   REAL(KIND=dp), DIMENSION(nmxeclipse) :: distprim,distsec
!
!   old dimension
!
!          DIMENSION zzq(6,60,Ndyn)
!
   CHARACTER (LEN=9) :: extension
   CHARACTER (LEN=12) :: scr2string
   CHARACTER (LEN=40) :: instring1
   CHARACTER (LEN=1000) :: scr1string
!
   dynparm=''
   planetparm=''
   fracstring=''
   newparmstr=''
   scr1string=''
   scr2string=''
   parmstring=''
   orbitparm=0.0_dp
!
   ioutflagsave=ioutflag
   IF(ioutflag == 9)ioutflag=1
!
   nsky1=0
   nsky2=0
   qqq=1.0_dp
   bdist=1.0_dp
   tpole1=1.0_dp
   tpole2=1.0_dp
   rpole1=1.0_dp
   rpole2=1.0_dp
   pot1=1.0_dp
   rrr=1.0_dp
   sa1=1.0_dp
   sa2=1.0_dp
   pots1=1.0_dp
   pots2=1.0_dp
   gscale1=1.0_dp
   gscale2=1.0_dp
   DO i=1,8
      darkint3(i)=0.0_dp
      darkint4(i)=0.0_dp
      darkint5(i)=0.0_dp
      third(i)=0.0_dp
      fourth(i)=0.0_dp
      fifth(i)=0.0_dp
   END DO
   www=0.0_dp
   emphase=0.0_dp
   ipstep=0
   ivsave=0
   savethetamis=0.0_dp
   savephimis=0.0_dp
   pstep=0.0_dp
   pstop=0.0_dp
   icountx=0
   neclipse1=0
   neclipse2=0
   neclipsed=0
   pots1=1.0_dp
   pots2=1.0_dp
   diskrad=0.0_dp
   diskthick=0.0_dp
!
   DO ij=1,40
      ncycle(ij)=0
      DO ik=1,nmxeclipse
         ttimes(ij,ik)=0.0_dp
         tseps(ij,ik)=0.0_dp
         tdur1(ij,ik)=0.0_dp
         tdur2(ij,ik)=0.0_dp
         durprim1(ik)=0.0_dp
         durprim2(ik)=0.0_dp
      END DO
   END DO
   itide=0
   igr=isw26
   tidephi=0.0_dp
   i3flag=0
   teff4=sw80
   teff5=sw81
   g4=sw82
   g5=sw83
   ieccbbskip=0
   ieccatmskip=0
   idobbskip=0
   idoatmskip=0
   nphase=0
   xmod=0.0_dp
   xrvmod=0.0_dp
   ymodu=0.0_dp
   ymodb=0.0_dp
   ymodv=0.0_dp
   ymodr=0.0_dp
   ymodi=0.0_dp
   ymodj=0.0_dp
   ymodh=0.0_dp
   ymodk=0.0_dp
   ymods1=0.0_dp
   ymods2=0.0_dp
   ymods3=0.0_dp
   ymodd=0.0_dp
   rv1=0.0_dp
   rv2=0.0_dp
   rv3=0.0_dp
   rv4=0.0_dp
   rv5=0.0_dp
   drv1=0.0_dp
   drv2=0.0_dp
   drv3=0.0_dp
   drv4=0.0_dp
   drv5=0.0_dp
   fracs1=0.0_dp
   fracs2=0.0_dp
   fracs3=0.0_dp
   fracs4=0.0_dp
   fracs5=0.0_dp
   fracs6=0.0_dp
   fracs7=0.0_dp
   fracs8=0.0_dp
 
!

!
!   UPDATE December 15, 2012
!
!   Set Ngap=isw31
!
   ngap=isw31
!
!   UPDATE JULY 5, 2011
!
!   Add a variable called contam, which will be sw31.
!   This will be the Kepler contamination value, between
!   0.0 and 1.0.  It will be assumed the Kepler position is
!   in in the U position, so modelU is altered.
!
!          contam=sw31
!
   IF(contam < 0.0_dp)contam=0.0_dp
   IF(contam >= 1.0_dp)contam=0.999999_dp
!
!   UPDATE MAY 5, 2013
!
!   Add contamination by seasons
!
   iseason=isw34
!
!   If itime is less than 2, disable the Ngap
!
   IF(isw7 <= 1)ngap=0
!
!  UPDATE September 5, 2012
!
!  The flag isw29 will let the user specify e*cos(omega),
!  esin(omega)
!
   IF(isw29 > 0)THEN
      ecc=SQRT(ocose*ocose+osine*osine)
      argper=ATAN2(osine,ocose)*radtodeg
      IF((ABS(sqecos) >= EPSILON(sqecos)).AND.(ABS(sqesin) >= EPSILON(sqesin)))THEN
         ecc=sqecos**2+sqesin**2
         argper=ATAN2(sqesin,sqecos)*radtodeg
      END IF
      IF(argper < 0.0_dp)argper=argper+360.0_dp
      IF(argper > 360.0_dp)argper=argper-360.0_dp
      IF(ecc >= 1.0_dp)ecc=0.995_dp
   END IF
!
   IF(isw30 > 2)THEN
      tertecc=SQRT(tertecos**2+tertesin**2)
      IF(tertecc >= 1.0_dp)tertecc=0.995_dp
      tertargrad=ATAN2(tertesin,tertecos)
      IF((ABS(sqtertesin) >= EPSILON(sqtertesin)).AND.(ABS(sqtertecos) >=  &
                   EPSILON(sqtertecos)))THEN
         tertargrad=ATAN2(sqtertesin,sqtertecos)
         tertecc=sqtertesin**2+sqtertecos**2
      END IF
      IF(tertargrad < 0.0_dp)tertargrad=tertargrad+twopie
      IF(tertargrad > twopie)tertargrad=tertargrad-twopie
      tertarg=(ATAN2(tertesin,tertecos))*radtodeg
      IF(tertarg < 0.0_dp)tertarg=tertarg+360.0_dp
      IF(tertarg > 360.0_dp)tertarg=tertarg-360.0_dp
   END IF
!
!   UPDATE JULY 15, 2011
!
!   Here is a flag for third light scaling
!
   ididscale3=0
!
!    Update October 15, 2010
!
!    Add Doppler boosting.  beam1=sw33 and beam2=sw34
!
   IF(ilaw > 10)THEN
      DO i=1,8
         dwavex(i,2)=dwavex(i,1)
         dwavey(i,2)=dwavey(i,1)
      END DO
   END IF
!
!   If the fast binning mode for Kepler is chosen, set
!   the time step to 0.00395693 days
!
   IF((isw87 >= 1).AND.(sw29 > 0.0_dp).AND.(isw7 >= 2))THEN
      sw9=0.00395693_dp
   END IF
!
   CALL newrecordparm(ioutflag,nalph1,nalph2,nalph3,nbet1,nbet2,  &
      nbet3,nradius,nref,nseg,ntheta,irvfilt,iatm,icnb,icnh,icni,  &
      icnj,icnk,icnr,icnu,icnv,idark1,idark2,idraw,iecheck,iidint,  &
      ikeep,ilaw,ism1,isw1,isw13,isw2,isw21,isw22,isw23,  &
      isw24,isw25,isw26,isw27,isw28,isw29,isw3,isw30,isw31,isw32,  &
      isw33,isw34,isw4,isw5,isw6,isw7,isw8,isw80,isw81,  &
      isw85,isw86,isw87,isw88,isw89,isw9,isw100,isynch,it1,  &
      it2,it3,it4,itconj,p1mtc,p1ptc,p2omega,p2q,p2t0,p2ecos,  &
      p2esin,p2incl,p2mtc,p2ptc,p2period,p2ratrad,p2tconj,p3omega,  &
      p3q,p3t0,p3ecos,p3esin,p3incl,p3mtc,p3ptc,p3period,p3ratrad,  &
      p3tconj,p4omega,p4q,p4t0,p4ecos,p4esin,p4incl,p4mtc,p4ptc,  &
      p4period,p4ratrad,p4tconj,p5omega,p5q,p5t0,p5ecos,p5esin,  &
      p5incl,p5mtc,p5ptc,p5period,p5ratrad,p5tconj,p6omega,p6q,  &
      p6t0,p6ecos,p6esin,p6incl,p6mtc,p6ptc,p6period,p6ratrad,  &
      p6tconj,p7omega,p7q,p7t0,p7ecos,p7esin,p7incl,p7mtc,p7ptc,  &
      p7period,p7ratrad,p7tconj,p8omega,p8q,p8t0,p8ecos,p8esin,  &
      p8incl,p8mtc,p8ptc,p8period,p8ratrad,p8tconj,pbmtc,pbptc,  &
      period,q,sa3,t0,tconj,teff1,teff2,tgrav1,tgrav2,alb1,alb2,  &
      argper,beam1,beam2,betarim,bigi,bigi2,bigi3,bigi4,bigbeta,  &
      bigbeta2,bigbeta3,bigbeta4,bin2q,bn2massdff,bn2masssum,  &
      bn2raddiff,bn2radsum,bin2ratrad,contam,contams0,contams1,  &
      contams2,contams3,dbolx,dboly,dphase,dwavex,dwavey,  &
      ecc,ecosw,fill1,fill2,finc,frac1,frac2,g10,g3,g6,g7,g8,g9,  &
      gamma,hh,massdiff,masssum,ocose,omega1,omega2,omega3,omega4,  &
      omega5,omega6,omega7,omega8,omega9,omega10,osine,  &
      primk,primmass,primrad,pshift,rlx,raddiff,radsum,  &
      ratrad,rinner,rk3,rk4,rk5,rk6,rk7,rk8,rk9,rk10,router,  &
      sdarkint1,sdarkint2,sdarkint3,sdarkint4,sdarkint5,sdarkint6,  &
      sdarkint7,sdarkint8,sdarkint9,sdarkint10,secmass,secrad,  &
      separ,spot1parm,spot2parm,spotdparm,sw1,sw2,sw23,sw24,sw25,  &
      sw26,sw27,sw28,sw29,sw3,sw30,sw47,sw48,sw49,sw5,sw6,sw7,sw72,  &
      sw73,sw8,sw80,sw81,sw82,sw83,sw84,  &
      sw9,t10,t3,t6,t7,t8,t9,tdisk,temprat,tertomega,tertq,  &
      tertconj,tertecos,tertesin,tertincl,tertperiod,tertratrad,  &
      tertt0,wave,xi,iunit,fracsum,fracdiff,bin2m3,bin2m4,bin2r3,  &
      bin2r4,sqecos,sqesin,sqtertecos,sqtertesin,sqp2ecos,sqp2esin,  &
      sqp3ecos,sqp3esin,sqp4ecos,sqp4esin,sqp5ecos,sqp5esin,  &
      sqp6ecos,sqp6esin,sqp7ecos,sqp7esin,sqp8ecos,sqp8esin,  &
      angsum1,angdiff1,angsum2,angdiff2,angsum3,angdiff3,angsum4,  &
      angdiff4,angsum5,angdiff5,angsum6,angdiff6,angsum7,angdiff7,  &
      angsum8,angdiff8,imag,fillsum,filldiff,binqtc,p1qtc,p2qtc,  &
      p3qtc,p4qtc,p5qtc,p6qtc,p7qtc,p8qtc,tbinoff,t1off,t2off,  &
      t3off,t4off,t5off,t6off,t7off,t8off,iversion,tesscontam,  &
      tessfilt,tessbin)
!
   CALL checkinput(fill1,fill2,omega1,omega2,dphase,q,finc,  &
      teff1,teff2,tgrav1,tgrav2,betarim,rinner,router,  &
      alb1,alb2,nref,period,fm,separ,idraw,iecheck,iidint,  &
      ism1,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,ecc,pshift,  &
      ecosw,argper,temprat,ilaw,dwavex,dwavey,  &
      tertq,p2q,p3q,p4q,p5q,p6q,p7q,p8q,ioutflag,masssum,isw27)
!
   thetamis=0.0_dp
   phimis=0.0_dp
   obsparm=0.0_dp
   obsparm(19)=t3
!
!  Set the periods if needed.
!
   CALL setperiod(ioutflag,isw28,itconj,period,tconj,pbmtc,  &
      pbptc,tertperiod,tertconj,p1mtc,p1ptc,p2period,p2mtc,p2ptc,  &
      p2tconj,p3period,p3mtc,p3ptc,p3tconj,p4period,p4mtc,p4ptc,  &
      p4tconj,p5period,p5mtc,p5ptc,p5tconj,p6period,p6mtc,p6ptc,  &
      p6tconj,p7period,p7mtc,p7ptc,p7tconj,p8period,p8mtc,p8ptc,  &
      p8tconj,binqtc,p1qtc,p2qtc,p3qtc,p4qtc,p5qtc,p6qtc,p7qtc,  &
      p8qtc,tbinoff,t1off,t2off,t3off,t4off,t5off,t6off,t7off,t8off)
!
!  Set the inclinations and nodal angles, if needed
!
   CALL setangle(ioutflag,angsum1,angdiff1,tertincl,tertomega,  &
      angsum2,angdiff2,p2incl,p2omega,angsum3,angdiff3,p3incl,  &
      p3omega,angsum4,angdiff4,p4incl,p4omega,angsum5,angdiff5,  &
      p5incl,p5omega,angsum6,angdiff6,p6incl,p6omega,angsum7,  &
      angdiff7,p7incl,p7omega,angsum8,angdiff8,p8incl,p8omega)
!
!  If we are fitting for the conjunction time, find the T0 needed
!
   IF((isw28 > 0).AND.(isw7 >= 1))THEN
      CALL gett0star(finc,period,ecc,argper,t0,tconj)
   END IF
!
!  Here is the fast analytic mode.
!
   IF(isw27 >= 1)THEN
!
      nbody=isw30
!
      reff1=0.0_dp
      reff2=0.0_dp
      reff3=0.0_dp
      reff4=0.0_dp
      reff5=0.0_dp
      reff6=0.0_dp
      reff7=0.0_dp
      reff8=0.0_dp
      reff9=0.0_dp
      reff10=0.0_dp
!
!   Determine the masses, radii, and rotational velocities
!
      CALL analyticscale(q,finc,period,primmass,primk,ecc,frac1,  &
         frac2,primrad,ratrad,reff1,reff2,separ,vrot1,vrot2,gp1,gp2,  &
         rm1,rm2,masssum,massdiff,radsum,raddiff,secmass,secrad,  &
         fracsum,fracdiff,ioutflag)
      rmass(1)=rm1
      rmass(2)=rm2
!
!   Determine the reference fluxes.  These will be stored in darkint(k)
!
      gscale1=1.0_dp
      gscale2=1.0_dp
!
      CALL getatmint(maxlines,maxmu,nlines,atmt,atmg,atmmu,nmu,  &
         atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,  &
         atmint8,gscale1,darkint1,teff1,gp1,dwavex,dwavey,ilaw,iatm,1)
!
      CALL getatmint(maxlines,maxmu,nlines,atmt,atmg,atmmu,nmu,  &
         atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,  &
         atmint8,gscale2,darkint2,teff2,gp2,dwavex,dwavey,ilaw,iatm,2)
!
!  The radius of the third body is now set by tertratrad, and not
!  SA3
!
      IF(ABS(tertratrad) <= EPSILON(tertratrad))THEN
         reff3=0.0_dp
      ELSE
         reff3=reff1/tertratrad
      END IF
!
      IF(isw30 <= 2)THEN
         IF(sa3 <= 0.0_dp)THEN
            reff3=reff1
         ELSE
            reff3=reff1/SQRT(sa3)
         END IF
         ssref=reff3/SQRT(pie)
         CALL thirdlight(iatm,t3,g3,1.0_dp,third,maxlines,maxmu,  &
            nlines,atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,  &
            atmint4,atmint5,atmint6,atmint7,atmint8,icnu,icnb,icnv,  &
            icnr,icni,icnj,icnh,icnk,separ,dwavex,dwavey,ilaw,3,  &
            ssref,ioutflag)
      ELSE
!
!  If we are in binary+binary mode, set the masses and
!  radii if the sum of the masses and/or the sum of the
!  sum of the radii are given.
!
         IF((isw80 >= 1).AND.(nbody /= 4))THEN
            WRITE(*,*)'Error:  set binary+binary switch',' to 0,'
            WRITE(*,*)'or set the body 3 switch to 4  if binary',  &
               '+binary is needed'
            STOP
         END IF
!
         bin2separ=0.0_dp
         IF((nbody == 4).AND.(isw80 >= 1))THEN
            CALL setbinbinscale(ioutflag,rmass,reff3,reff4,  &
               bn2masssum,bn2massdff,bin2q,bn2radsum,bn2raddiff,  &
               bin2ratrad,bin2m3,bin2m4,bin2r3,bin2r4,separ,bin2separ, &
               p2period)
         END IF
!
         IF(ABS(p2ratrad) <= EPSILON(p2ratrad))THEN
            reff4=0.0_dp
         ELSE
            reff4=reff1/p2ratrad
         END IF
!
         ssref=reff1/(pie)
         CALL thirdlight(iatm,t3,g3,sa3,third,maxlines,maxmu,  &
            nlines,atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,  &
            atmint4,atmint5,atmint6,atmint7,atmint8,icnu,icnb,icnv,  &
            icnr,icni,icnj,icnh,icnk,separ,dwavex,dwavey,ilaw,3, &
            ssref,ioutflag)
!
         IF(ABS(p3ratrad) <= EPSILON(p3ratrad))THEN
            reff5=0.0_dp
         ELSE
            reff5=reff1/p3ratrad
         END IF
!
         IF(teff4 > 110.0_dp)THEN
            ssref=reff4/(pie)
            ssa3=1.0_dp
            CALL thirdlight(iatm,teff4,g4,ssa3,fourth,maxlines,  &
               maxmu,nlines,atmt,atmg,atmmu,nmu,atmint1,atmint2,  &
               atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,icnu,  &
               icnb,icnv,icnr,icni,icnj,icnh,icnk,separ,dwavex,dwavey,  &
               ilaw,4,ssref,ioutflag)
         END IF
      END IF
!
      CALL getanalyticint(maxlines,maxmu,nlines,atmt,atmg,atmmu,  &
         nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,  &
         atmint7,atmint8,gp1,darkint1,teff1,dwavex,dwavey,ilaw,iatm,  &
         1,wave,reff1,separ)
!
      CALL getanalyticint(maxlines,maxmu,nlines,atmt,atmg,atmmu,  &
         nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,  &
         atmint7,atmint8,gp2,darkint2,teff2,dwavex,dwavey,ilaw,iatm,  &
         2,wave,reff2,separ)
!
      IF(t3 > 110.0_dp)THEN
         CALL getanalyticint(maxlines,maxmu,nlines,atmt,atmg,  &
            atmmu,nmu,atmint1,atmint2,atmint3,atmint4,atmint5,  &
            atmint6,atmint7,atmint8,10.0_dp**(ABS(g3)),darkint3,  &
            ABS(t3),dwavex,dwavey,ilaw,iatm,3,wave,reff3,separ)
      END IF
!
      IF(teff4 > 110.0_dp)THEN
         CALL getanalyticint(maxlines,maxmu,nlines,atmt,atmg,  &
            atmmu,nmu,atmint1,atmint2,atmint3,atmint4,atmint5,  &
            atmint6,atmint7,atmint8,10.0_dp**(ABS(g4)),darkint4,  &
            ABS(teff4),dwavex,dwavey,ilaw,iatm,4,wave,reff4,separ)
      END IF
!
      IF(teff5 > 110.0_dp)THEN
         CALL getanalyticint(maxlines,maxmu,nlines,atmt,atmg,  &
            atmmu,nmu,atmint1,atmint2,atmint3,atmint4,atmint5,  &
            atmint6,atmint7,atmint8,10.0_dp**(ABS(g5)),darkint5,  &
            ABS(teff5),dwavex,dwavey,ilaw,iatm,5,wave,reff5,separ)
      END IF
!
      IF(ilaw > 10)THEN
         DO i=1,8
            dwavex(i,2)=dwavex(i,1)
            dwavey(i,2)=dwavey(i,1)
         END DO
      END IF
!
      tstart=sw23
      tend=sw24
      tstep=sw9
!
      IF(isw7 >= 2)THEN
         lengthtime=int((tend-tstart)/tstep)+10
      ELSE
         lengthtime=nmaxphase+10
      END IF
      ALLOCATE(timearray(lengthtime))
      timearray=0.0_dp
!
!   Figure out how many integration steps are needed, and allocate
!   the arrays
!
      IF(isw30 > 2)THEN
         icount=1
         tref=sw47
         IF(tref >= tstart)THEN
           CALL dynlim(tstart,tend,hh,Ndynwin,dynwinlow,dynwinhigh,icount)
         ELSE
           CALL dynlim(tref,tend,hh,Ndynwin,dynwinlow,dynwinhigh,icount)
         END IF
         newndyn=icount
         ndyn=newndyn
      ELSE
         newndyn=2
         ndyn=newndyn
      END IF
      ALLOCATE(odetime(newNdyn))
      odetime=0.0_dp
!
      ALLOCATE(body01pos_x(newNdyn),body01pos_y(newNdyn))
      ALLOCATE(body01pos_z(newNdyn),body01vel_x(newNdyn))
      ALLOCATE(body01vel_y(newNdyn),body01vel_z(newNdyn))
      body01pos_x=0.0_dp ; body01pos_y=0.0_dp; body01pos_z=0.0_dp
      body01vel_x=0.0_dp ; body01vel_y=0.0_dp; body01vel_z=0.0_dp
!
      ALLOCATE(body02pos_x(newNdyn),body02pos_y(newNdyn))
      ALLOCATE(body02pos_z(newNdyn),body02vel_x(newNdyn))
      ALLOCATE(body02vel_y(newNdyn),body02vel_z(newNdyn))
      body02pos_x=0.0_dp ; body02pos_y=0.0_dp; body02pos_z=0.0_dp
      body02vel_x=0.0_dp ; body02vel_y=0.0_dp; body02vel_z=0.0_dp
!
      ALLOCATE(body03pos_x(newNdyn),body03pos_y(newNdyn))
      ALLOCATE(body03pos_z(newNdyn),body03vel_x(newNdyn))
      ALLOCATE(body03vel_y(newNdyn),body03vel_z(newNdyn))
      body03pos_x=0.0_dp ; body03pos_y=0.0_dp; body03pos_z=0.0_dp
      body03vel_x=0.0_dp ; body03vel_y=0.0_dp; body03vel_z=0.0_dp
!
      ALLOCATE(body04pos_x(newNdyn),body04pos_y(newNdyn))
      ALLOCATE(body04pos_z(newNdyn),body04vel_x(newNdyn))
      ALLOCATE(body04vel_y(newNdyn),body04vel_z(newNdyn))
      body04pos_x=0.0_dp ; body04pos_y=0.0_dp; body04pos_z=0.0_dp
      body04vel_x=0.0_dp ; body04vel_y=0.0_dp; body04vel_z=0.0_dp
!
      ALLOCATE(body05pos_x(newNdyn),body05pos_y(newNdyn))
      ALLOCATE(body05pos_z(newNdyn),body05vel_x(newNdyn))
      ALLOCATE(body05vel_y(newNdyn),body05vel_z(newNdyn))
      body05pos_x=0.0_dp ; body05pos_y=0.0_dp; body05pos_z=0.0_dp
      body05vel_x=0.0_dp ; body05vel_y=0.0_dp; body05vel_z=0.0_dp
!
      ALLOCATE(body06pos_x(newNdyn),body06pos_y(newNdyn))
      ALLOCATE(body06pos_z(newNdyn),body06vel_x(newNdyn))
      ALLOCATE(body06vel_y(newNdyn),body06vel_z(newNdyn))
      body06pos_x=0.0_dp ; body06pos_y=0.0_dp; body06pos_z=0.0_dp
      body06vel_x=0.0_dp ; body06vel_y=0.0_dp; body06vel_z=0.0_dp
!
      ALLOCATE(body07pos_x(newNdyn),body07pos_y(newNdyn))
      ALLOCATE(body07pos_z(newNdyn),body07vel_x(newNdyn))
      ALLOCATE(body07vel_y(newNdyn),body07vel_z(newNdyn))
      body07pos_x=0.0_dp ; body07pos_y=0.0_dp; body07pos_z=0.0_dp
      body07vel_x=0.0_dp ; body07vel_y=0.0_dp; body07vel_z=0.0_dp
!
      ALLOCATE(body08pos_x(newNdyn),body08pos_y(newNdyn))
      ALLOCATE(body08pos_z(newNdyn),body08vel_x(newNdyn))
      ALLOCATE(body08vel_y(newNdyn),body08vel_z(newNdyn))
      body08pos_x=0.0_dp ; body08pos_y=0.0_dp; body08pos_z=0.0_dp
      body08vel_x=0.0_dp ; body08vel_y=0.0_dp; body08vel_z=0.0_dp
!
      ALLOCATE(body09pos_x(newNdyn),body09pos_y(newNdyn))
      ALLOCATE(body09pos_z(newNdyn),body09vel_x(newNdyn))
      ALLOCATE(body09vel_y(newNdyn),body09vel_z(newNdyn))
      body09pos_x=0.0_dp ; body09pos_y=0.0_dp; body09pos_z=0.0_dp
      body09vel_x=0.0_dp ; body09vel_y=0.0_dp; body09vel_z=0.0_dp
!
      ALLOCATE(body10pos_x(newNdyn),body10pos_y(newNdyn))
      ALLOCATE(body10pos_z(newNdyn),body10vel_x(newNdyn))
      ALLOCATE(body10vel_y(newNdyn),body10vel_z(newNdyn))
      body10pos_x=0.0_dp ; body10pos_y=0.0_dp; body10pos_z=0.0_dp
      body10vel_x=0.0_dp ; body10vel_y=0.0_dp; body10vel_z=0.0_dp
!
!  dynamics, need the body 3 switch to be 3 or more
!
      IF(isw30 > 2)THEN
!
!  Make sure the periods of the unused bodies are zero.
!
         IF(isw30 == 3)THEN
            p4period=0.0_dp
            p5period=0.0_dp
            p6period=0.0_dp
            p7period=0.0_dp
            p8period=0.0_dp
         END IF
!
         IF(isw30 == 4)THEN
            p5period=0.0_dp
            p6period=0.0_dp
            p7period=0.0_dp
            p8period=0.0_dp
         END IF
!
         IF(isw30 == 5)THEN
            p6period=0.0_dp
            p7period=0.0_dp
            p8period=0.0_dp
         END IF
!
         IF(isw30 == 6)THEN
            p7period=0.0_dp
            p8period=0.0_dp
         END IF
!
         IF(isw30 == 7)THEN
            p8period=0.0_dp
         END IF
!
         IF(ABS(p4ratrad) <= EPSILON(p4ratrad))THEN
            reff6=0.0_dp
         ELSE
            reff6=reff1/p4ratrad
         END IF
!
         IF(ABS(p5ratrad) <= EPSILON(p5ratrad))THEN
            reff7=0.0_dp
         ELSE
            reff7=reff1/p5ratrad
         END IF
!
         IF(ABS(p6ratrad) <= EPSILON(p6ratrad))THEN
            reff8=0.0_dp
         ELSE
            reff8=reff1/p6ratrad
         END IF
!
         IF(ABS(p7ratrad) <= EPSILON(p7ratrad))THEN
            reff9=0.0_dp
         ELSE
            reff9=reff1/p7ratrad
         END IF
!
         IF(ABS(p8ratrad) <= EPSILON(p8ratrad))THEN
            reff10=0.0_dp
         ELSE
            reff10=reff1/p8ratrad
         END IF
!
         rmass(1)=0.0_dp
         rmass(2)=0.0_dp
         rmass(3)=0.0_dp
         rmass(4)=0.0_dp
         rmass(5)=0.0_dp
         rmass(6)=0.0_dp
         rmass(7)=0.0_dp
         rmass(8)=0.0_dp
         rmass(9)=0.0_dp
         rmass(10)=0.0_dp
         tstart=sw23
         tend=sw24
         tstep=sw9
!
         CALL counttime(ngap,gaplow,gaphigh,ntime,timearray,  &
            tstart,tend,tstep,nmaxphase,lengthtime)
!
         rmass(1)=rm1
         rmass(2)=rm2
         rmass(3)=(rm1+rm2)/tertq
!
         IF(it1 == 2)rmass(3)=tertq/earthmasstosolar
         IF(nbody >= 4)THEN
            IF(ABS(p2q) <= EPSILON(p2q))THEN
               rmass(4)=0.0_dp
            ELSE
               rmass(4)=(rm1+rm2)/p2q
               IF(it1 == 2)rmass(4)=p2q/earthmasstosolar
            END IF
         END IF
         IF(nbody >= 5)THEN
            IF(ABS(p3q) <= EPSILON(p3q))THEN
               rmass(5)=0.0_dp
            ELSE
               rmass(5)=(rm1+rm2)/p3q
               IF(it1 == 2)rmass(5)=p3q/earthmasstosolar
            END IF
         END IF
         IF(nbody >= 6)THEN
            IF(ABS(p4q) <= EPSILON(p4q))THEN
               rmass(6)=0.0_dp
            ELSE
               rmass(6)=(rm1+rm2)/p4q
               IF(it1 == 2)rmass(6)=p4q/earthmasstosolar
            END IF
         END IF
         IF(nbody >= 7)THEN
            IF(ABS(p5q) <= EPSILON(p5q))THEN
               rmass(7)=0.0_dp
            ELSE
               rmass(7)=(rm1+rm2)/p5q
               IF(it1 == 2)rmass(7)=p5q/earthmasstosolar
            END IF
         END IF
         IF(nbody >= 8)THEN
            IF(ABS(p6q) <= EPSILON(p6q))THEN
               rmass(8)=0.0_dp
            ELSE
               rmass(8)=(rm1+rm2)/p6q
               IF(it1 == 2)rmass(8)=p6q/earthmasstosolar
            END IF
         END IF
         IF(nbody >= 9)THEN
            IF(ABS(p7q) <= EPSILON(p7q))THEN
               rmass(9)=0.0_dp
            ELSE
               rmass(9)=(rm1+rm2)/p7q
               IF(it1 == 2)rmass(9)=p7q/earthmasstosolar
            END IF
         END IF
         IF(nbody >= 10)THEN
            IF(ABS(p8q) <= EPSILON(p8q))THEN
               rmass(10)=0.0_dp
            ELSE
               rmass(10)=(rm1+rm2)/p8q
               IF(it1 == 2)rmass(10)=p8q/earthmasstosolar
            END IF
         END IF
!
!  If we are in binary+binary mode, set the masses and
!  radii if the sum of the masses and/or the sum of the
!  sum of the radii are given.
!
         IF((isw80 >= 1).AND.(nbody /= 4))THEN
            WRITE(*,*)'Error:  set binary+binary switch',' to 0,'
            WRITE(*,*)'or set the body 3 switch to 4  if binary',  &
               '+binary is needed'
            STOP
         END IF
!
         IF((nbody == 4).AND.(isw80 >= 1))THEN
            CALL setbinbinscale(0,rmass,reff3,reff4,bn2masssum,  &
               bn2massdff,bin2q,bn2radsum,bn2raddiff,bin2ratrad,  &
               bin2m3,bin2m4,bin2r3,bin2r4,separ,bin2separ,p2period)
         END IF
!
         ribcinp(1,1)=period
         ribcinp(2,1)=tertperiod
         ribcinp(3,1)=p2period
         ribcinp(4,1)=p3period
         ribcinp(5,1)=p4period
         ribcinp(6,1)=p5period
         ribcinp(7,1)=p6period
         ribcinp(8,1)=p7period
         ribcinp(9,1)=p8period
!
         tp1ecos=tertecos
         tp1esin=tertesin
         IF((ABS(sqtertecos) >= EPSILON(sqtertecos)).AND.(ABS(sqtertesin) &
                 >= EPSILON(sqtertesin)))THEN
            ttte=sqtertecos**2+sqtertesin**2
            tttt=ATAN2(sqtertesin,sqtertecos)
            tp1ecos=ttte*COS(tttt)
            tp1esin=ttte*SIN(tttt)
         END IF
!
         tp2ecos=p2ecos
         tp2esin=p2esin
         IF((ABS(sqp2ecos) >= EPSILON(sqp2ecos)).AND.(ABS(sqp2esin) &
                 >= EPSILON(sqp2esin)))THEN
            ttte=sqp2ecos**2+sqp2esin**2
            tttt=ATAN2(sqp2esin,sqp2ecos)
            tp2ecos=ttte*COS(tttt)
            tp2esin=ttte*SIN(tttt)
         END IF
!
         tp3ecos=p3ecos
         tp3esin=p3esin
         IF((ABS(sqp3ecos) >= EPSILON(sqp3ecos)).AND.(ABS(sqp3esin) &
                >= EPSILON(sqp3esin)))THEN
            ttte=sqp3ecos**2+sqp3esin**2
            tttt=ATAN2(sqp3esin,sqp3ecos)
            tp3ecos=ttte*COS(tttt)
            tp3esin=ttte*SIN(tttt)
         END IF
!
         tp4ecos=p4ecos
         tp4esin=p4esin
         IF((ABS(sqp4ecos) >= EPSILON(sqp4ecos)).AND.(ABS(sqp4esin) &
               >= EPSILON(sqp4esin)))THEN
            ttte=sqp4ecos**2+sqp4esin**2
            tttt=ATAN2(sqp4esin,sqp4ecos)
            tp4ecos=ttte*COS(tttt)
            tp4esin=ttte*SIN(tttt)
         END IF
!
         tp5ecos=p5ecos
         tp5esin=p5esin
         IF((ABS(sqp5ecos) >= EPSILON(sqp5ecos)).AND.(ABS(sqp5esin) &
                >= EPSILON(sqp5esin)))THEN
            ttte=sqp5ecos**2+sqp5esin**2
            tttt=ATAN2(sqp5esin,sqp5ecos)
            tp5ecos=ttte*COS(tttt)
            tp5esin=ttte*SIN(tttt)
         END IF
!
         tp6ecos=p6ecos
         tp6esin=p6esin
         IF((ABS(sqp6ecos) >= EPSILON(sqp6ecos)).AND.(ABS(sqp6esin) &
                 >= EPSILON(sqp6esin)))THEN
            ttte=sqp6ecos**2+sqp6esin**2
            tttt=ATAN2(sqp6esin,sqp6ecos)
            tp6ecos=ttte*COS(tttt)
            tp6esin=ttte*SIN(tttt)
         END IF
!
         tp7ecos=p7ecos
         tp7esin=p7esin
         IF((ABS(sqp7ecos) >= EPSILON(sqp7ecos)).AND.(ABS(sqp7esin) &
               >= EPSILON(sqp7esin)))THEN
            ttte=sqp7ecos**2+sqp7esin**2
            tttt=ATAN2(sqp7esin,sqp7ecos)
            tp7ecos=ttte*COS(tttt)
            tp7esin=ttte*SIN(tttt)
         END IF
!
         tp8ecos=p8ecos
         tp8esin=p8esin
         IF((ABS(sqp8ecos) >= EPSILON(sqp8ecos)).AND.(ABS(sqp8esin) &
                    >= EPSILON(sqp8esin)))THEN
            ttte=sqp8ecos**2+sqp8esin**2
            tttt=ATAN2(sqp8esin,sqp8ecos)
            tp8ecos=ttte*COS(tttt)
            tp8esin=ttte*SIN(tttt)
         END IF
!
         ribcinp(1,2)=ecc*COS(argper*degtorad)
         ribcinp(2,2)=tp1ecos
         ribcinp(3,2)=tp2ecos
         ribcinp(4,2)=tp3ecos
         ribcinp(5,2)=tp4ecos
         ribcinp(6,2)=tp5ecos
         ribcinp(7,2)=tp6ecos
         ribcinp(8,2)=tp7ecos
         ribcinp(9,2)=tp8ecos
!
         ribcinp(1,3)=ecc*SIN(argper*degtorad)
         ribcinp(2,3)=tp1esin
         ribcinp(3,3)=tp2esin
         ribcinp(4,3)=tp3esin
         ribcinp(5,3)=tp4esin
         ribcinp(6,3)=tp5esin
         ribcinp(7,3)=tp6esin
         ribcinp(8,3)=tp7esin
         ribcinp(9,3)=tp8esin
!
         ribcinp(1,4)=finc*degtorad
         ribcinp(2,4)=tertincl*degtorad
         ribcinp(3,4)=p2incl*degtorad
         ribcinp(4,4)=p3incl*degtorad
         ribcinp(5,4)=p4incl*degtorad
         ribcinp(6,4)=p5incl*degtorad
         ribcinp(7,4)=p6incl*degtorad
         ribcinp(8,4)=p7incl*degtorad
         ribcinp(9,4)=p8incl*degtorad
!
         ribcinp(1,5)=sw49*degtorad
         ribcinp(2,5)=tertomega*degtorad
         ribcinp(3,5)=p2omega*degtorad
         ribcinp(4,5)=p3omega*degtorad
         ribcinp(5,5)=p4omega*degtorad
         ribcinp(6,5)=p5omega*degtorad
         ribcinp(7,5)=p6omega*degtorad
         ribcinp(8,5)=p7omega*degtorad
         ribcinp(9,5)=p8omega*degtorad
!
         ribcinp(1,6)=tconj
         ribcinp(2,6)=tertconj
         ribcinp(3,6)=p2tconj
         ribcinp(4,6)=p3tconj
         ribcinp(5,6)=p4tconj
         ribcinp(6,6)=p5tconj
         ribcinp(7,6)=p6tconj
         ribcinp(8,6)=p7tconj
         ribcinp(9,6)=p8tconj
!
         tref=sw47
!
         DO ijk=1,30
            dynqq(ijk)=0.0_dp
            dynpp(ijk)=0.0_dp
         END DO
         IF((nbody == 4).AND.(isw80 >= 1))THEN
            CALL getbinbinibc(nbody,rmass,ribcinp,dynqq,dynpp,tref,isw28)
         END IF
!
         IF(isw80 == 0)THEN
            CALL getibc(nbody,rmass,ribcinp,dynqq,dynpp,tref,itconj,isw28)
         END IF
!
         IF((Nbody.eq.4).and.(isw80.ge.1))THEN
            CALL newcartkepbinbin(rmass,dynQQ,dynPP,Tref,p_arr, &
               ecc_arr,a_arr,MA_arr,ArgPer_arr,inc_arr,long_arr, &
               Tconj_arr,f_arr)
         ELSE
            CALL newcartkep(nbody,rmass,dynqq,dynpp,tref,p_arr,  &
               ecc_arr,a_arr,ma_arr,argper_arr,inc_arr,long_arr,  &
               tconj_arr,f_arr)
         END IF
!
!   Save true anomaly, mean anonmaly, mean longitude into an
!   array that is passed out of light curve and eventually into
!   the "extra" parameters in generation.1??????
!
         orbitparm(1)=f_arr(1)*radtodeg
         orbitparm(2)=ma_arr(1)*radtodeg
         lambda=(argper_arr(1)+f_arr(1)+ribcinp(1,5))*radtodeg
         orbitparm(3)=lambda
!
!  orbit 2
!
         orbitparm(4)=f_arr(2)*radtodeg
         orbitparm(5)=ma_arr(2)*radtodeg
         lambda=(argper_arr(2)+f_arr(2)+ribcinp(2,5))*radtodeg
         orbitparm(6)=lambda
!
!  orbit 3
!
         IF(nbody >= 4)THEN
            orbitparm(7)=f_arr(3)*radtodeg
            orbitparm(8)=ma_arr(3)*radtodeg
            lambda=(argper_arr(3)+f_arr(3)+ribcinp(3,5))*radtodeg
            orbitparm(9)=lambda
         END IF
!
!  orbit 4
!
         IF(nbody >= 5)THEN
            orbitparm(10)=f_arr(4)*radtodeg
            orbitparm(11)=ma_arr(4)*radtodeg
            lambda=(argper_arr(4)+f_arr(4)+ribcinp(4,5))*radtodeg
            orbitparm(12)=lambda
         END IF
!
!  orbit 5
!
         IF(nbody >= 6)THEN
            orbitparm(13)=f_arr(5)*radtodeg
            orbitparm(14)=ma_arr(5)*radtodeg
            lambda=(argper_arr(5)+f_arr(5)+ribcinp(5,5))*radtodeg
            orbitparm(15)=lambda
         END IF
!
!  orbit 6
!
         IF(nbody >= 7)THEN
            orbitparm(16)=f_arr(6)*radtodeg
            orbitparm(17)=ma_arr(6)*radtodeg
            lambda=(argper_arr(6)+f_arr(6)+ribcinp(6,5))*radtodeg
            orbitparm(18)=lambda
         END IF
!
!  orbit 7
!
         IF(nbody >= 8)THEN
            orbitparm(19)=f_arr(7)*radtodeg
            orbitparm(20)=ma_arr(7)*radtodeg
            lambda=(argper_arr(7)+f_arr(7)+ribcinp(7,5))*radtodeg
            orbitparm(21)=lambda
         END IF
!
!  orbit 8
!
         IF(nbody >= 9)THEN
            orbitparm(22)=f_arr(8)*radtodeg
            orbitparm(23)=ma_arr(8)*radtodeg
            lambda=(argper_arr(8)+f_arr(8)+ribcinp(8,5))*radtodeg
            orbitparm(24)=lambda
         END IF
!
!  orbit 9
!
         IF(nbody >= 10)THEN
            orbitparm(25)=f_arr(9)*radtodeg
            orbitparm(26)=ma_arr(9)*radtodeg
            lambda=(argper_arr(9)+f_arr(9)+ribcinp(9,5))*radtodeg
            orbitparm(27)=lambda
         END IF
!
         CALL writedynparm(dynparm,rmass,dynqq,dynpp,tref)
!
         finccos=COS(finc*degtorad)
         fincsin=SIN(finc*degtorad)
!
         hutfac=(1.0_dp+7.5_dp*ecc*ecc+5.625_dp*ecc**4+0.3125_dp*ecc**  &
            6)/((1.0_dp+3.0_dp*ecc*ecc+3.0_dp/8.0_dp*ecc**4)*SQRT((1.0_dp- &
            ecc*ecc)**3))
!
         otemp1=omega1*hutfac*(twopie/period)
         otemp2=omega2*hutfac*(twopie/period)
!
         tideparm(1)=sw72
         tideparm(2)=sw73
         tideparm(3)=reff1*separ*auinsolarrad
         tideparm(4)=reff2*separ*auinsolarrad
         tideparm(5)=0.0_dp
         tideparm(6)=otemp1*fincsin
         tideparm(7)=-otemp1*finccos
         tideparm(8)=0.0_dp
         tideparm(9)=otemp2*fincsin
         tideparm(10)=-otemp2*finccos
!
!  If we are in binary+binary mode, put in tidal parameters for the
!  second binary.
!
         IF(ABS(p2period) >= EPSILON(p2period))THEN
            tttt=SQRT(tp2ecos**2+tp2esin**2)
            hutfac2=(1.0_dp+7.5_dp*tttt**2+5.625_dp*tttt**4+0.3125_dp*  &
               tttt**6)/((1.0_dp+3.0_dp*tttt**2+3.0_dp/8.0_dp*tttt**4)*  &
               SQRT((1.0_dp-tttt**2)**3))
            otemp1=omega3*hutfac2*(twopie/p2period)
            otemp2=omega4*hutfac2*(twopie/p2period)
         ELSE
            hutfac2=0.0_dp
            otemp1=1.0_dp
            otemp2=0.0_dp
         END IF
         finccos2=COS(p2incl*degtorad)
         fincsin2=SIN(p2incl*degtorad)
!
         tideparm(11)=rk3
         tideparm(12)=rk4
         tideparm(13)=reff3*bin2separ*auinsolarrad
         tideparm(14)=reff4*bin2separ*auinsolarrad
         tideparm(15)=0.0_dp
         tideparm(16)=otemp1*fincsin2
         tideparm(17)=-otemp1*finccos2
         tideparm(18)=0.0_dp
         tideparm(19)=otemp2*fincsin2
         tideparm(20)=-otemp2*finccos2
!
!   Open the ELCdynamics.out file if it2 > 0
!
         IF((it2 >= 1).AND.(inopt == 0))THEN
            CALL inform1(igr,hh,nbody,tideparm,omega1,omega2,vrot1,  &
               hutfac,vrot2,period,isw80,solarrad,twopie,secinday,  &
               separ,reff3,reff4,p2period,fincsin2,omega3,omega4,  &
               vrot3,vrot4,hutfac2,rk3,rk4,rmass,auinsolarrad,reff5,  &
               reff6,reff7,reff8,reff9,reff10,ilaw,dwavex,dwavey,  &
               contams0,contams1,contams2,contams3,sdarkint1,  &
               sdarkint2,sdarkint3,sdarkint4,sdarkint5,sdarkint6,  &
               sdarkint7,sdarkint8,sdarkint9,isw86,darkint1,darkint2,  &
               darkint3,darkint4,darkint5,tref,ribcinp,dynqq,dynpp,  &
               ecc_arr,a_arr,ma_arr,argper_arr,f_arr,reff1,reff2,  &
               radtodeg,teff1,teff2,t3,teff4,teff5)
         END IF
!
         IF(ABS(tref - tstart) >= EPSILON(tref))THEN
            tdiff=ABS(tstart-tref)
            temphh=hh
            compare1=tdiff/temphh
            compare2=(REAL(nint(compare1),KIND=dp)-compare1)
            IF(ABS(compare2) > 1.0E-10_dp)THEN
               WRITE(*,*)'Error:  (T_start-T_ref)/hh should ',  &
                  'be an integer ',tstart,tref,temphh,compare1,compare2
               STOP
            END IF
            IF(tstart < tref)THEN
               temphh=-temphh
            END IF
            CALL goback(nbody,temphh,tref,tstart,nstep,dynqq,dynpp,  &
               rmass,posarray,velarray,odetime,zzq,timeinterp,ndyn, &
               igr,tideparm,isw80)
         END IF
!
!   Add to the ELCdynamics.out file if it2 > 0
!
         IF((it2 > 0).AND.(inopt == 0))THEN
            CALL inform2(nbody,dynqq,dynpp,rmass,tstart,tref,radtodeg,isw80)
         END IF
!
!  Convert the Cartesian coordinates into Keplerian
!  and save.
!
         IF((Nbody.eq.4).and.(isw80.ge.1))THEN
            CALL newcartkepbinbin(rmass,dynQQ,dynPP,Tref,p_arr, &
               ecc_arr,a_arr,MA_arr,ArgPer_arr,inc_arr,long_arr, &
               Tconj_arr,f_arr)
         ELSE
            CALL newcartkep(nbody,rmass,dynqq,dynpp,tref,p_arr,  &
               ecc_arr,a_arr,ma_arr,argper_arr,inc_arr,long_arr,  &
               tconj_arr,f_arr)
         END IF
!
         DO i=1,nbody-1
            p_init(i)=p_arr(i)
            ecc_init(i)=ecc_arr(i)
            a_init(i)=a_arr(i)
            ma_init(i)=ma_arr(i)
            argper_init(i)=argper_arr(i)
            inc_init(i)=inc_arr(i)
            omega_init(i)=long_arr(i)
            tconj_init(i)=tconj_arr(i)
            f_init(i)=f_arr(i)
         END DO
!
!   Do the integration.
!
         CALL solveorbit(nbody,hh,tstart,tend,nstep,dynqq,dynpp,  &
            rmass,odetime,zzq,timeinterp,ndyn,igr,tideparm,ndynwin,  &
            dynwinlow,dynwinhigh,isw80,body01pos_x,body01pos_y,  &
            body01pos_z,body02pos_x,body02pos_y,body02pos_z,  &
            body03pos_x,body03pos_y,body03pos_z,body04pos_x,  &
            body04pos_y,body04pos_z,body05pos_x,body05pos_y,  &
            body05pos_z,body06pos_x,body06pos_y,body06pos_z,  &
            body07pos_x,body07pos_y,body07pos_z,body08pos_x,  &
            body08pos_y,body08pos_z,body09pos_x,body09pos_y,  &
            body09pos_z,body10pos_x,body10pos_y,body10pos_z,  &
            body01vel_x,body01vel_y,body01vel_z,body02vel_x,  &
            body02vel_y,body02vel_z,body03vel_x,body03vel_y,  &
            body03vel_z,body04vel_x,body04vel_y,body04vel_z,  &
            body05vel_x,body05vel_y,body05vel_z,body06vel_x,  &
            body06vel_y,body06vel_z,body07vel_x,body07vel_y,  &
            body07vel_z,body08vel_x,body08vel_y,body08vel_z,  &
            body09vel_x,body09vel_y,body09vel_z,body10vel_x,  &
            body10vel_y,body10vel_z)
!
!   Write ELCdynamics.pos and ELCdynamics.vel if
!   it2 > 0
!
         IF(it2 >= 1)THEN
            CALL writedynamics(nbody,nstep,ndyn,odetime,  &
               body01pos_x,body01pos_y,body01pos_z,body01vel_x,  &
               body01vel_y,body01vel_z,body02pos_x,body02pos_y,  &
               body02pos_z,body02vel_x,body02vel_y,body02vel_z,  &
               body03pos_x,body03pos_y,body03pos_z,body03vel_x,  &
               body03vel_y,body03vel_z,body04pos_x,body04pos_y,  &
               body04pos_z,body04vel_x,body04vel_y,body04vel_z,  &
               body05pos_x,body05pos_y,body05pos_z,body05vel_x,  &
               body05vel_y,body05vel_z,body06pos_x,body06pos_y,  &
               body06pos_z,body06vel_x,body06vel_y,body06vel_z,  &
               body07pos_x,body07pos_y,body07pos_z,body07vel_x,  &
               body07vel_y,body07vel_z,body08pos_x,body08pos_y,  &
               body08pos_z,body09vel_x,body09vel_y,body09vel_z,  &
               body10pos_x,body10pos_y,body10pos_z,body10vel_x,  &
               body10vel_y,body10vel_z,body08vel_x,body08vel_y,  &
               body08vel_z,body09pos_x,body09pos_y,body09pos_z)
         END IF
!
!  Add to the ELCdynamics.out file if it2 > 0
!
         IF((it2 > 0).AND.(inopt == 0))THEN
            CALL inform3(nbody,dynqq,dynpp,rmass,odetime(nstep),  &
               tref,radtodeg,nstep,body01pos_x,body01pos_y,  &
               body01pos_z,body01vel_x,body01vel_y,body01vel_z,  &
               body02pos_x,body02pos_y,body02pos_z,body02vel_x,  &
               body02vel_y,body02vel_z,body03pos_x,body03pos_y,  &
               body03pos_z,body03vel_x,body03vel_y,body03vel_z,  &
               body04pos_x,body04pos_y,body04pos_z,body04vel_x,  &
               body04vel_y,body04vel_z,body05pos_x,body05pos_y,  &
               body05pos_z,body05vel_x,body05vel_y,body05vel_z,  &
               body06pos_x,body06pos_y,body06pos_z,body06vel_x,  &
               body06vel_y,body06vel_z,body07pos_x,body07pos_y,  &
               body07pos_z,body07vel_x,body07vel_y,body07vel_z,  &
               body08pos_x,body08pos_y,body08pos_z,body09vel_x,  &
               body09vel_y,body09vel_z,body10pos_x,body10pos_y,  &
               body10pos_z,body10vel_x,body10vel_y,body10vel_z,  &
               body08vel_x,body08vel_y,body08vel_z,body09pos_x,  &
               body09pos_y,body09pos_z,ndyn,isw80)
!
         END IF
!
!   Convert the x,y,z coordinates at the end of the
!   integration into Keplerian and save.
!
         IF((Nbody.eq.4).and.(isw80.ge.1))THEN
            CALL newcartkepbinbin(rmass,dynQQ,dynPP,Tref,p_arr, &
               ecc_arr,a_arr,MA_arr,ArgPer_arr,inc_arr,long_arr, &
               Tconj_arr,f_arr)
         ELSE
            CALL newcartkep(nbody,rmass,dynqq,dynpp,tref,p_arr,  &
               ecc_arr,a_arr,ma_arr,argper_arr,inc_arr,long_arr,  &
               tconj_arr,f_arr)
         END IF
!
         DO i=1,nbody-1
            p_fin(i)=p_arr(i)
            ecc_fin(i)=ecc_arr(i)
            a_fin(i)=a_arr(i)
            ma_fin(i)=ma_arr(i)
            argper_fin(i)=argper_arr(i)
            inc_fin(i)=inc_arr(i)
            omega_fin(i)=long_arr(i)
            tconj_fin(i)=tconj_arr(i)
            f_fin(i)=f_arr(i)
         END DO
!
!   Finish the ELCdynamics.out file if it2 > 0
!
         IF((it2 >= 1).AND.(inopt == 0))THEN
            CALL inform4(p_init,p_fin,ecc_init,ecc_fin,a_init,  &
               a_fin,ma_init,ma_fin,argper_init,argper_fin,inc_init,  &
               inc_fin,omega_init,omega_fin,tconj_init,tconj_fin,  &
               rmass,nbody,odetime,nstep,ndyn,radtodeg,igr,  &
               auinsolarrad,sw72,sw73,omega1,omega2,reff1,reff2,f_init,f_fin)
         END IF
!
!   find the times of primary and secondary eclipses unless
!   iwriteeclipse (isw23) is 2
!
         nprim=0
         nsec=0
!
         IF(isw23 < 2)THEN
            CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
               eprim,nsec,esec,ndyn,distprim,distsec,reff1,reff2,  &
               separ,1,2,nmxeclipse,durprim1,dursec1,durprim2,  &
               dursec2,sw85,inopt,body01pos_x,body01pos_y,  &
               body01pos_z,body01vel_x,body01vel_y,body01vel_z,  &
               body02pos_x,body02pos_y,body02pos_z,body02vel_x,  &
               body02vel_y,body02vel_z)
!
            ncycle(1)=nprim
            ncycle(2)=nsec
            DO ij=1,nprim
               ttimes(1,ij)=eprim(ij)
               tseps(1,ij)=distprim(ij)
               tdur1(1,ij)=durprim1(ij)
               tdur2(1,ij)=durprim2(ij)
            END DO
            DO ij=1,nsec
               ttimes(2,ij)=esec(ij)
               tseps(2,ij)=distsec(ij)
               tdur1(2,ij)=dursec1(ij)
               tdur2(2,ij)=dursec2(ij)
            END DO
!
!   find the times of transit and occultation of body 3 by the
!   primary
!
            IF(isw82 <= 0)THEN
               CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                  eprim,nsec,esec,ndyn,distprim,distsec,reff1,reff3,  &
                  separ,1,3,nmxeclipse,durprim1,dursec1,durprim2,  &
                  dursec2,sw85,inopt,body01pos_x,body01pos_y,  &
                  body01pos_z,body01vel_x,body01vel_y,body01vel_z,  &
                  body03pos_x,body03pos_y,body03pos_z,body03vel_x,  &
                  body03vel_y,body03vel_z)
!
               ncycle(3)=nprim
               ncycle(4)=nsec
               DO ij=1,nprim
                  ttimes(3,ij)=eprim(ij)
                  tseps(3,ij)=distprim(ij)
                  tdur1(3,ij)=durprim1(ij)
                  tdur2(3,ij)=durprim2(ij)
               END DO
               DO ij=1,nsec
                  ttimes(4,ij)=esec(ij)
                  tseps(4,ij)=distsec(ij)
                  tdur1(4,ij)=dursec1(ij)
                  tdur2(4,ij)=dursec2(ij)
               END DO
            ELSE
               ncycle(3)=0
               ncycle(4)=0
            END IF
!
!   find the times of transit and occultation of body 3 by the
!   secondary
!
            IF(isw82 <= 0)THEN
               CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                  eprim,nsec,esec,ndyn,distprim,distsec,reff2,reff3,  &
                  separ,2,3,nmxeclipse,durprim1,dursec1,durprim2,  &
                  dursec2,sw85,inopt,body02pos_x,body02pos_y,  &
                  body02pos_z,body02vel_x,body02vel_y,body02vel_z,  &
                  body03pos_x,body03pos_y,body03pos_z,body03vel_x,  &
                  body03vel_y,body03vel_z)
!
               ncycle(5)=nprim
               ncycle(6)=nsec
               DO ij=1,nprim
                  ttimes(5,ij)=eprim(ij)
                  tseps(5,ij)=distprim(ij)
                  tdur1(5,ij)=durprim1(ij)
                  tdur2(5,ij)=durprim2(ij)
               END DO
               DO ij=1,nsec
                  ttimes(6,ij)=esec(ij)
                  tseps(6,ij)=distsec(ij)
                  tdur1(6,ij)=dursec1(ij)
                  tdur2(6,ij)=dursec2(ij)
               END DO
            ELSE
               ncycle(5)=0
               ncycle(6)=0
            END IF
!
!   find the times of transit and occultation of body 4 by the
!   primary
!
            IF(nbody >= 4)THEN
               IF(isw83 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff1,reff4,  &
                     separ,1,4,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body01pos_x,body01pos_y,  &
                     body01pos_z,body01vel_x,body01vel_y,body01vel_z,  &
                     body04pos_x,body04pos_y,body04pos_z,body04vel_x,  &
                     body04vel_y,body04vel_z)
!
                  ncycle(7)=nprim
                  ncycle(8)=nsec
                  DO ij=1,nprim
                     ttimes(7,ij)=eprim(ij)
                     tseps(7,ij)=distprim(ij)
                     tdur1(7,ij)=durprim1(ij)
                     tdur2(7,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(8,ij)=esec(ij)
                     tseps(8,ij)=distsec(ij)
                     tdur1(8,ij)=dursec1(ij)
                     tdur2(8,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(7)=0
                  ncycle(8)=0
               END IF
!
!   find the times of transit and occultation of body 4 by the
!   secondary
!
               IF(isw83 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff2,reff4,  &
                     separ,2,4,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body02pos_x,body02pos_y,  &
                     body02pos_z,body02vel_x,body02vel_y,body02vel_z,  &
                     body04pos_x,body04pos_y,body04pos_z,body04vel_x,  &
                     body04vel_y,body04vel_z)
!
                  ncycle(9)=nprim
                  ncycle(10)=nsec
                  DO ij=1,nprim
                     ttimes(9,ij)=eprim(ij)
                     tseps(9,ij)=distprim(ij)
                     tdur1(9,ij)=durprim1(ij)
                     tdur2(9,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(10,ij)=esec(ij)
                     tseps(10,ij)=distsec(ij)
                     tdur1(10,ij)=dursec1(ij)
                     tdur2(10,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(9)=0
                  ncycle(10)=0
               END IF
!
!   find the times of transit and occultation of body 3 by
!   body 4
!
               IF((isw83 <= 0).AND.(isw82 <= 0))THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff3,reff4,  &
                     separ,3,4,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body03pos_x,body03pos_y,  &
                     body03pos_z,body03vel_x,body03vel_y,body03vel_z,  &
                     body04pos_x,body04pos_y,body04pos_z,body04vel_x,  &
                     body04vel_y,body04vel_z)
!
                  ncycle(35)=nprim
                  ncycle(36)=nsec
                  DO ij=1,nprim
                     ttimes(35,ij)=eprim(ij)
                     tseps(35,ij)=distprim(ij)
                     tdur1(35,ij)=durprim1(ij)
                     tdur2(35,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(36,ij)=esec(ij)
                     tseps(36,ij)=distsec(ij)
                     tdur1(36,ij)=dursec1(ij)
                     tdur2(36,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(35)=0
                  ncycle(36)=0
               END IF
!
!  end if Nbody .ge. 4
!
            END IF
!
!   find the times of transit and occultation of body 5 by the
!   primary
!
            IF(nbody >= 5)THEN
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff1,reff5,  &
                     separ,1,5,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body01pos_x,body01pos_y,  &
                     body01pos_z,body01vel_x,body01vel_y,body01vel_z,  &
                     body05pos_x,body05pos_y,body05pos_z,body05vel_x,  &
                     body05vel_y,body05vel_z)
!
                  ncycle(11)=nprim
                  ncycle(12)=nsec
                  DO ij=1,nprim
                     ttimes(11,ij)=eprim(ij)
                     tseps(11,ij)=distprim(ij)
                     tdur1(11,ij)=durprim1(ij)
                     tdur2(11,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(12,ij)=esec(ij)
                     tseps(12,ij)=distsec(ij)
                     tdur1(12,ij)=dursec1(ij)
                     tdur2(12,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(11)=0
                  ncycle(12)=0
               END IF
!
!   find the times of transit and occultation of body 5 by the
!   secondary
!
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff2,reff5,  &
                     separ,2,5,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body02pos_x,body02pos_y,  &
                     body02pos_z,body02vel_x,body02vel_y,body02vel_z,  &
                     body05pos_x,body05pos_y,body05pos_z,body05vel_x,  &
                     body05vel_y,body05vel_z)
!
                  ncycle(13)=nprim
                  ncycle(14)=nsec
                  DO ij=1,nprim
                     ttimes(13,ij)=eprim(ij)
                     tseps(13,ij)=distprim(ij)
                     tdur1(13,ij)=durprim1(ij)
                     tdur2(13,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(14,ij)=esec(ij)
                     tseps(14,ij)=distsec(ij)
                     tdur1(14,ij)=dursec1(ij)
                     tdur2(14,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(13)=0
                  ncycle(14)=0
               END IF
!
!   find the times of body 3 and body 5 events
!
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff3,reff5,  &
                     separ,3,5,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body03pos_x,body03pos_y,  &
                     body03pos_z,body03vel_x,body03vel_y,body03vel_z,  &
                     body05pos_x,body05pos_y,body05pos_z,body05vel_x,  &
                     body05vel_y,body05vel_z)
!
                  ncycle(37)=nprim
                  ncycle(38)=nsec
                  DO ij=1,nprim
                     ttimes(37,ij)=eprim(ij)
                     tseps(37,ij)=distprim(ij)
                     tdur1(37,ij)=durprim1(ij)
                     tdur2(37,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(38,ij)=esec(ij)
                     tseps(38,ij)=distsec(ij)
                     tdur1(38,ij)=dursec1(ij)
                     tdur2(38,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(37)=0
                  ncycle(38)=0
               END IF
!
!   find the times of body 4 and body 5 events
!
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff4,reff5,  &
                     separ,4,5,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body04pos_x,body04pos_y,  &
                     body04pos_z,body04vel_x,body04vel_y,body04vel_z,  &
                     body05pos_x,body05pos_y,body05pos_z,body05vel_x,  &
                     body05vel_y,body05vel_z)
!
                  ncycle(39)=nprim
                  ncycle(40)=nsec
                  DO ij=1,nprim
                     ttimes(39,ij)=eprim(ij)
                     tseps(39,ij)=distprim(ij)
                     tdur1(39,ij)=durprim1(ij)
                     tdur2(39,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(40,ij)=esec(ij)
                     tseps(40,ij)=distsec(ij)
                     tdur1(40,ij)=dursec1(ij)
                     tdur2(40,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(39)=0
                  ncycle(40)=0
               END IF
!
!   end if Nbody .ge. 5
!
            END IF
!
!   find the times of transit and occultation of body 6 by the
!   primary
!
            IF(nbody >= 6)THEN
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff1,reff6,  &
                     separ,1,6,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body01pos_x,body01pos_y,  &
                     body01pos_z,body01vel_x,body01vel_y,body01vel_z,  &
                     body06pos_x,body06pos_y,body06pos_z,body06vel_x,  &
                     body06vel_y,body06vel_z)
!
                  ncycle(15)=nprim
                  ncycle(16)=nsec
                  DO ij=1,nprim
                     ttimes(15,ij)=eprim(ij)
                     tseps(15,ij)=distprim(ij)
                     tdur1(15,ij)=durprim1(ij)
                     tdur2(15,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(16,ij)=esec(ij)
                     tseps(16,ij)=distsec(ij)
                     tdur1(16,ij)=dursec1(ij)
                     tdur2(16,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(15)=0
                  ncycle(16)=0
               END IF
!
!   find the times of transit and occultation of body 6 by the
!   secondary
!
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff2,reff6,  &
                     separ,2,6,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body02pos_x,body02pos_y,  &
                     body02pos_z,body02vel_x,body02vel_y,body02vel_z,  &
                     body06pos_x,body06pos_y,body06pos_z,body06vel_x,  &
                     body06vel_y,body06vel_z)
!
                  ncycle(17)=nprim
                  ncycle(18)=nsec
                  DO ij=1,nprim
                     ttimes(17,ij)=eprim(ij)
                     tseps(17,ij)=distprim(ij)
                     tdur1(17,ij)=durprim1(ij)
                     tdur2(17,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(18,ij)=esec(ij)
                     tseps(18,ij)=distsec(ij)
                     tdur1(18,ij)=dursec1(ij)
                     tdur2(18,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(17)=0
                  ncycle(18)=0
               END IF
!
!   end if Nbody .ge. 6
!
            END IF
!
!   find the times of transit and occultation of body 7 by the
!   primary
!
            IF(nbody >= 7)THEN
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff1,reff7,  &
                     separ,1,7,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body01pos_x,body01pos_y,  &
                     body01pos_z,body01vel_x,body01vel_y,body01vel_z,  &
                     body07pos_x,body07pos_y,body07pos_z,body07vel_x,  &
                     body07vel_y,body07vel_z)
!
                  ncycle(19)=nprim
                  ncycle(20)=nsec
                  DO ij=1,nprim
                     ttimes(19,ij)=eprim(ij)
                     tseps(19,ij)=distprim(ij)
                     tdur1(19,ij)=durprim1(ij)
                     tdur2(19,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(20,ij)=esec(ij)
                     tseps(20,ij)=distsec(ij)
                     tdur1(20,ij)=dursec1(ij)
                     tdur2(20,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(19)=0
                  ncycle(20)=0
               END IF
!
!   find the times of transit and occultation of body 7 by the
!   secondary
!
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff2,reff7,  &
                     separ,2,7,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body02pos_x,body02pos_y,  &
                     body02pos_z,body02vel_x,body02vel_y,body02vel_z,  &
                     body07pos_x,body07pos_y,body07pos_z,body07vel_x,  &
                     body07vel_y,body07vel_z)
!
                  ncycle(21)=nprim
                  ncycle(22)=nsec
                  DO ij=1,nprim
                     ttimes(21,ij)=eprim(ij)
                     tseps(21,ij)=distprim(ij)
                     tdur1(21,ij)=durprim1(ij)
                     tdur2(21,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(22,ij)=esec(ij)
                     tseps(22,ij)=distsec(ij)
                     tdur1(22,ij)=dursec1(ij)
                     tdur2(22,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(21)=0
                  ncycle(22)=0
               END IF
!
!   end if Nbody .ge. 7
!
            END IF
!
!   find the times of transit and occultation of body 8 by the
!   primary
!
            IF(nbody >= 8)THEN
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff1,reff8,  &
                     separ,1,8,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body01pos_x,body01pos_y,  &
                     body01pos_z,body01vel_x,body01vel_y,body01vel_z,  &
                     body08pos_x,body08pos_y,body08pos_z,body08vel_x,  &
                     body08vel_y,body08vel_z)
!
                  ncycle(23)=nprim
                  ncycle(24)=nsec
                  DO ij=1,nprim
                     ttimes(23,ij)=eprim(ij)
                     tseps(23,ij)=distprim(ij)
                     tdur1(23,ij)=durprim1(ij)
                     tdur2(23,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(24,ij)=esec(ij)
                     tseps(24,ij)=distsec(ij)
                     tdur1(24,ij)=dursec1(ij)
                     tdur2(24,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(23)=0
                  ncycle(24)=0
               END IF
!
!   find the times of transit and occultation of body 8 by the
!   secondary
!
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff2,reff8,  &
                     separ,2,8,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body02pos_x,body02pos_y,  &
                     body02pos_z,body02vel_x,body02vel_y,body02vel_z,  &
                     body08pos_x,body08pos_y,body08pos_z,body08vel_x,  &
                     body08vel_y,body08vel_z)
!
                  ncycle(25)=nprim
                  ncycle(26)=nsec
                  DO ij=1,nprim
                     ttimes(25,ij)=eprim(ij)
                     tseps(25,ij)=distprim(ij)
                     tdur1(25,ij)=durprim1(ij)
                     tdur2(25,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(26,ij)=esec(ij)
                     tseps(26,ij)=distsec(ij)
                     tdur1(26,ij)=dursec1(ij)
                     tdur2(26,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(25)=0
                  ncycle(26)=0
               END IF
!
!   end if Nbody .ge. 8
!
            END IF
!
!   find the times of transit and occultation of body 9 by the
!   primary
!
            IF(nbody >= 9)THEN
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff1,reff9,  &
                     separ,1,9,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body01pos_x,body01pos_y,  &
                     body01pos_z,body01vel_x,body01vel_y,body01vel_z,  &
                     body09pos_x,body09pos_y,body09pos_z,body09vel_x,  &
                     body09vel_y,body09vel_z)
!
                  ncycle(27)=nprim
                  ncycle(28)=nsec
                  DO ij=1,nprim
                     ttimes(27,ij)=eprim(ij)
                     tseps(27,ij)=distprim(ij)
                     tdur1(27,ij)=durprim1(ij)
                     tdur2(27,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(28,ij)=esec(ij)
                     tseps(28,ij)=distsec(ij)
                     tdur1(28,ij)=dursec1(ij)
                     tdur2(28,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(27)=0
                  ncycle(28)=0
               END IF
!
!   find the times of transit and occultation of body 9 by the
!   secondary
!
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff2,reff9,  &
                     separ,2,9,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body02pos_x,body02pos_y,  &
                     body02pos_z,body02vel_x,body02vel_y,body02vel_z,  &
                     body09pos_x,body09pos_y,body09pos_z,body09vel_x,  &
                     body09vel_y,body09vel_z)
!
                  ncycle(29)=nprim
                  ncycle(30)=nsec
                  DO ij=1,nprim
                     ttimes(29,ij)=eprim(ij)
                     tseps(29,ij)=distprim(ij)
                     tdur1(29,ij)=durprim1(ij)
                     tdur2(29,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(30,ij)=esec(ij)
                     tseps(30,ij)=distsec(ij)
                     tdur1(30,ij)=dursec1(ij)
                     tdur2(30,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(29)=0
                  ncycle(30)=0
               END IF
!
!   end if Nbody .ge. 9
!
            END IF
!
!   find the times of transit and occultation of body 10 by the
!   primary
!
            IF(nbody >= 10)THEN
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff1,reff10,  &
                     separ,1,10,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body01pos_x,body01pos_y,  &
                     body01pos_z,body01vel_x,body01vel_y,body01vel_z,  &
                     body10pos_x,body10pos_y,body10pos_z,body10vel_x,  &
                     body10vel_y,body10vel_z)
!
                  ncycle(31)=nprim
                  ncycle(32)=nsec
                  DO ij=1,nprim
                     ttimes(31,ij)=eprim(ij)
                     tseps(31,ij)=distprim(ij)
                     tdur1(31,ij)=durprim1(ij)
                     tdur2(31,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(32,ij)=esec(ij)
                     tseps(32,ij)=distsec(ij)
                     tdur1(32,ij)=dursec1(ij)
                     tdur2(32,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(31)=0
                  ncycle(32)=0
               END IF
!
!   find the times of transit and occultation of body 10 by the
!   secondary
!
               IF(isw84 <= 0)THEN
                  CALL findprimaryeclipse(nbody,odetime,nstep,nprim,  &
                     eprim,nsec,esec,ndyn,distprim,distsec,reff2,reff10,  &
                     separ,2,10,nmxeclipse,durprim1,dursec1,durprim2,  &
                     dursec2,sw85,inopt,body02pos_x,body02pos_y,  &
                     body02pos_z,body02vel_x,body02vel_y,body02vel_z,  &
                     body10pos_x,body10pos_y,body10pos_z,body10vel_x,  &
                     body10vel_y,body10vel_z)
!
                  ncycle(33)=nprim
                  ncycle(34)=nsec
                  DO ij=1,nprim
                     ttimes(33,ij)=eprim(ij)
                     tseps(33,ij)=distprim(ij)
                     tdur1(33,ij)=durprim1(ij)
                     tdur2(33,ij)=durprim2(ij)
                  END DO
                  DO ij=1,nsec
                     ttimes(34,ij)=esec(ij)
                     tseps(34,ij)=distsec(ij)
                     tdur1(34,ij)=dursec1(ij)
                     tdur2(34,ij)=dursec2(ij)
                  END DO
               ELSE
                  ncycle(33)=0
                  ncycle(34)=0
               END IF
!
!   end if Nbody .ge. 10
!
            END IF
!
!   end if isw23.lt.2
!
         END IF
!
!   end if Nbody .ge. 3
!
      END IF
!
!  see if we use fluxes from user
!
      IF(isw86 == 1)THEN
         DO jkl=1,8
            darkint1(jkl)=sdarkint1(jkl)/pie
            darkint2(jkl)=sdarkint2(jkl)/pie
            darkint3(jkl)=sdarkint3(jkl)/pie
            darkint4(jkl)=sdarkint4(jkl)/pie
            darkint5(jkl)=sdarkint5(jkl)/pie
            IF(isw30 <= 2)third(jkl)=sdarkint3(jkl)/pie
         END DO
      END IF
!
!  If the flag isw86 is 2, then the fluxes for stars 2 through
!  5 are flux ratios.
!
      IF(isw86 >= 2)THEN
         DO jkl=1,8
            darkint1(jkl)=sdarkint1(jkl)/pie
            darkint2(jkl)=sdarkint1(1)*sdarkint2(jkl)/pie
            darkint3(jkl)=sdarkint1(1)*sdarkint3(jkl)/pie
            darkint4(jkl)=sdarkint1(1)*sdarkint4(jkl)/pie
            darkint5(jkl)=sdarkint1(1)*sdarkint5(jkl)/pie
            IF(isw30 <= 2)third(jkl)=sdarkint3(jkl)/pie
         END DO
      END IF
!
!  If it2 >= 2, open files to contain the light travel
!  time corrected positions
!
      IF((it2 >= 2).AND.(isw30 > 2))THEN
         OPEN(UNIT=91,FILE='ELCdynamics.body01',STATUS='unknown')
         OPEN(UNIT=92,FILE='ELCdynamics.body02',STATUS='unknown')
         IF(isw30 >= 3)OPEN(UNIT=93,FILE='ELCdynamics.body03', STATUS='unknown')
         IF(isw30 >= 4)OPEN(UNIT=94,FILE='ELCdynamics.body04', STATUS='unknown')
         IF(isw30 >= 5)OPEN(UNIT=95,FILE='ELCdynamics.body05', STATUS='unknown')
         IF(isw30 >= 6)OPEN(UNIT=96,FILE='ELCdynamics.body06', STATUS='unknown')
         IF(isw30 >= 7)OPEN(UNIT=97,FILE='ELCdynamics.body07', STATUS='unknown')
         IF(isw30 >= 8)OPEN(UNIT=98,FILE='ELCdynamics.body08', STATUS='unknown')
         IF(isw30 >= 9)OPEN(UNIT=99,FILE='ELCdynamics.body09', STATUS='unknown')
         IF(isw30 >= 10)OPEN(UNIT=100,FILE='ELCdynamics.body10', STATUS='unknown')
      END IF
!
      qtemp=q
      IF(q <= 0.0_dp)qtemp=rm2/rm1
      CALL fastanalytic(nphase,nmaxphase,xmod,ymodu,ymodb,ymodv,  &
         ymodr,ymodi,ymodj,ymodh,ymodk,ymods1,ymods2,ymods3,ymodd,  &
         rv1,rv2,drv1,drv2,nrvphase,xrvmod,fracs1,fracs2,fracs3,  &
         fracs4,fracs5,fracs6,fracs7,fracs8,period,t0,ecc,  &
         argper,omega1,finc,ilaw,dwavex,dwavey,bigi,bigbeta,sw29,  &
         sw30,isw21,ikeep,pshift,reff1,reff2,darkint1,darkint2,  &
         idark2,dphase,irvfilt,qtemp,separ,gamma,isw27,  &
         icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,icnrv1,icnrv2,  &
         timearray,sw9,sw23,sw24,isw7,sa3,third,contam,pconj,beam1,  &
         beam2,ngap,gaplow,gaphigh,tertperiod,tertt0,tertecos,  &
         tertesin,tertincl,tertomega,tertq,itconj,tertconj,isw30,  &
         darkint3,omegadot,odetime,nstep,isw33,  &
         contams0,contams1,contams2,contams3,iseason,ndyn,p2tconj,  &
         p2period,p2ecos,p2esin,p2incl,p2omega,p2q,p2ratrad,  &
         p3tconj,p3period,p3ecos,p3esin,p3incl,p3omega,p3q,  &
         p3ratrad,p4tconj,p4period,p4ecos,p4esin,p4incl,  &
         p4omega,p4q,p4ratrad,p5tconj,p5period,p5ecos,p5esin,  &
         p5incl,p5omega,p5q,p5ratrad,p6tconj,p6period,p6ecos,  &
         p6esin,p6incl,p6omega,p6q,p6ratrad,p7tconj,p7period,  &
         p7ecos,p7esin,p7incl,p7omega,p7q,p7ratrad,p8tconj,p8period,  &
         p8ecos,p8esin,p8incl,p8omega,p8q,p8ratrad,rv3,nsc,xsc,  &
         ysc,darkint4,fourth,ymods4,ymods5,darkint5,rv4,isw87,  &
         tertratrad,sdarkint6,sdarkint7,sdarkint8,  &
         sdarkint9,sdarkint10,sqtertecos,sqtertesin,  &
         sqp2ecos,sqp2esin,sqp3ecos,sqp3esin,sqp4ecos,sqp4esin,  &
         sqp5ecos,sqp5esin,sqp6ecos,sqp6esin,sqp7ecos,sqp7esin,  &
         sqp8ecos,sqp8esin,body01pos_x,body01pos_y,body01pos_z,  &
         body02pos_x,body02pos_y,body02pos_z,body03pos_x,  &
         body03pos_y,body03pos_z,body04pos_x,body04pos_y,  &
         body04pos_z,body05pos_x,body05pos_y,body05pos_z,  &
         body06pos_x,body06pos_y,body06pos_z,body07pos_x,  &
         body07pos_y,body07pos_z,body08pos_x,body08pos_y,  &
         body08pos_z,body09pos_x,body09pos_y,body09pos_z,  &
         body10pos_x,body10pos_y,body10pos_z,body01vel_x,  &
         body01vel_y,body01vel_z,body02vel_x,body02vel_y,  &
         body02vel_z,body03vel_x,body03vel_y,body03vel_z,  &
         body04vel_x,body04vel_y,body04vel_z,body05vel_x,  &
         body05vel_y,body05vel_z,body06vel_x,body06vel_y,  &
         body06vel_z,body07vel_x,body07vel_y,body07vel_z,  &
         body08vel_x,body08vel_y,body08vel_z,body09vel_x,  &
         body09vel_y,body09vel_z,body10vel_x,body10vel_y,  &
         body10vel_z,bigi2,bigi3,bigi4,bigbeta2,bigbeta3,bigbeta4,  &
         omega2,omega3,omega4,omega5,omega6,omega7,omega8,omega9,  &
         omega10,drv3,drv4,drv5,rv5,it2,iatm,lengthtime,iversion, &
         tesscontam,tessfilt,tessbin)
!
      IF((it2 >= 2).AND.(isw30 > 2))THEN
         CLOSE(91)
         CLOSE(92)
         IF(isw30 >= 3)CLOSE(93)
         IF(isw30 >= 4)CLOSE(94)
         IF(isw30 >= 5)CLOSE(95)
         IF(isw30 >= 6)CLOSE(96)
         IF(isw30 >= 7)CLOSE(97)
         IF(isw30 >= 8)CLOSE(98)
         IF(isw30 >= 9)CLOSE(99)
         IF(isw30 >= 10)CLOSE(100)
      END IF
!
      rpole1=1.0_dp
      rpole2=1.0_dp
      bdist=1.0_dp
!
      CALL parms(1,teff2,qtemp,finc,separ,period,reff1,reff2,  &
         vrot1,vrot2,gscale1,gscale2,omega1,omega2,ecc,0,  &
         rmass,rrad,rrau,rm1,rm2,r1,r2,isw30,obsparm)
!
      obsparm(19)=t3
      CALL parms1(teff2,qtemp,finc,separ,period,reff1,reff2,gp1,  &
         gp2,vrot1,vrot2,gscale1,gscale2,omega1,omega2,obsparm,  &
         bdist,ecc,argper,teff1,0)
!
      pot1=0.0_dp
      pot2=0.0_dp
      ave11=0.0_dp
      ave12=0.0_dp
      ave21=0.0_dp
      ave22=0.0_dp
      ave1=0.0_dp
      ave2=0.0_dp
!
      rdepth=1.0_dp
      IF(icnu /= 430)CALL getdepth(nphase,ymodu,rdepth)
      CALL lineparms1(teff2,qtemp,finc,separ,period,reff1,reff2,  &
         vrot1,vrot2,omega1,omega2,bdist,ecc,sa3,ave11,ave12,ave21,  &
         ave22,ave1,ave2,parmstring,pot1,pot2,rdepth,tertq,argper)
!
      IF(isw30 > 2)CALL planetparms(planetparm,tref,qtemp,finc,  &
         separ,period,reff1,reff2,ecc,tertratrad,tertperiod,tertt0,  &
         tertecos,tertesin,tertincl,tertomega,tertq,itconj,tertconj,  &
         p2tconj,p2period,p2t0,p2ecos,p2esin,p2incl,p2omega,p2q,  &
         p2ratrad,p3tconj,p3period,p3t0,p3ecos,p3esin,p3incl,  &
         p3omega,p3q,p3ratrad,p4tconj,p4period,p4t0,p4ecos,p4esin,  &
         p4incl,p4omega,p4q,p4ratrad,p5tconj,p5period,p5t0,p5ecos,  &
         p5esin,p5incl,p5omega,p5q,p5ratrad,p6tconj,p6period,p6t0,  &
         p6ecos,p6esin,p6incl,p6omega,p6q,p6ratrad,p7tconj,p7period,  &
         p7t0,p7ecos,p7esin,p7incl,p7omega,p7q,p7ratrad,p8tconj,  &
         p8period,p8t0,p8ecos,p8esin,p8incl,p8omega,p8q,p8ratrad,  &
         argper,t0,tconj,isw28,it1,rrad,rrau)
!
      rrad(1)=reff1*separ
      rrad(2)=reff2*separ
      rrad(3)=reff3*separ
      rrad(4)=reff4*separ
      rrad(5)=reff5*separ
      rrad(6)=reff6*separ
      rrad(7)=reff7*separ
      rrad(8)=reff8*separ
      rrad(9)=reff9*separ
      rrad(10)=reff10*separ
      qtemp=q
      IF(q <= 0.0_dp)qtemp=rm2/rm1
      CALL parms(1,teff2,qtemp,finc,separ,period,reff1,reff2,  &
         vrot1,vrot2,gscale1,gscale2,omega1,omega2,ecc,  &
         ioutflag,rmass,rrad,rrau,rm1,rm2,r1,r2,isw30,obsparm)
!
      ave11=0.0_dp
      ave12=0.0_dp
      ave21=0.0_dp
      ave22=0.0_dp
      ave1=0.0_dp
      ave2=0.0_dp
      diskrad=0.0_dp
      diskthick=0.0_dp
      fill1=0.0_dp
      fill2=0.0_dp
      rdepth=1.0_dp
      IF(icnu /= 430)CALL getdepth(nphase,ymodu,rdepth)
      ioutflag=ioutflagsave
      obsparm(9)=0.0_dp
      CALL newparm(ioutflag,newparmstr,rmass,rrad,rrau,  &
         teff2,qtemp,separ,ecc,argper,period,finc,omega1,omega2,  &
         ave11,ave12,ave21,ave22,ave1,ave2,diskrad,diskthick,  &
         obsparm(9),rdepth,sw49,tconj,t0,nbody,tref,ribcinp,itconj,  &
         tertt0,p2t0,p3t0,p4t0,p5t0,p6t0,p7t0,p8t0,fill1,fill2)
      ioutflagsave=ioutflag
      IF(ioutflag == 9)ioutflag=1
!
      icount=nphase
      eshift=0.0_dp
      IF(isw24 >= 1)CALL getanalfracs(nmaxphase,icount,fracs1,  &
         fracs2,fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,compfracs,  &
         nphase,xmod,eshift,pshift,sw26,fracstring)
!
!            if(isw23.ge.1)then
!              call analdistorttime(Nmaxphase,Nphase,xmod,RV2,gamma,
!     %           pconj)
!            endif
!
      IF(ioutflag == 1)CLOSE(2)
!
!  Deallocate the variables needed for the dynamical
!  integrator
!
      DEALLOCATE(timearray)
      DEALLOCATE(odetime)
!
      DEALLOCATE(body01pos_x,body01pos_y,body01pos_z)
      DEALLOCATE(body01vel_x,body01vel_y,body01vel_z)
!
      DEALLOCATE(body02pos_x,body02pos_y,body02pos_z)
      DEALLOCATE(body02vel_x,body02vel_y,body02vel_z)
!
      DEALLOCATE(body03pos_x,body03pos_y,body03pos_z)
      DEALLOCATE(body03vel_x,body03vel_y,body03vel_z)
!
      DEALLOCATE(body04pos_x,body04pos_y,body04pos_z)
      DEALLOCATE(body04vel_x,body04vel_y,body04vel_z)
!
      DEALLOCATE(body05pos_x,body05pos_y,body05pos_z)
      DEALLOCATE(body05vel_x,body05vel_y,body05vel_z)
!
      DEALLOCATE(body06pos_x,body06pos_y,body06pos_z)
      DEALLOCATE(body06vel_x,body06vel_y,body06vel_z)
!
      DEALLOCATE(body07pos_x,body07pos_y,body07pos_z)
      DEALLOCATE(body07vel_x,body07vel_y,body07vel_z)
!
      DEALLOCATE(body08pos_x,body08pos_y,body08pos_z)
      DEALLOCATE(body08vel_x,body08vel_y,body08vel_z)
!
      DEALLOCATE(body10pos_x,body10pos_y,body10pos_z)
      DEALLOCATE(body10vel_x,body10vel_y,body10vel_z)
!
!
      CLOSE(2)
      RETURN
!
!   end fast analytic block
!
   END IF
!
!   UPDATE JULY 21, 2006
!
!   Add a "fast genetic" mode.  If ifastflag=1, then set
!     Nalph1=40
!     Nbet1=14
!     Nalph2=40
!     Nbet2=14
!     dphase=3
!
!   We need to save the values to reset at the end of the subroutine
!
   ALLOCATE(xecx(5000),xecy(5000))
   xecx=0.0_dp  ;  xecy=0.0_dp    
   ina1save=nalph1
   ina2save=nalph2
   inb1save=nbet1
   inb2save=nbet2
   savedphase=dphase
!
   IF(ifastflag >= 1)THEN
      nalph1=40
      nalph2=40
      nbet1=14
      nbet2=14
      dphase=10.0_dp*savedphase
      IF(dphase > 3.0_dp)dphase=3.0_dp
   END IF
!
!   Save the value of the flag iecheck so we can reset it at the
!   end of the routine.
!
   iesave=iecheck
!
!  UPDATE May 8, 2006
!
!  Add new flags and variables, including ialign, bigI, bigbeta.
!
   ialign=isw21
   IF(ialign >= 0)THEN
      bigbeta=0.0_dp
      bigi=finc
      savethetamis=bigi
      savephimis=bigbeta
   END IF
!
   ionephase=isw1
   onephase=sw1
   isquare=isw2
   iusepot=isw3
   usepot1=sw2
   usepot2=sw3
   bdist=1.0_dp
!
   fluxu2=0.0_dp
   fluxb2=0.0_dp
   fluxv2=0.0_dp
   fluxr2=0.0_dp
   fluxi2=0.0_dp
   fluxj2=0.0_dp
   fluxh2=0.0_dp
   fluxk2=0.0_dp
!
!   UPDATE May 10, 2006
!
!   If we are in analytic mode (isw12>0), then set iehceck=0 and ism1=0
!
   IF(isw12 > 0)THEN
      ism1=0
      iecheck=1
   END IF
!
!    May 8, 2001
!
!   Define the 'simpson switch' and the 'gravity exponent switch'
!
   tteff2=0.0_dp
   IF(sw5 > 0.0_dp)tteff2=teff2
!
!   UPDATE October 13, 2008
!
!   Redefine the isw5 switch.  It will now control how the spot
!   temperature profile is computed.
!
!   ispotprof=0    constant temperature factor
!   ispotprof=1    linear change in temperature profile
!   ispotprof=2    Gaussian change
!
   isimp=0
   ispotprof=isw5
   igrav=isw6
!
!   Count the number of spots on each star.
!
   ispot1=0
   ispot2=0
   ispotd=0
   DO  ii=1,2
      IF(spot1parm(ii,1) > 0.0_dp)ispot1=ispot1+1
      IF(spot2parm(ii,1) > 0.0_dp)ispot2=ispot2+1
      IF(spotdparm(ii,1) > 0.0_dp)ispotd=ispotd+1
   END DO
!
   IF(igrav == 1)CALL gravexp(teff1,tgrav1,1,ioutflag)
   IF((igrav == 2).AND.(teff2 > 0.0_dp))THEN
      CALL gravexp(teff2,tgrav2,2,ioutflag)
   END IF
   IF(igrav == 3)THEN
      CALL gravexp(teff1,tgrav1,1,ioutflag)
      IF(teff2 > 0.0_dp)CALL gravexp(teff2,tgrav2,2,ioutflag)
   END IF
!
   ivrt=0
   fillper1=fill1
   fillper2=fill2
   bdist=1.0_dp-ecc
   pervol1=1.0_dp
   pervol2=1.0_dp
!
!   If isynch = 1, then set the omega values so that the rotation is
!   synchronous at periastron.
!
   IF((ecc > 0.0_dp).AND.(isynch >= 1))THEN
!
      sss=SQRT((1.0_dp+ecc)/(1.0_dp-ecc)**3)
      omega1=sss
      omega2=sss
   END IF
!
   tstep=sw9
   tstart=sw23
   tstop=sw24
!
   lengthtime=int((tstop-tstart)/tstep)+10
   ALLOCATE(timearray(lengthtime))
   timearray=0.0_dp
!
   IF(isw7 == 2)CALL filltime(ntime,timearray,tstart,tstop,tstep,lengthtime)
!
!   UPDATE JULY 4, 2004
!
!   Assign the variable MonteCarlo to isw8.  It will be used
!   in the Monte Carlo routine to compute fractionally eclipsed
!   pixels.
!
   montecarlo=isw8
   IF(montecarlo >= montemax)montecarlo=montemax
!
!   UPDATE December 21, 2008
!
!   Here is a new subroutine call.  radfill sets the filling
!   factor based on the
!   effective radius, rather than the L_1 point distance
!
   radfill1=sw27
   radfill2=sw28
   bdist=1.0_dp-ecc
   qtemp=q
   qsave=q
   IF(q <= 0.0_dp)THEN
      rm1=0.5_dp*(masssum+massdiff)
      rm2=masssum-rm1
      qtemp=rm2/rm1
   END IF
   CALL setfill(1,qtemp,fill1,radfill1,omega1,bdist,tidephi,  &
      itide,ecc,thetamis,phimis,ioutflag)
   CALL setfill(2,qtemp,fill2,radfill2,omega2,bdist,tidephi,  &
      itide,ecc,thetamis,phimis,ioutflag)
!
!   Allocate the arrays associated with the stars
!   when using Roche geometry
!
   ialphmax1=nalph1+10
   ibetmax1=6*nbet1+10
   IF(teff2 > 0.0_dp)THEN
      ialphmax2=nalph2+10
      ibetmax2=6*nbet2+10
   ELSE
      nalph2=20
      nbet2=4
      ialphmax2=nalph1+10
      ibetmax2=6*nbet2+10
   END IF
   IF((isw30 >= 2).AND.(isw7 >= 2))THEN
      ialphmax3=nalph3+10
      ibetmax3=6*nbet3+10
   ELSE
      ialphmax3=10
      ibetmax3=10
   END IF
   IF(iidint >= 1)THEN
      nthetamax=ntheta+10
      nrmax=nradius+10
   ELSE
      nthetamax=5
      nrmax=5
   END IF
   ALLOCATE(mmdx1(ialphmax1,ibetmax1),mmdx2(ialphmax2,ibetmax2),mmdx3(ialphmax3,ibetmax3))
   mmdx1=0 ; mmdx2=0 ; mmdx3=0
   ALLOCATE(ibetlim1(ialphmax1),ibetlim2(ialphmax2),ibetlim3(ialphmax3))
   ibetlim1=0 ; ibetlim2=0 ; ibetlim3=0
   ALLOCATE(rad1(ialphmax1*ibetmax1),rad2(ialphmax2*ibetmax2),rad3(ialphmax3*ibetmax3))
   rad1=0.0_dp ; rad2=0.0_dp ; rad3=0.0_dp
   ALLOCATE(x1(ialphmax1*ibetmax1),y1(ialphmax1*ibetmax1),z1(ialphmax1*ibetmax1))
   x1=0.0_dp ; y1=0.0_dp ; z1=0.0_dp
   ALLOCATE(x2(ialphmax2*ibetmax2),y2(ialphmax2*ibetmax2),z2(ialphmax2*ibetmax2))
   x2=0.0_dp ; y2=0.0_dp ; z2=0.0_dp
   ALLOCATE(x3(ialphmax3*ibetmax3),y3(ialphmax3*ibetmax3),z3(ialphmax3*ibetmax3))
   x3=0.0_dp ; y3=0.0_dp ; z3=0.0_dp
   ALLOCATE(visib1(ialphmax1*ibetmax1),visib2(ialphmax2*ibetmax2),visib3(ialphmax3*ibetmax3))
   visib1=0.0_dp ; visib2=0.0_dp ; visib3=0.0_dp
   ALLOCATE(rinty1(ialphmax1*ibetmax1),rinty2(ialphmax2*ibetmax2),rinty3(ialphmax3*ibetmax3))
   rinty1=0.0_dp ; rinty2=0.0_dp ; rinty3=0.0_dp
   ALLOCATE(flum1(ialphmax1*ibetmax1),flum2(ialphmax2*ibetmax2),flum3(ialphmax3*ibetmax3))
   flum1=0.0_dp ; flum2=0.0_dp ; flum3=0.0_dp
   ALLOCATE(saveinty1(ialphmax1*ibetmax1),saveinty2(ialphmax2*ibetmax2),  &
      saveinty3(ialphmax3*ibetmax3))
   saveinty1=0.0_dp ; saveinty2=0.0_dp ; saveinty3=0.0_dp  
   ALLOCATE(phiar1(ialphmax1*ibetmax1),phiar2(ialphmax2*ibetmax2),phiar3(ialphmax3*ibetmax3))
   phiar1=0.0_dp ; phiar2=0.0_dp ; phiar3=0.0_dp 
   ALLOCATE(delphi1(ialphmax1*ibetmax1),delphi2(ialphmax2*ibetmax2), &
      delphi3(ialphmax3*ibetmax3))
   delphi1=0.0_dp ; delphi2=0.0_dp ; delphi3=0.0_dp 
   ALLOCATE(iedgestar1(ialphmax1*ibetmax1),iedgestar2(ialphmax2*ibetmax2), &
      iedgestar3(ialphmax3*ibetmax3))
   iedgestar1=0.0_dp ; iedgestar2 = 0.0_dp ; iedgestar3=0.0_dp 
   ALLOCATE(iedgehor1(ialphmax1*ibetmax1),iedgehor2(ialphmax2*ibetmax2),  &
      iedgehor3(ialphmax3*ibetmax3))
   iedgehor1=0.0_dp ; iedgehor2=0.0_dp ; iedgehor3=0.0_dp
   ALLOCATE(delphie1(ialphmax1*ibetmax1),delphie2(ialphmax2*ibetmax2),  &
      delphie3(ialphmax3*ibetmax3))
   delphie1=0.0_dp ; delphie2 = 0.0_dp ; delphie3=0.0_dp
   ALLOCATE(phihor1(ialphmax1,4),phihor2(ialphmax2,4),phihor3(ialphmax3,4))
   phihor1=0.0_dp ; phihor2=0.0_dp ; phihor3=0.0_dp
   ALLOCATE(surf1(ialphmax1*ibetmax1),surf2(ialphmax2*ibetmax2),surf3(ialphmax3*ibetmax3))
   surf1=0.0_dp ; surf2=0.0_dp ; surf3=0.0_dp
   ALLOCATE(gradx1(ialphmax1*ibetmax1),gradx2(ialphmax2*ibetmax2))
   gradx1=0.0_dp ; gradx2=0.0_dp
   ALLOCATE(grady1(ialphmax1*ibetmax1),grady2(ialphmax2*ibetmax2))
   grady1=0.0_dp ; grady2=0.0_dp
   ALLOCATE(gradz1(ialphmax1*ibetmax1),gradz2(ialphmax2*ibetmax2))
   gradz1=0.0_dp ; gradz2=0.0_dp
   ALLOCATE(phistart1(ialphmax1),phistart2(ialphmax2),phistart3(ialphmax3))
   phistart1=0.0_dp ; phistart2=0.0_dp ; phistart3=0.0_dp
   ALLOCATE(g1(ialphmax1*ibetmax1),g2(ialphmax2*ibetmax2),gthird(ialphmax3*ibetmax3))
   g1=0.0_dp ; g2=0.0_dp ; gthird=0.0_dp
   ALLOCATE(gradx3(ialphmax3*ibetmax3),grady3(ialphmax3*ibetmax3),  &
      gradz3(ialphmax3*ibetmax3),grav3(ialphmax3*ibetmax3))
   gradx3=0.0_dp ; grady3=0.0_dp ; gradz3=0.0_dp ; grav3=0.0_dp
   ALLOCATE(temp1(ialphmax1*ibetmax1),temp2(ialphmax2*ibetmax2),temp3(ialphmax3*ibetmax3))
   temp1=0.0_dp ; temp2=0.0_dp ; temp3=0.0_dp
   ALLOCATE(rpol1(ialphmax1),rpol2(ialphmax2))
   rpol1=0.0_dp ; rpol2=0.0_dp
   ALLOCATE(xhoriz1(4*ibetmax1),yhoriz1(4*ibetmax1))
   xhoriz1=0.0_dp ; yhoriz1=0.0_dp
   ALLOCATE(xhoriz2(4*ibetmax2),yhoriz2(4*ibetmax2))
   xhoriz2=0.0_dp ; yhoriz2=0.0_dp
   ALLOCATE(xhoriz3(4*ibetmax3),yhoriz3(4*ibetmax3))
   xhoriz3=0.0_dp ; yhoriz3=0.0_dp
   ALLOCATE(xsky1(ialphmax1*ibetmax1*4),ysky1(ialphmax1*ibetmax1*4))
   xsky1=0.0_dp ; ysky1=0.0_dp
   ALLOCATE(xsky2(ialphmax2*ibetmax2*4),ysky2(ialphmax2*ibetmax2*4))
   xsky2=0.0_dp ; ysky2=0.0_dp
   ALLOCATE(xsky3(ialphmax3*ibetmax3*4),ysky3(ialphmax3*ibetmax3*4))
   xsky3=0.0_dp ; ysky3=0.0_dp
   ALLOCATE(ratio1(ialphmax1*ibetmax1),ratio2(ialphmax2*ibetmax2),  &
      tempold1(ialphmax1*ibetmax1),tempold2(ialphmax2*ibetmax2))
   ratio1=0.0_dp ; ratio2=0.0_dp ; tempold1=0.0_dp ; tempold2=0.0_dp
   ALLOCATE(projarray1(ialphmax1*ibetmax1),projarray2(ialphmax2*ibetmax2), &
      projarray3(ialphmax3*ibetmax3))
   projarray1=0.0_dp ; projarray2=0.0_dp ; projarray3=0.0_dp
   ALLOCATE(dumxsky1(ialphmax1*ibetmax1*4),dumysky1(ialphmax1*ibetmax1*4))
   dumxsky1=0.0_dp ; dumysky1=0.0_dp
   ALLOCATE(dumxsky2(ialphmax2*ibetmax2*4),dumysky2(ialphmax2*ibetmax2*4))
   dumxsky2=0.0_dp ; dumysky2=0.0_dp
   ALLOCATE(coprat1(ialphmax1*ibetmax1),coprat2(ialphmax2*ibetmax2))
   coprat1=0.0_dp ; coprat2=0.0_dp
   ALLOCATE(toldspot1(ialphmax1*ibetmax1),toldspot2(ialphmax2*ibetmax2))
   toldspot1=0.0_dp ; toldspot2=0.0_dp
   ALLOCATE(xtop2horiz(4*ibetmax2),ytop2horiz(4*ibetmax2))
   xtop2horiz=0.0_dp ; ytop2horiz=0.0_dp
!
!   Arrays associated with the disk
!
   ALLOCATE(dtemp(nrmax*nthetamax),dx(nrmax*nthetamax),dy(nrmax*nthetamax), &
      dz(nrmax*nthetamax),drad(nrmax*nthetamax))
   dtemp=0.0_dp ; dx=0.0_dp ; dy=0.0_dp ; dz=0.0_dp
   ALLOCATE(dinty(nrmax*nthetamax),einty(nthetamax*11),savedinty(nrmax*nthetamax), &
      saveeinty(nthetamax*11))
   dinty=0.0_dp ; einty=0.0_dp ; savedinty=0.0_dp ; saveeinty=0.0_dp 
   ALLOCATE(tedge(nthetamax*11),xedge(nthetamax*11),yedge(nthetamax*11),  &
      zedge(nthetamax*11))
   tedge=0.0_dp ; xedge=0.0_dp ; yedge=0.0_dp ; zedge=0.0_dp
   ALLOCATE(dxhoriz(2*nthetamax),dyhoriz(2*nthetamax),dtopx(2*nthetamax), &
      dtopy(2*nthetamax))
   dxhoriz=0.0_dp ; dyhoriz=0.0_dp ; dtopx=0.0_dp
   ALLOCATE(diskproj(nrmax*nthetamax),edgeproj(nthetamax*11))
   diskproj=0.0_dp ; edgeproj=0.0_dp
   ALLOCATE(dvisib(nrmax*nthetamax),evisib(nthetamax*11))
   dvisib=0.0_dp ; evisib=0.0_dp
   ALLOCATE(xskydisk(nthetamax*nrmax),yskydisk(nthetamax*nrmax),zskydisk(nthetamax*nrmax))
   xskydisk=0.0_dp ; yskydisk=0.0_dp ; zskydisk=0.0_dp
   ALLOCATE(xskyedge(nthetamax*11),yskyedge(nthetamax*11))
   xskyedge=0.0_dp ; yskyedge=0.0_dp
!
   iverb=0
   CALL setupgeo(1,ialphmax1,ibetmax1,nalph1,nbet1,ibetlim1,  &
      fill1,omega1,q,finc,x1,y1,z1,surf1,rad1,gradx1,grady1,gradz1,  &
      g1,xend1,separ,tgrav1,teff1,reff1,rl1,tpole1,rpol1,regg1,sa1,  &
      pot1,gpole1,phiar1,isquare,iusepot,usepot1,ivrt,pervol1,  &
      fillper1,bdist,pots1,mmdx1,primmass,primk,primrad,  &
      ratrad,frac1,frac2,ecc,period,size1,sw5,tteff2,density,  &
      tidephi,itide,phistart1,thetamis,phimis,ioutflag,arrsobx,  &
      montemax,masssum,massdiff,radsum,raddiff,secmass,  &
      secrad,fracsum,fracdiff,qtemp,fillsum,filldiff)
!
!   November 17, 2012
!
!   Load the third body geometry
!
   IF((isw30 >= 2).AND.(isw7 >= 2))THEN
      CALL setupgeo3(ialphmax3,ibetmax3,nalph3,nbet3,ibetlim3,x3,  &
         y3,z3,mmdx3,phiar3,surf3,rad3,gradx3,grady3,gradz3,gthird,  &
         temp3,reff1,sa3,reff3,t3,g3,grav3)
!
      fincr=finc*degtorad
!
!   period in hours
!
      ppp=period*24.0_dp
      total_mass=(separ)**(3)*coeff/(ppp*ppp)
      tertmass=total_mass/tertq
      tt1=(total_mass+tertmass)*(tertperiod*secinday)**2*gmsun
      smet=(tt1/(4.0_dp*pie*pie))**(1.0_dp/3.0_dp)
      tertsep=smet/solarrad
      axisscale=tertsep/separ
      tt1=(total_mass)*(period*secinday)**2*gmsun
      smet=(tt1/(4.0_dp*pie*pie))**(1.0_dp/3.0_dp)
!
      nhoriz1=360
      nhoriz2=360
      CALL fakehorizon(nhoriz1,xhoriz1,yhoriz1,999.9_dp,999.9_dp,1.0_dp)
      CALL fakehorizon(nhoriz2,xhoriz2,yhoriz2,999.9_dp,999.9_dp,1.0_dp)
      neclipse3=0
      nsky3=0
      IF(isw30 > 2)CALL getvisib3(3,ialphmax3,ibetmax3,nalph3,  &
         ibetlim3,0.0_dp,finc,qtemp,1.0_dp,gradx3,grady3,gradz3,  &
         x3,y3,z3,visib3,nhoriz1,xhoriz1,yhoriz1,nhoriz2,xhoriz2,  &
         yhoriz2,nsky3,xsky3,ysky3,projarray3,neclipse3,phiar3,  &
         rad3,delphi3,mmdx3,0,phistart3,thetamis,phimis,1,iedgehor3,  &
         tertincl,1.0_dp,90.0_dp,tertq,axisscale,isw30,isw7,tertomega)
!
      IF(iatm <= 0)THEN
         DO jj=1,8
            www=wave(jj)
            flimbx=dwavex(jj,3)
            flimby=dwavey(jj,3)
!
            CALL getbbflux(ialphmax3,ibetmax3,nalph3,ibetlim3,www,  &
               visib3,projarray3,temp3,surf3,flimbx,flimby,ilaw,  &
               rinty3,flum3,flux3,delphi3,delphie3,iedgestar3,  &
               iedgehor3,rldint3,separ,mmdx3,montecarlo,isw13,ialfmin,  &
               ialfmax,fluxlat,1,phiar3,phihor3)
            flux3keep(jj)=flux3
         END DO
      ELSE
         gscale3=1.0_dp
         CALL getatmint(maxlines,maxmu,nlines,atmt,atmg,atmmu,nmu,  &
            atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,  &
            atmint8,gscale3,darkint3,t3,g3,dwavex,dwavey,ilaw,iatm,2)
!
         CALL getatmflux(ialphmax3,ibetmax3,nalph3,ibetlim3,  &
            visib3,projarray3,temp3,surf3,grav3,rinty3,flum3,  &
            maxlines,maxmu,nlines,atmt,atmg,atmmu,nmu,atmint1,  &
            atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,  &
            gscale3,fluxu3,fluxb3,fluxv3,fluxr3,fluxi3,fluxj3,fluxh3,  &
            fluxk3,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,irvfilt,  &
            delphi3,delphie3,iedgestar3,iedgehor3,separ,mmdx3,  &
            montecarlo,dwavex,dwavey,ilaw,iatm,3)
!
         thirdkeep(1)=fluxu3
         thirdkeep(2)=fluxb3
         thirdkeep(3)=fluxv3
         thirdkeep(4)=fluxr3
         thirdkeep(5)=fluxi3
         thirdkeep(6)=fluxj3
         thirdkeep(7)=fluxh3
         thirdkeep(8)=fluxk3
      END IF
!
   END IF
!
   IF(teff2 > 0.0_dp)THEN
      CALL setupgeo(2,ialphmax2,ibetmax2,nalph2,nbet2,ibetlim2,  &
         fill2,omega2,qtemp,finc,x2,y2,z2,surf2,rad2,gradx2,grady2,  &
         gradz2,g2,xend2,separ,tgrav2,teff2,reff2,rl2,tpole2,rpol2,  &
         regg2,sa2,pot2,gpole2,phiar2,isquare,iusepot,usepot2,ivrt,  &
         pervol2,fillper2,bdist,pots2,mmdx2,primmass,primk,  &
         primrad,ratrad,frac1,frac2,ecc,period,size1,sw5,tteff2,  &
         density,tidephi,itide,phistart2,thetamis,phimis,ioutflag,  &
         arrsobx,montemax,masssum,massdiff,radsum,raddiff,  &
         secmass,secrad,fracsum,fracdiff,qtemp,fillsum,filldiff)
   ELSE
!
      CALL dummyvalues(ialphmax2,ibetmax2,nalph2,nbet2,x2,y2,z2,  &
         surf2,gradx2,grady2,gradz2,g2,xend2,darkbol2,temp2,ibetlim2,mmdx2,0)
      regg2=rocheradius(qtemp)
      reff2=regg2
      overq=1.0_dp/qtemp
      CALL findl1(overq,omega2,x0,1,bdist,tidephi,ecc,thetamis, phimis)
      rl2=x0
      tpole2=-1.0_dp
      pot2=1.0_dp
      gscale2=1.0_dp
      xhmin2=0.0_dp
      xhmax2=0.0_dp
      yhmin2=0.0_dp
      yhmax2=0.0_dp
   END IF
!
   IF(iidint >= 1)CALL disksetup(nthetamax,nrmax,ntheta,nradius,  &
      betarim,rinner,router,regg2,rl2,separ,tdisk,xi,dtemp,dx,dy,  &
      dz,drad,tedge,xedge,yedge,zedge,redge,stepr,stepz,bdist,ivrt,  &
      reper,rsper,ioutflag,diskrad,diskthick)
!
!  If the model atmosphere option is on, then compute the third light.
!
   IF(isw30 <= 2)CALL thirdlight(iatm,t3,g3,sa3,third,maxlines,  &
      maxmu,nlines,atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,  &
      atmint4,atmint5,atmint6,atmint7,atmint8,icnu,icnb,icnv,icnr,  &
      icni,icnj,icnh,icnk,separ,dwavex,dwavey,ilaw,3,reff1, ioutflag)
!
!   If the orbit is eccentric, then we have to loop over phases here.
!   Otherwise, we loop a bit further down.
!
!   Use the symmetry of the orbit in the mean anomaly M to only
!   compute half the phases for an eccentric orbit.  Thus, do not
!   disable the ism1 switch.   Also, define the variable pstep as
!   below (equals dphase by default)
!
   pstart=0.0_dp
   pstop=360.0_dp-dphase
   pconj=pie
   pconj2=0.0_dp
   pstep=dphase
   idcheck=100
   IF(ism1 >= 1)pstop=180.0_dp
!
!   UPDATE October 18, 2002
!
!   Use the input flags sw7 and sw8 to define a phase range
!   to compute.  Require sw7 > 0 and sw8 > 0  AND  sw7 < sw 8
!
   IF((sw7 > 0.0_dp).AND.(sw8 > 0.0_dp).AND.(sw7 < sw8))THEN
      IF((sw8-sw7) < dphase)dphase=sw8-sw7
      pstart=sw7
      pstop=sw8-dphase
   END IF
   pstartout=onephase
   pstopout=onephase
   IF(ecc > 0.0_dp)THEN
      pstartout=0.0_dp
      pstopout=360.0_dp-dphase
      IF(ism1 >= 1)pstopout=180.0_dp
   END IF
!
!   April 19, 2001.
!
!   If the ism1 flag is set, then modify the value of pstopout as above.
!
   IF(ioutflag == 1)OPEN(UNIT=64,FILE='ELC.phases',STATUS= 'unknown')
!
!   Open a new output file for eccentric orbits.
!
   IF(ioutflag == 1)THEN
      IF(ecc > 0.0_dp)OPEN(UNIT=65,FILE='ELC.eccentric',STATUS= 'unknown')
   END IF
!
   itoggle=-1
   icount=0
   icounttime=0
   togglephase=360.0_dp
!
   argrad=argper*degtorad
   trc=halfpie-argrad
   CALL checkangle(trc)
   htrc=0.5_dp*trc
   IF(ABS(halfpie-htrc) < 7.0E-6_dp)GO TO 20
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-ecc)/(1.0_dp+ecc))*TAN(htrc))
   GO TO 30
20 ecan=pie
30 xmc=ecan-ecc*SIN(ecan)
   IF(xmc < 0._dp)xmc=xmc+twopie
   phper=1.0_dp-xmc/(twopie)
   pconj=(xmc+argrad)/(twopie)-0.25_dp
!
!   UPDATE March 14, 2008
!
!   Make sure the conjunction phase is between 0 and 1
!
   IF(pconj > 1.0_dp)pconj=pconj-1.0_dp
!
!   UPDATE September 10, 2001
!
!   Make this new block to compute the conjunction phase for star 2.
!
   trc=halfpie-argrad+pie
   CALL checkangle(trc)
   htrc=0.5_dp*trc
   IF(ABS(halfpie-htrc) < 7.0E-6_dp)GO TO 40
   IF(ABS(4.712388980384690_dp-htrc) < 7.0E-6_dp)GO TO 40
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-ecc)/(1.0_dp+ecc))*TAN(htrc))
   GO TO 50
40 ecan=pie
50 xmc=ecan-ecc*SIN(ecan)
   IF(xmc < 0._dp)xmc=xmc+twopie
   phper2=1._dp-xmc/twopie
   pconj2=(xmc+argrad)/twopie-0.25_dp
!
!   UPDATE March 14, 2008
!
!   Make sure the conjunction phase is between 0 and 1
!
   IF(pconj2 > 1.0_dp)pconj2=pconj2-1.0_dp
!
   eshift=0.0_dp
   IF(ikeep == 1)eshift=phper+pconj-0.5_dp
   IF(ikeep == 2)eshift=phper2+pconj2
!
   IF(ABS(ecc) <= EPSILON(ecc))THEN
      eshift=0.0_dp
      pconj=0.0_dp
   END IF
!
!  UPDATE May 3, 2006
!
!  Add a "fast transit" mode.  If isw13 > 1, then find the range
!  of latitude rows on the star that are eclipsed.  These values
!  are returned as ialfmin,ialfmax
!
   ialfmin=999999
   ialfmax=-111111
   IF(isw13 >= 1)THEN
      fincr=finc*degtorad
      pup=360.0_dp
      IF(ism1 >= 1)pup=180.0_dp+dphase
      sf2=SIN(fincr)**2
      thetatan=radtodeg*ACOS(SQRT((1.0_dp-(reff1)**2)/sf2))
!
      iloopp=0
      nloopp=0
      nloopp=INT(((pup-thetatan+dphase)-dphase)/dphase)
      pp=pup-thetatan+dphase+dphase
!
!            do 6666 pp=pup-thetatan+dphase,(0.0_dp+dphase),-dphase
!
      DO  iloopp=nloopp,1,-1
         pp=pp-dphase
         phaser=pp*radtodeg
!
         delta=(COS(fincr)**2+(SIN(fincr)*SIN(phaser))**2)
         delta=bdist*SQRT(delta)
         IF(delta > reff1+reff2)CYCLE
!
         tt1=ABS(phaser-twopie*pconj)
         tt2=ABS(phaser-twopie*(pconj+1.0_dp))
         IF(tt1 <= tt2)THEN
            diff1=tt1
         ELSE
            diff1=tt2
         END IF
         tt1=ABS(phaser-twopie*pconj2)
         tt2=ABS(phaser-twopie*(pconj2+1.0_dp))
         IF(tt1 <= tt2)THEN
            diff2=tt1
         ELSE
            diff2=tt2
         END IF
         IF(diff1 < diff2)CYCLE
!
         dummyphase=MOD(pp+180.0_dp,360.0_dp)
         CALL gethorizon(2,ialphmax2,ibetmax2,nalph2,ibetlim2,  &
            dummyphase,finc,qtemp,pot2,omega2,x2,y2,z2,rad2,gradx2,  &
            grady2,gradz2,xend2,nhoriz2,xhoriz2,yhoriz2,phiar2,  &
            iedgestar2,delphie2,bdist,mmdx2,xhmin2,xhmax2,yhmin2,  &
            yhmax2,tidephi,itide,phihor2,ecc,thetamis,phimis,  &
            tertincl,tertbdist,tertphase,tertq,axisscale,isw30,isw7, &
            tertomega)
         CALL getalflim(1,ialphmax1,ibetmax1,nalph1,ibetlim1,pp,  &
            finc,qtemp,gradx1,grady1,gradz1,x1,y1,z1,nhoriz2,xhoriz2,  &
            yhoriz2,bdist,mmdx1,ialfmin,ialfmax,tertincl,tertbdist,  &
            tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
      END DO
!
      pp=180.0_dp
      dummyphase=MOD(pp+180.0_dp,360.0_dp)
      CALL gethorizon(2,ialphmax2,ibetmax2,nalph2,ibetlim2,  &
         dummyphase,finc,qtemp,pot2,omega2,x2,y2,z2,rad2,gradx2,  &
         grady2,gradz2,xend2,nhoriz2,xhoriz2,yhoriz2,phiar2,  &
         iedgestar2,delphie2,bdist,mmdx2,xhmin,xhmax,yhmin,yhmax,  &
         tidephi,itide,phihor2,ecc,thetamis,phimis,tertincl,  &
         tertbdist,tertphase,tertq,axisscale,isw30,isw7,tertomega)
      CALL getalflim(1,ialphmax1,ibetmax1,nalph1,ibetlim1,pp,  &
         finc,qtemp,gradx1,grady1,gradz1,x1,y1,z1,nhoriz2,xhoriz2,  &
         yhoriz2,bdist,mmdx1,ialfmin,ialfmax,tertincl,tertbdist,  &
         tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
      ialfmin=ialfmin-1
      ialfmax=ialfmax+1
!
!   Now we have to find the integrated brightness of the pixels on star
!   1 outside the range ialfmin,ialfmax
!
      IF(idark1 <= 0)CALL getrefvisib(ialphmax1,ibetmax1,nalph1,  &
         ibetlim1,0.0_dp,finc,gradx1,grady1,gradz1,visib1,projarray1, &
         mmdx1)
!
      IF(idark1 <= 0)CALL setuptemp(1,ialphmax1,ibetmax1,nalph1,  &
         ibetlim1,g1,tpole1,tgrav1,temp1,gpole1,mmdx1,ioutflag)
!
      IF(iatm == 0)THEN
         DO  jj=1,8
!
            flux1=0.0_dp
            IF(idark1 <= 0)THEN
               rpole1=rpol1(nalph1/2)
               www=wave(jj)
               flimbx=dwavex(jj,1)
               flimby=dwavey(jj,1)
               flux1=0.0_dp
               CALL getbblumcor(ialphmax1,ibetmax1,nalph1,ibetlim1,  &
                  www,visib1,projarray1,temp1,surf1,flimbx,flimby,ilaw,  &
                  rinty1,flum1,flux1,mmdx1,ialfmin,ialfmax)
            END IF
!
            rlatflux(jj)=flux1
         END DO
      END IF
!
!   end if fast transit mode
!
   END IF
!
!   UPDATE June 16, 2003
!
!   Add an EBOP mode.  If iecheck=9, then compute 'reference' fluxes
!   for star 1 and star 2.  Then at each phase, check the distance
!   between the two stellar centers.  If the distance is more than
!   the sum of the radii then skip the flux computation.
!
!   UPDATE April 24, 2006
!
!   If isw12=1, then compute analytic transits using Mandel and Agol.
!   Compute reference fluxes as in EBOP mode, then compute the ratio
!   of the transit given the separation between centers and the radius
!   ratio
!
   IF((iecheck == 9).OR.(isw12 >= 1))THEN
      IF(idark1 <= 0)CALL getrefvisib(ialphmax1,ibetmax1,nalph1,  &
         ibetlim1,0.0_dp,finc,gradx1,grady1,gradz1,visib1,projarray1, &
         mmdx1)
!
      IF(idark2 <= 0)CALL getrefvisib(ialphmax2,ibetmax2,nalph2,  &
         ibetlim2,180.0_dp,finc,gradx2,grady2,gradz2,visib2,projarray2, &
         mmdx2)
!
      IF(idark1 <= 0)CALL setuptemp(1,ialphmax1,ibetmax1,nalph1,  &
         ibetlim1,g1,tpole1,tgrav1,temp1,gpole1,mmdx1,ioutflag)
      IF((teff2 > 0.0_dp).AND.(idark2 <= 0))CALL setuptemp(2,  &
         ialphmax2,ibetmax2,nalph2,ibetlim2,g2,tpole2,tgrav2,temp2,  &
         gpole2,mmdx2,ioutflag)
!
      IF(iatm == 0)THEN
         DO  jj=1,8
!
            corr1(jj)=0.0_dp
            corr2(jj)=0.0_dp
            flux1=0.0_dp
            IF(idark1 <= 0)THEN
               rpole1=rpol1(nalph1/2)
!
               IF(jj == 1)THEN
                  CALL parms(1,teff2,qtemp,finc,separ,period,reff1,  &
                     reff2,vrot1,vrot2,gscale1,gscale2,omega1,omega2,  &
                     ecc,ioutflag,rmass,rrad,rrau,rm1,rm2,r1,r2,isw30,obsparm)
!
                  CALL parms1(teff2,qtemp,finc,separ,period,reff1,  &
                     reff2,gp1,gp2,vrot1,vrot2,gscale1,gscale2,omega1,  &
                     omega2,obsparm,bdist,ecc,argper,teff1,0)
!
               END IF
               www=wave(jj)
               flimbx=dwavex(jj,1)
               flimby=dwavey(jj,1)
               flux1=0.0_dp
               CALL getrefbbflux(ialphmax1,ibetmax1,nalph1,ibetlim1,  &
                  www,visib1,projarray1,temp1,surf1,flimbx,flimby,ilaw,  &
                  rinty1,flum1,flux1,rldint1,separ,mmdx1)
            END IF
!
            flux2=0.0_dp
            IF(idark2 <= 0)THEN
!
               rpole2=rpol2(nalph2/2)
!
               IF(jj == 1)THEN
                  CALL parms(1,teff2,qtemp,finc,separ,period,reff1,  &
                     reff2,vrot1,vrot2,gscale1,gscale2,omega1,omega2,  &
                     ecc,ioutflag,rmass,rrad,rrau,rm1,rm2,r1,r2,isw30,obsparm)
!
                  CALL parms1(teff2,qtemp,finc,separ,period,reff1,  &
                     reff2,gp1,gp2,vrot1,vrot2,gscale1,gscale2,omega1,  &
                     omega2,obsparm,bdist,ecc,argper,teff1,0)
!
               END IF
               www=wave(jj)
               flimbx=dwavex(jj,2)
               flimby=dwavey(jj,2)
!
               IF(ilaw > 10)THEN
                  flimbx=dwavex(jj,1)
                  flimby=dwavey(jj,1)
               END IF
!
               flux2=0.0_dp
               IF(teff2 > 0.0_dp)CALL getrefbbflux(ialphmax2,  &
                  ibetmax2,nalph2,ibetlim2,www,visib2,projarray2,temp2,  &
                  surf2,flimbx,flimby,ilaw,rinty2,flum2,flux2,rldint2,  &
                  separ,mmdx2)
            END IF
            refflux1(jj)=flux1
            refflux2(jj)=flux2
         END DO
      END IF
      IF(iatm >= 1)THEN
         fluxu1=0.0_dp
         fluxu2=0.0_dp
         fluxb1=0.0_dp
         fluxb2=0.0_dp
         fluxv1=0.0_dp
         fluxv2=0.0_dp
         fluxr1=0.0_dp
         fluxr2=0.0_dp
         fluxi1=0.0_dp
         fluxi2=0.0_dp
         fluxj1=0.0_dp
         fluxj2=0.0_dp
         fluxh1=0.0_dp
         fluxh2=0.0_dp
         fluxk1=0.0_dp
         fluxk2=0.0_dp
!
         IF(idark1 <= 0)THEN
            rpole1=rpol1(nalph1/2)
!
            CALL parms(1,teff2,qtemp,finc,separ,period,reff1,reff2,  &
               vrot1,vrot2,gscale1,gscale2,omega1,omega2,ecc,  &
               ioutflag,rmass,rrad,rrau,rm1,rm2,r1,r2,isw30,obsparm)
!
            CALL parms1(teff2,qtemp,finc,separ,period,reff1,reff2,  &
               gp1,gp2,vrot1,vrot2,gscale1,gscale2,omega1,omega2,  &
               obsparm,bdist,ecc,argper,teff1,0)
!
            CALL getatmint(maxlines,maxmu,nlines,atmt,atmg,atmmu,  &
               nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,  &
               atmint7,atmint8,gscale1,darkint1,tpole1,gpole1,dwavex,  &
               dwavey,ilaw,iatm,1)
!
            CALL getrefatmflux(ialphmax1,ibetmax1,nalph1,ibetlim1,  &
               visib1,projarray1,temp1,surf1,g1,rinty1,flum1,maxlines,  &
               maxmu,nlines,atmt,atmg,atmmu,nmu,atmint1,atmint2,  &
               atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,  &
               gscale1,fluxu1,fluxb1,fluxv1,fluxr1,fluxi1,fluxj1,  &
               fluxh1,fluxk1,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,  &
               irvfilt,separ,mmdx1,dwavex,dwavey,ilaw,iatm,1)
!
            corr1(1)=0.0_dp
            corr2(1)=0.0_dp
            corr1(2)=0.0_dp
            corr2(2)=0.0_dp
            corr1(3)=0.0_dp
            corr2(3)=0.0_dp
            corr1(4)=0.0_dp
            corr2(4)=0.0_dp
            corr1(5)=0.0_dp
            corr2(5)=0.0_dp
            corr1(6)=0.0_dp
            corr2(6)=0.0_dp
            corr1(7)=0.0_dp
            corr2(7)=0.0_dp
            corr1(8)=0.0_dp
            corr2(8)=0.0_dp
!
         END IF
         IF(idark2 <= 0)THEN
            rpole2=rpol2(nalph2/2)
!
            CALL parms(1,teff2,qtemp,finc,separ,period,reff1,reff2,  &
               vrot1,vrot2,gscale1,gscale2,omega1,omega2,ecc,  &
               ioutflag,rmass,rrad,rrau,rm1,rm2,r1,r2,isw30,obsparm)
!
            CALL parms1(teff2,qtemp,finc,separ,period,reff1,reff2,  &
               gp1,gp2,vrot1,vrot2,gscale1,gscale2,omega1,omega2,  &
               obsparm,bdist,ecc,argper,teff1,0)
!
            IF(teff2 > 0.0_dp)CALL getatmint(maxlines,maxmu,nlines,  &
               atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
               atmint5,atmint6,atmint7,atmint8,gscale2,darkint2,  &
               tpole2,gpole2,dwavex,dwavey,ilaw,iatm,2)
!
            IF(teff2 > 0.0_dp)CALL getrefatmflux(ialphmax2,  &
               ibetmax2,nalph2,ibetlim2,visib2,projarray2,temp2,surf2,  &
               g2,rinty2,flum2,maxlines,maxmu,nlines,atmt,atmg,atmmu,  &
               nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,  &
               atmint7,atmint8,gscale2,fluxu2,fluxb2,fluxv2,fluxr2,  &
               fluxi2,fluxj2,fluxh2,fluxk2,icnu,icnb,icnv,icnr,icni,  &
               icnj,icnh,icnk,irvfilt,separ,mmdx2,dwavex,dwavey,ilaw,iatm,2)
!
         END IF
         refflux1(1)=fluxu1
         refflux2(1)=fluxu2
         refflux1(2)=fluxb1
         refflux2(2)=fluxb2
         refflux1(3)=fluxv1
         refflux2(3)=fluxv2
         refflux1(4)=fluxr1
         refflux2(4)=fluxr2
         refflux1(5)=fluxi1
         refflux2(5)=fluxi2
         refflux1(6)=fluxj1
         refflux2(6)=fluxj2
         refflux1(7)=fluxh1
         refflux2(7)=fluxh2
         refflux1(8)=fluxk1
         refflux2(8)=fluxk2
!
      END IF
   END IF
!
!   UPDATE OCTOBER 20, 2005
!
!   Add an "EBOP mode" where only the flux at even phases are computed.
!   Set the refflux=-99 and filter out the negative values later.
!
   IF(iecheck == 5)THEN
      DO  jjj=1,8
         refflux1(jjj)=-99.0_dp
         refflux2(jjj)=-99.0_dp
      END DO
   END IF
!
   ttiny=0.0_dp
   IF(ecc <= 0.0_dp)ttiny=1.0E-6_dp
!
!   UPDATE JULY 22, 2010
!
!   Add this block to get itime=2 working in eccentric mode.
!
   IF((isw7 == 2).AND.(ecc > 0.0_dp))THEN
      pstartout=360.0_dp*(timearray(1)-t0)/period
      pstopout=360.0_dp*(timearray(ntime)-t0)/period
      dphase=360.0_dp*tstep/period
      ism1=0
   END IF
!
   phaseout=0.0_dp
   nloopout=0
   nloopout=INT((pstopout+ttiny-pstartout)/dphase)
   phaseout=pstartout-dphase
!
!          do 999 phaseout=pstartout,pstopout+ttiny,dphase
!
   loop240:  DO  iloopout=1,nloopout+1
      phaseout=phaseout+dphase
!
      IF((icounttime >= 1).AND.(ngap >= 1))THEN
         DO ijk=1,ngap
            IF((timearray(icounttime) > gaplow(ijk)).AND.  &
               (timearray(icounttime) < gaphigh(ijk)))THEN
               icounttime=icounttime+1
               CYCLE loop240
            END IF
         END DO
      END IF
!
      IF(ecc > 0.0_dp)THEN
         ivrt=1
!
!   April 19, 2001.
!
!   If the ism1 flag is set, then modify the start and stop phase
!   of the inner loop.  Also, define a variable called pstep.
!
         IF(ism1 == 0)THEN
            em=phaseout*degtorad
!
            CALL gete(em,ecc,bige)
            CALL checkangle(bige)
            rnu=2.0_dp*ATAN(SQRT((1.0_dp+ecc)/(1.0_dp-ecc))*TAN(bige/2.0_dp))
            CALL checkangle(rnu)
            bdist=(1.0_dp-ecc*COS(bige))
!
!   Use the dmod function for pstart and pstop.
!
            pstart=MOD(rnu*radtodeg+argper+90.0_dp,360.0_dp)
            pstop=MOD(rnu*radtodeg+argper+90.0_dp,360.0_dp)
            pstep=dphase
!
!   end if isym = 0
!
         END IF
!
         IF(ism1 >= 1)THEN
            em=phaseout*degtorad
            CALL gete(em,ecc,bige)
            CALL checkangle(bige)
            rnu=2.0_dp*ATAN(SQRT((1.0_dp+ecc)/(1.0_dp-ecc))*TAN(bige/2.0_dp))
            CALL checkangle(rnu)
            bdist1=(1.0_dp-ecc*COS(bige))
!
!   April 19, 2001
!
!   Use the dmod function for pstart and pstop.
!
            pstart=MOD(rnu*radtodeg+argper+90.0_dp,360.0_dp)
!
!   Here is the other phase that gives the same binary separation
!
            emnew=-1.0_dp*em
!
!   We need to do the periastron and apastron phases once.
!
            IF(ABS(phaseout - pstartout) <= EPSILON(phaseout))emnew=em
            IF(ABS(phaseout - pstopout) <= EPSILON(phaseout))emnew=em
            CALL gete(emnew,ecc,bigenew)
            CALL checkangle(bigenew)
            rnunew=2.0_dp*ATAN(SQRT((1.0_dp+ecc)/(1.0_dp-ecc))*TAN(bigenew/2.0_dp))
            CALL checkangle(rnunew)
!
            pstop=MOD(rnunew*radtodeg+argper+90.0_dp,360.0_dp)
            pstep=pstop-pstart
!
            IF(ABS(pstep) <= EPSILON(pstep))pstep=1.0_dp
            bdist=bdist1
!
!   We need to do the periastron and apastron phases only once.
!
            IF(ABS(phaseout - pstartout) <= EPSILON(phaseout))pstop=pstart
            IF(ABS(phaseout - pstopout) <= EPSILON(phaseout))pstop=pstart
!
!   end if isym > 1
!
         END IF
!
!   UPDATE September 11, 2001
!
!   Add the iverb flag to setupgeo
!
         iverb=0
         iskip1=0
         fincr=finc*degtorad
         phaser=pstart*degtorad
         thetamis=savethetamis
         phimis=savephimis-pstart   !phase
         thetamis=thetamis*degtorad
         phimis=phimis*degtorad
         thetamis=0.0_dp
         phimis=0.0_dp
!
         delta=(COS(fincr)**2+(SIN(fincr)*SIN(phaser))**2)
         delta=bdist*SQRT(delta)
         IF(delta > (reff1*1.2_dp+reff2*1.2_dp))THEN
!
            iskip1=10
            IF((isw30 >= 3).AND.(isw7 >= 2))THEN
               IF(iloopout == 1)THEN
                  IF(itconj == 2)THEN
                     CALL gett0(tertincl,tertperiod,tertecc,tertarg, &
                        tertt0,tertconj)
                  END IF
                  IF(itconj == 1)THEN
                     CALL gett0tran(tertincl,tertperiod,tertecc,  &
                        tertarg,tertt0,tertconj)
                  END IF
               END IF
               tertphase=(timearray(icounttime+1)-tertt0)/tertperiod
               tertphase=360.0_dp*tertphase
               CALL tertnu(tertphase,tertecc,tertbdist,tertrnu)
               tertphase=MOD(tertrnu*radtodeg+tertarg+90.0_dp,360.0_dp)
               IF(tertphase < 0.0_dp)tertphase=tertphase+360.0_dp
               IF(tertphase > 360.0_dp)tertphase=tertphase-360.0_dp
               i3flag=0
               tertppp=MOD(tertphase,360.0_dp)
               IF(tertppp < 0.0_dp)tertppp=tertppp+360.0_dp
               IF(tertppp > 360.0_dp)tertppp=tertppp-360.0_dp
               nhoriz3=360
               CALL gethorizon3(nhoriz3,xhoriz3,yhoriz3,reff3,  &
                  axisscale,tertbdist,tertphase,tertincl,tertq,tertomega)
               IF((tertppp >= 0.0_dp).AND.(tertppp < 90.0_dp))i3flag= 1
               IF((tertppp >= 270.0_dp).AND.(tertppp <= 360.0_dp))i3flag=1
!
               xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
               yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
               tomrad=tertomega*degtorad
               xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
               yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
               xx=0.0_dp
               yy=0.0_dp
               zz=0.0_dp
               xp=xtran(xx,yy,phase,qtemp,1,bdist)+xxoff
               yp=ytran(xx,yy,zz,phase,fincr,qtemp,1,bdist)+yyoff
               nhoriz1=360
               CALL fakehorizon(nhoriz1,xhoriz1,yhoriz1,xp,yp,reff1)
               xx=0.0_dp
               yy=0.0_dp
               zz=0.0_dp
               xp=xtran(xx,yy,phase+180.0_dp,qtemp,2,bdist)+ xxoff
               yp=ytran(xx,yy,zz,phase+180.0_dp,fincr,qtemp,2,bdist)+ yyoff
               nhoriz2=360
               CALL fakehorizon(nhoriz2,xhoriz2,yhoriz2,xp,yp,reff2)
               ioverlap=-9999
               CALL overlaphoriz(nhoriz1,xhoriz1,yhoriz1,nhoriz2,  &
                  xhoriz2,yhoriz2,ioverlap)
               IF((isw30 >= 3).AND.(isw7 >= 2))THEN
                  CALL overlaphoriz(nhoriz1,xhoriz1,yhoriz1,nhoriz3,  &
                     xhoriz3,yhoriz3,ioverlap)
                  CALL overlaphoriz(nhoriz2,xhoriz2,yhoriz2,nhoriz3,  &
                     xhoriz3,yhoriz3,ioverlap)
                  IF(ioverlap < 900)THEN
                     iskip1=10
                  ELSE
                     iskip1=0
                  END IF
               END IF
            END IF
         END IF
!
         iskip2=0
         fincr=finc*degtorad
         phaser=pstop*degtorad
         phase=pstop
         delta=(COS(fincr)**2+(SIN(fincr)*SIN(phaser))**2)
         delta=bdist*SQRT(delta)
!
         IF(delta > (reff1*1.2_dp+reff2*1.2_dp))THEN
!
            iskip2=10
            IF((isw30 >= 3).AND.(isw7 >= 2))THEN
               IF(itconj == 2)THEN
                  CALL gett0(tertincl,tertperiod,tertecc,tertarg,tertt0,tertconj)
               END IF
               IF(itconj == 1)THEN
                  CALL gett0tran(tertincl,tertperiod,tertecc,tertarg,tertt0,tertconj)
               END IF
               tertphase=(timearray(icounttime+1)-tertt0)/tertperiod
               tertphase=360.0_dp*tertphase
               CALL tertnu(tertphase,tertecc,tertbdist,tertrnu)
               tertphase=MOD(tertrnu*radtodeg+tertarg+90.0_dp,360.0_dp)
               IF(tertphase < 0.0_dp)tertphase=tertphase+360.0_dp
               IF(tertphase > 360.0_dp)tertphase=tertphase-360.0_dp
               i3flag=0
               tertppp=MOD(tertphase,360.0_dp)
               IF(tertppp < 0.0_dp)tertppp=tertppp+360.0_dp
               IF(tertppp > 360.0_dp)tertppp=tertppp-360.0_dp
               nhoriz3=360
               CALL gethorizon3(nhoriz3,xhoriz3,yhoriz3,reff3,  &
                  axisscale,tertbdist,tertphase,tertincl,tertq, tertomega)
               IF((tertppp >= 0.0_dp).AND.(tertppp < 90.0_dp))i3flag= 1
               IF((tertppp >= 270.0_dp).AND.(tertppp <= 360.0_dp))i3flag=1
!
               xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
               yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
               tomrad=tertomega*degtorad
               xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
               yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
               xx=0.0_dp
               yy=0.0_dp
               zz=0.0_dp
               xp=xtran(xx,yy,phase,qtemp,1,bdist)+xxoff
               yp=ytran(xx,yy,zz,phase,fincr,qtemp,1,bdist)+yyoff
               nhoriz1=360
               CALL fakehorizon(nhoriz1,xhoriz1,yhoriz1,xp,yp,reff1)
               xx=0.0_dp
               yy=0.0_dp
               zz=0.0_dp
               xp=xtran(xx,yy,phase+180.0_dp,qtemp,2,bdist)+xxoff
               yp=ytran(xx,yy,zz,phase+180.0_dp,fincr,qtemp,2,bdist)+yyoff
               nhoriz2=360
               CALL fakehorizon(nhoriz2,xhoriz2,yhoriz2,xp,yp,reff2)
!
               ioverlap=-9999
               CALL overlaphoriz(nhoriz1,xhoriz1,yhoriz1,nhoriz2,  &
                  xhoriz2,yhoriz2,ioverlap)
               IF((isw30 >= 3).AND.(isw7 >= 2))THEN
                  CALL overlaphoriz(nhoriz1,xhoriz1,yhoriz1,nhoriz3,  &
                     xhoriz3,yhoriz3,ioverlap)
                  CALL overlaphoriz(nhoriz2,xhoriz2,yhoriz2,nhoriz3,  &
                     xhoriz3,yhoriz3,ioverlap)
                  IF(ioverlap < 900)THEN
                     iskip2=10
                  ELSE
                     iskip2=0
                  END IF
               END IF
            END IF
         END IF
!
!   Now, if idark1>0, then we can skip the phase where star 2 is
!   in front (e.g. phase 180).  Likewise, if idark2 > 0, then skip
!   phases near 0.
!
         IF(((phase >= 0.0_dp).AND.(phase <= 90.0_dp)).OR.((phase >  &
            270.0_dp).AND.(phase <= 360.0_dp)))THEN
            IF(idark2 > 0)iskip1=10
         END IF
         IF((phase >= 90.0_dp).AND.(phase <= 270.0_dp))THEN
            IF(idark1 > 0)iskip2=10
         END IF
!
! UPDATE OCTOBER 20, 2005
!
! Add iecheck=5.  In this case, compute only integer phases.
!
         fflag=-99.0_dp
         ddum=phase
         IF(ecc > 0.0_dp)ddum=em*180.0_dp/2.0_dp/pie
         fdiff=(ABS(ddum*0.5_dp-REAL(INT(ddum*0.5_dp),KIND=dp)))
         IF(fdiff < 0.5_dp*dphase)fflag=99.0_dp
!
         idobbskip=0
         idoatmskip=0
         IF((ecc > 0.0_dp).AND.(iecheck >= 5).AND.((iskip1 == 10)  &
            .OR.(iskip2 == 10)))THEN
            IF(fflag >= 90.0_dp)THEN
               iskip1=0
               iskip2=0
               GO TO 100
            END IF
!
            IF((isw30 >= 3).AND.(isw7 >= 2))THEN
               IF(itconj == 2)THEN
                  CALL gett0(tertincl,tertperiod,tertecc,tertarg,tertt0,tertconj)
               END IF
               IF(itconj == 1)THEN
                  CALL gett0tran(tertincl,tertperiod,tertecc,tertarg,tertt0,tertconj)
               END IF
               tertphase=(timearray(icounttime+1)-tertt0)/tertperiod
               tertphase=360.0_dp*tertphase
               CALL tertnu(tertphase,tertecc,tertbdist,tertrnu)
               tertphase=MOD(tertrnu*radtodeg+tertarg+90.0_dp,360.0_dp)
               IF(tertphase < 0.0_dp)tertphase=tertphase+360.0_dp
               IF(tertphase > 360.0_dp)tertphase=tertphase-360.0_dp
            END IF
!
            icount=icount+1
            icounttime=icounttime+1
            phase=pstart
            dummyphase=phase+180.0_dp
            IF(iatm == 0)THEN
               ieccbbskip=10
               GO TO 110
            END IF
            IF(iatm >= 1)THEN
               ieccatmskip=10
               GO TO 110
            END IF
         END IF
!
!   UPDATE May 10, 2006
!
!   If we are in analytic mode, and the eccentricity is more than 0.0,
!   skip the setupgeo, etc. since it is not needed.
!
!              IF((isw12.gt.0).and.(ecc.gt.0.0_dp))GO TO 777
!
100      CALL setupgeo(1,ialphmax1,ibetmax1,nalph1,nbet1,ibetlim1,  &
            fill1,omega1,q,finc,x1,y1,z1,surf1,rad1,gradx1,grady1,  &
            gradz1,g1,xend1,separ,tgrav1,teff1,reff1,rl1,tpole1,  &
            rpol1,regg1,sa1,pot1,gpole1,phiar1,isquare,iusepot,  &
            usepot1,ivrt,pervol1,fillper1,bdist,pots1,mmdx1,  &
            primmass,primk,primrad,ratrad,frac1,frac2,ecc,period,  &
            size1,sw5,tteff2,density,tidephi,itide,phistart1,  &
            thetamis,phimis,ioutflag,arrsobx,montemax,  &
            masssum,massdiff,radsum,raddiff,secmass,secrad,fracsum,  &
            fracdiff,qtemp,fillsum,filldiff)
         IF(teff2 > 0.0_dp)THEN
            CALL setupgeo(2,ialphmax2,ibetmax2,nalph2,nbet2,  &
               ibetlim2,fill2,omega2,qtemp,finc,x2,y2,z2,surf2,rad2,  &
               gradx2,grady2,gradz2,g2,xend2,separ,tgrav2,teff2,reff2,  &
               rl2,tpole2,rpol2,regg2,sa2,pot2,gpole2,phiar2,isquare,  &
               iusepot,usepot2,ivrt,pervol2,fillper2,bdist,pots2,  &
               mmdx2,primmass,primk,primrad,ratrad,frac1,frac2,  &
               ecc,period,size1,sw5,tteff2,density,tidephi,itide,  &
               phistart2,thetamis,phimis,ioutflag,arrsobx,  &
               montemax,masssum,massdiff,radsum,raddiff,secmass,  &
               secrad,fracsum,fracdiff,qtemp,fillsum,filldiff)
         ELSE
!
            CALL dummyvalues(ialphmax2,ibetmax2,nalph2,nbet2,x2,y2,  &
               z2,surf2,gradx2,grady2,gradz2,g2,xend2,darkbol2,temp2, &
               ibetlim2,mmdx2,0)
            regg2=rocheradius(qtemp)
            reff2=regg2
            overq=1.0_dp/qtemp
            CALL findl1(overq,omega2,x0,1,bdist,tidephi,ecc,thetamis,phimis)
            rl2=x0
         END IF
!
!   end if ecc.gt.0
!
      END IF
!
!  We come here from above if it is necessary to skip some
!  phases.
!
110   CONTINUE
!
!  We will skip down to the section of the routine that
!  assign fluxes if iecBBskip or ieccATMskip are non-zero.
!
      IF((ieccbbskip == 0).AND.(ieccatmskip == 0))THEN
         IF(iidint >= 1)CALL disksetup(nthetamax,nrmax,ntheta,  &
            nradius,betarim,rinner,router,regg2,rl2,separ,tdisk,xi,  &
            dtemp,dx,dy,dz,drad,tedge,xedge,yedge,zedge,redge,stepr,  &
            stepz,bdist,ivrt,reper,rsper,ioutflag,diskrad,diskthick)
!
!   Find the temperatures in the absence of reflection (heating).
!   The modified temperatures do not depend on phase.
!
         CALL setuptemp(1,ialphmax1,ibetmax1,nalph1,ibetlim1,g1,  &
            tpole1,tgrav1,temp1,gpole1,mmdx1,ioutflag)
!
         IF(teff2 > 0.0_dp)CALL setuptemp(2,ialphmax2,ibetmax2,  &
            nalph2,ibetlim2,g2,tpole2,tgrav2,temp2,gpole2,mmdx2,ioutflag)
!
!   Initialize the ratios and copy the temperatures only if Nref>0
!
         IF(nref >= -1)THEN
            CALL copytemp(ialphmax1,ibetmax1,nalph1,temp1,tempold1,mmdx1,ibetlim1)
            CALL copytemp(ialphmax2,ibetmax2,nalph2,temp2,tempold2,mmdx2,ibetlim2)
!
!   Compute the reflection effect and find the modified temperatures.
!   First initialize the ratios...
!
            CALL initratio(ialphmax1,ibetmax1,nalph1,nbet1,nalph2,  &
               nbet2,ratio1,ratio2,coprat1,coprat2,ialphmax2,ibetmax2)
         END IF
!
!   UPDATE March 25, 2002
!
!   I have added another routine called simplerefl, which is a much
!   more efficient routine when the stars are nearly point sources.
!   If Nref=0, call this routine and skip to statement 888.  If
!   Nref < 0, skip both.
!
!   If Teff2 < 0, then star 2 is a point source.  Hence we need only
!   1 iteration of the reflection effect.
!
!   Also, if there is no star 2, call simplerefl.
!
         IF((teff2 <= 0.0_dp).AND.(nref > 0))nref=0
!
         IF(nref < 0)GO TO 130
         IF(nref == 0)THEN
            CALL simplerefl(ialphmax1,ibetmax1,nalph1,ibetlim1,  &
               nalph2,ibetlim2,x1,y1,z1,gradx1,grady1,gradz1,g1,x2,y2,  &
               z2,gradx2,grady2,gradz2,g2,temp1,temp2,dbolx,dboly,  &
               ilaw,alb1,alb2,teff1,teff2,tgrav1,tgrav2,rlx,iidint,  &
               redge,betarim,gpole1,gpole2,tpole1,tpole2,bdist,sa1,  &
               sa2,rad1,rad2,separ,mmdx1,mmdx2,ialphmax2,ibetmax2,isw25,ioutflag)
            CALL copytemp(ialphmax1,ibetmax1,nalph1,temp1,toldspot1,mmdx1,ibetlim1)
            CALL copytemp(ialphmax2,ibetmax2,nalph2,temp2,toldspot2,mmdx2,ibetlim2)
            GO TO 130
         END IF
!
         DO  jj=1,nref
!
            CALL detailrefl(ialphmax1,ibetmax1,nalph1,ibetlim1,  &
               nalph2,ibetlim2,ratio1,ratio2,x1,y1,z1,gradx1,grady1,  &
               gradz1,g1,surf1,x2,y2,z2,gradx2,grady2,gradz2,g2,surf2,  &
               temp1,temp2,tempold1,tempold2,dbolx,dboly,ilaw,alb1,  &
               alb2,teff2,tgrav1,tgrav2,rlx,iidint,redge,betarim,  &
               gpole1,gpole2,tpole1,tpole2,coprat1,coprat2,bdist,  &
               mmdx1,mmdx2,ialphmax2,ibetmax2,ioutflag)
!
            CALL copytemp(ialphmax1,ibetmax1,nalph1,temp1,toldspot1,mmdx1,ibetlim1)
            CALL copytemp(ialphmax2,ibetmax2,nalph2,temp2,toldspot2,mmdx2,ibetlim2)
         END DO
!
!   Add spots here, if any. Set the averages to zero first.
!
130      CONTINUE
         ave11=0.0_dp
         ave12=0.0_dp
         ave21=0.0_dp
         ave22=0.0_dp
         IF(ispot1 > 0)CALL addstarspot(1,ialphmax1,ibetmax1,  &
            nalph1,ibetlim1,temp1,spot1parm,ave11,ave12,phiar1,mmdx1,  &
            ispotprof,ioutflag)
         IF((ispot2 > 0).AND.(teff2 > 0.0_dp))CALL addstarspot(2,  &
            ialphmax2,ibetmax2,nalph2,ibetlim2,temp2,spot2parm,ave21,  &
            ave22,phiar2,mmdx2,ispotprof,ioutflag)
!
         ave1=0.0_dp
         ave2=0.0_dp
         IF((ispotd > 0).AND.(iidint > 0).AND.(tdisk > 0.0_dp))  &
            CALL adddiskspot(nthetamax,nrmax,ntheta,nradius,rinner,  &
              router,reff2,rl2,dtemp,tedge,redge,ivrt,reper,rsper,  &
              spotdparm,ave1,ave2,ioutflag)
!
!   We can now compute interesting system parameters based in the input
!   numbers.
!
         rpole1=rpol1(nalph1/2)
         rpole2=rpol2(nalph2/2)
!
         CALL parms(1,teff2,qtemp,finc,separ,period,reff1,reff2,  &
            vrot1,vrot2,gscale1,gscale2,omega1,omega2,ecc,  &
            ioutflag,rmass,rrad,rrau,rm1,rm2,r1,r2,isw30,obsparm)
!
         CALL parms1(teff2,qtemp,finc,separ,period,reff1,reff2,  &
            gp1,gp2,vrot1,vrot2,gscale1,gscale2,omega1,omega2,  &
            obsparm,bdist,ecc,argper,teff1,0)
!
         rdepth=0.0_dp
         CALL lineparms1(teff2,qtemp,finc,separ,period,reff1,  &
            reff2,vrot1,vrot2,omega1,omega2,bdist,ecc,sa3,ave11,  &
            ave12,ave21,ave22,ave1,ave2,parmstring,pot1,pot2,rdepth, &
            tertq,argper)
!
         IF(isw30 > 2)CALL planetparms(planetparm,tref,qtemp,  &
            finc,separ,period,reff1,reff2,ecc,tertratrad,tertperiod,  &
            tertt0,tertecos,tertesin,tertincl,tertomega,tertq,itconj,  &
            tertconj,p2tconj,p2period,p2t0,p2ecos,p2esin,p2incl,  &
            p2omega,p2q,p2ratrad,p3tconj,p3period,p3t0,p3ecos,p3esin,  &
            p3incl,p3omega,p3q,p3ratrad,p4tconj,p4period,p4t0,p4ecos,  &
            p4esin,p4incl,p4omega,p4q,p4ratrad,p5tconj,p5period,p5t0,  &
            p5ecos,p5esin,p5incl,p5omega,p5q,p5ratrad,p6tconj,  &
            p6period,p6t0,p6ecos,p6esin,p6incl,p6omega,p6q,p6ratrad,  &
            p7tconj,p7period,p7t0,p7ecos,p7esin,p7incl,p7omega,p7q,  &
            p7ratrad,p8tconj,p8period,p8t0,p8ecos,p8esin,p8incl,  &
            p8omega,p8q,p8ratrad,argper,t0,tconj,isw28,it1,rrad,rrau)
!
!   Output the necessary information to make contour plots of the
!   temperature and gravity.
!
         IF((ABS(ecc) <= EPSILON(ecc)).AND.(idraw >= 1))THEN
            CALL writetempgrav(ialphmax1,ibetmax1,nalph1,nbet1,  &
               ibetlim1,temp1,g1,gscale1,1,x1,y1,z1,mmdx1,phistart1,separ)
            IF(teff2 > 0.0_dp)THEN
               CALL writetempgrav(ialphmax2,ibetmax2,nalph2,nbet2,  &
                  ibetlim2,temp2,g2,gscale2,2,x2,y2,z2,mmdx2,phistart2,separ)
            END IF
         END IF
!
!   We have to make sure we have the correct light curve so we can
!   compute the radial velocity curve if necessary.  If
!   icnRV1.ne.430 or if icnRV2.ne.430, then we need to set icn?
!   temporarily to 1.
!
         IF(irvfilt == 1)ivsave=icnu
         IF(irvfilt == 2)ivsave=icnb
         IF(irvfilt == 3)ivsave=icnv
         IF(irvfilt == 4)ivsave=icnr
         IF(irvfilt == 5)ivsave=icni
         IF(irvfilt == 6)ivsave=icnj
         IF(irvfilt == 7)ivsave=icnh
         IF(irvfilt == 8)ivsave=icnk
!
!   UPDATE October 22, 2008
!
!   Always compute at the filter corresponding to iRVfilt
!
         IF(irvfilt == 1)icnu=1
         IF(irvfilt == 2)icnb=1
         IF(irvfilt == 3)icnv=1
         IF(irvfilt == 4)icnr=1
         IF(irvfilt == 5)icni=1
         IF(irvfilt == 6)icnj=1
         IF(irvfilt == 7)icnh=1
         IF(irvfilt == 8)icnk=1
!
!   Initialize the disk correction matrix
!
         DO  kk=1,8
            IF(idcheck > 0)zdcorr(kk)=0.0_dp
            darkint1(kk)=1.0_dp
            darkint2(kk)=1.0_dp
         END DO
!
!   If we are using the atmosphere table, compute the DINT factors.
!
         IF(iatm >= 1)THEN
!
            CALL getatmint(maxlines,maxmu,nlines,atmt,atmg,atmmu,  &
               nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,  &
               atmint7,atmint8,gscale1,darkint1,tpole1,gpole1,dwavex,  &
               dwavey,ilaw,iatm,1)
!
!   UPDATE JULY 15, 2011
!
!   Modify the third light so that the scaling comes out correct.
!
            DO  kk=1,8
               IF(ididscale3 == 0)THEN
                  ididscale3=999
               END IF
            END DO
            IF(teff2 > 0.0_dp)CALL getatmint(maxlines,maxmu,nlines,  &
               atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
               atmint5,atmint6,atmint7,atmint8,gscale2,darkint2,  &
               tpole2,gpole2,dwavex,dwavey,ilaw,iatm,2)
         END IF
      END IF
!
!   Loop over phases and turn the binary in space.
!
!   If ism1=1, then do only phases 0.0 to 180.0 and reflect the
!   light curve at the end.
!
      IF(ionephase >= 1)THEN
         pstart=onephase
         pstop=onephase
      END IF
!
      ipstep=0
      IF((isw7 == 2).AND.(ABS(ecc) <= EPSILON(ecc)))THEN
         pstart=360.0_dp*(timearray(1)-t0)/period
         pstop=360.0_dp*(timearray(ntime)-t0)/period
         pstep=360.0_dp*tstep/period
         ism1=0
      END IF
!
      nloopin=0
      iloopin=0
      phasein=0.0_dp
      nloopin=INT((pstop+ttiny-pstart)/pstep)
!
!          do 10 phasein=pstart,pstop+ttiny,pstep
!
      phasein=pstart-pstep
      loop230: DO  iloopin=1,nloopin+1
!
!  If ieccBBskip or ieccATMskip are non-zero, then skip
!  most of the steps below.
!
         IF((ieccbbskip == 0).AND.(ieccatmskip == 0))THEN
            phasein=phasein+pstep
!
            IF((icount >= 1).AND.(ngap >= 1))THEN
               DO ijk=1,ngap
                  IF((timearray(icounttime) > gaplow(ijk)).AND.  &
                     (timearray(icounttime) < gaphigh(ijk)))THEN
                     icounttime=icounttime+1
                     CYCLE loop230
                  END IF
               END DO
            END IF
!
            IF(ABS(ecc) <= EPSILON(ecc))iskip2=10
!
!   April 19, 2001
!
!   Put in a flag for the case when ecc>0 and ism1>0 to let
!   the program know which phase is being done
!
            ipstep=ipstep+1
!
            phase=MOD(phasein,360.0_dp)
            IF(phase < 0.0_dp)phase=phase+360.0_dp
!
            icount=icount+1
            icounttime=icounttime+1
!
            IF((isw30 >= 3).AND.(isw7 >= 2))THEN
               IF(iloopin == 1)THEN
                  IF(itconj == 2)THEN
                     CALL gett0(tertincl,tertperiod,tertecc,tertarg,tertt0,tertconj)
                  END IF
                  IF(itconj == 1)THEN
                     CALL gett0tran(tertincl,tertperiod,tertecc,  &
                        tertarg,tertt0,tertconj)
                  END IF
               END IF
               tertphase=(timearray(icounttime)-tertt0)/tertperiod
               tertphase=360.0_dp*tertphase
!
               CALL tertnu(tertphase,tertecc,tertbdist,tertrnu)
               tertphase=MOD(tertrnu*radtodeg+tertarg+90.0_dp,360.0_dp)
               IF(tertphase < 0.0_dp)tertphase=tertphase+360.0_dp
               IF(tertphase > 360.0_dp)tertphase=tertphase-360.0_dp
!
            END IF
!
            IF((ispot1 >= 1).AND.(isw7 >= 2))THEN
               CALL copytemp(ialphmax1,ibetmax1,nalph1,toldspot1,  &
                  temp1,mmdx1,ibetlim1)
               CALL addmovespot(ialphmax1,ibetmax1,nalph1,ibetlim1,  &
                  temp1,spot1parm,ave11,ave12,omega1,phiar1,mmdx1,  &
                  period,t0,timearray(icounttime))
            END IF
!
            IF((ispot2 >= 1).AND.(isw7 >= 2).AND.(teff2 > 0.0_dp)) THEN
               CALL copytemp(ialphmax2,ibetmax2,nalph2,toldspot2,  &
                  temp2,mmdx2,ibetlim2)
               CALL addmovespot(ialphmax2,ibetmax2,nalph2,ibetlim2,  &
                  temp2,spot2parm,ave21,ave22,omega2,phiar2,mmdx2,  &
                  period,t0,timearray(icounttime))
            END IF
!
!   April 19, 2001
!
!   Put as the argument to getextension  dmod(extphase,360.0_dp),
!   and modify the phase according to the phase shifts.
!
            extphase=phase
            IF((ecc > 0.0_dp).OR.(ABS(pshift) >= EPSILON(pshift)))THEN
               IF((ecc > 0.0_dp).AND.(ism1 == 0))emphase=em*radtodeg
               IF((ecc > 0.0_dp).AND.(ism1 > 0))THEN
                  IF(ipstep == 1)emphase=em*radtodeg
                  IF(ipstep == 2)emphase=emnew*radtodeg
               END IF
               tshift=pshift+eshift
               extphase=emphase+360.0_dp*tshift
!
!   UPDATE September 10, 2001
!
!   Add the if-then clauses
!
               IF(ikeep == 1)extphase=emphase+360.0_dp*(tshift-pconj)
               IF(ikeep == 2)extphase=emphase+360.0_dp*(tshift-pconj2)
               IF(ABS(ecc) <= EPSILON(ecc))extphase=phase+360.0_dp*pshift
            END IF
            CALL getextension(MOD(extphase,360.0_dp),extension,isw7,icounttime)
!
!   this is for star 2
!
            dummyphase=MOD(phase+180.0_dp,360.0_dp)
!
!   Check the various toggle switches which tell the code whether
!   to check for eclipses.  For example, if points were eclipsed up
!   until phase 15.0, then the code will not check again until
!   phase=180-15.  It will keep checking until phase=180+15 and not
!   check again until phase=360-15.
!
            pdiff1=ABS(phase-(360.0_dp-togglephase))
            IF(pdiff1 < 0.00001_dp)THEN
               IF(iecheck >= 1)idcheck=100
            END IF
!
            iskip1=0
            iskip2=0
            fincr=finc*degtorad
            phaser=phase*degtorad
            delta=(COS(fincr)**2+(SIN(fincr)*SIN(phaser))**2)
            delta=bdist*SQRT(delta)
            IF(delta > (reff1*1.2_dp+reff2*1.2_dp))THEN
!
               iskip1=10
               iskip2=10
               IF((isw30 >= 3).AND.(isw7 >= 2))THEN
                  IF(iloopin == 1)THEN
                     IF(itconj == 2)THEN
                        CALL gett0(tertincl,tertperiod,tertecc,tertarg,tertt0,tertconj)
                     END IF
                     IF(itconj == 1)THEN
                        CALL gett0tran(tertincl,tertperiod,tertecc,  &
                           tertarg,tertt0,tertconj)
                     END IF
                  END IF
                  tertphase=(timearray(icounttime+1)-tertt0)/ tertperiod
                  tertphase=360.0_dp*tertphase
                  CALL tertnu(tertphase,tertecc,tertbdist,tertrnu)
!
                  tertphase=MOD(tertrnu*radtodeg+tertarg+90.0_dp,360.0_dp)
                  IF(tertphase < 0.0_dp)tertphase=tertphase+360.0_dp
                  IF(tertphase > 360.0_dp)tertphase=tertphase-360.0_dp
                  i3flag=0
                  tertppp=MOD(tertphase,360.0_dp)
                  IF(tertppp < 0.0_dp)tertppp=tertppp+360.0_dp
                  IF(tertppp > 360.0_dp)tertppp=tertppp-360.0_dp
                  nhoriz3=360
                  CALL gethorizon3(nhoriz3,xhoriz3,yhoriz3,reff3,  &
                     axisscale,tertbdist,tertphase,tertincl,tertq, tertomega)
!
                  IF((tertppp >= 0.0_dp).AND.(tertppp < 90.0_dp))i3flag=1
                  IF((tertppp >= 270.0_dp).AND.(tertppp <= 360.0_dp))i3flag=1
!
                  xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
                  yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
                  tomrad=tertomega*degtorad
                  xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
                  yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
                  xx=0.0_dp
                  yy=0.0_dp
                  zz=0.0_dp
                  xp=xtran(xx,yy,phase,qtemp,1,bdist)+xxoff
                  yp=ytran(xx,yy,zz,phase,fincr,qtemp,1,bdist)+yyoff
                  nhoriz1=360
                  CALL fakehorizon(nhoriz1,xhoriz1,yhoriz1,xp,yp,reff1)
                  xx=0.0_dp
                  yy=0.0_dp
                  zz=0.0_dp
                  xp=xtran(xx,yy,phase+180.0_dp,qtemp,2,bdist)+xxoff
                  yp=ytran(xx,yy,zz,phase+180.0_dp,fincr,qtemp,2,bdist)+yyoff
                  nhoriz2=360
                  CALL fakehorizon(nhoriz2,xhoriz2,yhoriz2,xp,yp,reff2)
!
                  ioverlap=-9999
                  CALL overlaphoriz(nhoriz1,xhoriz1,yhoriz1,nhoriz2,  &
                     xhoriz2,yhoriz2,ioverlap)
                  IF((isw30 >= 3).AND.(isw7 >= 2))THEN
                     CALL overlaphoriz(nhoriz1,xhoriz1,yhoriz1,  &
                        nhoriz3,xhoriz3,yhoriz3,ioverlap)
                     CALL overlaphoriz(nhoriz2,xhoriz2,yhoriz2,  &
                        nhoriz3,xhoriz3,yhoriz3,ioverlap)
                     IF(ioverlap < 900)THEN
                        iskip1=10
                        iskip2=10
                     ELSE
                        iskip1=0
                        iskip2=0
                     END IF
                  END IF
               END IF
            END IF
!
!   Now, if idark1>0, then we can skip the phase where star 2
!   is in front (e.g. phase 180).  Likewise, if idark2 > 0, then skip
!   phases near 0.
!
            IF(((phase >= 0.0_dp).AND.(phase < 90.0_dp)).OR.((phase  &
               .GT.270.0_dp).AND.(phase <= 360.0_dp)))THEN
               IF(idark2 > 0)iskip1=10
            END IF
!
            IF((phase >= 90.0_dp).AND.(phase <= 270.0_dp))THEN
               IF(idark1 > 0)iskip2=10
            END IF
!
!    Check for analytic mode
!
            idobbskip=10
            idoatmskip=10
!
!   change to ge.5 (if iecheck=5, then compute the integer phases)
!
            fflag=-99.0_dp
            ddum=phase
            IF(ecc > 0.0_dp)ddum=em*180.0_dp/2.0_dp/pie
            fdiff=(ABS(ddum*0.5_dp-REAL(INT(ddum*0.5_dp),KIND=dp)))
            IF(fdiff < 0.5_dp*dphase)fflag=99.0_dp
            idobbskip=0
            idoatmskip=0
            IF((iecheck >= 5).AND.(iskip1 == 10))THEN
               IF(fflag >= 90.0_dp)THEN
                  iskip1=0
                  iskip2=0
                  GO TO 160
               END IF
               IF(iatm == 0)THEN
                  idobbskip=10
                  GO TO 170
               END IF
               IF(iatm >= 1)THEN
                  idoatmskip=10
                  GO TO 200
               END IF
            END IF
160         CALL gethorizon(1,ialphmax1,ibetmax1,nalph1,ibetlim1,  &
               phase,finc,qtemp,pot1,omega1,x1,y1,z1,rad1,gradx1,  &
               grady1,gradz1,xend1,nhoriz1,xhoriz1,yhoriz1,phiar1,  &
               iedgestar1,delphie1,bdist,mmdx1,xhmin1,xhmax1,yhmin1,  &
               yhmax1,tidephi,itide,phihor1,ecc,thetamis,phimis,  &
               tertincl,tertbdist,tertphase,tertq,axisscale,isw30, &
               isw7,tertomega)
!
            IF((isw30 >= 3).AND.(isw7 >= 2))THEN
               i3flag=0
               tertppp=MOD(tertphase,360.0_dp)
               IF(tertppp < 0.0_dp)tertppp=tertppp+360.0_dp
               IF(tertppp > 360.0_dp)tertppp=tertppp-360.0_dp
               nhoriz3=360
               CALL gethorizon3(nhoriz3,xhoriz3,yhoriz3,reff3,  &
                  axisscale,tertbdist,tertphase,tertincl,tertq,tertomega)
               IF((tertppp >= 0.0_dp).AND.(tertppp < 90.0_dp))i3flag= 1
               IF((tertppp >= 270.0_dp).AND.(tertppp <= 360.0_dp))i3flag=1
            END IF
!
            IF(teff2 > 0.0_dp)THEN
               CALL gethorizon(2,ialphmax2,ibetmax2,nalph2,ibetlim2,  &
                  dummyphase,finc,qtemp,pot2,omega2,x2,y2,z2,rad2,  &
                  gradx2,grady2,gradz2,xend2,nhoriz2,xhoriz2,yhoriz2,  &
                  phiar2,iedgestar2,delphie2,bdist,mmdx2,xhmin2,xhmax2,  &
                  yhmin2,yhmax2,tidephi,itide,phihor2,ecc,thetamis,  &
                  phimis,tertincl,tertbdist,tertphase,tertq,axisscale,  &
                  isw30,isw7,tertomega)
               IF(iidint >= 1)CALL gettophorizon(2,ialphmax2,  &
                  ibetmax2,nalph2,ibetlim2,dummyphase,finc,qtemp,x2,y2,  &
                  z2,gradx2,grady2,gradz2,ntop2,xtop2horiz,ytop2horiz,  &
                  bdist,mmdx2,tertincl,tertbdist,tertphase,tertq,  &
                  axisscale,isw30,isw7,tertomega)
            ELSE
               CALL dummyhoriz(ibetmax2,nbet2,nhoriz2,xhoriz2,  &
                  yhoriz2,ntop2,xtop2horiz,ytop2horiz)
               xhmin2=0.0_dp
               xhmax2=0.0_dp
               yhmin2=0.0_dp
               yhmax2=0.0_dp
            END IF
!
!    UPDATE May 26, 2004
!
!    If iecheck=9, check to see if the horizon of star 1 overlaps
!    with the horizon of star 2.  If so, then jump to the escape point.
!    ioverlap=999 means there is overlap
!
            ioverlap=-999
            ioverlap1=-999
            ioverlap2=-999
            CALL overlaphoriz(nhoriz1,xhoriz1,yhoriz1,nhoriz2,  &
               xhoriz2,yhoriz2,ioverlap)
            IF((isw30 >= 3).AND.(isw7 >= 2))THEN
               CALL overlaphoriz(nhoriz1,xhoriz1,yhoriz1,nhoriz3,  &
                  xhoriz3,yhoriz3,ioverlap1)
               CALL overlaphoriz(nhoriz2,xhoriz2,yhoriz2,nhoriz3,  &
                  xhoriz3,yhoriz3,ioverlap2)
            END IF
            idobbskip=0
            idoatmskip=0
            IF(iecheck == 9)THEN
               IF(ioverlap < 900)THEN
                  iskip1=10
                  iskip2=10
                  IF(iatm == 0)THEN
                     idobbskip=10
                     GO TO 170
                  END IF
                  IF(iatm >= 1)THEN
                     idoatmskip=10
                     GO TO 200
                  END IF
               END IF
               IF(ioverlap1 < 900)THEN
                  iskip1=10
                  iskip2=10
                  IF(iatm == 0)THEN
                     idobbskip=10
                     GO TO 170
                  END IF
                  IF(iatm >= 1)THEN
                     idoatmskip=10
                     GO TO 200
                  END IF
               END IF
               IF(ioverlap2 < 900)THEN
                  iskip1=10
                  iskip2=10
                  IF(iatm == 0)THEN
                     idobbskip=10
                     GO TO 170
                  END IF
                  IF(iatm >= 1)THEN
                     idoatmskip=10
                     GO TO 200
                  END IF
               END IF
            END IF
!
!   UPDATE September 10, 2001
!
!   If Teff < 0 check to see if the center of star 2 is eclipsed.
!
            IF(teff2 <= 0.0_dp)THEN
               pppp=MOD(phase,360.0_dp)
               IF(((pppp > -90.0_dp).AND.(pppp < 90.0_dp)).OR.((pppp  &
                  .GT.270.0_dp).AND.(pppp <= 450.0_dp)))THEN
                  CALL getxecl(nhoriz1,xhoriz1,yhoriz1,ixecl,qtemp,  &
                     finc,bdist,phase,tertincl,tertbdist,tertphase,  &
                     tertq,axisscale,isw30,isw7,tertomega)
               ELSE
                  ixecl=-100
               END IF
               xecx(icount)=phase
               xecy(icount)=REAL(ixecl,KIND=dp)
            END IF
!
            ndhoriz=0
            ndtop=0

            IF(iidint >= 1)CALL getdiskhoriz(nthetamax,ntheta,  &
               qtemp,phase,finc,xedge,yedge,zedge,ndhoriz,dxhoriz,  &
               dyhoriz,ndtop,dtopx,dtopy,bdist,tertincl,tertbdist,  &
               tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
!   Check the visibilities of grid elements.  Note that horizon 2 goes
!   in the argument list for star 1, and vice-versa.
!
            CALL getvisib(1,ialphmax1,ibetmax1,nalph1,ibetlim1,  &
               phase,finc,qtemp,pot1,omega1,gradx1,grady1,gradz1,x1,  &
               y1,z1,xend1,visib1,nhoriz2,xhoriz2,yhoriz2,iidint,  &
               ndhoriz,dxhoriz,dyhoriz,ndtop,dtopx,dtopy,nsky1,xsky1,  &
               ysky1,projarray1,iecheck,neclipse1,phiar1,rad1,delphi1,  &
               iedgehor1,bdist,mmdx1,montecarlo,isw13,ialfmin,ialfmax,  &
               xhmin2,xhmax2,yhmin2,yhmax2,tidephi,itide,phistart1,  &
               ecc,thetamis,phimis,nhoriz3,xhoriz3,yhoriz3,i3flag,  &
               tertincl,tertbdist,tertphase,tertq,axisscale,isw30,  &
               isw7,tertomega,arrsobx,arrsoby,montemax)
!
            neclipse2=0
            IF(teff2 > 0.0_dp)CALL getvisib(2,ialphmax2,ibetmax2,  &
               nalph2,ibetlim2,dummyphase,finc,qtemp,pot2,omega2,  &
               gradx2,grady2,gradz2,x2,y2,z2,xend2,visib2,nhoriz1,  &
               xhoriz1,yhoriz1,iidint,ndhoriz,dxhoriz,dyhoriz,ndtop,  &
               dtopx,dtopy,nsky2,xsky2,ysky2,projarray2,iecheck,  &
               neclipse2,phiar2,rad2,delphi2,iedgehor2,bdist,mmdx2,  &
               montecarlo,isw13,ialfmin,ialfmax,xhmin1,xhmax1,yhmin1,  &
               yhmax1,tidephi,itide,phistart2,ecc,thetamis,phimis,  &
               nhoriz3,xhoriz3,yhoriz3,i3flag,tertincl,tertbdist,  &
               tertphase,tertq,axisscale,isw30,isw7,tertomega,arrsobx,  &
               arrsoby,montemax)
!
            nsky3=0
            neclipse3=0
            IF((ioverlap1 > 10).OR.(ioverlap2 > 10))THEN
               IF(isw30 > 2)CALL getvisib3(3,ialphmax3,ibetmax3,  &
                  nalph3,ibetlim3,phase,finc,qtemp,1.0_dp,gradx3,  &
                  grady3,gradz3,x3,y3,z3,visib3,nhoriz1,xhoriz1,  &
                  yhoriz1,nhoriz2,xhoriz2,yhoriz2,nsky3,xsky3,ysky3,  &
                  projarray3,neclipse3,phiar3,rad3,delphi3,  &
                  mmdx3,0,phistart3,thetamis,phimis,i3flag,iedgehor3,  &
                  tertincl,tertbdist,tertphase,tertq,axisscale,isw30, &
                  isw7,tertomega)
            END IF
!
            IF(iidint >= 1)CALL diskvisib(nrmax,nthetamax,nradius,  &
               ntheta,phase,finc,qtemp,betarim,dx,dy,dz,xedge,yedge,  &
               zedge,diskproj,edgeproj,dvisib,evisib,nskydisk,  &
               xskydisk,yskydisk,zskydisk,nskyedge,xskyedge,yskyedge,  &
               ntop2,xtop2horiz,ytop2horiz,nhoriz1,xhoriz1,yhoriz1,  &
               ndtop,dtopx,dtopy,iecheck,neclipsed,bdist,tertincl,  &
               tertbdist,tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
         END IF
!
!   We might have jumped down here if we are skipping things,
!   in which case idoBBskip or idoATMskip are non-zero.
!
!   If we are in blackbody mode, we need to
!   loop over filters and find the fluxes.   Otherwise, we can call
!   the atmosphere routines a single time and get the fluxes for the
!   8 filters all at once.
!
170      CONTINUE
!
         IF(iatm <= 0)THEN
            DO  jj=1,8
!
!  If we jumped down here from above because we are skipping,
!  use the if-then clause to skip most of the steps.
!
               IF(idobbskip == 0)THEN
                  www=wave(jj)
                  flimbx=dwavex(jj,1)
                  flimby=dwavey(jj,1)
                  flux1=0.0_dp
                  IF(idark1 <= 0)THEN
                     IF(isimp == 0)THEN
!
                        fluxlat=rlatflux(jj)
                        CALL getbbflux(ialphmax1,ibetmax1,nalph1,  &
                           ibetlim1,www,visib1,projarray1,temp1,surf1,  &
                           flimbx,flimby,ilaw,rinty1,flum1,flux1,delphi1,  &
                           delphie1,iedgestar1,iedgehor1,rldint1,separ,  &
                           mmdx1,montecarlo,isw13,ialfmin,ialfmax,fluxlat,  &
                           1,phiar1,phihor1)
!
                        flux3=flux3keep(jj)
                        IF((neclipse3 > 0).AND.(isw30 > 2))CALL  &
                           getbbflux(ialphmax3,ibetmax3,nalph3,ibetlim3,  &
                           www,visib3,projarray3,temp3,surf3,flimbx,  &
                           flimby,ilaw,rinty3,flum3,flux3,delphi3,  &
                           delphie3,iedgestar3,iedgehor3,rldint3,separ,  &
                           mmdx3,montecarlo,isw13,ialfmin,ialfmax,fluxlat,  &
                           1,phiar3,phihor3)
!
                     END IF
                  END IF
!
                  IF(idraw == 1)THEN
                     IF(jj == irvfilt)CALL rotkern(ialphmax1,ibetmax1,  &
                        nalph1,ibetlim1,1,omega1,phase,finc,qtemp,flum1,  &
                        x1,y1,flux1,separ,period,gamma,ecc,argrad,visib1, &
                        extension,mmdx1)
                  END IF
!
                  CALL getvel(ialphmax1,ibetmax1,nalph1,ibetlim1,1,  &
                     omega1,phase,finc,qtemp,flum1,x1,y1,flux1,separ,  &
                     period,gamma,vel1,delvel1,rldint1,ecc,argrad,mmdx1,  &
                     isw13,ialfmin,ialfmax,bigi,bigbeta,z1)
!
                  flimbx=dwavex(jj,2)
                  flimby=dwavey(jj,2)
                  IF(ilaw > 10)THEN
                     flimbx=dwavex(jj,2)
                     flimby=dwavey(jj,2)
                  END IF
                  flux2=0.0_dp
                  IF(idark2 <= 0)THEN
                     IF(teff2 > 0.0_dp)THEN
                        IF(isimp == 0)THEN
                           fluxlat=0.0_dp
                           CALL getbbflux(ialphmax2,ibetmax2,nalph2,  &
                              ibetlim2,www,visib2,projarray2,temp2,surf2,  &
                              flimbx,flimby,ilaw,rinty2,flum2,flux2,  &
                              delphi2,delphie2,iedgestar2,iedgehor2,  &
                              rldint2,separ,mmdx2,montecarlo,isw13,ialfmin,  &
                              ialfmax,fluxlat,2,phiar2,phihor2)
!
                        END IF
                     END IF
                  END IF
!
!  UPDATE August 16, 2001
!
!  Remove the if clause.  If there is no star 2 (as in an X-ray
!  binary, then the sine curve will still be computed.
!
!                if(teff2.gt.0.0_dp)
!
                  CALL getvel(ialphmax2,ibetmax2,nalph2,ibetlim2,2,  &
                     omega2,dummyphase,finc,qtemp,flum2,x2,y2,flux2,  &
                     separ,period,gamma,vel2,delvel2,rldint2,ecc,argrad+  &
                     pie,mmdx2,isw13,ialfmin,ialfmax,bigi,bigbeta,z2)
!
                  IF(idraw == 1)THEN
                     IF(jj == irvfilt)CALL rotkern(ialphmax2,ibetmax2,  &
                        nalph2,ibetlim2,2,omega2,phase,finc,qtemp,flum2,  &
                        x2,y2,flux2,separ,period,gamma,ecc,argrad,visib2, & 
                        extension,mmdx2)
                  END IF
!
                  dflux=0.0_dp
!
!   UPDATE December 17, 2001
!
!   If tdisk is less than 0, and iidint is more than 1, then
!   compute the disk geometry and eclipses, but ignore its flux.
!
                  IF(tdisk > 0.0_dp)THEN
                     IF(idcheck >= 1)THEN
!
                        IF(iidint >= 1)CALL getdiskbbflux(nrmax,  &
                           nthetamax,nradius,ntheta,diskproj,edgeproj,  &
                           dvisib,evisib,dtemp,tedge,drad,dinty,einty,  &
                           stepr,stepz,www,jj,ilaw,dflux,separ)
!
                        zdcorr(jj)=dflux
                     ELSE
                        dflux=zdcorr(jj)
                     END IF
                  ELSE
                     dflux=0.0_dp
                  END IF
               END IF
!
!   UPDATE OCTOBER 20, 2005
!
!   Change to .ge.5
!
!   If we are skipping phases, this in-then block might be
!   entered, in which case the "reference" fluxex found
!   above are used.
!
               IF((iecheck >= 5).OR.(isw12 >= 1))THEN
                  IF((((ABS(ecc) <= EPSILON(ecc)).AND.(iskip1 == 10).AND.(iskip2  &
                     .EQ.10)).OR.((ecc > 0.0_dp).AND.((iskip1 == 10).OR.  &
                     (iskip2 == 10)))).OR.(isw12 >= 1))THEN
                     DO  ll=1,8
!
!   Add Doppler boosting
!
                        CALL getrefvel(1,phase,finc,qtemp,separ,period,  &
                           gamma,vel1,ecc,argrad)
                        CALL getrefvel(2,dummyphase,finc,qtemp,separ,  &
                           period,gamma,vel2,ecc,argrad+pie)
!
                        dop1=(vel1-gamma)/speedlightkm
                        dop2=(vel2-gamma)/speedlightkm
!
                        IF(ll == irvfilt)THEN
                           refflux1(ll)=refflux1(ll)*(1.0_dp-beam1*dop1)
                           refflux2(ll)=refflux2(ll)*(1.0_dp-beam2*dop2)
                        END IF
!
                        IF(ll == 1)ymodu(icount)=refflux1(1)+refflux2(1)  &
                           +corr1(1)+corr2(1)
                        IF(ll == 2)ymodb(icount)=refflux1(2)+refflux2(2)  &
                           +corr1(2)+corr2(2)
                        IF(ll == 3)ymodv(icount)=refflux1(3)+refflux2(3)  &
                           +corr1(3)+corr2(3)
                        IF(ll == 4)ymodr(icount)=refflux1(4)+refflux2(4)  &
                           +corr1(4)+corr2(4)
                        IF(ll == 5)ymodi(icount)=refflux1(5)+refflux2(5)  &
                           +corr1(5)+corr2(5)
                        IF(ll == 6)ymodj(icount)=refflux1(6)+refflux2(6)  &
                           +corr1(6)+corr2(6)
                        IF(ll == 7)ymodh(icount)=refflux1(7)+refflux2(7)  &
                           +corr1(7)+corr2(7)
                        IF(ll == 8)ymodk(icount)=refflux1(8)+refflux2(8)  &
                           +corr1(8)+corr2(8)
!                        yeclipse(icount)=REAL(neclipse1,KIND=dp)
                        rv1(icount)=vel1
                        rv2(icount)=vel2
                        IF(ll == irvfilt)THEN
                           ymods1(icount)=refflux1(ll)
                           ymods2(icount)=refflux2(ll)
                           drv1(icount)=gimvel(ll)
                        END IF
!
!   UPDATE January 12, 2009
!
!   make fracs fracs1, fracs2, fracs3, ... fracs8
!
                        IF(ll == 1)THEN
                           fracs1(icount,1)=refflux1(ll)
                           fracs1(icount,2)=refflux2(ll)
                           fracs1(icount,3)=dflux
                           fracs1(icount,4)=corr1(1)+corr2(1)
                        END IF
                        IF(ll == 2)THEN
                           fracs2(icount,1)=refflux1(ll)
                           fracs2(icount,2)=refflux2(ll)
                           fracs2(icount,3)=dflux
                           fracs2(icount,4)=corr1(2)+corr2(2)
                        END IF
                        IF(ll == 3)THEN
                           fracs3(icount,1)=refflux1(ll)
                           fracs3(icount,2)=refflux2(ll)
                           fracs3(icount,3)=dflux
                           fracs3(icount,4)=corr1(3)+corr2(3)
                        END IF
                        IF(ll == 4)THEN
                           fracs4(icount,1)=refflux1(ll)
                           fracs4(icount,2)=refflux2(ll)
                           fracs4(icount,3)=dflux
                           fracs4(icount,4)=corr1(4)+corr2(4)
                        END IF
                        IF(ll == 5)THEN
                           fracs5(icount,1)=refflux1(ll)
                           fracs5(icount,2)=refflux2(ll)
                           fracs5(icount,3)=dflux
                           fracs5(icount,4)=corr1(5)+corr2(5)
                        END IF
                        IF(ll == 6)THEN
                           fracs6(icount,1)=refflux1(ll)
                           fracs6(icount,2)=refflux2(ll)
                           fracs6(icount,3)=dflux
                           fracs6(icount,4)=corr1(6)+corr2(6)
                        END IF
                        IF(ll == 7)THEN
                           fracs7(icount,1)=refflux1(ll)
                           fracs7(icount,2)=refflux2(ll)
                           fracs7(icount,3)=dflux
                           fracs7(icount,4)=corr1(7)+corr2(7)
                        END IF
                        IF(ll == 8)THEN
                           fracs8(icount,1)=refflux1(ll)
                           fracs8(icount,2)=refflux2(ll)
                           fracs8(icount,3)=dflux
                           fracs8(icount,4)=corr1(8)+corr2(8)
                        END IF
!
                     END DO
!
!  Once we have the reference fluxes, jump out to the end
!  of the big loop.
!
                     IF(ABS(ecc) <= EPSILON(ecc))GO TO 220
                     IF(ecc > 0.0_dp)GO TO 220
                  END IF
               END IF
               dop1=(vel1-gamma)/speedlightkm
               dop2=(vel2-gamma)/speedlightkm
               IF(jj == irvfilt)THEN
                  flux1=flux1*(1.0_dp-beam1*dop1)
                  flux2=flux2*(1.0_dp-beam2*dop2)
               END IF
!
               IF(jj == 1)ymodu(icount)=flux1+flux2+dflux+flux3
               IF(jj == 2)ymodb(icount)=flux1+flux2+dflux+flux3
               IF(jj == 3)ymodv(icount)=flux1+flux2+dflux+flux3
               IF(jj == 4)ymodr(icount)=flux1+flux2+dflux+flux3
               IF(jj == 5)ymodi(icount)=flux1+flux2+dflux+flux3
               IF(jj == 6)ymodj(icount)=flux1+flux2+dflux+flux3
               IF(jj == 7)ymodh(icount)=flux1+flux2+dflux+flux3
               IF(jj == 8)ymodk(icount)=flux1+flux2+dflux+flux3
!               yeclipse(icount)=REAL(neclipse1,KIND=dp)
!
               IF(jj == 1)THEN
                  fracs1(icount,1)=flux1
                  fracs1(icount,2)=flux2
                  fracs1(icount,3)=dflux
                  fracs1(icount,4)=flux3
               END IF
               IF(jj == 2)THEN
                  fracs2(icount,1)=flux1
                  fracs2(icount,2)=flux2
                  fracs2(icount,3)=dflux
                  fracs2(icount,4)=flux3
               END IF
               IF(jj == 3)THEN
                  fracs3(icount,1)=flux1
                  fracs3(icount,2)=flux2
                  fracs3(icount,3)=dflux
                  fracs3(icount,4)=flux3
               END IF
               IF(jj == 4)THEN
                  fracs4(icount,1)=flux1
                  fracs4(icount,2)=flux2
                  fracs4(icount,3)=dflux
                  fracs4(icount,4)=flux3
               END IF
               IF(jj == 5)THEN
                  fracs5(icount,1)=flux1
                  fracs5(icount,2)=flux2
                  fracs5(icount,3)=dflux
                  fracs5(icount,4)=flux3
               END IF
               IF(jj == 6)THEN
                  fracs6(icount,1)=flux1
                  fracs6(icount,2)=flux2
                  fracs6(icount,3)=dflux
                  fracs6(icount,4)=flux3
               END IF
               IF(jj == 7)THEN
                  fracs7(icount,1)=flux1
                  fracs7(icount,2)=flux2
                  fracs7(icount,3)=dflux
                  fracs7(icount,4)=flux3
               END IF
               IF(jj == 8)THEN
                  fracs8(icount,1)=flux1
                  fracs8(icount,2)=flux2
                  fracs8(icount,3)=dflux
                  fracs8(icount,4)=flux3
               END IF
!
               IF(jj == irvfilt)THEN
                  ymods1(icount)=flux1
                  ymods2(icount)=flux2
                  ymodd(icount)=dflux
                  rv1(icount)=vel1
                  rv2(icount)=vel2
                  drv1(icount)=delvel1
                  drv2(icount)=delvel2
                  fluxv1=flux1
                  fluxv2=flux2
                  CALL copyinty(ialphmax1,ibetmax1,nalph1,nalph2,  &
                     rinty1,saveinty1,rinty2,saveinty2,mmdx1,mmdx2,  &
                     ibetlim1,ibetlim2,ialphmax2,ibetmax2)
                  IF(isw30 > 2)CALL copyinty3(ialphmax3,ibetmax3,  &
                     nalph3,ibetlim3,mmdx3,rinty3,saveinty3)
                  IF(iidint >= 1)CALL copydiskinty(nrmax,nthetamax,  &
                     nradius,ntheta,dinty,savedinty,einty,saveeinty)
!
               END IF
            END DO
         END IF
!
!   Do the same block for iatm > 0
!
!   If we are skipping phases since iecheck=5, then we might
!   have jumped to here.
!
200      CONTINUE
!
         IF(iatm >= 1)THEN
!
!   UPDATE November 7, 2008
!
!   zero out the disk fluxes
!
            dfluxu=0.0_dp
            dfluxb=0.0_dp
            dfluxv=0.0_dp
            dfluxr=0.0_dp
            dfluxi=0.0_dp
            dfluxj=0.0_dp
            dfluxh=0.0_dp
            dfluxk=0.0_dp
!
            jj=1
            www=wave(jj)
            flimbx=dwavex(jj,1)
            flimby=dwavey(jj,1)
!
!  If we are skipping phases, then only do this block if
!  idoATMskip is 0.
!
            IF(idoatmskip == 0)THEN
               IF(idark1 <= 0)THEN
                  CALL getatmflux(ialphmax1,ibetmax1,nalph1,ibetlim1,  &
                     visib1,projarray1,temp1,surf1,g1,rinty1,flum1,  &
                     maxlines,maxmu,nlines,atmt,atmg,atmmu,nmu,atmint1,  &
                     atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,  &
                     atmint8,gscale1,fluxu1,fluxb1,fluxv1,fluxr1,fluxi1,  &
                     fluxj1,fluxh1,fluxk1,icnu,icnb,icnv,icnr,icni,icnj,  &
                     icnh,icnk,irvfilt,delphi1,delphie1,iedgestar1,  &
                     iedgehor1,separ,mmdx1,montecarlo,dwavex,dwavey,  &
                     ilaw,iatm,1)
!
                  IF(irvfilt == 1)flux1=fluxu1
                  IF(irvfilt == 2)flux1=fluxb1
                  IF(irvfilt == 3)flux1=fluxv1
                  IF(irvfilt == 4)flux1=fluxr1
                  IF(irvfilt == 5)flux1=fluxi1
                  IF(irvfilt == 6)flux1=fluxj1
                  IF(irvfilt == 7)flux1=fluxh1
                  IF(irvfilt == 8)flux1=fluxk1
                  CALL getvel(ialphmax1,ibetmax1,nalph1,ibetlim1,1,  &
                     omega1,phase,finc,qtemp,flum1,x1,y1,flux1,separ,  &
                     period,gamma,vel1,delvel1,darkint1(irvfilt),ecc,  &
                     argrad,mmdx1,isw13,ialfmin,ialfmax,bigi,bigbeta,z1)
!
               END IF
!
               IF((isw30 >= 3).AND.(isw7 >= 2))THEN
                  DO jk=1,8
                     third(jk)=thirdkeep(jk)
                  END DO
               END IF
               IF((neclipse3 > 0).AND.(isw30 > 2))THEN
                  gscale3=1.0_dp
                  CALL getatmflux(ialphmax3,ibetmax3,nalph3,ibetlim3,  &
                     visib3,projarray3,temp3,surf3,grav3,rinty3,flum3,  &
                     maxlines,maxmu,nlines,atmt,atmg,atmmu,nmu,atmint1,  &
                     atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,  &
                     atmint8,gscale3,fluxu3,fluxb3,fluxv3,fluxr3,fluxi3,  &
                     fluxj3,fluxh3,fluxk3,icnu,icnb,icnv,icnr,icni,icnj,  &
                     icnh,icnk,irvfilt,delphi3,delphie3,iedgestar3,  &
                     iedgehor3,separ,mmdx3,montecarlo,dwavex,dwavey,  &
                     ilaw,iatm,3)
!
                  IF(irvfilt == 1)flux3=fluxu3
                  IF(irvfilt == 2)flux3=fluxb3
                  IF(irvfilt == 3)flux3=fluxv3
                  IF(irvfilt == 4)flux3=fluxr3
                  IF(irvfilt == 5)flux3=fluxi3
                  IF(irvfilt == 6)flux3=fluxj3
                  IF(irvfilt == 7)flux3=fluxh3
                  IF(irvfilt == 8)flux3=fluxk3
                  third(1)=fluxu3
                  third(2)=fluxb3
                  third(3)=fluxv3
                  third(4)=fluxr3
                  third(5)=fluxi3
                  third(6)=fluxj3
                  third(7)=fluxh3
                  third(8)=fluxk3
               END IF
               IF(idraw == 1)THEN
                  CALL rotkern(ialphmax1,ibetmax1,nalph1,ibetlim1,1,  &
                     omega1,phase,finc,qtemp,flum1,x1,y1,flux1,separ,  &
                     period,gamma,ecc,argrad,visib1,extension,mmdx1)
               END IF
!
               flux2=0.0_dp
               IF(idark2 <= 0)THEN
                  IF(teff2 > 0.0_dp)CALL getatmflux(ialphmax2,  &
                     ibetmax2,nalph2,ibetlim2,visib2,projarray2,temp2,  &
                     surf2,g2,rinty2,flum2,maxlines,maxmu,nlines,atmt,  &
                     atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
                     atmint5,atmint6,atmint7,atmint8,gscale2,fluxu2,  &
                     fluxb2,fluxv2,fluxr2,fluxi2,fluxj2,fluxh2,fluxk2,  &
                     icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,irvfilt,  &
                     delphi2,delphie2,iedgestar2,iedgehor2,separ,mmdx2,  &
                     montecarlo,dwavex,dwavey,ilaw,iatm,2)
!
                  IF(irvfilt == 1)flux2=fluxu2
                  IF(irvfilt == 2)flux2=fluxb2
                  IF(irvfilt == 3)flux2=fluxv2
                  IF(irvfilt == 4)flux2=fluxr2
                  IF(irvfilt == 5)flux2=fluxi2
                  IF(irvfilt == 6)flux2=fluxj2
                  IF(irvfilt == 7)flux2=fluxh2
                  IF(irvfilt == 8)flux2=fluxk2
               END IF
!
!  UPDATE August 16, 2001
!
!  Remove the if clause.  If there is no star 2 (as in an X-ray
!  binary, then the sine curve will still be computed.
!
!              if(teff2.gt.0.0_dp)
!
               CALL getvel(ialphmax2,ibetmax2,nalph2,ibetlim2,2,  &
                  omega2,dummyphase,finc,qtemp,flum2,x2,y2,flux2,separ,  &
                  period,gamma,vel2,delvel2,darkint2(irvfilt),ecc,  &
                  argrad+pie,mmdx2,isw13,ialfmin,ialfmax,bigi,bigbeta,z2)
!
!   UPDATE May 24, 2002
!
!   Here is a new subroutine call.
!
               IF(idraw == 1)THEN
                  CALL rotkern(ialphmax2,ibetmax2,nalph2,ibetlim2,2,  &
                     omega2,phase,finc,qtemp,flum2,x2,y2,flux2,separ,  &
                     period,gamma,ecc,argrad,visib2,extension,mmdx2)
               END IF
!
               dflux=0.0_dp
!
!   UPDATE DECEMBER 17, 2001
!
!   If tdisk is less than 0, and if iidint is more than 0, then
!   the disk is there for geometrical purposes only (ignore its flux).
!
               IF(tdisk > 0.0_dp)THEN
                  IF(idcheck >= 1)THEN
!
                     IF(iidint >= 1)CALL getdiskatmflux(nrmax,  &
                        nthetamax,nradius,ntheta,diskproj,edgeproj,  &
                        dvisib,evisib,dtemp,tedge,drad,dinty,einty,stepr,  &
                        stepz,maxlines,maxmu,nlines,atmt,atmg,atmmu,nmu,  &
                        atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,  &
                        atmint7,atmint8,icnu,icnb,icnv,icnr,icni,icnj,  &
                        icnh,icnk,dfluxu,dfluxb,dfluxv,dfluxr,dfluxi,  &
                        dfluxj,dfluxh,dfluxk,irvfilt,separ,dwavex,dwavey, &
                        ilaw,iatm,tmin)
!
                     zdcorr(1)=dfluxu
                     zdcorr(2)=dfluxb
                     zdcorr(3)=dfluxv
                     zdcorr(4)=dfluxr
                     zdcorr(5)=dfluxi
                     zdcorr(6)=dfluxj
                     zdcorr(7)=dfluxh
                     zdcorr(8)=dfluxk
                  ELSE
                     dfluxu=zdcorr(1)
                     dfluxb=zdcorr(2)
                     dfluxv=zdcorr(3)
                     dfluxr=zdcorr(4)
                     dfluxi=zdcorr(5)
                     dfluxj=zdcorr(6)
                     dfluxh=zdcorr(7)
                     dfluxk=zdcorr(8)
                  END IF
               ELSE
                  dfluxu=0.0_dp
                  dfluxb=0.0_dp
                  dfluxv=0.0_dp
                  dfluxr=0.0_dp
                  dfluxi=0.0_dp
                  dfluxj=0.0_dp
                  dfluxh=0.0_dp
                  dfluxk=0.0_dp
               END IF
               IF(irvfilt == 1)dflux=dfluxu
               IF(irvfilt == 2)dflux=dfluxb
               IF(irvfilt == 3)dflux=dfluxv
               IF(irvfilt == 4)dflux=dfluxr
               IF(irvfilt == 5)dflux=dfluxi
               IF(irvfilt == 6)dflux=dfluxj
               IF(irvfilt == 7)dflux=dfluxh
               IF(irvfilt == 8)dflux=dfluxk
            END IF
!
!  If we are skipping phases, we might enter this if-then
!  block to use reference values determined above.
!
            IF((iecheck >= 5))THEN
               IF(((ABS(ecc) <= EPSILON(ecc)).AND.(iskip1 == 10).AND.(iskip2 ==  &
                  10)).OR.((ecc > 0.0_dp).AND.((iskip1 == 10).OR.(iskip2 == 10))))THEN
                  DO  ll=1,8
                     IF(ll == 1)ymodu(icount)=refflux1(1)+refflux2(1)+  &
                        third(1)+corr1(1)+corr2(1)
                     IF(ll == 2)ymodb(icount)=refflux1(2)+refflux2(2)+  &
                        third(2)+corr1(2)+corr2(2)
                     IF(ll == 3)ymodv(icount)=refflux1(3)+refflux2(3)+  &
                        third(3)+corr1(3)+corr2(3)
                     IF(ll == 4)ymodr(icount)=refflux1(4)+refflux2(4)+  &
                        third(4)+corr1(4)+corr2(4)
                     IF(ll == 5)ymodi(icount)=refflux1(5)+refflux2(5)+  &
                        third(5)+corr1(5)+corr2(5)
                     IF(ll == 6)ymodj(icount)=refflux1(6)+refflux2(6)+  &
                        third(6)+corr1(6)+corr2(6)
                     IF(ll == 7)ymodh(icount)=refflux1(7)+refflux2(7)+  &
                        third(7)+corr1(7)+corr2(7)
                     IF(ll == 8)ymodk(icount)=refflux1(8)+refflux2(8)+  &
                        third(8)+corr1(8)+corr2(8)
!                     yeclipse(icount)=REAL(neclipse1,KIND=dp)
                     CALL getrefvel(1,phase,finc,qtemp,separ,period,  &
                        gamma,vel1,ecc,argrad)
                     CALL getrefvel(2,dummyphase,finc,qtemp,separ,  &
                        period,gamma,vel2,ecc,argrad+pie)
                     rv1(icount)=vel1
                     rv2(icount)=vel2
                     IF(ll == irvfilt)THEN
                        ymods1(icount)=refflux1(ll)
                        ymods2(icount)=refflux2(ll)
                     END IF
!
                     IF(ll == 1)THEN
                        fracs1(icount,1)=refflux1(ll)
                        fracs1(icount,2)=refflux2(ll)
                        fracs1(icount,3)=dflux
                        fracs1(icount,4)=third(1)
                     END IF
                     IF(ll == 2)THEN
                        fracs2(icount,1)=refflux1(ll)
                        fracs2(icount,2)=refflux2(ll)
                        fracs2(icount,3)=dflux
                        fracs2(icount,4)=third(2)
                     END IF
                     IF(ll == 3)THEN
                        fracs3(icount,1)=refflux1(ll)
                        fracs3(icount,2)=refflux2(ll)
                        fracs3(icount,3)=dflux
                        fracs3(icount,4)=third(3)
                     END IF
                     IF(ll == 4)THEN
                        fracs4(icount,1)=refflux1(ll)
                        fracs4(icount,2)=refflux2(ll)
                        fracs4(icount,3)=dflux
                        fracs4(icount,4)=third(4)
                     END IF
                     IF(ll == 5)THEN
                        fracs5(icount,1)=refflux1(ll)
                        fracs5(icount,2)=refflux2(ll)
                        fracs5(icount,3)=dflux
                        fracs5(icount,4)=third(5)
                     END IF
                     IF(ll == 6)THEN
                        fracs6(icount,1)=refflux1(ll)
                        fracs6(icount,2)=refflux2(ll)
                        fracs6(icount,3)=dflux
                        fracs6(icount,4)=third(6)
                     END IF
                     IF(ll == 7)THEN
                        fracs7(icount,1)=refflux1(ll)
                        fracs7(icount,2)=refflux2(ll)
                        fracs7(icount,3)=dflux
                        fracs7(icount,4)=third(7)
                     END IF
                     IF(ll == 8)THEN
                        fracs8(icount,1)=refflux1(ll)
                        fracs8(icount,2)=refflux2(ll)
                        fracs8(icount,3)=dflux
                        fracs8(icount,4)=third(8)
                     END IF
                  END DO
!
!  If we used the reference values, jump out to near the end
!  of the large loop over phases.
!
                  IF(ABS(ecc) <= EPSILON(ecc))GO TO 220
                  IF(ecc > 0.0_dp)GO TO 220
               END IF
            END IF
!
!    Doppler boosting
!
            dop1=(vel1-gamma)/speedlightkm
            dop2=(vel2-gamma)/speedlightkm
            IF(irvfilt == 1)fluxu1=fluxu1*(1.0_dp-beam1*dop1)
            IF(irvfilt == 2)fluxb1=fluxb1*(1.0_dp-beam1*dop1)
            IF(irvfilt == 3)fluxv1=fluxv1*(1.0_dp-beam1*dop1)
            IF(irvfilt == 4)fluxr1=fluxr1*(1.0_dp-beam1*dop1)
            IF(irvfilt == 5)fluxi1=fluxi1*(1.0_dp-beam1*dop1)
            IF(irvfilt == 6)fluxj1=fluxj1*(1.0_dp-beam1*dop1)
            IF(irvfilt == 7)fluxh1=fluxh1*(1.0_dp-beam1*dop1)
            IF(irvfilt == 8)fluxk1=fluxk1*(1.0_dp-beam1*dop1)
!
            IF(irvfilt == 1)fluxu2=fluxu2*(1.0_dp-beam2*dop2)
            IF(irvfilt == 2)fluxb2=fluxb2*(1.0_dp-beam2*dop2)
            IF(irvfilt == 3)fluxv2=fluxv2*(1.0_dp-beam2*dop2)
            IF(irvfilt == 4)fluxr2=fluxr2*(1.0_dp-beam2*dop2)
            IF(irvfilt == 5)fluxi2=fluxi2*(1.0_dp-beam2*dop2)
            IF(irvfilt == 6)fluxj2=fluxj2*(1.0_dp-beam2*dop2)
            IF(irvfilt == 7)fluxh2=fluxh2*(1.0_dp-beam2*dop2)
            IF(irvfilt == 8)fluxk2=fluxk2*(1.0_dp-beam2*dop2)
!
            ymodu(icount)=fluxu1+fluxu2+dfluxu+third(1)
            ymodb(icount)=fluxb1+fluxb2+dfluxb+third(2)
            ymodv(icount)=fluxv1+fluxv2+dfluxv+third(3)
            ymodr(icount)=fluxr1+fluxr2+dfluxr+third(4)
            ymodi(icount)=fluxi1+fluxi2+dfluxi+third(5)
            ymodj(icount)=fluxj1+fluxj2+dfluxj+third(6)
            ymodh(icount)=fluxh1+fluxh2+dfluxh+third(7)
            ymodk(icount)=fluxk1+fluxk2+dfluxk+third(8)
!            yeclipse(icount)=REAL(neclipse1,KIND=dp)
!
            fracs1(icount,1)=fluxu1
            fracs2(icount,1)=fluxb1
            fracs3(icount,1)=fluxv1
            fracs4(icount,1)=fluxr1
            fracs5(icount,1)=fluxi1
            fracs6(icount,1)=fluxj1
            fracs7(icount,1)=fluxh1
            fracs8(icount,1)=fluxk1
!
            fracs1(icount,2)=fluxu2
            fracs2(icount,2)=fluxb2
            fracs3(icount,2)=fluxv2
            fracs4(icount,2)=fluxr2
            fracs5(icount,2)=fluxi2
            fracs6(icount,2)=fluxj2
            fracs7(icount,2)=fluxh2
            fracs8(icount,2)=fluxk2
!
            fracs1(icount,3)=dfluxu
            fracs2(icount,3)=dfluxb
            fracs3(icount,3)=dfluxv
            fracs4(icount,3)=dfluxr
            fracs5(icount,3)=dfluxi
            fracs6(icount,3)=dfluxj
            fracs7(icount,3)=dfluxh
            fracs8(icount,3)=dfluxk
!
            fracs1(icount,4)=third(1)
            fracs2(icount,4)=third(2)
            fracs3(icount,4)=third(3)
            fracs4(icount,4)=third(4)
            fracs5(icount,4)=third(5)
            fracs6(icount,4)=third(6)
            fracs7(icount,4)=third(7)
            fracs8(icount,4)=third(8)
!
            ymods1(icount)=flux1
            ymods2(icount)=flux2
            ymods3(icount)=third(irvfilt)
            ymodd(icount)=dflux
            rv1(icount)=vel1
            drv1(icount)=delvel1
            rv2(icount)=vel2
            drv2(icount)=delvel2
!
            CALL copyinty(ialphmax1,ibetmax1,nalph1,nalph2,rinty1,  &
               saveinty1,rinty2,saveinty2,mmdx1,mmdx2,ibetlim1,  &
               ibetlim2,ialphmax2,ibetmax2)
            IF(isw30 > 2)CALL copyinty3(ialphmax3,ibetmax3,nalph3,  &
               ibetlim3,mmdx3,rinty3,saveinty3)
            IF(iidint >= 1)CALL copydiskinty(nrmax,nthetamax,  &
               nradius,ntheta,dinty,savedinty,einty,saveeinty)
!
!   end if iatm .ge. 1
!
         END IF
!
!  If drawing was requested, output the needed files.
!
         IF(idraw == 1)THEN
            ppp=phase
            dppp=dummyphase
            IF((ecc > 0.0_dp).AND.(ism1 == 0))THEN
               ppp=MOD(em*radtodeg-phase,360.0_dp)
               ppp=pstart
            END IF
            IF((ecc > 0.0_dp).AND.(ism1 > 0))THEN
               IF(ipstep == 1)ppp=MOD(em*radtodeg-phase,360.0_dp)
               IF(ipstep == 2)ppp=MOD(emnew*radtodeg-phase,360.0_dp)
               ppp=pstart
            END IF
            IF(ecc > 0.0_dp)dppp=ppp+180.0_dp
!
            IF(iidint >= 1)THEN
               CALL hidgrid(1,ialphmax1,ibetmax1,nalph1,ibetlim1,  &
                  ppp,finc,qtemp,x1,y1,z1,xend1,projarray1,g1,gscale1,  &
                  surf1,ndhoriz,dxhoriz,dyhoriz,saveinty1,extension,  &
                  separ,flux1,reff1,iecheck,temp1,nhoriz1,xhoriz1,  &
                  yhoriz1,bdist,mmdx1,tertincl,tertbdist,tertphase,  &
                  tertq,axisscale,isw30,isw7,tertomega,  &
                  nhoriz3,xhoriz3,yhoriz3,i3flag,bigi,bigbeta,omega1,flum1)
            END IF
!
            IF(iidint <= 0)THEN
               CALL hidgrid(1,ialphmax1,ibetmax1,nalph1,ibetlim1,  &
                  ppp,finc,qtemp,x1,y1,z1,xend1,projarray1,g1,gscale1,  &
                  surf1,nhoriz2,xhoriz2,yhoriz2,saveinty1,extension,  &
                  separ,flux1,reff1,iecheck,temp1,nhoriz1,xhoriz1,  &
                  yhoriz1,bdist,mmdx1,tertincl,tertbdist,tertphase,  &
                  tertq,axisscale,isw30,isw7,tertomega,  &
                  nhoriz3,xhoriz3,yhoriz3,i3flag,bigi,bigbeta,omega1,flum1)
            END IF
!
            IF(teff2 > 0.0_dp)CALL hidgrid(2,ialphmax2,ibetmax2,  &
               nalph2,ibetlim2,dppp,finc,qtemp,x2,y2,z2,xend2,  &
               projarray2,g2,gscale2,surf2,nhoriz1,xhoriz1,yhoriz1,  &
               saveinty2,extension,separ,flux2,reff2,iecheck,temp2,  &
               nhoriz2,xhoriz2,yhoriz2,bdist,mmdx2,tertincl,tertbdist,  &
               tertphase,tertq,axisscale,isw30,isw7,tertomega,  &
               nhoriz3,xhoriz3,yhoriz3,i3flag,bigi2, bigbeta2,omega2,flum2)
!
            IF(isw30 > 2)CALL hidgrid3(ialphmax3,ibetmax3,nalph3,  &
               ibetlim3,x3,y3,z3,projarray3,gthird,  &
               g3,surf3,nhoriz1,xhoriz1,yhoriz1,rinty3,extension,  &
               separ,fluxv3,reff3,iecheck,temp3,mmdx3,tertincl,  &
               tertbdist,tertphase,tertq,axisscale,  &
               tertomega,nhoriz2,xhoriz2,yhoriz2,i3flag)
            IF(iidint > 0)CALL hiddiskgrid(nrmax,nthetamax,  &
               nradius,ntheta,diskproj,edgeproj,dtemp,tedge,dx,dy,dz,  &
               xedge,yedge,zedge,savedinty,saveeinty,ppp,finc,qtemp,  &
               nhoriz1,xhoriz1,yhoriz1,extension,separ,dflux,bdist,  &
               tertincl,tertbdist,tertphase,tertq,axisscale,isw30, &
               isw7,tertomega)
!
            CALL getcoords(1,ialphmax1,ibetmax1,nalph1,ibetlim1,  &
               ppp,finc,qtemp,x1,y1,z1,gradx1,grady1,gradz1,temp1,  &
               ndumsky1,dumxsky1,dumysky1,xend1,extension,separ,bdist,  &
               mmdx1,tertincl,tertbdist,tertphase,tertq,axisscale,  &
               isw30,isw7,tertomega)
!
            IF(teff2 > 0.0_dp)CALL getcoords(2,ialphmax2,ibetmax2,  &
               nalph2,ibetlim2,dppp,finc,qtemp,x2,y2,z2,gradx2,grady2,  &
               gradz2,temp2,ndumsky2,dumxsky2,dumysky2,xend2,  &
               extension,separ,bdist,mmdx2,tertincl,tertbdist,  &
               tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
            CALL writepoints(ialphmax1,ibetmax1,nthetamax,nsky1,  &
               xsky1,ysky1,nsky2,xsky2,ysky2,nhoriz1,xhoriz1,yhoriz1,  &
               nhoriz2,xhoriz2,yhoriz2,nskydisk,xskydisk,yskydisk,  &
               zskydisk,ntop2,xtop2horiz,ytop2horiz,ndtop,dtopx,dtopy,  &
               ndhoriz,dxhoriz,dyhoriz,nskyedge,xskyedge,yskyedge,  &
               extension,separ,teff2,iidint,ialphmax2,ibetmax2,  &
               nsky3,xsky3,ysky3,nhoriz3,xhoriz3,yhoriz3)
         END IF
!
!   Next, set various toggle switches based on whether any points were
!   eclipsed.  If iecheck = 1, then the code will not check for
!   eclipses for phases between togglephase and (180-togglephase) and
!   between (180+togglephase) and (360-(togglephase-180)) where
!   togglephase is the phase where the number of eclipsed points is zero
!   for the first time.
!
!   Also, if iecheck was set to 1, the disk integration will be skipped
!   at phases where there is no eclipse.
!
         ntotal=neclipse1+neclipse2+neclipsed
         IF((itoggle == -1).AND.(ntotal == 0))THEN
            itoggle=1
            IF(icount > 1)THEN
               IF(phase < 180.0_dp)togglephase=phase
            ELSE
               IF(phase < 180.0_dp)togglephase=dphase
            END IF
            IF(iecheck >= 1)idcheck=-100
         END IF
220      IF(isw7 >= 2)xmod(icount)=timearray(icounttime)
         IF(isw7 <= 1)xmod(icount)=phase/360.0_dp
         ieccbbskip=0
         ieccatmskip=0
!
!   Change the assignment of the value of xmod for eccentric orbits as
!   below.
!
         IF((ecc > 0.0_dp).AND.(ism1 == 0))xmod(icount)=em/(twopie)
         IF((ecc > 0.0_dp).AND.(ism1 > 0))THEN
            IF(ipstep == 1)xmod(icount)=em/(twopie)
            IF(ipstep == 2)xmod(icount)=emnew/(twopie)
         END IF
!
         IF((isw7 >= 2).AND.(ecc > 0.0_dp))xmod(icount)=timearray(icounttime)
         IF(ioutflag == 1)WRITE(64,390)phase,ntotal,iecheck,  &
            idcheck,itoggle,togglephase
         tshift=pshift+eshift
!
!   UPDATE September 10, 2001
!
!   Add the if-then clauses.
!
         IF(ikeep == 1)tshift=pshift+eshift-pconj
         IF(ikeep == 2)tshift=pshift+eshift-pconj2
         qqq=MOD(xmod(icount)+tshift,1.0_dp)
         overq=1.0_dp/qtemp
         rrr=pot2/overq+0.5_dp*(overq-1.0_dp)/overq
!
!   May 16, 2001
!
!   Record parameters for eccentric orbits in unit 65.
!
         IF(ioutflag == 1)THEN
            IF(ecc > 0.0_dp)WRITE(65,380)qqq,bdist,tpole1,tpole2,  &
               fill1,fill2,rpole1,rpole2,pot1,rrr,sa1,sa2,pots1,pots2, &
               gscale1,gscale2
         END IF
!
!   UPDATE OCTOBER 20, 2005
!
!   change to .ge.5
!
         IF((iecheck >= 5).AND.(ecc > 0.0_dp).AND.((iskip1 == 10)  &
            .OR.(iskip2 == 10)))CYCLE loop240
         IF((iecheck >= 5).AND.(ABS(ecc) <= EPSILON(ecc)).AND.((iskip1 == 10)  &
            .AND.(iskip2 == 10)))CYCLE
      END DO  loop230
!
!   continue the big loop if eccentric
!
   END DO loop240
!
   nphase=icount
   icountx=icount
!
!          IF(Nphase.le.1)WRITE(*,*)finc,Qtemp,separ,pstart,pstop
!
!   If ism1=1, then we have to reflect the light curves
!   to get phases 180 to 360-dphase.
!
!   April 19, 2001
!
!   If the eccentricity is greater than 0, do not 'finish'
!   the light curve since it is already complete.
!
!   UPDATE October 18, 2002
!
!   Use the input flags sw7 and sw8 to define a phase range
!   to compute.  Require sw7 > 0 and sw8 > 0  AND  sw7 < sw 8
!   If this is true, then don't complete the light curves.
!
   IF(isw7 >= 2)GO TO 260
   IF((sw7 > 0.0_dp).AND.(sw8 > 0.0_dp).AND.(sw7 < sw8))GO TO 250
!
   IF((ionephase == 0).AND.(ism1 >= 1).AND.(ABS(ecc) <= EPSILON(ecc)))THEN
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymodu,1,ioutflag)
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymodb,0,ioutflag)
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymodv,0,ioutflag)
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymodr,0,ioutflag)
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymodi,0,ioutflag)
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymodj,0,ioutflag)
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymodh,0,ioutflag)
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymodk,0,ioutflag)
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymods1,0,ioutflag)
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymods2,0,ioutflag)
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymods3,0,ioutflag)
      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,ymodd,0,ioutflag)
!      CALL finishlc(nmaxphase,icount,dphase,nphase,xmod,yeclipse,0,ioutflag)
      CALL finishrv(1,nmaxphase,icount,dphase,nphase,xmod,rv1,gamma,drv1)
      CALL finishrv(2,nmaxphase,icount,dphase,nphase,xmod,rv2,gamma,drv2)
   END IF
!
   IF(isw24 >= 1)CALL getfracs(nmaxphase,icount,fracs1,fracs2,  &
      fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,compfracs,dphase,  &
      eshift,pshift,ionephase,ism1,ecc,sw26,fracstring)
!
!   UPDATE October 18, 2002
!
!   Add the statement label 654 below.
!
250 CONTINUE
!
!   Close the file with the eccentric parameters.
!
   IF(ecc > 0.0_dp)CLOSE(65)
!
!   Reset the value of iecheck.
!
   iecheck=iesave
   IF(irvfilt == 1)icnu=ivsave
   IF(irvfilt == 2)icnb=ivsave
   IF(irvfilt == 3)icnv=ivsave
   IF(irvfilt == 4)icnr=ivsave
   IF(irvfilt == 5)icni=ivsave
   IF(irvfilt == 6)icnj=ivsave
   IF(irvfilt == 7)icnh=ivsave
   IF(irvfilt == 8)icnk=ivsave
!
!   Apply the phase shift, if any.
!
260 CONTINUE
   IF((isw7 >= 2))THEN
      IF(isw24 >= 1)CALL getfracstime(nmaxphase,icount,fracs1,  &
         fracs2,fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,compfracs, &
         sw26,fracstring)
      GO TO 360
   END IF
   IF(ionephase == 0)THEN
      IF((ecc > 0.0_dp).OR.(ABS(pshift) >= EPSILON(pshift)))THEN
         tshift=pshift+eshift
!
!   UPDATE September 10, 2001
!
!   Add the if-then clauses.
!
         IF(ikeep == 1)tshift=pshift+eshift-pconj
         IF(ikeep == 2)tshift=pshift+eshift-pconj2
!
         CALL shiftlc(nmaxphase,nphase,xmod,ymodu,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymodb,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymodv,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymodr,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymodi,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymodj,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymodh,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymodk,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymods1,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymods2,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymods3,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymodd,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,rv1,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,drv1,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,rv2,tshift,0)
!         CALL shiftlc(nmaxphase,nphase,xmod,yeclipse,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,drv2,tshift,1)
      END IF
   END IF
!
!   UPDATE September 10, 2001
!
!   If Teff < 0, then compute the duration of the X-ray eclipse
!   if any. The length of the X-ray eclipse in DEGREES will be
!   stored in the variable obsparm(9).
!
!   UPDATE December 11, 2001
!
!   If ionephase > 0, only one phase was requested (presumably for
!   drawing purposes).  If ionephase > 0, skip to the end.
!
   IF(ionephase >= 1)GO TO 360
   phin=0.0_dp
   phout=0.0_dp
   IF(teff2 <= 0.0_dp)THEN
!
!   case for circular orbits
!
      IF(ABS(ecc) <= EPSILON(ecc))THEN
         IF(icountx > 1)CALL sort2(icountx,xecx,xecy)
!
!   Check at phase 0.0 to see if there is an eclipse.
!
         bdist=1.0_dp
         phase=0.0_dp
!
         CALL gethorizon(1,ialphmax1,ibetmax1,nalph1,ibetlim1,  &
            phase,finc,qtemp,pot1,omega1,x1,y1,z1,rad1,gradx1,grady1,  &
            gradz1,xend1,nhoriz1,xhoriz1,yhoriz1,phiar1,iedgestar1,  &
            delphie1,bdist,mmdx1,xhmin1,xhmax1,yhmin1,yhmax1,tidephi,  &
            itide,phihor1,ecc,thetamis,phimis,tertincl,tertbdist,  &
            tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
         CALL getxecl(nhoriz1,xhoriz1,yhoriz1,ixecl,qtemp,finc,  &
            bdist,phase,tertincl,tertbdist,tertphase,tertq,axisscale,  &
            isw30,isw7,tertomega)
!
         IF(ixecl <= 0)THEN
            obsparm(9)=0.0_dp
            CALL pspacestring('X-ray eclipse duration',6,obsparm(9)  &
               ,instring1,ilength1)
            IF(ioutflag == 1)WRITE(2,400)TRIM(instring1)
!
!   no eclipse here
!
            GO TO 360
         END IF
!
!   Now we have to locate the phase where the X-ray source is not
!   eclipsed and iterate.
!
         phin=0.0_dp
         DO  ii=2,icountx
            IF(xecy(ii) > 10.0_dp)THEN
               phin=xecx(ii)
               CYCLE
            ELSE
               phout=xecx(ii)
               EXIT
            END IF
         END DO
!
         DO  ii=1,30
            phase=0.5_dp*(phout+phin)
            bdist=1.0_dp
!
            CALL gethorizon(1,ialphmax1,ibetmax1,nalph1,ibetlim1,  &
               phase,finc,qtemp,pot1,omega1,x1,y1,z1,rad1,gradx1,  &
               grady1,gradz1,xend1,nhoriz1,xhoriz1,yhoriz1,phiar1,  &
               iedgestar1,delphie1,bdist,mmdx1,xhmin1,xhmax1,yhmin1,  &
               yhmax1,tidephi,itide,phihor1,ecc,thetamis,phimis,  &
               tertincl,tertbdist,tertphase,tertq,axisscale,isw30, &
               isw7,tertomega)
!
            CALL getxecl(nhoriz1,xhoriz1,yhoriz1,ixecl,qtemp,finc,  &
               bdist,phase,tertincl,tertbdist,tertphase,tertq,  &
               axisscale,isw30,isw7,tertomega)
!
            IF(ixecl > 10)phin=phase
            IF(ixecl < -10)phout=phase
         END DO
!
         obsparm(9)=2.0_dp*phin
         CALL pspacestring('X-ray eclipse duration',6,obsparm(9),  &
            instring1,ilength1)
         IF(ioutflag == 1)WRITE(2,400)TRIM(instring1)
!
!   end if ecc = 0
!
      END IF
!
!   case for eccentric
!
      IF(ecc > 0.0_dp)THEN
         IF(icountx > 1)CALL sort2(icountx,xecx,xecy)
!
!   Check at the conjunction phase to see if there is an eclipse.
!
         rnu=-argper-90.0_dp
         rnu=rnu*degtorad
         phase=0.0_dp
         bdist=(1.0_dp-ecc*ecc)/(1.0_dp+ecc*COS(rnu))
!
         CALL setupgeo(1,ialphmax1,ibetmax1,nalph1,nbet1,ibetlim1,  &
            fill1,omega1,qtemp,finc,x1,y1,z1,surf1,rad1,gradx1,  &
            grady1,gradz1,g1,xend1,separ,tgrav1,teff1,reff1,rl1,  &
            tpole1,rpol1,regg1,sa1,pot1,gpole1,phiar1,isquare,  &
            iusepot,usepot1,ivrt,pervol1,fillper1,bdist,pots1,  &
            mmdx1,primmass,primk,primrad,ratrad,frac1,frac2,ecc,  &
            period,size1,sw5,tteff2,density,tidephi,itide,phistart1,  &
            thetamis,phimis,ioutflag,arrsobx,montemax,  &
            masssum,massdiff,radsum,raddiff,secmass,secrad,fracsum,  &
            fracdiff,qtemp,fillsum,filldiff)
!
         CALL gethorizon(1,ialphmax1,ibetmax1,nalph1,ibetlim1,  &
            phase,finc,qtemp,pot1,omega1,x1,y1,z1,rad1,gradx1,grady1,  &
            gradz1,xend1,nhoriz1,xhoriz1,yhoriz1,phiar1,iedgestar1,  &
            delphie1,bdist,mmdx1,xhmin1,xhmax1,yhmin1,yhmax1,tidephi,  &
            itide,phihor1,ecc,thetamis,phimis,tertincl,tertbdist,  &
            tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
         CALL getxecl(nhoriz1,xhoriz1,yhoriz1,ixecl,qtemp,finc,  &
            bdist,phase,tertincl,tertbdist,tertphase,tertq,axisscale,  &
            isw30,isw7,tertomega)
!
         IF(ixecl <= 0)THEN
            obsparm(9)=0.0_dp
            CALL pspacestring('X-ray eclipse duration',6,obsparm(9)  &
               ,instring1,ilength1)
            IF(ioutflag == 1)WRITE(2,400)LEN(instring1)
!
!  no eclipse here
!
            GO TO 360
         END IF
!
!   Now we have to locate the phase where the X-ray source is not
!   eclipsed and iterate.
!
         phin=0.0_dp
!
         DO  ii=1,icountx
            IF(xecy(ii) > 10.0_dp)THEN
               phin=xecx(ii)
               CYCLE
            ELSE
               phout=xecx(ii)
               EXIT
            END IF
         END DO
!
         DO  ii=1,20
            phase=0.5_dp*(phout+phin)
            rnu=degtorad*MOD((phase-90.0_dp-argper),360.0_dp)
            IF(rnu < 0.0_dp)rnu=rnu+2.0_dp*pie
            bdist=(1.0_dp-ecc*ecc)/(1.0_dp+ecc*COS(rnu))
!
            CALL setupgeo(1,ialphmax1,ibetmax1,nalph1,nbet1,  &
               ibetlim1,fill1,omega1,qtemp,finc,x1,y1,z1,surf1,rad1,  &
               gradx1,grady1,gradz1,g1,xend1,separ,tgrav1,teff1,reff1,  &
               rl1,tpole1,rpol1,regg1,sa1,pot1,gpole1,phiar1,isquare,  &
               iusepot,usepot1,ivrt,pervol1,fillper1,bdist,pots1,  &
               mmdx1,primmass,primk,primrad,ratrad,frac1,frac2,ecc,  &
               period,size1,sw5,tteff2,density,tidephi,itide,  &
               phistart1,thetamis,phimis,ioutflag,arrsobx,  &
               montemax,masssum,massdiff,radsum,raddiff,secmass,  &
               secrad,fracsum,fracdiff,qtemp,fillsum,filldiff)
!
            CALL gethorizon(1,ialphmax1,ibetmax1,nalph1,ibetlim1,  &
               phase,finc,qtemp,pot1,omega1,x1,y1,z1,rad1,gradx1,  &
               grady1,gradz1,xend1,nhoriz1,xhoriz1,yhoriz1,phiar1,  &
               iedgestar1,delphie1,bdist,mmdx1,xhmin1,xhmax1,yhmin1,  &
               yhmax1,tidephi,itide,phihor1,ecc,thetamis,phimis,  &
               tertincl,tertbdist,tertphase,tertq,axisscale,isw30, &
               isw7,tertomega)
!
            CALL getxecl(nhoriz1,xhoriz1,yhoriz1,ixecl,qtemp,finc,  &
               bdist,phase,tertincl,tertbdist,tertphase,tertq,  &
               axisscale,isw30,isw7,tertomega)
!
            IF(ixecl > 10)phin=phase
            IF(ixecl < -10)phout=phase
         END DO
!
!   Now figure out the observed phase of the angle corresponding
!   to rnu.
!
         IF(rnu < 0.0_dp)rnu=rnu+twopie
         ecan=2.0_dp*ATAN(TAN(rnu*0.5_dp)*SQRT((1.0_dp-ecc)/(1.0_dp+ecc)))
         ecan=MOD(ecan,twopie)
         IF(ecan < 0.0_dp)ecan=ecan+twopie
         obsph1=ecan-ecc*SIN(ecan)
!
!   Now look at the other ingress phase.
!
         DO  ii=icountx,1,-1
            IF(xecy(ii) > 10.0_dp)THEN
               phin=xecx(ii)
               CYCLE
            ELSE
               phout=xecx(ii)
               IF(ii == icountx)phin=359.99_dp
               EXIT
            END IF
         END DO
!
         DO  ii=1,20
            phase=0.5_dp*(phout+phin)
            rnu=degtorad*MOD((phase-90.0_dp-argper),360.0_dp)
            IF(rnu < 0.0_dp)rnu=rnu+twopie
            bdist=(1.0_dp-ecc*ecc)/(1.0_dp+ecc*COS(rnu))
!
            CALL setupgeo(1,ialphmax1,ibetmax1,nalph1,nbet1,  &
               ibetlim1,fill1,omega1,qtemp,finc,x1,y1,z1,surf1,rad1,  &
               gradx1,grady1,gradz1,g1,xend1,separ,tgrav1,teff1,reff1,  &
               rl1,tpole1,rpol1,regg1,sa1,pot1,gpole1,phiar1,isquare,  &
               iusepot,usepot1,ivrt,pervol1,fillper1,bdist,pots1,  &
               mmdx1,primmass,primk,primrad,ratrad,frac1,frac2,ecc,  &
               period,size1,sw5,tteff2,density,tidephi,itide,  &
               phistart1,thetamis,phimis,ioutflag,arrsobx,  &
               montemax,masssum,massdiff,radsum,raddiff,secmass,  &
               secrad,fracsum,fracdiff,qtemp,fillsum,filldiff)
!
            CALL gethorizon(1,ialphmax1,ibetmax1,nalph1,ibetlim1,  &
               phase,finc,qtemp,pot1,omega1,x1,y1,z1,rad1,gradx1,  &
               grady1,gradz1,xend1,nhoriz1,xhoriz1,yhoriz1,phiar1,  &
               iedgestar1,delphie1,bdist,mmdx1,xhmin1,xhmax1,yhmin1,  &
               yhmax1,tidephi,itide,phihor1,ecc,thetamis,phimis,  &
               tertincl,tertbdist,tertphase,tertq,axisscale,isw30, &
               isw7,tertomega)
!
            CALL getxecl(nhoriz1,xhoriz1,yhoriz1,ixecl,qtemp,finc,  &
               bdist,phase,tertincl,tertbdist,tertphase,tertq,  &
               axisscale,isw30,isw7,tertomega)
!
            IF(ixecl > 10)phin=phase
            IF(ixecl < -10)phout=phase
         END DO
!
!   Figure out the observed phase of the angle rnu.
!
         IF(rnu < 0.0_dp)rnu=rnu+twopie
         ecan=2.0_dp*ATAN(TAN(rnu*0.5_dp)*SQRT((1.0_dp-ecc)/(1.0_dp+ecc)))
         ecan=MOD(ecan,twopie)
         IF(ecan < 0.0_dp)ecan=ecan+twopie
         obsph2=ecan-ecc*SIN(ecan)
!
         ddd2=ABS(obsph2-obsph1)
         IF(ddd2 > pie)THEN
            ddd2=(obsph1+2.0_dp*pie)-obsph2
         END IF
         obsparm(9)=ddd2*radtodeg
         CALL pspacestring('X-ray eclipse duration',6,obsparm(9),  &
            instring1,ilength1)
         IF(ioutflag == 1)WRITE(2,400)TRIM(instring1)
!
!  end if ecc = 0
!
      END IF
!
!  end if Teff < 0
!
   END IF
!
!   Close the unit 2 file here (ELC.out) instead of in the
!   main program.
!
360 IF(ioutflag == 1)CLOSE(2)
   IF(ioutflag == 1)CLOSE(64)
!
!   Close the file with the eccentric parameters.
!
   IF(ioutflag == 1)THEN
      IF(ecc > 0.0_dp)CLOSE(65)
   END IF
!
   scr1string=TRIM(parmstring)
   WRITE(scr2string,410)obsparm(9)
   parmstring=TRIM(scr1string)//scr2string
!
!   UPDATE OCTOBER 24, 2005
!
!   If the iecheck=5 option was used, remove the skipped phases.
!   These will have negative values in the light curves.
!
   IF(iecheck == 5)THEN
      icount=nphase
      CALL cliplc(nmaxphase,icount,nphase,xmod,ymodu,ymodb,ymodv,  &
         ymodr,ymodi,ymodj,ymodh,ymodk,ymods1,ymods2,ymods3,ymodd, &
         rv1,rv2,drv1,drv2)
   END IF
!
   nrvphase=nphase
   DO  ii=1,nphase
      xrvmod(ii)=xmod(ii)
   END DO
!
!   UPDATE JULY 21, 2006
!
!   Add a "fast genetic" mode.  If ifastflag=1, then set
!     Nalph1=40
!     Nbet1=14
!     Nalph2=40
!     Nbet2=14
!     dphase=3
!
!   We need to restore the reset values above.
!
   IF(ifastflag >= 1)THEN
      nalph1=ina1save
      nalph2=ina2save
      nbet1=inb1save
      nbet2=inb2save
      dphase=savedphase
   END IF
!
!  UPDATE JULY 5, 2011
!
!  If the Kepler contamination is not zero, then dilute the
!  light curve (modelU)
!
   IF((contam > 0.0_dp).AND.(contam < 1.0_dp))THEN
      IF(nphase > 1)CALL contaminate(nmaxphase,nphase,xmod,ymodu,contam)
   END IF
!
!   UPDATE JULY 13, 2009
!
!   If requested, bin the light and velocity curves.  sw29 will be
!   the binsize for the photometry, in minutes, and sw30 will be
!   the bin size for the RV curves, in minutes.
!
   IF((sw29 > 0.0_dp).AND.(icnu /= 430))THEN
      IF(isw7 <= 1)THEN
         CALL binlc(nmaxphase,nphase,xmod,ymodu,period,sw29)
      ELSE
         CALL binlctime(nmaxphase,nphase,xmod,ymodu,period,sw29,nsc,xsc,ysc,isw87)
      END IF
   END IF
   IF(sw30 > 0.0_dp)THEN
      IF(isw7 <= 1)THEN
         IF(icnrv1 /= 430)CALL binlc(nmaxphase,nrvphase,xrvmod, rv1,period,sw30)
      ELSE
         IF(icnrv1 /= 430)CALL binlctime(nmaxphase,nrvphase,  &
            xrvmod,rv1,period,sw30,nsc,xsc,ysc,isw87)
      END IF
   END IF
   IF(sw30 > 0.0_dp)THEN
      IF(isw7 <= 1)THEN
         IF(icnrv2 /= 430)CALL binlc(nmaxphase,nrvphase,xrvmod,rv2,period,sw30)
      ELSE
         IF(icnrv1 /= 430)CALL binlctime(nmaxphase,nrvphase,  &
            xrvmod,rv2,period,sw30,nsc,xsc,ysc,isw87)
      END IF
   END IF
!
   IF(sw30 > 0.0_dp)THEN
      IF(isw7 <= 1)THEN
         IF(icnrv1 /= 430)CALL binlc(nmaxphase,nrvphase,xrvmod,drv1,period,sw30)
      ELSE
         IF(icnrv1 /= 430)CALL binlctime(nmaxphase,nrvphase,  &
            xrvmod,drv1,period,sw30,nsc,xsc,ysc,isw87)
      END IF
   END IF
   IF(sw30 > 0.0_dp)THEN
      IF(isw7 <= 1)THEN
         IF(icnrv2 /= 430)CALL binlc(nmaxphase,nrvphase,xrvmod,drv2,period,sw30)
      ELSE
         IF(icnrv2 /= 430)CALL binlctime(nmaxphase,nrvphase,  &
            xrvmod,drv2,period,sw30,nsc,xsc,ysc,isw87)
      END IF
   END IF
!
   IF((sw29 > 0.0_dp).AND.(iidint > 0))CALL binlc(nmaxphase,  &
      nphase,xmod,ymodd,period,sw29)
!
   rdepth=1.0_dp
   IF(icnu /= 430)CALL getdepth(nphase,ymodu,rdepth)
   scr1string=TRIM(parmstring)
   WRITE(scr2string,410)rdepth
   parmstring=TRIM(scr1string)//scr2string
!
   nbody=isw30
   rmass(1)=rm1
   rmass(2)=rm2
   rrad(1)=r1
   rrad(2)=r2
!          Qtemp=Q
   ioutflag=ioutflagsave
   CALL newparm(ioutflag,newparmstr,rmass,rrad,rrau,  &
      teff2,qtemp,separ,ecc,argper,period,finc,omega1,omega2,ave11,  &
      ave12,ave21,ave22,ave1,ave2,diskrad,diskthick,obsparm(9),  &
      rdepth,sw49,tconj,t0,nbody,tref,ribcinp,itconj,tertt0,p2t0,  &
      p3t0,p4t0,p5t0,p6t0,p7t0,p8t0,fill1,fill2)
   q=qsave
!
380 FORMAT(f15.6,1X,f8.5,1X,2(f12.5,1X),1X,2(f8.5,1X),1X,2(f8.5,  &
      1X),2(f12.5,1X),1X,2(f9.6,1X),4(f12.6,1X))
390 FORMAT(f15.8,10X,i8,2X,i4,1X,i4,2X,i2,1X,f13.8)
400 FORMAT(a,1X,'degrees')
410 FORMAT(1X,f11.7)
!
   DEALLOCATE(timearray)
!
!   Deallocate the arrays associated with the stars
!   when using Roche geometry
!
   DEALLOCATE(mmdx1,mmdx2,mmdx3)
   DEALLOCATE(ibetlim1,ibetlim2,ibetlim3)
   DEALLOCATE(rad1,rad2,rad3)
   DEALLOCATE(x1,y1,z1)
   DEALLOCATE(x2,y2,z2)
   DEALLOCATE(x3,y3,z3)
   DEALLOCATE(visib1,visib2,visib3)
   DEALLOCATE(rinty1,rinty2,rinty3)
   DEALLOCATE(flum1,flum2,flum3)
   DEALLOCATE(saveinty1,saveinty2,saveinty3)
   DEALLOCATE(phiar1,phiar2,phiar3)
   DEALLOCATE(delphi1,delphi2,delphi3)
   DEALLOCATE(iedgestar1,iedgestar2,iedgestar3)
   DEALLOCATE(iedgehor1,iedgehor2,iedgehor3)
   DEALLOCATE(delphie1,delphie2,delphie3)
   DEALLOCATE(phihor1,phihor2,phihor3)
   DEALLOCATE(surf1,surf2,surf3)
   DEALLOCATE(gradx1,gradx2)
   DEALLOCATE(grady1,grady2)
   DEALLOCATE(gradz1,gradz2)
   DEALLOCATE(phistart1,phistart2,phistart3)
   DEALLOCATE(g1,g2,gthird)
   DEALLOCATE(gradx3,grady3,gradz3,grav3)
   DEALLOCATE(temp1,temp2,temp3)
   DEALLOCATE(rpol1,rpol2)
   DEALLOCATE(xhoriz1,yhoriz1)
   DEALLOCATE(xhoriz2,yhoriz2)
   DEALLOCATE(xhoriz3,yhoriz3)
   DEALLOCATE(xsky1,ysky1)
   DEALLOCATE(xsky2,ysky2)
   DEALLOCATE(xsky3,ysky3)
   DEALLOCATE(ratio1,ratio2,tempold1,tempold2)
   DEALLOCATE(projarray1,projarray2,projarray3)
   DEALLOCATE(dumxsky1,dumysky1)
   DEALLOCATE(dumxsky2,dumysky2)
   DEALLOCATE(coprat1,coprat2)
   DEALLOCATE(toldspot1,toldspot2)
   DEALLOCATE(xtop2horiz,ytop2horiz)
!
!   Arrays associated with the disk
!
   DEALLOCATE(dtemp,dx,dy,dz,drad)
   DEALLOCATE(dinty,einty,savedinty,saveeinty)
   DEALLOCATE(tedge,xedge,yedge,zedge)
   DEALLOCATE(dxhoriz,dyhoriz,dtopx,dtopy)
   DEALLOCATE(diskproj,edgeproj)
   DEALLOCATE(dvisib,evisib)
   DEALLOCATE(xskydisk,yskydisk,zskydisk)
   DEALLOCATE(xskyedge,yskyedge)
!
   DEALLOCATE(xecx,xecy)
!
   CLOSE(2)
   RETURN
!
END SUBROUTINE lightcurve
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE acchor(q,psi0,omega,xvis,yvis,zvis,rvis,phivis,  &
   xhid,yhid,zhid,rhid,phihid,ax,ay,az,xacc,yacc,zacc,bdist,  &
   tidephi,itide,ecc,thetamis,phimis)
!
!  May 5, 2000
!
!  This subroutine will take two points along a latitude row, where the
!  first is visible and the second is hidden, and iterate to find a
!  more accurate horizon.  We can find coz, which is kept constant.  We
!  bisect on phi, and check the visibility at each iteration.  The
!  x,y,z coordinates of the horizon are returned as xacc,yacc,zacc.
!  
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN OUT)            :: psi0
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(OUT)               :: xvis
   REAL(KIND=dp), INTENT(OUT)               :: yvis
   REAL(KIND=dp), INTENT(IN OUT)            :: zvis
   REAL(KIND=dp), INTENT(IN OUT)            :: rvis
   REAL(KIND=dp), INTENT(OUT)               :: phivis
   REAL(KIND=dp), INTENT(OUT)               :: xhid
   REAL(KIND=dp), INTENT(OUT)               :: yhid
   REAL(KIND=dp), INTENT(IN OUT)            :: zhid
   REAL(KIND=dp), INTENT(IN OUT)            :: rhid
   REAL(KIND=dp), INTENT(OUT)               :: phihid
   REAL(KIND=dp), INTENT(IN)                :: ax
   REAL(KIND=dp), INTENT(IN)                :: ay
   REAL(KIND=dp), INTENT(IN)                :: az
   REAL(KIND=dp), INTENT(OUT)               :: xacc
   REAL(KIND=dp), INTENT(OUT)               :: yacc
   REAL(KIND=dp), INTENT(OUT)               :: zacc
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   INTEGER, INTENT(IN)                      :: itide
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
!
   REAL(KIND=dp) :: gravity,gx,gy,gz,z,psi,x,y,proj
   REAL(KIND=dp) :: cozvis,cozhid,coz,theta,psiy,psiz,psix
   REAL(KIND=dp) :: sithet,diffphi,phinew,rnew,cox,coy
!
   INTEGER :: i
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   DO  i=1,25
      cozvis=zvis/rvis
      cozhid=zhid/rhid
      coz=0.5_dp*(cozvis+cozhid)
      theta=ACOS(coz)
      sithet=SIN(theta)
!
!   Find a new phi, which is the average of the two phi values.
!   Then given theta and phi, compute cox,coy,coz, etc.
!
      diffphi=ABS(phivis-phihid)
      IF(diffphi > 1.0_dp)THEN
         IF(phivis > 2.0_dp)phivis=phivis-twopie
         IF(phihid > 2.0_dp)phihid=phihid-twopie
      END IF
      phinew=0.5_dp*(phivis+phihid)
      IF(phinew < 0.0_dp)phinew=phinew+twopie
      rnew=0.5_dp*(rvis+rhid)
      cox=COS(phinew)*sithet
      coy=SIN(phinew)*sithet
      CALL rad(q,omega,cox,coy,coz,psi0,rnew,x,y,z,1,bdist,  &
         tidephi,itide,ecc,thetamis,phimis)
      CALL fastpot(q,omega,x,y,z,psi,psix,psiy,psiz,bdist,cox,  &
         coy,tidephi,itide,ecc,thetamis,phimis)
      gravity=SQRT(psix**2+psiy**2+psiz**2)
      gx=-psix/gravity
      gy=-psiy/gravity
      gz=-psiz/gravity
      proj=ax*gx+ay*gy+az*gz
      IF(proj > 0.0_dp)THEN
         xvis=x
         yvis=y
         zvis=z
         rvis=rnew
         phivis=phinew
      ELSE
         xhid=x
         yhid=y
         zhid=z
         rhid=rnew
         phihid=phinew
      END IF
   END DO
!
   xacc=xvis
   yacc=yvis
   zacc=zvis
!
   RETURN
!
END SUBROUTINE acchor
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE accphi(q,psi0,omega,phase,fincr,istar,xvis,yvis,  &
   zvis,rvis,phivis,xhid,yhid,zhid,rhid,phihid,nhoriz,xhoriz,  &
   yhoriz,phiacc,bdist,tidephi,itide,ecc,thetamis,phimis,  &
   tertincl,tertbdist,tertphase,tertq,axisscale,isw30,isw7,  &
   tertomega)
!
!  May 5, 2000
!
!  This subroutine will take two points along a latitude row, where the
!  first is visible and the second is hidden, and iterate to find the
!  phi value of the horizon crossing.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: psi0
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: fincr
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(OUT)               :: xvis
   REAL(KIND=dp), INTENT(OUT)               :: yvis
   REAL(KIND=dp), INTENT(IN OUT)            :: zvis
   REAL(KIND=dp), INTENT(IN OUT)            :: rvis
   REAL(KIND=dp), INTENT(OUT)               :: phivis
   REAL(KIND=dp), INTENT(OUT)               :: xhid
   REAL(KIND=dp), INTENT(OUT)               :: yhid
   REAL(KIND=dp), INTENT(IN OUT)            :: zhid
   REAL(KIND=dp), INTENT(IN OUT)            :: rhid
   REAL(KIND=dp), INTENT(OUT)               :: phihid
   INTEGER, INTENT(IN)                      :: nhoriz
   REAL(KIND=dp), INTENT(IN)                :: xhoriz(nhoriz)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz(nhoriz)
   REAL(KIND=dp), INTENT(OUT)               :: phiacc
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   INTEGER, INTENT(IN)                      :: itide
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp)  :: xxoff,yyoff,x,y,z,xtran,coz,ytran,ypnew,theta
   REAL(KIND=dp)  :: xxoff1,yyoff1,tomrad,cozvis,cozhid,tertxcen,overq
   REAL(KIND=dp)  :: tertycen,sithet,diffphi,phinew,rnew,cox,coy,xpnew
!
   INTEGER :: i,iyes,icut
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!    November 18, 2012
!
!    If there is a third body, offset all x and y sky coordinates
!
   xxoff=0.0_dp
   yyoff=0.0_dp
   IF((isw30 >= 3).AND.(isw7 >= 2))THEN
      xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      tomrad=tertomega*degtorad
      xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
      yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
   END IF
   overq=q
   IF(istar == 2)overq=1.0_dp/q
   cozvis=zvis/rvis
   cozhid=zhid/rhid
   coz=0.5_dp*(cozvis+cozhid)
   theta=ACOS(coz)
   sithet=SIN(theta)
!
   DO  i=1,20
!
!   Find a new phi, which is the average of the two phi values.
!   Then given theta and phi, compute cox,coy,coz, etc.
!
      diffphi=ABS(phivis-phihid)
      IF(diffphi > 2.0_dp)THEN
         IF(phivis > 2.0_dp)phivis=phivis-twopie
         IF(phihid > 2.0_dp)phihid=phihid-twopie
      END IF
      phinew=0.5_dp*(phivis+phihid)
      IF(phinew < 0.0_dp)phinew=phinew+twopie
      rnew=0.5_dp*(rvis+rhid)
      cox=COS(phinew)*sithet
      coy=SIN(phinew)*sithet
!
      CALL rad(overq,omega,cox,coy,coz,psi0,rnew,x,y,z,1,bdist,  &
         tidephi,itide,ecc,thetamis,phimis)
!
      xpnew=xtran(x,y,phase,q,istar,bdist)
      ypnew=ytran(x,y,z,phase,fincr,q,istar,bdist)
      xpnew=xpnew+xxoff
      ypnew=ypnew+yyoff
      iyes=-100
      CALL insidecircle(nhoriz,xhoriz,yhoriz,xpnew,ypnew,iyes,icut)
!
      IF(iyes == 100)THEN
         xhid=x
         yhid=y
         zhid=z
         rhid=rnew
         phihid=phinew
      ELSE
         xvis=x
         yvis=y
         zvis=z
         rvis=rnew
         phivis=phinew
      END IF
   END DO
!
   phiacc=phivis
!
   RETURN
!
END SUBROUTINE accphi
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE adddiskspot(nthetamax,nrmax,ntheta,nradius,rinner,  &
   router,reff2,rl2,dtemp,tedge,redge,ivrt,reper,rsper,spotparm,  &
   ave1,ave2,ioutflag)
!
!   May 8, 2001
!
!   This routine will modify the temperatures on the disk that are
!   within spots.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nthetamax
   INTEGER, INTENT(IN)                      :: nrmax
   INTEGER, INTENT(IN)                      :: ntheta
   INTEGER, INTENT(IN)                      :: nradius
   REAL(KIND=dp), INTENT(IN)                :: rinner
   REAL(KIND=dp), INTENT(IN)                :: router
   REAL(KIND=dp), INTENT(IN)                :: reff2
   REAL(KIND=dp), INTENT(IN)                :: rl2
   REAL(KIND=dp), INTENT(OUT)               :: dtemp(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: tedge(nthetamax*11)
   REAL(KIND=dp), INTENT(OUT)               :: redge
   INTEGER, INTENT(IN OUT)                  :: ivrt
   REAL(KIND=dp), INTENT(OUT)               :: reper
   REAL(KIND=dp), INTENT(OUT)               :: rsper
   REAL(KIND=dp), INTENT(IN)                :: spotparm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: ave1
   REAL(KIND=dp), INTENT(OUT)               :: ave2
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp)     :: fac1,fac2,summ1,summ2,theta,r,rsmall,az1,cut1,width1,az2
   REAL(KIND=dp)     :: cut2,width2,steptheta,zetain,zetaout,stepzeta,zeta
   REAL(KIND=dp)     :: ratt,thetar,angdiff1,angdiff2
!
   INTEGER :: icount1,icount2,iidx,iz,ir,ithet
!
!   Start with the disk face.  It is assumed that the lower
!   face is exactly the same as the upper face, but with a
!   negative z-value.  In practice,
!   however, we never see the bottom face.
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   IF(ivrt == 0)THEN
      redge=router*reff2
      rsmall=rinner*rl2
      reper=redge
      rsper=rsmall
   ELSE
      redge=reper
      rsmall=rsper
   END IF
!
   fac1=spotparm(1,1)
   az1=degtorad*spotparm(1,2)
   cut1=spotparm(1,3)
   width1=degtorad*spotparm(1,4)
   fac2=spotparm(2,1)
   az2=degtorad*spotparm(2,2)
   cut2=spotparm(2,3)
   width2=degtorad*spotparm(2,4)
   steptheta=360.0_dp/REAL(ntheta,KIND=dp)
!
!   Transform r into zeta.
!
   zetain=2.0_dp*SQRT(rsmall)
   zetaout=2.0_dp*SQRT(redge)
   stepzeta=(zetaout-zetain)/REAL(nradius-1,KIND=dp)
   theta=0.0_dp
   zeta=zetain
   icount1=0
   icount2=0
   summ1=0.0_dp
   summ2=0.0_dp
!
   IF((cut1 >= 1.0_dp).AND.(cut2 >= 1.0_dp))GO TO 30
   IF((cut1 >= 1.0_dp).AND.(fac2 <= 0.0_dp))GO TO 30
   IF((cut2 >= 1.0_dp).AND.(fac1 <= 0.0_dp))GO TO 30
!
   DO  ir=1,nradius
      zeta=zetain+REAL(ir-1,KIND=dp)*stepzeta
      r=0.25_dp*zeta*zeta
      ratt=r/redge
!
!   theta goes from zero to 360-step
!
      DO  ithet=1,ntheta
         theta=REAL(ithet,KIND=dp)*steptheta-0.5_dp*steptheta
         thetar=theta*degtorad
         angdiff1=ACOS(COS(thetar-az1))
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(ir-1)*ntheta+ithet
!
         IF((angdiff1 <= width1).AND.(fac1 > 0.0_dp).AND.(ratt >= cut1))THEN
            dtemp(iidx)=dtemp(iidx)*fac1
            icount1=icount1+1
            summ1=summ1+dtemp(iidx)
         END IF
         angdiff2=ACOS(COS(thetar-az2))
         IF((angdiff2 <= width2).AND.(fac2 > 0.0_dp).AND.(ratt >= cut2))THEN
            dtemp(iidx)=dtemp(iidx)*fac2
            icount2=icount2+1
            summ2=summ2+dtemp(iidx)
         END IF
      END DO
   END DO
!
30 DO  iz=-5,5
!
!   theta goes from zero to 360-step
!
      DO  ithet=1,ntheta
         theta=REAL(ithet,KIND=dp)*steptheta-0.5_dp*steptheta
         thetar=theta*degtorad
         angdiff1=ACOS(COS(thetar-az1))
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(iz+6-1)*ntheta+ithet
!
         IF((angdiff1 <= width1).AND.(fac1 > 0.0_dp))THEN
            tedge(iidx)=tedge(iidx)*fac1
            icount1=icount1+1
            summ1=summ1+tedge(iidx)
         END IF
         angdiff2=ACOS(COS(thetar-az2))
         IF((angdiff2 <= width2).AND.(fac2 > 0.0_dp))THEN
            tedge(iidx)=tedge(iidx)*fac2
            icount2=icount2+1
            summ2=summ2+tedge(iidx)
         END IF
      END DO
   END DO
!
   ave1=0.0_dp
   ave2=0.0_dp
   IF(icount1 > 0)ave1=summ1/REAL(icount1,KIND=dp)
   IF(icount2 > 0)ave2=summ2/REAL(icount2,KIND=dp)
!
   IF(ioutflag == 1)THEN
      IF(ave1 > 0.0_dp)WRITE(2,60)ave1,icount1
      IF(ave2 > 0.0_dp)WRITE(2,70)ave2,icount2
   END IF
!
60 FORMAT(/'disk spot 1:    average temperature ',f9.3,',  numbe'  &
      ,'r of grid points = ',i4)
70 FORMAT(/'disk spot 2:    average temperature ',f9.3,',  numbe'  &
      ,'r of grid points = ',i4)
!
   RETURN
!
END SUBROUTINE adddiskspot
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE addmovespot(ialphmax,ibetmax,nalph,ibetlim,  &
   tmatrix,spotparm,ave1,ave2,omega,phiar,mmdx,period,t0,ttime)
!
!   This routine will assign the temperatures of the grid points
!   of the stars that are covered by spots.  The underlying temperatures
!   are simply scaled by the temperature spot factor.
!
!   UPDATE March 26, 2002
!
!   Get rid of Nbet from the argument list of addstarspot.  Its value
!   is contained within ibetlim.
!
!    UPDATE June 17, 2002
!
!    Add these dummy assignments for phase and omega to supress
!    compiler warnings about unused variables.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalph
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(OUT)               :: tmatrix(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: spotparm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: ave1
   REAL(KIND=dp), INTENT(OUT)               :: ave2
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: phiar(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: t0
   REAL(KIND=dp), INTENT(IN)                :: ttime
!
   REAL(KIND=dp)   :: fac1,fac2,rlat1,rlat2,sepang2,rad1,poff,rlong1,rlong2
   REAL(KIND=dp)   :: rad2,dtheta,summ1,summ2,theta,rlat,rlong,sepang1
!
   INTEGER :: icount1,icount2,ialf,ibet,iidx
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   poff=(ttime-t0)/period*(omega-1.0_dp)*twopie
   fac1=spotparm(1,1)
   fac2=spotparm(2,1)
   rlat1=degtorad*spotparm(1,2)-halfpie
   rlat2=degtorad*spotparm(2,2)-halfpie
   rlong1=MOD(degtorad*spotparm(1,3)+poff,twopie)
   rlong2=MOD(degtorad*spotparm(2,3)+poff,twopie)
   IF(rlong1 > pie)rlong1=rlong1-twopie
   IF(rlong2 > pie)rlong2=rlong2-twopie
   rad1=degtorad*spotparm(1,4)
   rad2=degtorad*spotparm(2,4)
!
   IF((fac1 < 0.0_dp).AND.(fac2 < 0.0_dp))RETURN
!
   dtheta=pie/REAL(nalph,KIND=dp)
   summ1=0.0_dp
   summ2=0.0_dp
   icount1=0
   icount2=0
   DO  ialf=1,nalph
      theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
      rlat=theta-halfpie
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=(ialf-1)*ibetlim(ialf)+ibet
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         rlong=phiar(iidx)
         IF(rlong > pie)rlong=rlong-twopie
         sepang1=SIN(rlat)*SIN(rlat1)+COS(rlat)*COS(rlat1)*COS(rlong-rlong1)
         sepang1=ABS(ACOS(sepang1))
         IF((sepang1 <= rad1).AND.(fac1 > 0.0_dp))THEN
            icount1=icount1+1
            tmatrix(iidx)=tmatrix(iidx)*fac1
            summ1=summ1+tmatrix(iidx)
         END IF
!
         sepang2=SIN(rlat)*SIN(rlat2)+COS(rlat)*COS(rlat2)*COS(rlong-rlong2)
         sepang2=ABS(ACOS(sepang2))
         IF((sepang2 <= rad2).AND.(fac2 > 0.0_dp))THEN
            icount2=icount2+1
            tmatrix(iidx)=tmatrix(iidx)*fac2
            summ2=summ2+tmatrix(iidx)
         END IF

      END DO
   END DO
!
   ave1=0.0_dp
   ave2=0.0_dp
   IF(icount1 > 0)ave1=summ1/REAL(icount1,KIND=dp)
   IF(icount2 > 0)ave2=summ2/REAL(icount2,KIND=dp)
!
   RETURN
!
END SUBROUTINE addmovespot
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE addpad(nphase,xmod,ymod,xpad,ypad)
!
!   This routine will return a padded pair of arrays with phases going
!   from -1 to 2.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nphase
   REAL(KIND=dp), INTENT(IN)                :: xmod(nphase)
   REAL(KIND=dp), INTENT(IN)                :: ymod(nphase)
   REAL(KIND=dp), INTENT(OUT)               :: xpad(nphase*3)
   REAL(KIND=dp), INTENT(OUT)               :: ypad(nphase*3)
!
   INTEGER :: icount,i
!
   icount=0
   DO  i=1,nphase
      icount=icount+1
      xpad(icount)=xmod(i)-1.0_dp
      ypad(icount)=ymod(i)
   END DO
!
   DO  i=1,nphase
      icount=icount+1
      xpad(icount)=xmod(i)
      ypad(icount)=ymod(i)
   END DO
!
   DO  i=1,nphase
      icount=icount+1
      xpad(icount)=xmod(i)+1.0_dp
      ypad(icount)=ymod(i)
   END DO
!
   RETURN
!
END SUBROUTINE addpad
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE addphipad(nphase,xmod,ymod,xpad,ypad)
!
!   This routine will return a padded pair of arrays with phases going
!   from -1 to 2.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nphase
   REAL(KIND=dp), INTENT(IN)                :: xmod(2000)
   REAL(KIND=dp), INTENT(IN)                :: ymod(2000)
   REAL(KIND=dp), INTENT(OUT)               :: xpad(9999)
   REAL(KIND=dp), INTENT(OUT)               :: ypad(9999)
!
   INTEGER :: icount,i
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   icount=0
   DO  i=1,nphase
      icount=icount+1
      xpad(icount)=xmod(i)-twopie
      ypad(icount)=ymod(i)
   END DO
!
   DO  i=1,nphase
      icount=icount+1
      xpad(icount)=xmod(i)
      ypad(icount)=ymod(i)
   END DO
!
   DO  i=1,nphase
      icount=icount+1
      xpad(icount)=xmod(i)+twopie
      ypad(icount)=ymod(i)
   END DO
!
   RETURN
!
END SUBROUTINE addphipad
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE addstarspot(istar,ialphmax,ibetmax,nalph,ibetlim,  &
   tmatrix,spotparm,ave1,ave2,phiar,mmdx,ispotprof,ioutflag)
!
!   This routine will assign the temperatures of the grid points
!   of the stars that are covered by spots.  The underlying temperatures
!   are simply scaled by the temperature spot factor.
!
!   UPDATE March 26, 2002
!
!   Get rid of Nbet from the argument list of addstarspot.  Its value
!   is contained within ibetlim.
!
!    UPDATE June 17, 2002
!
!    Add these dummy assignments for phase and omega to supress
!    compiler warnings about unused variables.
!
!    UPDATE October 13, 2008
!
!    Add ispotprof flag:
!
!    ispotprof=0    temperature factor same as before
!    ispotprof=1    linear profile for the temperature factor
!    ispotprof=2    Gaussian profile for temperature factor
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalph
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(OUT)               :: tmatrix(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: spotparm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: ave1
   REAL(KIND=dp), INTENT(OUT)               :: ave2
   REAL(KIND=dp), INTENT(IN)                :: phiar(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   INTEGER, INTENT(IN)                      :: ispotprof
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp)   :: fac1,fac2,rlat1,rlat2,sepang2,slope,fff,rad1,rlong1,rlong2
   REAL(KIND=dp)   :: rad2,dtheta,summ1,summ2,theta,rlat,rlong,sepang1
!
   INTEGER :: icount1,icount2,icount3,ialf,ibet,iidx
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   fac1=spotparm(1,1)
   fac2=spotparm(2,1)
   rlat1=degtorad*spotparm(1,2)-halfpie
   rlat2=degtorad*spotparm(2,2)-halfpie
   rlong1=degtorad*spotparm(1,3)
   rlong2=degtorad*spotparm(2,3)
   IF(rlong1 > pie)rlong1=rlong1-twopie
   IF(rlong2 > pie)rlong2=rlong2-twopie
   rad1=degtorad*spotparm(1,4)
   rad2=degtorad*spotparm(2,4)
!
   IF((fac1 < 0.0_dp).AND.(fac2 < 0.0_dp))RETURN
!
   dtheta=pie/REAL(nalph,KIND=dp)
   summ1=0.0_dp
   summ2=0.0_dp
   icount1=0
   icount2=0
   icount3=0
   DO  ialf=1,nalph
      theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
      rlat=theta-halfpie
      DO  ibet=1,ibetlim(ialf)
!
         icount3=icount3+1
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=(ialf-1)*ibetlim(ialf)+ibet
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         rlong=phiar(iidx)
         IF(rlong > pie)rlong=rlong-twopie
         sepang1=SIN(rlat)*SIN(rlat1)+COS(rlat)*COS(rlat1)*COS(rlong-rlong1)
         sepang1=ABS(ACOS(sepang1))
         IF((sepang1 <= rad1).AND.(fac1 > 0.0_dp))THEN
            IF(ispotprof == 0)THEN
               icount1=icount1+1
               tmatrix(iidx)=tmatrix(iidx)*fac1
               summ1=summ1+tmatrix(iidx)
            END IF
            IF(ispotprof == 1)THEN
               IF(rad1 <= 0.0_dp)THEN
                  CYCLE
               ELSE
                  icount1=icount1+1
                  slope=(1.0_dp-fac1)/rad1
                  fff=slope*(sepang1-rad1)+1.0_dp
                  tmatrix(iidx)=tmatrix(iidx)*fff
                  summ1=summ1+tmatrix(iidx)
               END IF
            END IF
            IF(ispotprof == 2)THEN
               IF(rad1 <= 0.0_dp)THEN
                  CYCLE
               ELSE
                  icount1=icount1+1
                  fff=(fac1-1.0_dp)*EXP(-4.5_dp*(sepang1/rad1)**2)+1.0_dp
                  tmatrix(iidx)=tmatrix(iidx)*fff
                  summ1=summ1+tmatrix(iidx)
               END IF
            END IF
         END IF
!
         sepang2=SIN(rlat)*SIN(rlat2)+COS(rlat)*COS(rlat2)*COS(rlong-rlong2)
         sepang2=ABS(ACOS(sepang2))
         IF((sepang2 <= rad2).AND.(fac2 > 0.0_dp))THEN
            IF(ispotprof == 0)THEN
               icount2=icount2+1
               tmatrix(iidx)=tmatrix(iidx)*fac2
               summ2=summ2+tmatrix(iidx)
            END IF
            IF(ispotprof == 1)THEN
               IF(rad2 <= 0.0_dp)THEN
                  CYCLE
               ELSE
                  icount2=icount2+1
                  slope=(sepang2-fac2)/rad2
                  fff=slope*(1.0_dp-rad2)+1.0_dp
                  tmatrix(iidx)=tmatrix(iidx)*fff
                  summ2=summ2+tmatrix(iidx)
               END IF
            END IF
            IF(ispotprof == 2)THEN
               IF(rad2 <= 0.0_dp)THEN
                  CYCLE
               ELSE
                  icount2=icount2+1
                  fff=(fac2-1.0_dp)*EXP(-4.5_dp*(sepang2/rad2)**2)+1.0_dp
                  tmatrix(iidx)=tmatrix(iidx)*fff
                  summ2=summ2+tmatrix(iidx)
               END IF
            END IF
         END IF
      END DO
   END DO
!
   ave1=0.0_dp
   ave2=0.0_dp
   IF(icount1 > 0)ave1=summ1/REAL(icount1,KIND=dp)
   IF(icount2 > 0)ave2=summ2/REAL(icount2,KIND=dp)
!
   IF(ioutflag == 1)THEN
      IF(ave1 > 0.0_dp)WRITE(2,30)istar,ave1,icount1,icount3
      IF(ave2 > 0.0_dp)WRITE(2,40)istar,ave2,icount2,icount3
   END IF
!
30 FORMAT(/'star ',i1,', spot 1:    average temperature ',f9.3,''  &
      ,',',/19X,'number of grid points = ',i6,' out of ',i6)
40 FORMAT(/'star ',i1,', spot 2:    average temperature ',f9.3,''  &
      ,',',/19X,'number of grid points = ',i6,' out of ',i6)
!
   RETURN
!
END SUBROUTINE addstarspot
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE analdistorttime(nmaxphase,nphase,xmod,rv,gamma,  &
   pconj)
!
!   February 5, 2001
!
!   This routine will apply a phase shift to a light or
!   velocity curve
!
   USE accur
   USE constants
!
   IMPLICIT NONE
!
   Integer, INTENT(IN OUT)                  :: nmaxphase
   INTEGER, INTENT(IN)                      :: nphase
   REAL(KIND=dp), INTENT(OUT)               :: xmod(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: rv(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: gamma
   REAL(KIND=dp), INTENT(IN OUT)            :: pconj
!
   INTEGER :: i
!
   REAL(KIND=dp)  :: ttt
!
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   DO  i=1,nphase
      IF(xmod(i) < 0.5_dp)THEN
         ttt=(rv(i)-gamma)/speedlightkm*(xmod(i)-pconj)
         xmod(i)=xmod(i)+ttt
      ELSE
         ttt=(rv(i)-gamma)/speedlightkm*(xmod(i)-(pconj+1.0_dp))
         xmod(i)=xmod(i)+ttt
      END IF
   END DO
!
   RETURN
!
END SUBROUTINE analdistorttime
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE analyticscale(q,finc,period,primmass,primk,ecc,  &
   frac1,frac2,primrad,ratrad,reff1,reff2,separ,vrot1,vrot2,  &
   gpole1,gpole2,rm1,rm2,masssum,massdiff,radsum,raddiff,  &
   secmass,secrad,fracsum,fracdiff,ioutflag)
!
!   December 9, 2009
!
!   This routine will return the radii and ratio of radii, which will
!   be needed for the fastanalytic routine.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN OUT)            :: q
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: primmass
   REAL(KIND=dp), INTENT(IN)                :: primk
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(OUT)               :: frac1
   REAL(KIND=dp), INTENT(OUT)               :: frac2
   REAL(KIND=dp), INTENT(IN)                :: primrad
   REAL(KIND=dp), INTENT(OUT)               :: ratrad
   REAL(KIND=dp), INTENT(OUT)               :: reff1
   REAL(KIND=dp), INTENT(OUT)               :: reff2
   REAL(KIND=dp), INTENT(OUT)               :: separ
   REAL(KIND=dp), INTENT(OUT)               :: vrot1
   REAL(KIND=dp), INTENT(OUT)               :: vrot2
   REAL(KIND=dp), INTENT(OUT)               :: gpole1
   REAL(KIND=dp), INTENT(OUT)               :: gpole2
   REAL(KIND=dp), INTENT(OUT)               :: rm1
   REAL(KIND=dp), INTENT(OUT)               :: rm2
   REAL(KIND=dp), INTENT(IN)                :: masssum
   REAL(KIND=dp), INTENT(IN OUT)            :: massdiff
   REAL(KIND=dp), INTENT(IN)                :: radsum
   REAL(KIND=dp), INTENT(IN OUT)            :: raddiff
   REAL(KIND=dp), INTENT(IN)                :: secmass
   REAL(KIND=dp), INTENT(IN)                :: secrad
   REAL(KIND=dp), INTENT(IN)                :: fracsum
   REAL(KIND=dp), INTENT(IN OUT)            :: fracdiff
   INTEGER, INTENT(IN OUT)                  :: ioutflag
!
   REAL(KIND=dp)   :: p,fincr,fpsq,qlow,aa,qtemp
   REAL(KIND=dp)   :: vfcn,cc,total_mass,sifinc,smet,r1,r2,fact
   REAL(KIND=dp)   :: efact,vkcgs,dqhi,dqlo,qhigh,qmid
!
   INTEGER :: kk,isetrad,isetmass,ilength1
   INTEGER :: ilength2,ilength3,ilength4,ilength5
!
   CHARACTER (LEN=40) :: instring1,instring2,instring3,instring4
   CHARACTER (LEN=40) :: instring5
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
   fpsq=4.0_dp*pie*pie
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   qtemp=q
   p=period*secinday
   fincr=finc*degtorad
!
   isetmass=0
!
!   primmass > 0 and secmass > 0
!
   IF((primmass > 0.0_dp).AND.(secmass > 0.0_dp))THEN
      q=secmass/primmass
      separ=(gmsun*p*p*primmass*(1.0_dp+q)/(4.0_dp*pie*pie))**(1.0_dp/3.0_dp)
      separ=separ/solarrad
      rm1=primmass
      rm2=secmass
      CALL pnoequalstring('primmmass fixed at',6,primmass, instring1,ilength1)
      CALL pnoequalstring('secmmass fixed at',6,secmass, instring2,ilength2)
      CALL pnoequalstring('The mass ratio set to',6,q,instring3, ilength3)
      CALL pnoequalstring('the separation set to',6,separ, instring4,ilength4)
      IF(ioutflag == 1)WRITE(2,50)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring4)
      isetmass=99
      GO TO 30
   END IF
!
!  masssum > 0
!
   IF(masssum > 0.0_dp)THEN
      IF(q <= 0.0_dp)THEN
         rm1=0.5_dp*(masssum+massdiff)
         rm2=masssum-rm1
         qtemp=rm2/rm1
         separ=(gmsun*p*p*rm1*(1.0_dp+qtemp)/(4.0_dp*pie*pie))**(1.0_dp/3.0_dp)
         separ=separ/solarrad
         CALL pnoequalstring('M_1 + M_2 fixed at',6,masssum,instring1,ilength1)
         CALL pnoequalstring('M_1 - M_2 fixed at',6,massdiff,instring2,ilength2)
         CALL pnoequalstring('M_1 set to',6,rm1,instring3,ilength3)
         CALL pnoequalstring('M_2 set to',6,rm2,instring4,ilength4)
         CALL pnoequalstring('The separation set to',6,separ,instring5,ilength5)
         IF(ioutflag == 1)WRITE(2,60)TRIM(instring1),TRIM(instring2), &
            TRIM(instring3),TRIM(instring4),TRIM(instring5)
      ELSE
         rm1=masssum/(1.0_dp+q)
         rm2=masssum-rm1
         qtemp=rm2/rm1
         separ=(gmsun*p*p*rm1*(1.0_dp+qtemp)/(4.0_dp*pie*pie))**(1.0_dp/3.0_dp)
         separ=separ/solarrad
         CALL pnoequalstring('M_1 + M_2 fixed at',6,masssum,instring1,ilength1)
         CALL pnoequalstring('Q fixed at',6,q,instring2,ilength2)
         CALL pnoequalstring('M_1 set to',6,rm1,instring3,ilength3)
         CALL pnoequalstring('M_2 set to',6,rm2,instring4,ilength4)
         CALL pnoequalstring('The separation set to',6,separ,instring5,ilength5)
         IF(ioutflag == 1)WRITE(2,70)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4),TRIM(instring5)
      END IF
      isetmass=99
      GO TO 30
   END IF
!
!   primmass > 0 only (secmass=0 and primK=0),
!   set the separation
!
   IF((primmass > 0.0_dp).AND.(primk <= 0.0_dp))THEN
      rm1=primmass
      rm2=q*rm1
      separ=(gmsun*p*p*primmass*(1.0_dp+q)/(4.0_dp*pie*pie))**(1.0_dp/3.0_dp)
      separ=separ/solarrad
      CALL pnoequalstring('M_1 fixed at',6,primmass,instring1, ilength1)
      CALL pnoequalstring('Q fixed at',6,q,instring2,ilength2)
      CALL pnoequalstring('M_2 set to',6,rm2,instring3, ilength3)
      CALL pnoequalstring('the separation set to',6,separ,instring4,ilength4)
      IF(ioutflag == 1)WRITE(2,80)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring4)
      isetmass=99
      GO TO 30
   END IF
!
!   secmass> 0, primmass=0, and Q > 0
!
   IF((secmass > 0.0_dp).AND.(primmass <= 0.0_dp).AND.(q > 0.0_dp) )THEN
      rm1=secmass/q
      rm2=secmass
      qtemp=rm2/rm1
      separ=(gmsun*p*p*rm1*(1.0_dp+qtemp)/(4.0_dp*pie*pie))**(1.0_dp/ 3.0_dp)
      separ=separ/solarrad
      CALL pnoequalstring('M_2 fixed at',6,secmass,instring1,ilength1)
      CALL pnoequalstring('Q fixed at',6,q,instring2,ilength2)
      CALL pnoequalstring('M_1 set to',6,rm1,instring3,ilength3)
      CALL pnoequalstring('the separation set to',6,separ,instring4,ilength4)
      IF(ioutflag == 1)WRITE(2,80)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring4)
      isetmass=99
      GO TO 30
   END IF
!
!   primK > 0 only, set the separation
!
   IF((primmass <= 0.0_dp).AND.(primk > 0.0_dp))THEN
      efact=SQRT(1.0_dp-ecc*ecc)
      vkcgs=primk*100000.0_dp*efact
      separ=vkcgs*p*(1.0_dp+q)/(twopie*SIN(fincr)*q)/solarrad/100.0_dp
      smet=separ*solarrad
      total_mass=smet*smet*smet*fpsq/(period*secinday)**2/gmsun
      rm1=total_mass/(1.0_dp+qtemp)
      rm2=qtemp*rm1
      CALL pnoequalstring('K_1 fixed at',6,primk,instring1,ilength1)
      CALL pnoequalstring('The separation set to',6,separ,instring2,ilength2)
      IF(ioutflag == 1)WRITE(2,90)TRIM(instring1),TRIM(instring2)
      isetmass=99
      GO TO 30
   END IF
!
!   primmass > 0 and primK > 0.  Solve for Q and separ
!
   IF((primmass > 0.0_dp).AND.(primk > 0.0_dp))THEN
      efact=SQRT(1.0_dp-ecc*ecc)
      dqhi=7.0_dp
      dqlo=-7.0_dp
      DO  kk=1,35
         qhigh=10.0_dp**dqhi
         qlow=10.0_dp**dqlo
         qmid=10.0_dp**((dqhi+dqlo)*0.5_dp)
         aa=vfcn(qlow,period,finc,primmass,primk,ecc)
         cc=vfcn(qmid,period,finc,primmass,primk,ecc)
         IF(aa*cc < 0.0_dp)THEN
            dqhi=(dqhi+dqlo)*0.5_dp
         ELSE
            dqlo=(dqhi+dqlo)*0.5_dp
         END IF
      END DO
      DO  kk=1,25
         qmid=(qhigh+qlow)*0.5_dp
         aa=vfcn(qlow,period,finc,primmass,primk,ecc)
         cc=vfcn(qmid,period,finc,primmass,primk,ecc)
         IF(aa*cc < 0.0_dp)THEN
            qhigh=(qhigh+qlow)*0.5_dp
         ELSE
            qlow=(qhigh+qlow)*0.5_dp
         END IF
      END DO
      q=qmid
      separ=(gmsun*p*p*primmass*(1.0_dp+q)/(4.0_dp*pie*pie))**(1.0_dp/3.0_dp)
      separ=separ/solarrad
      smet=separ*solarrad
      total_mass=smet*smet*smet*fpsq/(period*secinday)**2/gmsun
      rm1=total_mass/(1.0_dp+q)
      rm2=q*rm1
      CALL pnoequalstring('M_1 fixed at',6,primmass,instring1,ilength1)
      CALL pnoequalstring('K_1 fixed at',4,primk,instring2,ilength2)
      CALL pnoequalstring('Q set to',6,q,instring3,ilength3)
      CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
      IF(ioutflag == 1)WRITE(2,100)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring5)
      isetmass=99
      GO TO 30
   END IF
!
30 IF(isetmass <= 0)THEN
      WRITE(*,*)'masses not set'
      STOP
   END IF
!
!  Now attempt to compute the radii.
!
   isetrad=0
!
!  primrad > 0 and secrad > 0
!
   IF((primrad > 0.0_dp).AND.(secrad > 0.0_dp))THEN
      reff1=primrad/separ
      reff2=secrad/separ
      r1=primrad
      r2=secrad
      ratrad=r1/r2
      CALL pnoequalstring('R_1 fixed at',6,primrad,instring1,ilength1)
      CALL pnoequalstring('R_2 fixed at',4,secrad,instring2,ilength2)
      CALL pnoequalstring('ratrad set to',6,ratrad,instring3,ilength3)
      CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
      IF(ioutflag == 1)WRITE(2,110)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring5)
      isetrad=99
      GO TO 40
   END IF
!
!  check radsum, if non zero then set R1, R2
!
   IF(radsum > 0.0_dp)THEN
      IF(ABS(ratrad) <= EPSILON(ratrad))THEN
         r1=0.5_dp*(radsum+raddiff)
         r2=radsum-r1
         reff1=r1/separ
         reff2=r2/separ
         CALL pnoequalstring('R_1 + R_2 fixed at',6,radsum,instring1,ilength1)
         CALL pnoequalstring('R_1 - R_2 fixed at',6,raddiff,instring2,ilength2)
         CALL pnoequalstring('R_1 set to',6,r1,instring3,ilength3)
         CALL pnoequalstring('R_2 set to',6,r2,instring4,ilength4)
         CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
         IF(ioutflag == 1)WRITE(2,120)TRIM(instring1),TRIM(instring2), &
            TRIM(instring3),TRIM(instring4),TRIM(instring5)
         isetrad=99
         GO TO 40
      ELSE
         r2=radsum/(1.0_dp+ratrad)
         r1=radsum-r2
         reff2=r2/separ
         reff1=r1/separ
         CALL pnoequalstring('R_1 + R_2 fixed at',6,radsum,instring1,ilength1)
         CALL pnoequalstring('ratrad fixed at',6,ratrad,instring2,ilength2)
         CALL pnoequalstring('R_1 set to',6,r1,instring3,ilength3)
         CALL pnoequalstring('R_2 set to',6,r2,instring4,ilength4)
         CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
         IF(ioutflag == 1)WRITE(2,130)TRIM(instring1),TRIM(instring2), &
            TRIM(instring3),TRIM(instring4),TRIM(instring5)
         isetrad=99
         GO TO 40
      END IF
   END IF
!
!  check fracsum, if non zero then set frac1, frac2
!
   IF(fracsum > 0.0_dp)THEN
      IF(ABS(ratrad) <= EPSILON(ratrad))THEN
         frac1=0.5_dp*(fracsum+fracdiff)
         frac2=fracsum-frac1
         reff1=frac1
         reff2=frac2
         r1=reff1*separ
         r2=reff2*separ
         CALL pnoequalstring('R_1/a + R_2/a fixed at',7,fracsum,  &
            instring1,ilength1)
         CALL pnoequalstring('R_1/a - R_2/a fixed at',7,fracdiff,  &
            instring2,ilength2)
         CALL pnoequalstring('R_1 set to',6,r1,instring3,ilength3)
         CALL pnoequalstring('R_2 set to',6,r2,instring4,ilength4)
         CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
         IF(ioutflag == 1)WRITE(2,140)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4),TRIM(instring5)
         isetrad=99
         GO TO 40
      ELSE
         frac2=fracsum/(1.0_dp+ratrad)
         frac1=fracsum-frac2
         reff1=frac1
         reff2=frac2
         r1=reff1*separ
         r2=reff2*separ
         CALL pnoequalstring('R_1/a + R_2/a fixed at',7,fracsum,  &
            instring1,ilength1)
         CALL pnoequalstring('ratrad fixed at',7,ratrad,instring2,ilength2)
         CALL pnoequalstring('R_1 set to',6,r1,instring3,ilength3)
         CALL pnoequalstring('R_2 set to',6,r2,instring4,ilength4)
         CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
         IF(ioutflag == 1)WRITE(2,150)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4),TRIM(instring5)
         isetrad=99
         GO TO 40
      END IF
   END IF
!
!  frac1 > 0 and frac2 > 0
!
   IF((frac1 > 0.0_dp).AND.(frac2 > 0.0_dp))THEN
      reff1=frac1
      reff2=frac2
      r1=reff1*separ
      r2=reff2*separ
      ratrad=frac1/frac2
      CALL pnoequalstring('R_1/a fixed at',7,frac1,instring1,ilength1)
      CALL pnoequalstring('R_2/a fixed at',7,frac2,instring2,ilength2)
      CALL pnoequalstring('R_1 set to',6,r1,instring3,ilength3)
      CALL pnoequalstring('R_2 set to',6,r2,instring4,ilength4)
      CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
      IF(ioutflag == 1)WRITE(2,160)TRIM(instring1),TRIM(instring2), &
         TRIM(instring3),TRIM(instring4),TRIM(instring5)
      isetrad=99
      GO TO 40
   END IF
!
!  frac1 > 0, frac2 = 0, and ratrad > 0
!
   IF((frac1 > 0.0_dp).AND.(frac2 <= 0.0_dp).AND.(ratrad > 0.0_dp) )THEN
      reff1=frac1
      reff2=reff1/ratrad
      r1=reff1*separ
      r2=reff2*separ
      CALL pnoequalstring('R_1/a fixed at',7,frac1,instring1,ilength1)
      CALL pnoequalstring('ratrad fixed at',7,ratrad,instring2,ilength2)
      CALL pnoequalstring('R_1 set to',6,r1,instring3,ilength3)
      CALL pnoequalstring('R_2 set to',6,r2,instring4,ilength4)
      CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
      IF(ioutflag == 1)WRITE(2,170)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring4),TRIM(instring5)
      isetrad=99
      GO TO 40
   END IF
!
!   frac1 > 0 and secrad > 0 and ratrad = 0
!
   IF((frac1 > 0.0_dp).AND.(secrad > 0.0_dp).AND.   &
       (ABS(ratrad) <= EPSILON(ratrad)))THEN
      reff1=frac1
      r2=secrad
      reff2=r2/separ
      r1=reff1*separ
      CALL pnoequalstring('R_1/a fixed at',7,frac1,instring1,ilength1)
      CALL pnoequalstring('secrad fixed at',7,secrad,instring2,ilength2)
      CALL pnoequalstring('R_1 set to',6,r1,instring3,ilength3)
      CALL pnoequalstring('R_2 set to',6,r2,instring4,ilength4)
      CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
      IF(ioutflag == 1)WRITE(2,180)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring4),TRIM(instring5)
      isetrad=99
      GO TO 40
   END IF
!
!   primrad > 0 and frac2 > 0 and ratrad = 0
!
   IF((primrad > 0.0_dp).AND.(frac2 > 0.0_dp).AND.  &
       (ABS(ratrad) <= EPSILON(ratrad)))THEN
      r1=primrad
      reff1=primrad/separ
      reff2=frac2
      r2=reff2*separ
      CALL pnoequalstring('R_1 fixed at',7,primrad,instring1,ilength1)
      CALL pnoequalstring('R_2/a fixed at',7,frac2,instring2,ilength2)
      CALL pnoequalstring('R_1 set to',6,r1,instring3,ilength3)
      CALL pnoequalstring('R_2 set to',6,r2,instring4,ilength4)
      CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
      IF(ioutflag == 1)WRITE(2,190)TRIM(instring1),TRIM(instring2), &
         TRIM(instring3),TRIM(instring4),TRIM(instring5)
      isetrad=99
      GO TO 40
   END IF
!
!   primrad > 0, frac1 = 0, frac2 = 0, and ratrad > 0
!
   IF((primrad > 0.0_dp).AND.(ratrad > 0.0_dp).AND.(frac1 <=  &
      0.0_dp).AND.(frac2 <= 0.0_dp))THEN
      r1=primrad
      reff1=primrad/separ
      r2=r1/ratrad
      reff2=r2/separ
      CALL pnoequalstring('R_1 fixed at',7,primrad,instring1,ilength1)
      CALL pnoequalstring('ratrad fixed at',7,ratrad,instring2,ilength2)
      CALL pnoequalstring('R_1 set to',6,r1,instring3,ilength3)
      CALL pnoequalstring('R_2 set to',6,r2,instring4,ilength4)
      CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
      IF(ioutflag == 1)WRITE(2,200)TRIM(instring1),TRIM(instring2), &
         TRIM(instring3),TRIM(instring4),TRIM(instring5)
      isetrad=99
      GO TO 40
   END IF
!
!   secrad > 0, frac1 = 0, frac2 = 0, and ratrad > 0
!
   IF((secrad > 0.0_dp).AND.(ratrad > 0.0_dp).AND.(frac1 <=   &
      0.0_dp).AND.(frac2 <= 0.0_dp))THEN
      r2=secrad
      reff2=r2/separ
      r1=r2*ratrad
      reff1=r1/separ
      CALL pnoequalstring('R_2 fixed at',7,secrad,instring1,ilength1)
      CALL pnoequalstring('ratrad fixed at',7,ratrad,instring2,ilength2)
      CALL pnoequalstring('R_1 set to',6,r1,instring3,ilength3)
      CALL pnoequalstring('R_2 set to',6,r2,instring4,ilength4)
      CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
      IF(ioutflag == 1)WRITE(2,210)TRIM(instring1),TRIM(instring2), &
         TRIM(instring3),TRIM(instring4),TRIM(instring5)
      isetrad=99
      GO TO 40
   END IF
!
40 IF(isetrad == 0)THEN
      WRITE(*,220)
      STOP
   END IF
!
!   We have to figure out the gravities and the rotational velocities.
!
   sifinc=SIN(fincr)
   gpole1=gsun*rm1/(r1*r1)
   gpole2=gsun*rm2/(r2*r2)
   fact=solarrad*twopie/secinday/1.0E05_dp
   vrot1=fact*r1/period*sifinc*100.0_dp
   vrot2=fact*r2/period*sifinc*100.0_dp
!
50 FORMAT(/'fast analytic mode:',/1X,a,1X,'solar masses and',1X,  &
      a,1X,/' solar masses.',a,1X,'and',/1X,a,1X,'solar radii')
60 FORMAT(/'fast analytic mode:',/1X,a,1X,'solar masses and',1X,  &
      a,1X,'solar masses.',/1X,a,1X,'solar masses and',1X,a,1X,'so'  &
      ,'lar masses.',/1X,a,1X,'solar radii.')
70 FORMAT(/'fast analytic mode:',/1X,a,1X,'solar masses and',1X,  &
      a,'.',1X,/1X,a,1X,'solar masses and',1X,a,1X,'solar masses.',  &
      /1X,a,1X,'solar radii.')
80 FORMAT(/'fast analytic mode:',/1X,a,1X,'solar masses and',1X,  &
      a,'.',/1X,a,1X,'solar masses and',/1X,a,1X,'solar radii.')
90 FORMAT(/'fast analytic mode:',/1X,a,1X,'km/sec.',1X,a,1X,'sol'  &
      ,'ar radii.')
100 FORMAT(/'fast analytic mode:',/1X,a,1X,'solar masses and',1X,  &
      a,1X,'km/sec.',/1X,a,1X,'and',1X,a,1X,'solar radii.')
110 FORMAT(/'fast analytic mode:',/1X,a,1X,'solar radii and',1X,a,  &
      1X,'solar radii.',/1X,a,1X,'and',1X,a,1X,'solar radii.')
120 FORMAT(/'fast analytic mode:',/1X,a,1X,'solar radii and',1X,a,  &
      1X,'solar radii,',/1X,a,1X,'solar radii,',1X,a,1X,'solar rad'  &
      ,'ii and',/1X,a,1X,'solar radii.')
130 FORMAT(/'fast analytic mode:',/1X,a,1X,'solar radii and',1X,a,  &
      ',',/1X,a,1X,'solar radii,',1X,a,1X,'solar radii and',/1X,a,  &
      1X,'solar radii.')
140 FORMAT(/'fast analytic mode:',/1X,a,1X,'and',1X,a,',',/1X,a,  &
      1X,'solar radii,',1X,a,1X,'solar radii and',/1X,a,1X,'solar ' ,'radii.')
150 FORMAT(/'fast analytic mode:',/1X,a,1X,'and',1X,a,',',/1X,a,  &
      1X,'solar radii,',1X,a,1X,'solar radii and',/1X,a,1X,'solar ' ,'radii.')
160 FORMAT(/'fast analytic mode:',/1X,a,1X,'and',1X,a,',',/1X,a,  &
      1X,'solar radii,',1X,a,1X,'solar radii and',/1X,a,1X,'solar ' ,'radii.')
170 FORMAT(/'fast analytic mode:',/1X,a,1X,'and',1X,a,',',/1X,a,  &
      1X,'solar radii,',1X,a,1X,'solar radii and',/1X,a,1X,'solar ' ,'radii.')
180 FORMAT(/'fast analytic mode:',/1X,a,1X,'and',1X,a,',',/1X,a,  &
      1X,'solar radii,',1X,a,1X,'solar radii and',/1X,a,1X,'solar ' ,'radii.')
190 FORMAT(/'fast analytic mode:',/1X,a,1X,'solar radii and',1X,a,  &
      ',',/1X,a,1X,'solar radii,',1X,a,1X,'solar radii and',/1X,a,  &
      1X,'solar radii.')
200 FORMAT(/'fast analytic mode:',/1X,a,1X,'solar radii and',1X,a,  &
      ',',/1X,a,1X,'solar radii,',1X,a,1X,'solar radii and',/1X,a,  &
      1X,'solar radii.')
210 FORMAT(/'fast analytic mode:',/1X,a,1X,'solar radii and',1X,a,  &
      ',',/1X,a,1X,'solar radii,',1X,a,1X,'solar radii and',/1X,a,  &
      1X,'solar radii.')
220 FORMAT('fast analytic mode error:  radii not set')

   RETURN
!
END SUBROUTINE analyticscale
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION apsidalrate(rk1,rk2,rm1,rm2,omega1,omega2,frac1,  &
   frac2,ecc)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: rk1
   REAL(KIND=dp), INTENT(IN)                       :: rk2
   REAL(KIND=dp), INTENT(IN)                       :: rm1
   REAL(KIND=dp), INTENT(IN)                       :: rm2
   REAL(KIND=dp), INTENT(IN)                       :: omega1
   REAL(KIND=dp), INTENT(IN)                       :: omega2
   REAL(KIND=dp), INTENT(IN)                       :: frac1
   REAL(KIND=dp), INTENT(IN)                       :: frac2
   REAL(KIND=dp), INTENT(IN)                       :: ecc
!
   REAL(KIND=dp)  :: q,top,bot,hut,fe,GE,c21,c22,dw,apsidalrate
!
   q=rm2/rm1
   top=1.0_dp+7.5_dp*ecc**2+5.625_dp*ecc**4+0.3125_dp*ecc**6
   bot=(1.0_dp+3.0_dp*ecc**2+0.375_dp*ecc**4)*(1.0_dp-ecc**2)**(1.5_dp)
   hut=top/bot
   fe=1.0_dp/((1.0_dp-ecc*ecc)**2)
   GE=(8.0_dp+12.0_dp*ecc*ecc+ecc**4)*fe**(2.5_dp)/8.0_dp
   c21=frac1**(5.0_dp)*(hut*hut*omega1**2*(1.0_dp+q)*fe+15.0_dp*q*GE)
   c22=frac2**(5.0_dp)*(hut*hut*omega2**2*(1.0_dp+1.0_dp/q)*fe+15.0_dp/q*GE)
   dw=c21*rk1+c22*rk2
!          U=period/dw
   apsidalrate=360.0_dp*dw
!
   RETURN
!
END FUNCTION apsidalrate
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION arcintv3(ilaw,ldx,ldy,n,m,pathi,ctrn,rdn,ctrm,rdm,  &
   tol)
!
!   Will compute the integrals around the various arc paths.  The
!   limb darkening law is given by ilaw:
!
!   ilaw = 1 linear
!   ilaw = 2 log
!   ilaw = 3 sqrt
!   ilaw = 4 quad
!   ilaw = 5 Kipping quad law
!
!   The x and y coefficients of the limb darkening law are
!   given by ldx and ldy.
!
!   Pathi is a vector with 5 elements giving
!   [body1,body2,start,diff,stop]
!
!   The plane-of-the-sky centers are given in CTRN and CTRN
!   (two elements each), and the radii in the same units are
!   given in RDN and RDM
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(IN)                :: ldx
   REAL(KIND=dp), INTENT(IN)                :: ldy
   INTEGER, INTENT(IN)                      :: n
   INTEGER, INTENT(IN)                      :: m
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: ctrn(2)
   REAL(KIND=dp), INTENT(IN)                :: rdn
   REAL(KIND=dp), INTENT(IN)                :: ctrm(2)
   REAL(KIND=dp), INTENT(IN)                :: rdm
   REAL(KIND=dp), INTENT(IN)                :: tol
!
   REAL(KIND=dp) ::  ctrnx,ctrmx,ctrny,ctrmy,rmdn,cmnx,cmny,phi0,phi1,intl
   REAL(KIND=dp) ::  a,b,c,d,e2,intq,intlog,intsq,intg4pt,arcintv3,s,intc
!
   IF(n == m)THEN
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         s=(0.5_dp-ldx/6.0_dp)*pathi(4)
      END IF
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         s=(0.5_dp-(ldx+2.0_dp*ldy)/6.0_dp+ldy/4.0_dp)*pathi(4)
      END IF
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         s=(0.5_dp-(ldx+2.0_dp*ldy)/6.0_dp+ldy/4.0_dp)*pathi(4)
      END IF
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         s=(0.5_dp-ldx/6.0_dp-ldy/10.0_dp)*pathi(4)
      END IF
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         s=(0.5_dp-ldx/6.0_dp+ldy/9.0_dp)*pathi(4)
      END IF
      IF(ilaw == 0)THEN
         s=0.5_dp*pathi(4)
      END IF
      arcintv3=s
      RETURN
   END IF
!
   ctrnx=ctrn(1)
   ctrmx=ctrm(1)
   ctrny=ctrn(2)
   ctrmy=ctrm(2)
   rmdn=rdm/rdn
   cmnx=(ctrmx-ctrnx)/rdn
   cmny=(ctrmy-ctrny)/rdn
   phi0=pathi(3)
   phi1=pathi(5)
!
   IF((ilaw == 1).OR.(ilaw == 11))THEN
!
!   integral of constant term for linear
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of linear term
!
      intl=intg4pt(pathi,tol,rmdn,cmnx,cmny,ilaw)
      s=-intc+ldx*intl
   END IF
!
   IF((ilaw == 5).OR.(ilaw == 15))THEN
!
!   integral of constant term for Kipping quad
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of quadratic term
!
      a=(-cmnx**2*cmny-cmny**3-3.0_dp*cmny*rmdn**2)*rmdn/4.0_dp
      b=(-(cmnx*cmny*rmdn**2)/4.0_dp)
      c=(cmnx**2-cmny**2)*rmdn**2/8.0_dp
      d=(cmnx**3+cmnx*cmny**2+3.0_dp*cmnx*rmdn**2)*rmdn/4.0_dp
      e2=(cmnx**2+cmny**2+rmdn**2/2.0_dp)*rmdn**2.0_dp/2.0_dp
      intq=a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-COS(2.0_dp*  &
         phi0))+c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+d*(SIN(phi1)-  &
         SIN(phi0))+e2*(phi1-phi0)
!
!           IntQ=IntG2pt(Pathi,Tol,RMdN,CMNx,CMNy,ilaw)
!
!   integral of linear term (note the value of 1 at end)
!
      intl=intg4pt(pathi,tol,rmdn,cmnx,cmny,1)
      s=(-intc+(ldx+2.0_dp*ldy)*intl-ldy*intq)
   END IF

   IF((ilaw == 4).OR.(ilaw == 14))THEN
!
!   integral of constant term for quad
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of quadratic term
!
      a=(-cmnx**2*cmny-cmny**3-3.0_dp*cmny*rmdn**2)*rmdn/4.0_dp
      b=(-(cmnx*cmny*rmdn**2)/4.0_dp)
      c=(cmnx**2-cmny**2)*rmdn**2/8.0_dp
      d=(cmnx**3+cmnx*cmny**2+3.0_dp*cmnx*rmdn**2)*rmdn/4.0_dp
      e2=(cmnx**2+cmny**2+rmdn**2/2.0_dp)*rmdn**2.0_dp/2.0_dp
      intq=a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-COS(2.0_dp*  &
         phi0))+c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+d*(SIN(phi1)-  &
         SIN(phi0))+e2*(phi1-phi0)
!
!           IntQ=IntG2pt(Pathi,Tol,RMdN,CMNx,CMNy,ilaw)
!
!   integral of linear term (note the value of 1 at end)
!
      intl=intg4pt(pathi,tol,rmdn,cmnx,cmny,1)
      s=(-intc+(ldx+2.0_dp*ldy)*intl-ldy*intq)
   END IF
!
   IF((ilaw == 2).OR.(ilaw == 12))THEN
!
!   integral of constant term
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of the linear term (note the value of 1 at the end)
!
      intl=intg4pt(pathi,tol,rmdn,cmnx,cmny,1)
!
!   integral of the log term
!
      intlog=intg4pt(pathi,tol,rmdn,cmnx,cmny,ilaw)
      s=-intc+ldx*intl+ldy*intlog
   END IF
!
   IF((ilaw == 3).OR.(ilaw == 13))THEN
!
!   integral of constant term for sqrt law
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of sqrt term
!
      intsq=intg4pt(pathi,tol,rmdn,cmnx,cmny,ilaw)
!
!           IntQ=IntG2pt(Pathi,Tol,RMdN,CMNx,CMNy,ilaw)
!
!   integral of linear term (note the value of 1 at end)
!
      intl=intg4pt(pathi,tol,rmdn,cmnx,cmny,1)
      s=-intc+ldx*intl+ldy*intsq
   END IF
!
!   no limb darkening
!
   IF(ilaw == 0)THEN
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
      s=-intc
   END IF
!
   arcintv3=s
!
   RETURN
!
END FUNCTION arcintv3
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE arcintv3sub(ilaw,iback,dwavex,dwavey,n,m,pathi,  &
   ctrn,rdn,ctrm,rdm,tol,sarray)
!
!   Will compute the integrals around the various arc paths.  The
!   limb darkening law is given by ilaw:
!
!   ilaw = 1 linear
!   ilaw = 2 log
!   ilaw = 3 sqrt
!   ilaw = 4 quad
!   ilaw = 5 Kipping quad law
!   ilaw = 6 triangular log
!   ilaw = 7 triangular sqrt
!
!   This version will loop over 8 bandpasses, using the
!   limb darkening coefficients in dwavex and dwavey.  The
!   sums are returned in Sarray.  The number of the body in
!   back whose flux is being computed is given by iback.
!
!   Pathi is a vector with 5 elements giving
!   [body1,body2,start,diff,stop]
!
!   The plane-of-the-sky centers are given in CTRN and CTRN
!   (two elements each), and the radii in the same units are
!   given in RDN and RDM
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: iback
   REAL(KIND=dp), INTENT(IN)                :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN)                :: dwavey(8,10)
   INTEGER, INTENT(IN OUT)                  :: n
   INTEGER, INTENT(IN OUT)                  :: m
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: ctrn(2)
   REAL(KIND=dp), INTENT(IN)                :: rdn
   REAL(KIND=dp), INTENT(IN)                :: ctrm(2)
   REAL(KIND=dp), INTENT(IN)                :: rdm
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(OUT)               :: sarray(8)
!
   REAL(KIND=dp)  ::  ldx,ldy,s,intc,xsave,ysave,cmnx2,cmny2,cmnx3,cmny3,rmdn2
   REAL(KIND=dp)  ::  ctrnx,ctrmx,ctrny,ctrmy,rmdn,cmnx,cmny,phi0,phi1,intl
   REAL(KIND=dp)  ::  a,b,c,d,e2,intq,intlog,intsq,intgnpt
!
   INTEGER :: ifilt,ilawt
!
   DO ifilt=1,8
      sarray(ifilt)=0.0_dp
   END DO
   IF(n == m)THEN
      DO ifilt=1,8
         ldx=dwavex(ifilt,iback)
         ldy=dwavey(ifilt,iback)
         IF((ilaw == 5).OR.(ilaw == 15))THEN
            xsave=ldx
            ysave=ldy
            ldx=2.0_dp*SQRT(xsave)*ysave
            ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         END IF
!
         IF((ilaw == 6).OR.(ilaw == 16))THEN
            xsave=ldx
            ysave=ldy
            ldx=1.0_dp-SQRT(xsave)*ysave
            ldy=1.0_dp-SQRT(xsave)
         END IF
!
         IF((ilaw == 7).OR.(ilaw == 17))THEN
            xsave=ldx
            ysave=ldy
            ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
            ldy=2.0_dp*SQRT(xsave)*ysave
         END IF
!
         IF((ilaw == 1).OR.(ilaw == 11))THEN
            s=(0.5_dp-ldx/6.0_dp)*pathi(4)
         END IF
         IF((ilaw == 5).OR.(ilaw == 15))THEN
            s=(0.5_dp-(ldx+2.0_dp*ldy)/6.0_dp+ldy/4.0_dp)*pathi(4)
         END IF
         IF((ilaw == 4).OR.(ilaw == 14))THEN
            s=(0.5_dp-(ldx+2.0_dp*ldy)/6.0_dp+ldy/4.0_dp)*pathi(4)
         END IF
         IF((ilaw == 3).OR.(ilaw == 13))THEN
            s=(0.5_dp-ldx/6.0_dp-ldy/10.0_dp)*pathi(4)
         END IF
         IF((ilaw == 7).OR.(ilaw == 17))THEN
            s=(0.5_dp-ldx/6.0_dp-ldy/10.0_dp)*pathi(4)
         END IF
         IF((ilaw == 2).OR.(ilaw == 12))THEN
            s=(0.5_dp-ldx/6.0_dp+ldy/9.0_dp)*pathi(4)
         END IF
         IF((ilaw == 6).OR.(ilaw == 16))THEN
            s=(0.5_dp-ldx/6.0_dp+ldy/9.0_dp)*pathi(4)
         END IF
         IF(ilaw == 0)THEN
            s=0.5_dp*pathi(4)
         END IF
         sarray(ifilt)=s
      END DO
      RETURN
   END IF
!
   ctrnx=ctrn(1)
   ctrmx=ctrm(1)
   ctrny=ctrn(2)
   ctrmy=ctrm(2)
   rmdn=rdm/rdn
   cmnx=(ctrmx-ctrnx)/rdn
   cmny=(ctrmy-ctrny)/rdn
   phi0=pathi(3)
   phi1=pathi(5)
!
!   compute arc terms, which don't depend on limb darkening
!
   IF((ilaw == 1).OR.(ilaw == 11))THEN
!
!   integral of constant term for linear
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of linear term
!
      intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
   END IF
!
   IF((ilaw == 5).OR.(ilaw == 15))THEN
!
!   integral of constant term for Kipping quad
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of quadratic term
!
      cmnx2=cmnx**2
      cmnx3=cmnx**3
      cmny2=cmny**2
      cmny3=cmny**3
      rmdn2=rmdn**2
!
      a=(-cmnx2*cmny-cmny3-3.0_dp*cmny*rmdn2)*rmdn/4.0_dp
      b=(-(cmnx*cmny*rmdn2)/4.0_dp)
      c=(cmnx2-cmny2)*rmdn2/8.0_dp
      d=(cmnx3+cmnx*cmny2+3.0_dp*cmnx*rmdn2)*rmdn/4.0_dp
      e2=(cmnx2+cmny2+rmdn2/2.0_dp)*rmdn2/2.0_dp
!
!            A=(-CMNx**2*CMNy-CMNy**3-3.0d0*CMNy*RMdN**2)*RMdN/4.0d0
!            B=(-(CMNx*CMNy*RMdN**2)/4.0d0)
!            C=(CMNx**2-CMNy**2)*RMdN**2/8.0d0
!            D=(CMNx**3+CMNx*CMNy**2+3.0d0*CMNx*RMdN**2)*RMdN/4.0d0
!            E2=(CMNx**2+CMNy**2+RMdN**2/2.0d0)*RMdN**2.0d0/2.0d0
      intq=a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-COS(2.0_dp*  &
         phi0))+c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+d*(SIN(phi1)-  &
         SIN(phi0))+e2*(phi1-phi0)
!
!           IntQ=IntG2pt(Pathi,Tol,RMdN,CMNx,CMNy,ilaw)
!
!   integral of linear term (note the value of 1 at end)
!
      intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
   END IF

   IF((ilaw == 4).OR.(ilaw == 14))THEN
!
!   integral of constant term for quad
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of quadratic term
!
      cmnx2=cmnx**2
      cmnx3=cmnx**3
      cmny2=cmny**2
      cmny3=cmny**3
      rmdn2=rmdn**2
!
      a=(-cmnx2*cmny-cmny3-3.0_dp*cmny*rmdn2)*rmdn/4.0_dp
      b=(-(cmnx*cmny*rmdn2)/4.0_dp)
      c=(cmnx2-cmny2)*rmdn2/8.0_dp
      d=(cmnx3+cmnx*cmny2+3.0_dp*cmnx*rmdn2)*rmdn/4.0_dp
      e2=(cmnx2+cmny2+rmdn2/2.0_dp)*rmdn2/2.0_dp
!
!            A=(-CMNx**2*CMNy-CMNy**3-3.0d0*CMNy*RMdN**2)*RMdN/4.0d0
!            B=(-(CMNx*CMNy*RMdN**2)/4.0d0)
!            C=(CMNx**2-CMNy**2)*RMdN**2/8.0d0
!            D=(CMNx**3+CMNx*CMNy**2+3.0d0*CMNx*RMdN**2)*RMdN/4.0d0
!            E2=(CMNx**2+CMNy**2+RMdN**2/2.0d0)*RMdN**2.0d0/2.0d0
!
      intq=a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-COS(2.0_dp*  &
         phi0))+c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+d*(SIN(phi1)-  &
         SIN(phi0))+e2*(phi1-phi0)
!
!           IntQ=IntG2pt(Pathi,Tol,RMdN,CMNx,CMNy,ilaw)
!
!   integral of linear term (note the value of 1 at end)
!
      intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
   END IF
!
   IF((ilaw == 2).OR.(ilaw == 12))THEN
!
!   integral of constant term
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of the linear term (note the value of 1 at the end)
!
      intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
!
!   integral of the log term
!
      intlog=intgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
   END IF
!
   IF((ilaw == 6).OR.(ilaw == 16))THEN
!
      ilawt=2
!
!   integral of constant term
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of the linear term (note the value of 1 at the end)
!
      intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
!
!   integral of the log term
!
      intlog=intgnpt(pathi,tol,rmdn,cmnx,cmny,ilawt)
   END IF
!
   IF((ilaw == 3).OR.(ilaw == 13))THEN
!
!   integral of constant term for sqrt law
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of sqrt term
!
      intsq=intgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
!
!           IntQ=IntG2pt(Pathi,Tol,RMdN,CMNx,CMNy,ilaw)
!
!   integral of linear term (note the value of 1 at end)
!
      intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
   END IF
!
   IF((ilaw == 7).OR.(ilaw == 17))THEN
!
      ilawt=3
!
!   integral of constant term for sqrt law
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of sqrt term
!
      intsq=intgnpt(pathi,tol,rmdn,cmnx,cmny,ilawt)
!
!           IntQ=IntG2pt(Pathi,Tol,RMdN,CMNx,CMNy,ilaw)
!
!   integral of linear term (note the value of 1 at end)
!
      intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
   END IF
!
!   no limb darkening
!
   IF(ilaw == 0)THEN
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
      s=-intc
   END IF
!
!   now loop over filters and apply limb darkening parameters
!
   DO ifilt=1,8
      ldx=dwavex(ifilt,iback)
      ldy=dwavey(ifilt,iback)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF(ilaw == 0)THEN
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         s=-intc+ldx*intl
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         s=-intc+ldx*intl+ldy*intlog
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         s=-intc+ldx*intl+ldy*intlog
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         s=-intc+ldx*intl+ldy*intsq
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         s=-intc+ldx*intl+ldy*intsq
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         s=(-intc+(ldx+2.0_dp*ldy)*intl-ldy*intq)
!
!              S=(-IntC*(1.0d0-ldx-ldy)-(ldx+2.0d0*ldy)*IntL-ldy*IntQ)
!
!
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         s=(-intc+(ldx+2.0_dp*ldy)*intl-ldy*intq)
         sarray(ifilt)=s
      END IF

   END DO
!
   RETURN
!
END SUBROUTINE arcintv3sub
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE arcintv3sub2(ilaw,iback,dwavex,dwavey,n,m,pathi,  &
   ctrn,rdn,ctrm,rdm,tol,sarray)
!
!   Will compute the integrals around the various arc paths.  The
!   limb darkening law is given by ilaw:
!
!   ilaw = 1 linear
!   ilaw = 2 log
!   ilaw = 3 sqrt
!   ilaw = 4 quad
!   ilaw = 5 Kipping quad law
!
!   This version will loop over 8 bandpasses, using the
!   limb darkening coefficients in dwavex and dwavey.  The
!   sums are returned in Sarray.  The number of the body in
!   back whose flux is being computed is given by iback.
!
!   Pathi is a vector with 5 elements giving
!   [body1,body2,start,diff,stop]
!
!   The plane-of-the-sky centers are given in CTRN and CTRN
!   (two elements each), and the radii in the same units are
!   given in RDN and RDM.
!
!   This version is for two bodies.  In this case, we can
!   move the center of the front body to (delta,0) and the
!   back body to (0,0).  This allows us to use symmetry
!   which results in half of the function evaluations
!   in the Gaussian integration.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN OUT)                  :: ilaw
   INTEGER, INTENT(IN OUT)                  :: iback
   REAL(KIND=dp), INTENT(IN)                :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN)                :: dwavey(8,10)
   INTEGER, INTENT(IN OUT)                  :: n
   INTEGER, INTENT(IN OUT)                  :: m
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: ctrn(2)
   REAL(KIND=dp), INTENT(IN)                :: rdn
   REAL(KIND=dp), INTENT(IN)                :: ctrm(2)
   REAL(KIND=dp), INTENT(IN)                :: rdm
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(OUT)               :: sarray(8)
!
   REAL(KIND=dp)  ::  ctrnx,ctrmx,ctrny,ctrmy,rmdn,cmnx,cmny,phi0,phi1,intl
   REAL(KIND=dp)  ::  a,b,c,d,e2,intq,intlog,intsq,newintgnpt,ldx,ldy,s,intc
   REAL(KIND=dp)  ::  xsave,ysave,cmnx2,cmny2,cmnx3,cmny3,rmdn2
!
   INTEGER :: ifilt
!
   DO ifilt=1,8
      sarray(ifilt)=0.0_dp
   END DO
   IF(n == m)THEN
      DO ifilt=1,8
         ldx=dwavex(ifilt,iback)
         ldy=dwavey(ifilt,iback)
         IF((ilaw == 5).OR.(ilaw == 15))THEN
            xsave=ldx
            ysave=ldy
            ldx=2.0_dp*SQRT(xsave)*ysave
            ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         END IF
!
         IF((ilaw == 1).OR.(ilaw == 11))THEN
            s=(0.5_dp-ldx/6.0_dp)*pathi(4)
         END IF
         IF((ilaw == 5).OR.(ilaw == 15))THEN
            s=(0.5_dp-(ldx+2.0_dp*ldy)/6.0_dp+ldy/4.0_dp)*pathi(4)
         END IF
         IF((ilaw == 4).OR.(ilaw == 14))THEN
            s=(0.5_dp-(ldx+2.0_dp*ldy)/6.0_dp+ldy/4.0_dp)*pathi(4)
         END IF
         IF((ilaw == 3).OR.(ilaw == 13))THEN
            s=(0.5_dp-ldx/6.0_dp-ldy/10.0_dp)*pathi(4)
         END IF
         IF((ilaw == 2).OR.(ilaw == 12))THEN
            s=(0.5_dp-ldx/6.0_dp+ldy/9.0_dp)*pathi(4)
         END IF
         IF(ilaw == 0)THEN
            s=0.5_dp*pathi(4)
         END IF
         sarray(ifilt)=s
      END DO
      RETURN
   END IF
!
!
!   Shift the corrdinates
!
!          CTRNx=0.0d0  !CTRN(1)
!          CTRMx=sqrt((CTRM(1)-CTRN(1))**2+(CTRN(2)-CTRM(2))**2)  !CTRM(1)
!          CTRNy=0.0d0  !CTRN(2)
!          CTRMy=0.0d0  !CTRM(2)

   rmdn=rdm/rdn
!
   ctrnx=ctrn(1)
   ctrmx=ctrm(1)
   ctrny=ctrn(2)
   ctrmy=ctrm(2)
!
!          CTRMx=CTRMx-CTRNx
!          CTRNx=0.0d0
!          CTRMy=CTRMy-CTRNy
!          CTRNy=0.0d0
!
!          CTRMx=sqrt(CTRMx**2+CTRMy**2)
!          CTRMy=0.0d0

   cmnx=(ctrmx-ctrnx)/rdn
   cmny=(ctrmy-ctrny)/rdn

   phi0=pathi(3)
   phi1=pathi(5)
!
!   Compute arc terms, which don't depend on limb darkening.  For
!   this subroutine, call a different function to evaluate the
!   Gaussian quadrature (newIntGNpt instead of IntGNpt).
!
   IF((ilaw == 1).OR.(ilaw == 11))THEN
!
!   integral of constant term for linear
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of linear term
!
      intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
   END IF
!
   IF((ilaw == 5).OR.(ilaw == 15))THEN
!
!   integral of constant term for Kipping quad
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of quadratic term
!
      cmnx2=cmnx**2
      cmnx3=cmnx**3
      cmny2=cmny**2
      cmny3=cmny**3
      rmdn2=rmdn**2
!
      a=(-cmnx2*cmny-cmny3-3.0_dp*cmny*rmdn2)*rmdn/4.0_dp
      b=(-(cmnx*cmny*rmdn2)/4.0_dp)
      c=(cmnx2-cmny2)*rmdn2/8.0_dp
      d=(cmnx3+cmnx*cmny2+3.0_dp*cmnx*rmdn2)*rmdn/4.0_dp
      e2=(cmnx2+cmny2+rmdn2/2.0_dp)*rmdn2/2.0_dp
!
!            A=(-CMNx**2*CMNy-CMNy**3-3.0d0*CMNy*RMdN**2)*RMdN/4.0d0
!            B=(-(CMNx*CMNy*RMdN**2)/4.0d0)
!            C=(CMNx**2-CMNy**2)*RMdN**2/8.0d0
!            D=(CMNx**3+CMNx*CMNy**2+3.0d0*CMNx*RMdN**2)*RMdN/4.0d0
!            E2=(CMNx**2+CMNy**2+RMdN**2/2.0d0)*RMdN**2.0d0/2.0d0
!
      intq=a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-COS(2.0_dp*  &
         phi0))+c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+d*(SIN(phi1)-  &
         SIN(phi0))+e2*(phi1-phi0)
!
!           IntQ=IntG2pt(Pathi,Tol,RMdN,CMNx,CMNy,ilaw)
!
!   integral of linear term (note the value of 1 at end)
!
      intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
   END IF

   IF((ilaw == 4).OR.(ilaw == 14))THEN
!
!   integral of constant term for quad
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of quadratic term
!
      cmnx2=cmnx**2
      cmnx3=cmnx**3
      cmny2=cmny**2
      cmny3=cmny**3
      rmdn2=rmdn**2
!
      a=(-cmnx2*cmny-cmny3-3.0_dp*cmny*rmdn2)*rmdn/4.0_dp
      b=(-(cmnx*cmny*rmdn2)/4.0_dp)
      c=(cmnx2-cmny2)*rmdn2/8.0_dp
      d=(cmnx3+cmnx*cmny2+3.0_dp*cmnx*rmdn2)*rmdn/4.0_dp
      e2=(cmnx2+cmny2+rmdn2/2.0_dp)*rmdn2/2.0_dp
!
!            A=(-CMNx**2*CMNy-CMNy**3-3.0d0*CMNy*RMdN**2)*RMdN/4.0d0
!            B=(-(CMNx*CMNy*RMdN**2)/4.0d0)
!            C=(CMNx**2-CMNy**2)*RMdN**2/8.0d0
!            D=(CMNx**3+CMNx*CMNy**2+3.0d0*CMNx*RMdN**2)*RMdN/4.0d0
!            E2=(CMNx**2+CMNy**2+RMdN**2/2.0d0)*RMdN**2.0d0/2.0d0
!
      intq=a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-COS(2.0_dp*  &
         phi0))+c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+d*(SIN(phi1)-  &
         SIN(phi0))+e2*(phi1-phi0)
!
!           IntQ=IntG2pt(Pathi,Tol,RMdN,CMNx,CMNy,ilaw)
!
!   integral of linear term (note the value of 1 at end)
!
      intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
   END IF
!
   IF((ilaw == 2).OR.(ilaw == 12))THEN
!
!   integral of constant term
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of the linear term (note the value of 1 at the end)
!
      intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
!
!   integral of the log term
!
      intlog=newintgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
   END IF
!
   IF((ilaw == 3).OR.(ilaw == 13))THEN
!
!   integral of constant term for sqrt law
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of sqrt term
!
      intsq=newintgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
!
!           IntQ=IntG2pt(Pathi,Tol,RMdN,CMNx,CMNy,ilaw)
!
!   integral of linear term (note the value of 1 at end)
!
      intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
   END IF
!
!   no limb darkening
!
   IF(ilaw == 0)THEN
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
      s=-intc
   END IF
!
!   now loop over filters and apply limb darkening parameters
!
   DO ifilt=1,8
      ldx=dwavex(ifilt,iback)
      ldy=dwavey(ifilt,iback)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
!
      IF(ilaw == 0)THEN
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         s=-intc+ldx*intl
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         s=-intc+ldx*intl+ldy*intlog
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         s=-intc+ldx*intl+ldy*intsq
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         s=(-intc+(ldx+2.0_dp*ldy)*intl-ldy*intq)
!
!              S=(-IntC*(1.0d0-ldx-ldy)-(ldx+2.0d0*ldy)*IntL-ldy*IntQ)
!
!
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         s=(-intc+(ldx+2.0_dp*ldy)*intl-ldy*intq)
         sarray(ifilt)=s
      END IF

   END DO
!
   RETURN
!
END SUBROUTINE arcintv3sub2
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION atmintg2pt(pathi,tol,rmdn,cmnx,cmny,nmu,nmumax,  &
   table5)
!
!  Uses 2 point Gaussian integration to evaluate the tablulated
!  intensities in Table5
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
   INTEGER, INTENT(IN)                      :: nmu
   INTEGER, INTENT(IN)                      :: nmumax
   REAL(KIND=dp), INTENT(IN)                :: table5(nmumax,5)
!
   REAL(KIND=dp) :: atmintg2pt, a,b,h,c1,c2,phi
   REAL(KIND=dp) :: summ,xi,yi,rsq,xip,yip,bb,f,ig,p
!
   INTEGER :: k,m,indrsq,iceiling
!
   INTEGER, PARAMETER :: maxm=2*4096
   DIMENSION  phi(maxm)
!
   a=pathi(3)
   b=pathi(5)
   m=INT(REAL(INT(pathi(4)/0.2_dp)+1,KIND=dp)*tol)
   h=(b-a)/REAL(m,KIND=dp)
   summ=0.0_dp
!
!  abcissa for Gaussian 2 point
!
   c1=(1.0_dp-1.0_dp/SQRT(3.0_dp))/2.0_dp
   c2=(1.0_dp+1.0_dp/SQRT(3.0_dp))/2.0_dp
!
!  compute the values of the angle phi
!
   phi(1)=a+h*c1
   phi(2)=a+h*c2
   DO k=3,2*m-1
      phi(k)=phi(k-2)+h
      phi(k+1)=phi(k-1)+h
   END DO
!
!   collect the evaluation points from Table5
!
   DO k=1,2*m
      xi=rmdn*COS(phi(k))+cmnx
      yi=rmdn*SIN(phi(k))+cmny
      rsq=xi**2+yi**2
      xip=-rmdn*SIN(phi(k))
      yip=rmdn*COS(phi(k))
      bb=xi*yip-yi*xip
      indrsq=nmu-iceiling(REAL(nmu-1,KIND=dp)*SQRT(1.0_dp-rsq))
      p=rsq
      f=table5(indrsq,2)+(p-table5(indrsq,1))*  &
         (table5(indrsq,3)+(p-table5(indrsq,1))*  &
         (table5(indrsq,4)+(p-table5(indrsq+1,1))*table5(indrsq,5)))
      ig=f*bb
      summ=summ+ig
   END DO
!
   atmintg2pt=-0.5_dp*h*summ
!
   RETURN
!
END FUNCTION atmintg2pt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION atmintgnpt(pathi,tol,rmdn,cmnx,cmny,nmu,nmumax,table5)
!
!  Uses N point Gaussian integration to evaluate the tablulated
!  intensities in Table5
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
   INTEGER, INTENT(IN)                      :: nmu
   INTEGER, INTENT(IN)                      :: nmumax
   REAL(KIND=dp), INTENT(IN)                :: table5(nmumax,5)
!
   REAL(KIND=dp) atmintgnpt,a,b,h,phi,delta
   REAL(KIND=dp) summ,xi,yi,rsq,xip,yip,bb,f,ig,p,xx,ww
!
   INTEGER :: k,m,indrsq,iceiling,norder,muse,nopt,MAX,kk
!
   INTEGER, PARAMETER :: maxm=64
   DIMENSION  phi(maxm),xx(64),ww(64)
!
   a=pathi(3)
   b=pathi(5)
   b=a+0.5_dp*pathi(4)
!
   m=INT(REAL(INT(2.0_dp*rmdn*pathi(4)/0.2_dp)+1,KIND=dp)*tol)
   delta=SQRT(cmnx**2+cmny**2)
   IF(rmdn <= 1.0_dp)THEN
      IF(rmdn+delta >= 0.997_dp)m=m+1
   END IF
   IF(rmdn < 0.011_dp)m=2*m
   IF(rmdn < 0.035_dp)m=2*m
   IF((tol <= 3.0_dp).AND.(rmdn < 0.017_dp))m=m+2
   IF((tol <= 3.0_dp).AND.(rmdn < 0.025_dp))m=m+2
   IF((tol <= 3.0_dp).AND.(rmdn < 0.050_dp))m=m+2
   IF((tol <= 3.0_dp).AND.(rmdn < 0.080_dp))m=m+2
   IF((tol < 1.0_dp).AND.(rmdn < 0.150_dp))m=m+2
   IF(rmdn < 1.0_dp)THEN
      IF(delta > 0.80_dp+rmdn)m=m+2
   ELSE
      IF(delta > 0.95_dp+rmdn)m=m+2
   END IF
   IF(rmdn < 0.25_dp)THEN
      IF(delta > 1.0_dp-rmdn)m=m+2
   END IF
!
   norder=4
   muse=m
   nopt=m
   MAX=64
!
   IF(nopt <= MAX)THEN
      norder=nopt
      muse=1
   END IF
   DO k=1,100
      IF((nopt >= MAX*k+1).AND.(nopt <= (k+1)*MAX))THEN
         norder=nopt/(k+1)
         muse=k+1
      END IF
   END DO
!
   CALL gausscoeff(norder,xx,ww)
!
   h=(b-a)/REAL(muse,KIND=dp)
   DO k=1,norder
      phi(k)=a+h*(1.0_dp+xx(k))/2.0_dp
   END DO
!
   summ=0.0_dp
!
!   collect the evaluation points from Table5
!
   DO kk=1,muse
      DO k=1,norder
         xi=rmdn*COS(phi(k))+cmnx
         yi=rmdn*SIN(phi(k))+cmny
         rsq=xi**2+yi**2
         xip=-rmdn*SIN(phi(k))
         yip=rmdn*COS(phi(k))
         bb=xi*yip-yi*xip
         IF(rsq > 1.0_dp)THEN
            indrsq=nmu-1
         ELSE
            indrsq=nmu-iceiling(REAL(nmu-1,KIND=dp)*SQRT(1.0_dp-rsq))
         END IF
         p=rsq
         f=table5(indrsq,2)+(p-table5(indrsq,1))*(table5(indrsq,3)+  &
            (p-table5(indrsq,1))*(table5(indrsq,4)+(p-table5(indrsq+  &
            1,1))*table5(indrsq,5)))
         ig=f*bb
         summ=summ+ig*ww(k)
      END DO
      DO k=1,norder
         phi(k)=phi(k)+h
      END DO
   END DO
!
   atmintgnpt=-h*summ   !0.5d0*h*summ
!
   RETURN
!
END FUNCTION atmintgnpt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE atmshortmethod(nbody,zlist,xylist,radlist,  &
   reffluxlst,corrlist,rotlist,aalist,bblist,  &
   donvellist,tol,nmumax,nmu,table51a,table52a,table53a,  &
   table54a,table55a,table56a,table57a,table58a,table51b,  &
   table52b,table53b,table54b,table55b,table56b,table57b,  &
   table58b,table51c,table52c,table53c,table54c,table55c,  &
   table56c,table57c,table58c,table51d,table52d,table53d,  &
   table54d,table55d,table56d,table57d,table58d,table51e,  &
   table52e,table53e,table54e,table55e,table56e,table57e,  &
   table58e)
!
!   Will implement Don Short's method for multi-body
!   transits (which follows Pal).  Can use the linear, quadratic
!   sqrt, or log limb darkening law.
!
!   arguments:
!
!   Nbody       number of bodies, 2 through 10
!   zlist       1D array with the z-coordinates of each body, where
!               larger z-coordinates are closer to observer
!   xylist      2D array with x and y coordinates of the
!               centers of each body
!   radlist     1D array with the radius of each body
!   reffluxlst 2D array with reference fluxes for each body,
!               where the first index is the body number and
!               the second index is the filter number
!   corrlist    2D array with the flux corrections, first index
!               is the body number, the second index is the
!               filter number (output)
!   rotlist     1D array with the coefficient needed for
!               scaling the Rossiter effect for each body
!   AAlist      1D array with the A-coefficient for the
!               rotation of the spin axis for each body
!   BBlist      1D array with the B-coefficient for the
!               rotation of the spin axis for each body
!   donvellist  2D array with the Rossiter effect correction,
!               first index is the body number and the
!               second index is the filter number
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: zlist(10)
   REAL(KIND=dp), INTENT(IN)                :: xylist(10,2)
   REAL(KIND=dp), INTENT(IN)                :: radlist(10)
   REAL(KIND=dp), INTENT(IN)                :: reffluxlst(10,8)
   REAL(KIND=dp), INTENT(OUT)               :: corrlist(10,8)
   REAL(KIND=dp), INTENT(IN)                :: rotlist(10)
   REAL(KIND=dp), INTENT(IN)                :: aalist(10)
   REAL(KIND=dp), INTENT(IN)                :: bblist(10)
   REAL(KIND=dp), INTENT(OUT)               :: donvellist(10,8)
   REAL(KIND=dp), INTENT(IN)                :: tol
   INTEGER, INTENT(IN)                      :: nmumax
   INTEGER, INTENT(IN)                      :: nmu
   REAL(KIND=dp), INTENT(IN)                :: table51a(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table52a(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table53a(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table54a(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table55a(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table56a(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table57a(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table58a(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table51b(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table52b(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table53b(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table54b(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table55b(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table56b(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table57b(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table58b(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table51c(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table52c(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table53c(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table54c(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table55c(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table56c(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table57c(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table58c(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table51d(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table52d(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table53d(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table54d(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table55d(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table56d(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table57d(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table58d(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table51e(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table52e(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table53e(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table54e(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table55e(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table56e(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table57e(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table58e(nmumax,5)
!
   REAL(KIND=dp)  ::  rd,ctm,ctrn,ctrm,rdm,rdn,phi0back
   REAL(KIND=dp)  ::  pathn,pathi,path,bdr,cc,fluxfrac,ttt
   REAL(KIND=dp)  ::  sumarray, sarray,rot,aa,bb,intarray,phi1,phi0
   REAL(KIND=dp)  ::  dvsum,sumsave,sarrayn,rmdn,cmnx,cmny,phi1back
!
   INTEGER :: indxzlist,i,j,k,n,m,INDEX,idx,ifilt
   INTEGER :: indexpath,indexbdr,ilawlist
!
   DIMENSION dvsum(10,8),sumsave(10,8),rd(10)
   DIMENSION indxzlist(10),ctm(10,2),path(10,27,5),bdr(10,27,5)
   DIMENSION cc(8,10),fluxfrac(8,10),pathn(27,5),pathi(5)
   DIMENSION ctrn(2),ctrm(2),indexpath(10)
   DIMENSION indexbdr(10),sarray(8),sumarray(8)
   DIMENSION ilawlist(10),intarray(6),sarrayn(8)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!  We have to sort the z-coordinate array zlist.  A larger z
!  means closer, smaller z means further away.  The various
!  subroutines need the Nbody stars sorted from near to far.
!
   CALL indexx(10,zlist,indxzlist)
!
!  Construct the RD array (sorted stellar radii)
!
   k=1
   DO i=10,(10-nbody+1),-1
      rd(k)=radlist(indxzlist(i))
      ctm(k,1)=xylist(indxzlist(i),1)
      ctm(k,2)=xylist(indxzlist(i),2)
      ilawlist(k)=indxzlist(i)
      k=k+1
   END DO
!
!  Find the arcs and borders
!
   CALL integrationpaths(nbody,ctm,rd,path,bdr,indexpath,indexbdr)
!
!  Fill the correction array with zeros
!
   DO i=1,10
      DO j=1,8
         corrlist(i,j)=0.0_dp
         sumsave(i,j)=0.0_dp
      END DO
   END DO
!
   DO i=1,6
      intarray(i)=0.0_dp
   END DO
!
!  Now find the flux fractions, and loop over filters
!
!          Tol=3.0d0
!
   DO ifilt=1,8
      fluxfrac(ifilt,1)=1.0_dp
      cc(ifilt,1)=twopie
      dvsum(1,ifilt)=0.0_dp
      dvsum(2,ifilt)=0.0_dp
      dvsum(3,ifilt)=0.0_dp
      dvsum(4,ifilt)=0.0_dp
      dvsum(5,ifilt)=0.0_dp
      dvsum(6,ifilt)=0.0_dp
      dvsum(7,ifilt)=0.0_dp
      dvsum(8,ifilt)=0.0_dp
      dvsum(9,ifilt)=0.0_dp
      dvsum(10,ifilt)=0.0_dp
   END DO
!
   DO n=2,nbody
!
      idx=indxzlist(10-n+1)
      rot=rotlist(idx)
      aa=aalist(idx)
      bb=bblist(idx)
!
!   copy the path array for body N
!
      DO j=1,indexpath(n)
         pathn(j,1)=path(n,j,1)
         pathn(j,2)=path(n,j,2)
         pathn(j,3)=path(n,j,3)
         pathn(j,4)=path(n,j,4)
         pathn(j,5)=path(n,j,5)
      END DO
!
      INDEX=indexpath(n)
      IF(INDEX <= 0)THEN
         DO ifilt=1,8
            fluxfrac(ifilt,n)=0.0_dp
         END DO
         GO TO 10
      END IF
!
      DO ifilt=1,8
         sumarray(ifilt)=0.0_dp
      END DO

      IF(INDEX == 1)THEN
         IF(pathn(1,4) <= 0.0_dp)THEN
            DO ifilt=1,8
               fluxfrac(ifilt,n)=0.0_dp !1.0_dp
            END DO
         ELSE
            DO ifilt=1,8
               fluxfrac(ifilt,n)=1.0_dp
               cc(ifilt,n)=twopie
            END DO
         END IF
         GO TO 10
      END IF
!
      DO i=1,INDEX
         DO ifilt=1,8
            sarray(ifilt)=0.0_dp
         END DO
         pathi(1)=pathn(i,1)
         pathi(2)=pathn(i,2)
         pathi(3)=pathn(i,3)
         pathi(4)=pathn(i,4)
         pathi(5)=pathn(i,5)
         phi0=pathi(3)
         phi1=pathi(5)
         phi0back=pathn(n,3)
         phi1back=pathn(n,5)
         m=nint(pathi(2))
         ctrn(1)=ctm(n,1)
         ctrn(2)=ctm(n,2)
         ctrm(1)=ctm(m,1)
         ctrm(2)=ctm(m,2)
         rdm=rd(m)
         rdn=rd(n)
         rmdn=rdm/rdn
         cmnx=(ctrm(1)-ctrn(1))/rdn
         cmny=(ctrm(2)-ctrn(2))/rdn
!
         IF(ilawlist(n) == 1)THEN
            IF(m /= n)THEN
               CALL subatmintgnpt(pathi,tol,rmdn,cmnx,cmny,nmu,nmumax,  &
                  table51a,table52a,table53a,table54a,table55a,table56a,  &
                  table57a,table58a,sarray,1)
            ELSE
               sarray(1)=table51a(nmu,2)*(phi1-phi0)
               sarray(2)=table52a(nmu,2)*(phi1-phi0)
               sarray(3)=table53a(nmu,2)*(phi1-phi0)
               sarray(4)=table54a(nmu,2)*(phi1-phi0)
               sarray(5)=table55a(nmu,2)*(phi1-phi0)
               sarray(6)=table56a(nmu,2)*(phi1-phi0)
               sarray(7)=table57a(nmu,2)*(phi1-phi0)
               sarray(8)=table58a(nmu,2)*(phi1-phi0)
            END IF
         END IF
         IF(ilawlist(n) == 2)THEN
            IF(m /= n)THEN
               CALL subatmintgnpt(pathi,tol,rmdn,cmnx,cmny,nmu,nmumax,  &
                  table51b,table52b,table53b,table54b,table55b,table56b,  &
                  table57b,table58b,sarray,1)
            ELSE
               sarray(1)=table51b(nmu,2)*(phi1-phi0)
               sarray(2)=table52b(nmu,2)*(phi1-phi0)
               sarray(3)=table53b(nmu,2)*(phi1-phi0)
               sarray(4)=table54b(nmu,2)*(phi1-phi0)
               sarray(5)=table55b(nmu,2)*(phi1-phi0)
               sarray(6)=table56b(nmu,2)*(phi1-phi0)
               sarray(7)=table57b(nmu,2)*(phi1-phi0)
               sarray(8)=table58b(nmu,2)*(phi1-phi0)
            END IF
         END IF
         IF(ilawlist(n) == 3)THEN
            IF(m /= n)THEN
               CALL subatmintgnpt(pathi,tol,rmdn,cmnx,cmny,nmu,nmumax,  &
                  table51c,table52c,table53c,table54c,table55c,table56c,  &
                  table57c,table58c,sarray,1)
            ELSE
               sarray(1)=table51c(nmu,2)*(phi1-phi0)
               sarray(2)=table52c(nmu,2)*(phi1-phi0)
               sarray(3)=table53c(nmu,2)*(phi1-phi0)
               sarray(4)=table54c(nmu,2)*(phi1-phi0)
               sarray(5)=table55c(nmu,2)*(phi1-phi0)
               sarray(6)=table56c(nmu,2)*(phi1-phi0)
               sarray(7)=table57c(nmu,2)*(phi1-phi0)
               sarray(8)=table58c(nmu,2)*(phi1-phi0)
            END IF
         END IF
         IF(ilawlist(n) == 4)THEN
            IF(m /= n)THEN
               CALL subatmintgnpt(pathi,tol,rmdn,cmnx,cmny,nmu,nmumax,  &
                  table51d,table52d,table53d,table54d,table55d,table56d,  &
                  table57d,table58d,sarray,1)
            ELSE
               sarray(1)=table51d(nmu,2)*(phi1-phi0)
               sarray(2)=table52d(nmu,2)*(phi1-phi0)
               sarray(3)=table53d(nmu,2)*(phi1-phi0)
               sarray(4)=table54d(nmu,2)*(phi1-phi0)
               sarray(5)=table55d(nmu,2)*(phi1-phi0)
               sarray(6)=table56d(nmu,2)*(phi1-phi0)
               sarray(7)=table57d(nmu,2)*(phi1-phi0)
               sarray(8)=table58d(nmu,2)*(phi1-phi0)
            END IF
         END IF
         IF(ilawlist(n) == 5)THEN
            IF(m /= n)THEN
               CALL subatmintgnpt(pathi,tol,rmdn,cmnx,cmny,nmu,nmumax,  &
                  table51e,table52e,table53e,table54e,table55e,table56e,  &
                  table57e,table58e,sarray,1)
            ELSE
               sarray(1)=table51e(nmu,2)*(phi1-phi0)
               sarray(2)=table52e(nmu,2)*(phi1-phi0)
               sarray(3)=table53e(nmu,2)*(phi1-phi0)
               sarray(4)=table54e(nmu,2)*(phi1-phi0)
               sarray(5)=table55e(nmu,2)*(phi1-phi0)
               sarray(6)=table56e(nmu,2)*(phi1-phi0)
               sarray(7)=table57e(nmu,2)*(phi1-phi0)
               sarray(8)=table58e(nmu,2)*(phi1-phi0)
            END IF
         END IF
         DO ifilt=1,8
            sumarray(ifilt)=sumarray(ifilt)+sarray(ifilt)
         END DO
      END DO
!
      IF(ilawlist(n) == 1)THEN
         sarrayn(1)=table51a(nmu,2)*twopie
         sarrayn(2)=table52a(nmu,2)*twopie
         sarrayn(3)=table53a(nmu,2)*twopie
         sarrayn(4)=table54a(nmu,2)*twopie
         sarrayn(5)=table55a(nmu,2)*twopie
         sarrayn(6)=table56a(nmu,2)*twopie
         sarrayn(7)=table57a(nmu,2)*twopie
         sarrayn(8)=table58a(nmu,2)*twopie
      END IF
      IF(ilawlist(n) == 2)THEN
         sarrayn(1)=table51b(nmu,2)*twopie
         sarrayn(2)=table52b(nmu,2)*twopie
         sarrayn(3)=table53b(nmu,2)*twopie
         sarrayn(4)=table54b(nmu,2)*twopie
         sarrayn(5)=table55b(nmu,2)*twopie
         sarrayn(6)=table56b(nmu,2)*twopie
         sarrayn(7)=table57b(nmu,2)*twopie
         sarrayn(8)=table58b(nmu,2)*twopie
      END IF
      IF(ilawlist(n) == 3)THEN
         sarrayn(1)=table51c(nmu,2)*twopie
         sarrayn(2)=table52c(nmu,2)*twopie
         sarrayn(3)=table53c(nmu,2)*twopie
         sarrayn(4)=table54c(nmu,2)*twopie
         sarrayn(5)=table55c(nmu,2)*twopie
         sarrayn(6)=table56c(nmu,2)*twopie
         sarrayn(7)=table57c(nmu,2)*twopie
         sarrayn(8)=table58c(nmu,2)*twopie
      END IF
      IF(ilawlist(n) == 4)THEN
         sarrayn(1)=table51d(nmu,2)*twopie
         sarrayn(2)=table52d(nmu,2)*twopie
         sarrayn(3)=table53d(nmu,2)*twopie
         sarrayn(4)=table54d(nmu,2)*twopie
         sarrayn(5)=table55d(nmu,2)*twopie
         sarrayn(6)=table56d(nmu,2)*twopie
         sarrayn(7)=table57d(nmu,2)*twopie
         sarrayn(8)=table58d(nmu,2)*twopie
      END IF
      IF(ilawlist(n) == 5)THEN
         sarrayn(1)=table51e(nmu,2)*twopie
         sarrayn(2)=table52e(nmu,2)*twopie
         sarrayn(3)=table53e(nmu,2)*twopie
         sarrayn(4)=table54e(nmu,2)*twopie
         sarrayn(5)=table55e(nmu,2)*twopie
         sarrayn(6)=table56e(nmu,2)*twopie
         sarrayn(7)=table57e(nmu,2)*twopie
         sarrayn(8)=table58e(nmu,2)*twopie
      END IF
!
      DO ifilt=1,8
         cc(ifilt,n)=sarrayn(ifilt)
         fluxfrac(ifilt,n)=sumarray(ifilt)/cc(ifilt,n)
      END DO
!
      DO ifilt=1,8
         sumsave(idx,ifilt)=sumarray(ifilt)
      END DO
!
10    CONTINUE
!
!  end the loop over bodies
!
   END DO
!
!   Now we have to fill the corrlist
!
   DO ifilt=1,8
      DO k=1,nbody
         idx=indxzlist(10-k+1)
         ttt=-(1.0_dp-fluxfrac(ifilt,k))
         corrlist(idx,ifilt)=reffluxlst(idx,ifilt)*ttt
         IF(ABS(sumsave(idx,ifilt)) > 0.0_dp)THEN
            donvellist(idx,ifilt)=-dvsum(idx,ifilt)/sumsave(idx,ifilt)
         ELSE
            donvellist(idx,ifilt)=0.0_dp
         END IF
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE atmshortmethod
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE atmshortmethod2(ilaw,xfront,yfront,xback,  &
   yback,rfront,rback,reffluxbck,corrback,rot,aa,  &
   bb,donvel,tol,irossiter,table51,table52,table53,  &
   table54,table55,table56,table57,table58,nmumax,nmu)
!
!   Will implement Don Short's method for multi-body
!   transits (which follows Pal) that uses tabulated model atmosphere
!   intensities.    Can also use the linear, quadratic
!   sqrt, or log limb darkening laws.  This routine is streamlined
!   assuming only two bodies.
!
!   ilaw:   an integer flag giving the limb darkening law (1=linear
!           2=log, 3=sqrt, 4=quad)
!   xfront:  x-coordinate of center of the front body
!   yfront:  y-coordinate of center of the front body
!   xback:   x-coordinate of center of the back body
!   yback:   y-coordinate of center of the back body
!   rfront:  radius of the front body
!   rback:   radius of the back body
!   reffluxbck:   fluxes for star in back, 8 bandpasses
!   corrback:      corrections to the flux for the back body,
!                  8 bandpasses
!   rot:     ratio of spin frequency to orbital frequency of
!            back star
!   AA,BB:   Used for misaligned rotation axes (AA=1 and BB=0 for
!            aligned axis)
!   Tol:     Sets the accuracy of the integration
!   iRossiter:  Flag to include the Rossiter effect
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmumax
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(IN)                :: xfront
   REAL(KIND=dp), INTENT(IN)                :: yfront
   REAL(KIND=dp), INTENT(IN)                :: xback
   REAL(KIND=dp), INTENT(IN)                :: yback
   REAL(KIND=dp), INTENT(IN)                :: rfront
   REAL(KIND=dp), INTENT(IN)                :: rback
   REAL(KIND=dp), INTENT(IN)                :: reffluxbck(8)
   REAL(KIND=dp), INTENT(OUT)               :: corrback(8)
   REAL(KIND=dp), INTENT(IN)                :: rot
   REAL(KIND=dp), INTENT(IN OUT)            :: aa
   REAL(KIND=dp), INTENT(IN OUT)            :: bb
   REAL(KIND=dp), INTENT(OUT)               :: donvel(8)
   REAL(KIND=dp), INTENT(IN)                :: tol
   INTEGER, INTENT(IN)                      :: irossiter
   REAL(KIND=dp), INTENT(IN)                :: table51(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table52(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table53(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table54(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table55(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table56(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table57(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table58(nmumax,5)
   INTEGER, INTENT(IN)                      :: nmu
!
   REAL(KIND=dp)  :: rd,ctm,ctrn,ctrm
   REAL(KIND=dp)  :: pathi,cc,fluxfrac,intarray,ct1,ct2,arcn,arci
   REAL(KIND=dp)  :: rdm,rdn,sarray,sumarray,ttt,dvsum,intgnpt,sarrayn
   REAL(KIND=dp)  :: dist,tiny,w,phi1,phi0,r1,r2,a,b,c,ang1,arcout
   REAL(KIND=dp)  :: arcin,phi0front,phi1front,phi0back,phi1back,s
   REAL(KIND=dp)  :: rmdn,ctrnx,ctrny,ctrmx,ctrmy,cmnx,cmny,intl
!
   INTEGER :: j,n,ifilt
   INTEGER :: ifront,iiback
!
   DIMENSION rd(10),arcn(5),arci(5),ct1(2),ct2(2),sumarray(8)
   DIMENSION ctm(10,2),sarray(8),ctrn(2),ctrm(2),sarrayn(8)
   DIMENSION cc(8,10),fluxfrac(8,10),pathi(5)
   DIMENSION intarray(6),dvsum(8),arcout(2),arcin(2)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   aa=aa*2.0_dp
   bb=bb*2.0_dp
!
!
!   IF(PRECISION(tiny).EQ.18)THEN
!     tiny=3.0E-18_dp
!   ELSE
!     tiny=3.0E-15_dp
!   END IF
!
   tiny=10.0_dp*epsilon(aa)
!
   ifront=1
   iiback=2
!
   DO ifilt=1,8
      sumarray(ifilt)=0.0_dp
      dvsum(ifilt)=0.0_dp
      sarray(ifilt)=0.0_dp
   END DO
!
!   We will shift the center of the front body to (delta,0)
!   and the center of the back body to (0,0).  This will allow
!   us to use symmetry later on to reduce the number of
!   steps in the Gaussian quadrature.
!
   dist=SQRT((xfront-xback)**2+(yfront-yback)**2)
   ct1(1)=dist
   ct1(2)=0.0_dp
   ct2(1)=0.0_dp
   ct2(2)=0.0_dp
   ctm(1,1)=dist
   ctm(1,2)=0.0_dp
   ctm(2,1)=0.0_dp
   ctm(2,2)=0.0_dp
   rd(1)=rfront
   rd(2)=rback
!
!   If we are doing the Rossiter effect, we cannot rotate
!   the coordinates
!
   IF(irossiter >= 1)THEN
      ct1(1)=xfront
      ct1(2)=yfront
      ct2(1)=xback
      ct2(2)=yback
      ctm(1,1)=xfront
      ctm(1,2)=yfront
      ctm(2,1)=xback
      ctm(2,2)=yback
   END IF
!
   IF(rfront+rback-tiny <= dist)THEN
!
!   no eclipse event
!
      DO ifilt=1,8
         corrback(ifilt)=0.0_dp
         donvel(ifilt)=0.0_dp
      END DO
      RETURN
   END IF
!
   IF(dist+rfront <= rback-tiny)THEN
!
!   front inside back, transit event
!
      phi0front=0.0_dp
      phi1front=twopie
      phi0back=0.0_dp
      phi1back=twopie
      GO TO 10
   END IF
!
   IF(dist+rback <= rfront+tiny)THEN
!
!   front contained within back, total eclipse
!
      DO ifilt=1,8
         corrback(ifilt)=-1.0_dp*reffluxbck(ifilt)
         donvel(ifilt)=0.0_dp
      END DO
      RETURN
   END IF
!
   r1=rfront
   r2=rback
   phi0=MOD(ATAN2(ct2(2)-ct1(2),ct2(1)-ct1(1)),twopie)
   IF(phi0 < 0.0_dp)phi0=phi0+twopie
   w=(r1*r1+dist*dist-r2*r2)/(2.0_dp*r1*dist)
!
!   Trap a rare round-off error using the tiny
!
   IF(w > 1.0_dp)w=w-tiny
   IF(w < -1.0_dp)w=w+tiny
   IF(ABS(w) <= 1.0_dp)THEN
      phi1=ACOS(w)
      arcin(1)=MOD(phi0-phi1,twopie)
      IF(arcin(1) < 0.0_dp)arcin(1)=arcin(1)+twopie
      arcin(2)=2.0_dp*phi1
      a=arcin(1)
      b=arcin(2)
      c=a+b
      arci(1)=REAL(iiback,KIND=dp)
      arci(2)=REAL(ifront,KIND=dp)
      arci(3)=a
      arci(4)=c-a
      arci(5)=c
   ELSE
      WRITE(*,*)'Cosine Error1'
   END IF
!
   phi0front=arci(3)
   phi1front=arci(5)
!
   w=(r2*r2+dist*dist-r1*r1)/(2.0_dp*r2*dist)
!
!   Trap a rare round-off error using the tiny
!
   IF(w > 1.0_dp)w=w-tiny
   IF(w < -1.0_dp)w=w+tiny
!
   IF(ABS(w) <= 1.0_dp)THEN
      phi1=pie-ACOS(w)
      ang1=MOD(phi0-phi1,twopie)
      IF(ang1 < 0.0_dp)ang1=ang1+twopie
      arcout(1)=ang1
      arcout(2)=2.0_dp*phi1
      a=arcout(1)
      b=arcout(2)
      c=a+b
      arcn(1)=REAL(iiback,KIND=dp)
      arcn(2)=REAL(iiback,KIND=dp)
      arcn(3)=a
      arcn(4)=c-a
      arcn(5)=c
   ELSE
      WRITE(*,*)'Cosine Error2'
   END IF
!
   phi0back=arcn(3)
   phi1back=arcn(5)
10 CONTINUE
!
   phi1=phi1back
   phi0=phi0back
!
!  Fill the correction array
!
   DO j=1,8
      corrback(j)=0.0_dp
   END DO
!
   DO j=1,6
      intarray(j)=0.0_dp
   END DO
!
!  Now find the flux fractions, and loop over filters
!
   DO ifilt=1,8
      fluxfrac(ifilt,1)=1.0_dp
      cc(ifilt,1)=twopie
   END DO
!
   n=2
!
   DO ifilt=1,8
      sumarray(ifilt)=0.0_dp
      dvsum(ifilt)=0.0_dp
      s=0.0_dp
      sarrayn(ifilt)=1.0_dp
   END DO
!
   ctrn(1)=ctm(2,1)
   ctrn(2)=ctm(2,2)
   ctrm(1)=ctm(1,1)
   ctrm(2)=ctm(1,2)
   rdm=rd(1)
   rdn=rd(2)
!
!  body in front
!
   rmdn=rdm/rdn
!
   ctrnx=ctrn(1)
   ctrmx=ctrm(1)
   ctrny=ctrn(2)
   ctrmy=ctrm(2)
   cmnx=(ctrmx-ctrnx)/rdn
   cmny=(ctrmy-ctrny)/rdn
!
   phi0=phi0front
   phi1=phi1front
   pathi(3)=phi0
   pathi(4)=(phi1-phi0)
   pathi(5)=phi1
   IF(irossiter == 0)THEN
      CALL subatmintgnpt(pathi,tol,rmdn,cmnx,cmny,nmu,nmumax,  &
         table51,table52,table53,table54,table55,table56,table57, &
         table58,sarray,0)
   ELSE
      intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
   END IF
   sarray(1)=sarray(1)+table51(nmu,2)*(phi1back-phi0back)
   sarray(2)=sarray(2)+table52(nmu,2)*(phi1back-phi0back)
   sarray(3)=sarray(3)+table53(nmu,2)*(phi1back-phi0back)
   sarray(4)=sarray(4)+table54(nmu,2)*(phi1back-phi0back)
   sarray(5)=sarray(5)+table55(nmu,2)*(phi1back-phi0back)
   sarray(6)=sarray(6)+table56(nmu,2)*(phi1back-phi0back)
   sarray(7)=sarray(7)+table57(nmu,2)*(phi1back-phi0back)
   sarray(8)=sarray(8)+table58(nmu,2)*(phi1back-phi0back)
   sarrayn(1)=table51(nmu,2)*twopie
   sarrayn(2)=table52(nmu,2)*twopie
   sarrayn(3)=table53(nmu,2)*twopie
   sarrayn(4)=table54(nmu,2)*twopie
   sarrayn(5)=table55(nmu,2)*twopie
   sarrayn(6)=table56(nmu,2)*twopie
   sarrayn(7)=table57(nmu,2)*twopie
   sarrayn(8)=table58(nmu,2)*twopie
   DO ifilt=1,8
      sumarray(ifilt)=sumarray(ifilt)+sarray(ifilt)
   END DO
!
   DO ifilt=1,8
      cc(ifilt,n)=sarrayn(ifilt)
      fluxfrac(ifilt,n)=sumarray(ifilt)/cc(ifilt,n)
   END DO
!
!   Now we have to fill the corrlist
!
   DO ifilt=1,8
      ttt=-(1.0_dp-fluxfrac(ifilt,2))
      corrback(ifilt)=reffluxbck(ifilt)*ttt
      IF(irossiter >= 1)THEN
         IF(ABS(sarray(ifilt)) > 0.0_dp)THEN
            donvel(ifilt)=-rot*dvsum(ifilt)/sumarray(ifilt)
         ELSE
            donvel(ifilt)=0.0_dp
         END IF
      END IF
   END DO
!
   RETURN
!
END SUBROUTINE atmshortmethod2
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE atmtotable5(nmu,nmumax,mu,inten,table5)
!
!  Takes an array of mu angles (assumed to be from zero to 1)
!  and an array of intensities and converts them
!  into a form needed by the new integration method.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmu
   INTEGER, INTENT(IN)                      :: nmumax
   REAL(KIND=dp), INTENT(IN)                :: mu(nmu)
   REAL(KIND=dp), INTENT(IN)                :: inten(nmu)
   REAL(KIND=dp), INTENT(OUT)               :: table5(nmumax,5)
!
   INTEGER :: icount,i,k
!
   REAL(KIND=dp)  :: xmodelrsq(nmu),ymodelrsq(nmu),ymodelint(nmu),a,c,dx
   REAL(KIND=dp)  :: dymodelint(nmu),dymodelg(nmu),bcoef(nmu),dcoef(nmu)
   REAL(KIND=dp)  :: ymodelg(nmu),h,hp,pyp
!
!   Initialize
!
   DO i=1,nmu
      ymodelint(i)=0.0_dp
      dymodelg(i)=0.0_dp
      ymodelg(i)=0.0_dp
      bcoef(i)=0.0_dp
      dcoef(i)=0.0_dp
   END DO
!
!   Convert the angle mu into r^2.
!
   icount=0
   DO i=nmu,1,-1
      icount=icount+1
      xmodelrsq(icount)=1.0_dp-mu(i)**2
      ymodelrsq(icount)=inten(i)
   END DO
!
!   Integrate wrt r^2 using Gaussian 1 point which is
!   exact for linear equations.
!
   DO k=1,nmu-1
      h=xmodelrsq(k+1)-xmodelrsq(k)
      hp=0.5_dp*h
      pyp=0.5_dp*(ymodelrsq(k+1)+ymodelrsq(k))
      ymodelint(k+1)=(ymodelint(k)+h*pyp)
   END DO
!
   DO k=1,nmu
      ymodelint(k)=0.5_dp*ymodelint(k)
      dymodelint(k)=0.5_dp*ymodelrsq(k)
   END DO
!
!  Find the Piece-wise cubic hermit form for G(r^2)
!
   ymodelg(1)=0.5_dp
   DO k=2,nmu
      ymodelg(k)=ymodelint(k)/xmodelrsq(k)
   END DO
!
   dymodelg(1)=0.0_dp
   DO k=2,nmu
      dymodelg(k)=(0.5_dp*ymodelrsq(k)-ymodelg(k))/xmodelrsq(k)
   END DO
!
!  Compute the Piecewise Cubic Hermit Spline for G(r^2)/r^2.
!
   DO i=1,nmu-1
      dx=(xmodelrsq(i+1)-xmodelrsq(i))
      a=(ymodelg(i+1)-ymodelg(i))/dx
      bcoef(i)=(a-dymodelg(i))/dx
      c=(dymodelg(i+1)-a)/dx
      dcoef(i)=(c-bcoef(i))/dx
   END DO
!
!   Copy the various quantities into the Table5
!   array
!
   DO i=1,nmu
      table5(i,1)=xmodelrsq(i)
      table5(i,2)=ymodelg(i)
      table5(i,3)=dymodelg(i)
      table5(i,4)=bcoef(i)
      table5(i,5)=dcoef(i)
   END DO
!
   RETURN
!
END SUBROUTINE atmtotable5
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE binlc(nmaxphase,nphase,xmod,ymod,period,sw29)
!
!   This subroutine will bin a light curve in phase, using a binsize given
!   by sw29, where the units are minutes.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN)                      :: nphase
   REAL(KIND=dp), INTENT(IN OUT)            :: xmod(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: ymod(nmaxphase)
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: sw29
!
   REAL(KIND=dp) :: yinter,y2,xpad,ypad,pstep,pwidth
   REAL(KIND=dp) :: a,b,xxx,summ,tnm,del,x,s,qqq,qqqb,qqqa
!
   INTEGER :: i,jlo,kcount,mphase,nn,j,it,kk,jlotemp
!
   DIMENSION yinter(nmaxphase*3),y2(nmaxphase*3)
   DIMENSION xpad(nmaxphase*3),ypad(nmaxphase*3)
!
   CALL addpad(nphase,xmod,ymod,xpad,ypad)
   mphase=nphase*3
!
!   We will interpolate the model, and given each value in xmod, figure
!   out the range of phase needed, and average the interpolated y-values
!
   CALL spline(xpad,ypad,mphase,0.0_dp,0.0_dp,y2)
!
   pstep=sw29/1440.0_dp/period
   pwidth=0.5_dp*pstep
!
   nn=7
   DO  i=1,mphase
      IF(xpad(i) > 1.0_dp)CYCLE
      IF(xpad(i) < 0.0_dp)CYCLE
      kcount=0
      summ=0.0_dp
      jlo=i
!
      a=xpad(i)-pwidth
      b=xpad(i)+pwidth
!
      DO  j=1,nn
         IF(j == 1)THEN
            xxx=a
            CALL hunt(xpad,mphase,xxx,jlo)
            IF((jlo == mphase).OR.(jlo == 0))THEN
               CALL splint(xpad,ypad,y2,mphase,xxx,qqqa)
            ELSE
               jlotemp=jlo+1
               CALL fastsplint(xpad,ypad,y2,mphase,xxx,qqqa,jlo,jlotemp)
            END IF
            xxx=b
            CALL hunt(xpad,mphase,xxx,jlo)
            IF((jlo == mphase).OR.(jlo == 0))THEN
               CALL splint(xpad,ypad,y2,mphase,xxx,qqqb)
            ELSE
               jlotemp=jlo+1
               CALL fastsplint(xpad,ypad,y2,mphase,xxx,qqqb,jlo,jlotemp)
            END IF
            summ=0.5_dp*(b-a)*(qqqa+qqqb)
         ELSE
            it=2**(j-2)
            tnm=REAL(it,KIND=dp)
            del=(b-a)/tnm
            x=a+0.5_dp*del
            xxx=x
            s=0.0_dp
            DO  kk=1,it
               kcount=kcount+1
               CALL hunt(xpad,mphase,xxx,jlo)
               IF((jlo == mphase).OR.(jlo == 0))THEN
                  CALL splint(xpad,ypad,y2,mphase,xxx,qqq)
               ELSE
                  jlotemp=jlo+1
                  CALL fastsplint(xpad,ypad,y2,mphase,xxx,qqq,jlo,jlotemp)
               END IF
               s=s+qqq
               x=x+del
               xxx=x
            END DO
            summ=0.5_dp*(summ+(b-a)*s/tnm)
         END IF
!
      END DO
!
      yinter(i)=summ/pstep
!
   END DO
!
   DO  i=1,mphase
      ypad(i)=yinter(i)
   END DO
!
   CALL removepad(nphase,ymod,ypad)
!
   RETURN
!
END SUBROUTINE binlc
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE binlctime(nmaxphase,nphase,xmod,ymod,period,sw29,  &
   nsc,xsc,ysc,isw87)
!
!   This subroutine will bin a light curve in time, using a binsize given
!   by sw29, where the units are minutes.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN)                      :: nphase
   REAL(KIND=dp), INTENT(IN)                :: xmod(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: ymod(nmaxphase)
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: sw29
   INTEGER, INTENT(IN)                      :: nsc
   REAL(KIND=dp), INTENT(IN)                :: xsc(9999)
   REAL(KIND=dp), INTENT(IN)                :: ysc(9999)
   INTEGER, INTENT(IN)                      :: isw87
!
   REAL(KIND=dp)  :: ww1,ww2,pstep,pwidth,summ,a,b,xxx,qqqa,qqqb,tnm
   REAL(KIND=dp)  :: x,s,qqq,del
!
   INTEGER :: kk,mphase,nn,kcount
   INTEGER :: jlo,i,j,it,jlotemp
!
   INTEGER, PARAMETER :: isize=7000000
!
   REAL(KIND=dp), ALLOCATABLE    ::  yinter(:),y2(:),xpad(:),ypad(:)
!
   ALLOCATE(xpad(isize),ypad(isize),yinter(isize),y2(isize))
!
   IF(isize < nmaxphase)THEN
      WRITE(*,*) 'Dimension error in subroutine binlctime.'
      WRITE(*,*) 'Change isize to be > Nmaxphase.'
      STOP
   END IF
!
   IF(isw87 >= 1)THEN
      ww1=5.0_dp/9.0_dp
      ww2=8.0_dp/9.0_dp
      loop31: DO kk=3,nphase-2

!
!   check if xmod(i) is in a SC range.  If so, set yiter(i)=ymod(i)
!   and go to 10
!
         yinter(kk)=ymod(kk)
         DO j=1,nsc
            IF((xmod(kk) >= xsc(j)).AND.(xmod(kk) <= ysc(j)))THEN
               CYCLE loop31  
            END IF
         END DO
!
         yinter(kk)=0.5_dp*(ww1*ymod(kk-2)+ww1*ymod(kk+2)+ww2* ymod(kk))
      END DO loop31
!
      DO kk=3,nphase-2
         ymod(kk)=yinter(kk)
      END DO
      DEALLOCATE(xpad,ypad,yinter,y2)
      RETURN
   END IF
!
   DO kk=1,nphase
      xpad(kk)=xmod(kk)
      ypad(kk)=ymod(kk)
   END DO
   mphase=nphase
!
!   We will interpolate the model, and given each value in xmod, figure
!   out the range of phase needed, and average the interpolated y-values
!
   CALL spline(xpad,ypad,mphase,0.0_dp,0.0_dp,y2)
!
   pstep=sw29/1440.0_dp/period
   pstep=sw29/60.0_dp/24.0_dp
   pwidth=0.5_dp*pstep
!
   nn=7
   loop30: DO  i=1,mphase
      kcount=0
      summ=0.0_dp
      jlo=i
!
!   check if xmod(i) is in a SC range.  If so, set yiter(i)=ymod(i)
!   and go to 10
!
      DO kk=1,nsc
         IF((xpad(i) >= xsc(kk)).AND.(xpad(i) <= ysc(kk)))THEN
            yinter(i)=ypad(i)
            CYCLE loop30  !GO TO 30
         END IF
      END DO
      a=xpad(i)-pwidth
      b=xpad(i)+pwidth
!
      DO  j=1,nn
         IF(j == 1)THEN
            xxx=a
            CALL hunt(xpad,mphase,xxx,jlo)
            IF((jlo == mphase).OR.(jlo == 0))THEN
               CALL splint(xpad,ypad,y2,mphase,xxx,qqqa)
            ELSE
               jlotemp=jlo+1
               CALL fastsplint(xpad,ypad,y2,mphase,xxx,qqqa,jlo,jlotemp)
            END IF
            xxx=b
            CALL hunt(xpad,mphase,xxx,jlo)
            IF((jlo == mphase).OR.(jlo == 0))THEN
               CALL splint(xpad,ypad,y2,mphase,xxx,qqqb)
            ELSE
               jlotemp=jlo+1
               CALL fastsplint(xpad,ypad,y2,mphase,xxx,qqqb,jlo,jlotemp)
            END IF
            summ=0.5_dp*(b-a)*(qqqa+qqqb)
         ELSE
            it=2**(j-2)
            tnm=REAL(it,KIND=dp)
            del=(b-a)/tnm
            x=a+0.5_dp*del
            xxx=x
            s=0.0_dp
            DO  kk=1,it
               kcount=kcount+1
               CALL hunt(xpad,mphase,xxx,jlo)
               IF((jlo == mphase).OR.(jlo == 0))THEN
                  CALL splint(xpad,ypad,y2,mphase,xxx,qqq)
               ELSE
                  jlotemp=jlo+1
                  CALL fastsplint(xpad,ypad,y2,mphase,xxx,qqq,jlo,jlotemp)
               END IF
               s=s+qqq
               x=x+del
               xxx=x
            END DO
            summ=0.5_dp*(summ+(b-a)*s/tnm)
         END IF
!
      END DO
!
      yinter(i)=summ/pstep
!
   END DO loop30
!
   DO  i=1,mphase
      ymod(i)=yinter(i)
   END DO
!
   DEALLOCATE(xpad,ypad,yinter,y2)
!
   RETURN
!
END SUBROUTINE binlctime
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE checkangle(anglein)
!
!   Makes sure an input angle is between 0 and 2*pi.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN OUT)                :: anglein
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
10 IF(anglein < 0.0_dp)anglein=anglein+twopie
   IF(anglein < 0.0_dp)GO TO 10
!
20 IF(anglein >= twopie)anglein=anglein-twopie
   IF(anglein >= twopie)GO TO 20
!
   RETURN
!
END SUBROUTINE checkangle
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE checkgap(ndynwin,dynwinlow,dynwinhigh,ngap,gaplow,  &
   gaphigh,tstart,tend,tstep)
!
!   This routine will check to see that the ELCgap intervals
!   are compatible with the ELCdynwin intervals
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndynwin
   REAL(KIND=dp), INTENT(IN)                :: dynwinlow(1000)
   REAL(KIND=dp), INTENT(IN)                :: dynwinhigh(1000)
   INTEGER, INTENT(IN)                      :: ngap
   REAL(KIND=dp), INTENT(IN)                :: gaplow(9999)
   REAL(KIND=dp), INTENT(IN)                :: gaphigh(9999)
   REAL(KIND=dp), INTENT(IN)                :: tstart
   REAL(KIND=dp), INTENT(IN OUT)            :: tend
   REAL(KIND=dp), INTENT(IN)                :: tstep
!
   REAL(KIND=dp)  ::  tin
!
   INTEGER :: i,j,nstep,igoodwin,k
!
!   We need to see if there are time points that are NOT in gaps
!   in ELCgap but are inside one of the ELCdynwin intervals
!
   IF(ngap <= 0)RETURN
!
   IF(ndynwin <= 1)RETURN
!
   tin=tstart
   nstep=NINT((tend-tstart)/tstep)
   loop30:  DO  i=1,nstep
      tin=tin+tstep
      IF(tin >= tend)RETURN
      DO  j=1,ngap
         IF((tin > gaplow(j)).AND.(tin < gaphigh(j)))CYCLE loop30
      END DO
!
!   The point is not in an ELCgap gap, so a light curve point
!   would be computed for it.  Check to see if that input time
!   is inside one of the ELCdynwin intervals
!
      igoodwin=0
      DO  k=1,ndynwin
         IF((tin >= dynwinlow(k)).AND.(tin <= dynwinhigh(k)))THEN
            igoodwin=igoodwin+1
         END IF
      END DO
!
!  If igoodwin is zero, then the input time did not fall inside
!  one of the ELCdynwin intervals.  Write an error message and stop.
!
      IF(igoodwin == 0)THEN
         WRITE(*,40)tin
         STOP
      END IF
   END DO loop30
!
40 FORMAT('Error:  ELCgap.inp and ELCdynwin.inp files are not ',  &
      'compatible at time ',f12.5)
!
   RETURN
!
END SUBROUTINE checkgap
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE checkinput(fill1,fill2,omega1,omega2,dphase,q,  &
   finc,teff1,teff2,tgrav1,tgrav2,betarim,rinner,router,  &
   alb1,alb2,nref,period,fm,separ,idraw,iecheck,iidint,  &
   ism1,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,ecc,pshift,  &
   ecosw,argper,temprat,ilaw,dwavex,dwavey,  &
   tertq,p2q,p3q,p4q,p5q,p6q,p7q,p8q,ioutflag,masssum,isw27)
!
   USE accur
   USE constants
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN OUT)            :: fill1
   REAL(KIND=dp), INTENT(IN)                :: fill2
   REAL(KIND=dp), INTENT(OUT)               :: omega1
   REAL(KIND=dp), INTENT(IN OUT)            :: omega2
   REAL(KIND=dp), INTENT(IN OUT)            :: dphase
   REAL(KIND=dp), INTENT(IN OUT)            :: q
   REAL(KIND=dp), INTENT(IN OUT)            :: finc
   REAL(KIND=dp), INTENT(IN)                :: teff1
   REAL(KIND=dp), INTENT(OUT)               :: teff2
   REAL(KIND=dp), INTENT(IN OUT)            :: tgrav1
   REAL(KIND=dp), INTENT(IN OUT)            :: tgrav2
   REAL(KIND=dp), INTENT(IN OUT)            :: betarim
   REAL(KIND=dp), INTENT(OUT)               :: rinner
   REAL(KIND=dp), INTENT(IN OUT)            :: router
   REAL(KIND=dp), INTENT(IN OUT)            :: alb1
   REAL(KIND=dp), INTENT(IN OUT)            :: alb2
   INTEGER, INTENT(IN OUT)                  :: nref
   REAL(KIND=dp), INTENT(IN OUT)            :: period
   REAL(KIND=dp), INTENT(IN OUT)            :: fm
   REAL(KIND=dp), INTENT(OUT)               :: separ
   INTEGER, INTENT(IN OUT)                  :: idraw
   INTEGER, INTENT(IN OUT)                  :: iecheck
   INTEGER, INTENT(IN OUT)                  :: iidint
   INTEGER, INTENT(OUT)                     :: ism1
   INTEGER, INTENT(OUT)                     :: icnu
   INTEGER, INTENT(OUT)                     :: icnb
   INTEGER, INTENT(OUT)                     :: icnv
   INTEGER, INTENT(OUT)                     :: icnr
   INTEGER, INTENT(OUT)                     :: icni
   INTEGER, INTENT(OUT)                     :: icnj
   INTEGER, INTENT(OUT)                     :: icnh
   INTEGER, INTENT(OUT)                     :: icnk
   REAL(KIND=dp), INTENT(OUT)               :: ecc
   REAL(KIND=dp), INTENT(OUT)               :: pshift
   REAL(KIND=dp), INTENT(IN OUT)            :: ecosw
   REAL(KIND=dp), INTENT(IN OUT)            :: argper
   REAL(KIND=dp), INTENT(IN)                :: temprat
   INTEGER, INTENT(IN OUT)                  :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: dwavex(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: dwavey(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: tertq
   REAL(KIND=dp), INTENT(OUT)               :: p2q
   REAL(KIND=dp), INTENT(OUT)               :: p3q
   REAL(KIND=dp), INTENT(OUT)               :: p4q
   REAL(KIND=dp), INTENT(OUT)               :: p5q
   REAL(KIND=dp), INTENT(OUT)               :: p6q
   REAL(KIND=dp), INTENT(OUT)               :: p7q
   REAL(KIND=dp), INTENT(OUT)               :: p8q
   INTEGER, INTENT(IN OUT)                  :: ioutflag
   REAL(KIND=dp), INTENT(IN OUT)            :: masssum
   INTEGER, INTENT(IN OUT)                  :: isw27
!
   REAL(KIND=dp) :: rad_in_cm
!
   INTEGER :: icount,jj
!
   CHARACTER(LEN=1) :: bell
!
!   December 15, 2013:  add the check for the triangular limb darkening
!   sampling:  both coefficients must be between 0.0 and 1.0
!
   bell=CHAR(7)
!
!   CALL constants(earthmassinsolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   IF(tertq > 999999999.0_dp)tertq=999999999.0_dp
   IF(p2q > 999999999.9_dp)p2q=999999999.0_dp
   IF(p3q > 999999999.9_dp)p3q=999999999.0_dp
   IF(p4q > 999999999.9_dp)p4q=999999999.0_dp
   IF(p5q > 999999999.9_dp)p5q=999999999.0_dp
   IF(p6q > 999999999.9_dp)p6q=999999999.0_dp
   IF(p7q > 999999999.9_dp)p7q=999999999.0_dp
   IF(p8q > 999999999.9_dp)p8q=999999999.0_dp
   IF((ilaw == 5).OR.(ilaw == 15))THEN
      DO jj=1,8
         IF(dwavex(jj,1) < 0.0_dp)dwavex(jj,1)=0.0_dp
         IF(dwavex(jj,2) < 0.0_dp)dwavex(jj,2)=0.0_dp
         IF(dwavex(jj,3) < 0.0_dp)dwavex(jj,3)=0.0_dp
         IF(dwavex(jj,4) < 0.0_dp)dwavex(jj,4)=0.0_dp
         IF(dwavex(jj,5) < 0.0_dp)dwavex(jj,5)=0.0_dp
         IF(dwavey(jj,1) < 0.0_dp)dwavey(jj,1)=0.0_dp
         IF(dwavey(jj,2) < 0.0_dp)dwavey(jj,2)=0.0_dp
         IF(dwavey(jj,3) < 0.0_dp)dwavey(jj,3)=0.0_dp
         IF(dwavey(jj,4) < 0.0_dp)dwavey(jj,4)=0.0_dp
         IF(dwavey(jj,5) < 0.0_dp)dwavey(jj,5)=0.0_dp
!
         IF(dwavex(jj,1) > 1.0_dp)dwavex(jj,1)=1.0_dp
         IF(dwavex(jj,2) > 1.0_dp)dwavex(jj,2)=1.0_dp
         IF(dwavex(jj,3) > 1.0_dp)dwavex(jj,3)=1.0_dp
         IF(dwavex(jj,4) > 1.0_dp)dwavex(jj,4)=1.0_dp
         IF(dwavex(jj,5) > 1.0_dp)dwavex(jj,5)=1.0_dp
         IF(dwavey(jj,1) > 1.0_dp)dwavey(jj,1)=1.0_dp
         IF(dwavey(jj,2) > 1.0_dp)dwavey(jj,2)=1.0_dp
         IF(dwavey(jj,3) > 1.0_dp)dwavey(jj,3)=1.0_dp
         IF(dwavey(jj,4) > 1.0_dp)dwavey(jj,4)=1.0_dp
         IF(dwavey(jj,5) > 1.0_dp)dwavey(jj,5)=1.0_dp
      END DO
   END IF
!
   bell=CHAR(7)
!
   IF(fill1 > 1.0_dp)THEN
      WRITE(*,140)bell
      STOP
   END IF
!
   IF(fill2 > 1.0_dp)THEN
      WRITE(*,140)bell
      STOP
   END IF
!
   IF(omega1 <= 0.0_dp)THEN
      WRITE(*,150)bell
      omega1=ABS(omega1)
   END IF
!
   IF(omega2 <= 0.0_dp)THEN
      WRITE(*,160)bell
      STOP
   END IF
!
   IF((dphase <= 0.0_dp).OR.(dphase > 360.0_dp))THEN
      WRITE(*,170)bell
      STOP
   END IF
!
   IF(q < 0.0_dp)THEN
      WRITE(*,180)bell
      STOP
   END IF
!
   IF(teff1 < 0.0_dp)THEN
      WRITE(*,190)bell
      STOP
   END IF
!
   IF(teff2 < 0.0_dp)THEN
      IF(ioutflag == 1)WRITE(2,200)
   END IF
!
   IF(tgrav1 <= 0.0_dp)THEN
      WRITE(*,220)bell
   END IF
!
   IF(tgrav2 <= 0.0_dp)THEN
      WRITE(*,230)bell
   END IF
!
   IF((betarim < 0.0_dp).AND.(iidint >= 1))THEN
      WRITE(*,240)bell
      STOP
   END IF
!
   IF((rinner < 0.0_dp).AND.(iidint >= 1))THEN
      WRITE(*,250)bell
      STOP
   END IF
!
   IF((router < 0.0_dp).AND.(iidint >= 1))THEN
      WRITE(*,260)bell
      STOP
   END IF
!
   IF(temprat > 0.0_dp)THEN
      teff2=teff1*temprat
      IF(ioutflag == 1)WRITE(2,210)teff2
   END IF
!
   IF((rinner < fill2).AND.(teff2 > 0.0_dp).AND.(iidint >= 1))THEN
      WRITE(*,270)bell,fill2
      IF(ioutflag == 1)WRITE(2,270)bell,fill2
      rinner=fill2
   END IF
!
   IF((rinner > 1.0_dp).AND.(iidint >= 1))THEN
      WRITE(*,280)bell
      STOP
   END IF
!
   IF((rinner >= router).AND.(iidint >= 1))THEN
      WRITE(*,285)bell
      STOP
   END IF
!
   IF((router > 1.0_dp).AND.(iidint >= 1))THEN
      WRITE(*,290)bell
      STOP
   END IF
!
   IF(alb1 < 0.0_dp)THEN
      WRITE(*,340)bell
      STOP
   END IF
!
   IF(alb2 < 0.0_dp)THEN
      WRITE(*,350)bell
      STOP
   END IF
!
   IF(alb1 > 1.0_dp)THEN
      WRITE(*,360)bell
      STOP
   END IF
!
   IF(alb2 > 1.0_dp)THEN
      WRITE(*,370)bell
      STOP
   END IF
!
   IF((separ < 0.0_dp).AND.(period <= 0.0_dp))THEN
      WRITE(*,380)bell
      STOP
   END IF
!
   IF(separ < 0.0_dp)THEN
      IF(ioutflag == 1)WRITE(2,400)
      CALL getradius(q,finc,rad_in_cm,fm,period,ecc)
      separ=rad_in_cm/solarrad
      IF(ioutflag == 1)WRITE(2,410)separ
   END IF
!
   IF(idraw > 0)THEN
      IF(ioutflag == 1)WRITE(2,420)
   END IF
!
   IF(iecheck < 0)THEN
      IF(ioutflag == 1)WRITE(2,430)
   END IF
!
   IF(iidint <= 0)THEN
      IF(ioutflag == 1)WRITE(2,440)
   END IF
!
   IF(nref > 5)THEN
      WRITE(*,450)bell
   END IF
!
   IF((ecc < 0.0_dp).OR.(ecc >= 1.0_dp))THEN
      WRITE(*,470)bell
      ecc=0.0_dp
   END IF
!
   IF((pshift < -1.0_dp))THEN
      WRITE(*,480)bell
      pshift=-1.0_dp
   END IF
   IF((pshift > 1.0_dp))THEN
      WRITE(*,480)bell
      pshift=1.0_dp
   END IF

   icount=0
   IF(icnu == 0)THEN
      icnu=430
   ELSE
      icount=icount+1
   END IF
   IF(icnb == 0)THEN
      icnb=430
   ELSE
      icount=icount+1
   END IF
   IF(icnv == 0)THEN
      icnv=430
   ELSE
      icount=icount+1
   END IF
   IF(icnr == 0)THEN
      icnr=430
   ELSE
      icount=icount+1
   END IF
   IF(icni == 0)THEN
      icni=430
   ELSE
      icount=icount+1
   END IF
   IF(icnj == 0)THEN
      icnj=430
   ELSE
      icount=icount+1
   END IF
   IF(icnh == 0)THEN
      icnh=430
   ELSE
      icount=icount+1
   END IF
   IF(icnk == 0)THEN
      icnk=430
   ELSE
      icount=icount+1
   END IF
!
!    UPDATE June 16, 2003
!
!    If in EBOP mode, set ism1=0
!
   IF((iecheck == 9).AND.(ecc > 0.0_dp))THEN
      ism1=0
      IF(ioutflag == 1)WRITE(2,490)
   END IF
!
   IF(icount == 0)WRITE(*,460)bell
!
!    July 29, 2005
!
!    If ecosw > 0 and ecc > 0 then set the value of argper
!
   IF((ecc > 0.0_dp).AND.(ecosw > 0.0_dp))THEN
      CALL getom(ecc,ecosw,argper)
      IF(ioutflag == 1)WRITE(2,10)argper
   END IF
!
   IF((ABS(q) <= EPSILON(q)).AND.(ABS(masssum) <= EPSILON(masssum)))THEN
      WRITE(*,500)bell
      STOP
   END IF
!
   IF((iidint >= 1).AND.(isw27 > 0))THEN
      WRITE(*,510)bell
      STOP
   END IF
!
10 FORMAT('Info:  The value of argper has been set to ',f8.4,' d'  &
      ,'egrees')
140 FORMAT(a1,'Error:  fill1 exceeds 1.0')
150 FORMAT(a1,'Error:  omega1 is less than 0.0')
160 FORMAT(a1,'Error:  omega1 is less than 0.0')
170 FORMAT(a1,'Error:  dphase is out of bounds (0.0 < dphase','  '  &
      ,'          < 360.0)')
180 FORMAT(a1,'Error:  Q is negative')
190 FORMAT(a1,'Error:  Teff1 is negative')
200 FORMAT(/'Info:  Teff2 is negative---star 2 will be invisible')
210 FORMAT(/'Info:  Teff2 is set to ',f10.4,' K')
220 FORMAT(a1,'Warning:  Tgrav1 is negative')
230 FORMAT(a1,'Warning:  Tgrav2 is negative')
240 FORMAT(a1,'Error:  betarim is negative')
250 FORMAT(a1,'Error:  rinner is negative')
260 FORMAT(a1,'Error:  router is negative')
270 FORMAT(a1,'Warning:  rinner is in inside star 2---setting ',''  &
      ,' rinner to fill2 (currently ',f5.3,')')
280 FORMAT(a1,'Error:  rinner exceeds 1.0')
285 FORMAT(a1,'Error:  rinner exceeds router')
290 FORMAT(a1,'Error:  router exceeds 1.0')
340 FORMAT(a1,'Error:  alb1 is less than 0')
350 FORMAT(a1,'Error:  alb2 is less than 0')
360 FORMAT(a1,'Error:  alb1 exceeds 1.0')
370 FORMAT(a1,'Error:  alb2 exceeds 1.0')
380 FORMAT(a1,'Error:  Period is less than 0.0')
400 FORMAT('Info:  separation is less than 0.0---computing ','the'  &
      ,' separation from Period and ','         f(M)')
410 FORMAT('Info:  the separation has been set to ',f9.5,' solar '  &
      ,'radii')
420 FORMAT('Info:  output files for drawing codes will be ','writ'  &
      ,'ten')
430 FORMAT('Info:  eclipse checking is turned off')
440 FORMAT(/'Info:  there will be no accretion disk')
450 FORMAT(a1,'Warning:  Nref is rather large---long ',' executio'  &
      ,'n time')
460 FORMAT(a1,'Error:  No filters are specified')
470 FORMAT(a1,'Error:  eccentricity is out of range')
480 FORMAT(a1,'Error:  pshift is out of range')
490 FORMAT('Info:  Use ism1=0 for iececk=9 and ecc > 0.0')
500 FORMAT(a1,'Error:  Q is zero and masssum is zero')
510 FORMAT(a1,'Error:  fitting for accretion disk when ', 'Nterms > 0')
   RETURN
!
END SUBROUTINE checkinput
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE clip(nhoriz,xhoriz,yhoriz,xvis,yvis,xhid,yhid,  &
   xedge,yedge)
!
!   October 21, 1999
!
!   This routine assumes that the point xvis,yvis is outside the polygon
!   (xhoriz,yhoriz) and the point xhid,yhid is inside the horizon.  It
!   then computes the coordinate of the point along the line joining the
!   two points that intersects the horizon.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nhoriz
   REAL(KIND=dp), INTENT(IN)                :: xhoriz(nhoriz)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz(nhoriz)
   REAL(KIND=dp), INTENT(IN OUT)            :: xvis
   REAL(KIND=dp), INTENT(IN OUT)            :: yvis
   REAL(KIND=dp), INTENT(IN OUT)            :: xhid
   REAL(KIND=dp), INTENT(IN OUT)            :: yhid
   REAL(KIND=dp), INTENT(OUT)               :: xedge
   REAL(KIND=dp), INTENT(OUT)               :: yedge
!
   REAL(KIND=dp)  :: xvsave,yvsave,xhsave,yhsave,rise,run,slope
!
   INTEGER :: i,iyes,icut
!
!   Find the slope
!
   xvsave=xvis
   yvsave=yvis
   xhsave=xhid
   yhsave=yhid
   rise=yvis-yhid
   run=xvis-xhid
   IF(ABS(run) <= EPSILON(run))THEN
      xedge=xvis
      DO  i=1,20
         iyes=-100
         yedge=(yvis+yhid)/2.0_dp
         CALL insidecircle(nhoriz,xhoriz,yhoriz,xedge,yedge,iyes,icut)
         IF(iyes == 100)THEN
!
!    inside horizon
!
            yhid=yedge
!
         ELSE
!
!    outside horizon
!
            yvis=yedge
!
         END IF
      END DO
      GO TO 30
   END IF
!
   slope=rise/run
   DO  i=1,20
      iyes=-100
      xedge=(xvis+xhid)/2.0_dp
      yedge=slope*(xedge-xhsave)+yhsave
      CALL insidecircle(nhoriz,xhoriz,yhoriz,xedge,yedge,iyes,icut)
      IF(iyes == 100)THEN
!
!   inside horizon
!
         xhid=xedge
!
      ELSE
!
!   outside horizon
!
         xvis=xedge
!
      END IF
   END DO
!
30 yvis=yvsave
   xvis=xvsave
   xhid=xhsave
   yhid=yhsave
!
   RETURN
!
END SUBROUTINE clip
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE cliplc(nmaxphase,icount,nphase,xmod,ymodu,ymodb,  &
   ymodv,ymodr,ymodi,ymodj,ymodh,ymodk,ymods1,ymods2,ymods3,  &
   ymodd,rv1,rv2,drv1,drv2)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN)                      :: icount
   INTEGER, INTENT(OUT)                     :: nphase
   REAL(KIND=dp), INTENT(OUT)               :: xmod(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodu(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodb(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodv(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodr(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodi(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodj(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodh(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodk(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods2(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods3(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodd(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: rv1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: rv2(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv2(nmaxphase)
!
   INTEGER :: i,jcount
!
   jcount=0
   DO  i=1,icount
      IF(ymods1(i) >= 0.0_dp)THEN
         jcount=jcount+1
         xmod(jcount)=xmod(i)
         ymodu(jcount)=ymodu(i)
         ymodb(jcount)=ymodb(i)
         ymodv(jcount)=ymodv(i)
         ymodr(jcount)=ymodr(i)
         ymodi(jcount)=ymodi(i)
         ymodj(jcount)=ymodj(i)
         ymodh(jcount)=ymodh(i)
         ymodk(jcount)=ymodk(i)
         ymods1(jcount)=ymods1(i)
         ymods2(jcount)=ymods2(i)
         ymods3(jcount)=ymods3(i)
         ymodd(jcount)=ymodd(i)
         rv1(jcount)=rv1(i)
         rv2(jcount)=rv2(i)
         drv1(jcount)=drv1(i)
         drv2(jcount)=drv2(i)
      END IF
   END DO
!
   nphase=jcount
!
   RETURN
!
END SUBROUTINE cliplc
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE clipstring(instring,outstring,lengthout)
!
!   Will remove leading spaces from the input string
!
   USE accur
!
   IMPLICIT NONE
!
   CHARACTER (LEN=*), INTENT(IN)            :: instring
   CHARACTER (LEN=*), INTENT(OUT)           :: outstring
   INTEGER, INTENT(OUT)                     :: lengthout
!
   INTEGER :: i,icount,k1
!
   outstring=instring
   icount=0
   k1=LEN_TRIM(instring)
   DO i=1,k1
      IF(instring(i:i) /= ' ')THEN
         icount=icount+1
         outstring(icount:icount)=instring(i:i)
      END IF
   END DO
!
   DO i=icount+1,k1
      outstring(i:i)=' '
   END DO
!
   lengthout=LEN_TRIM(outstring)
!
   RETURN
!
END SUBROUTINE clipstring
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE coefg(ns,c,b,bc,nsd,aa,e,nm,sm,nmd,am,hstep)
!
!   From Ernst Haier
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmd
   INTEGER, INTENT(OUT)                     :: nm
   INTEGER, INTENT(IN)                      :: ns
   REAL(KIND=dp), INTENT(OUT)               :: c(ns)
   REAL(KIND=dp), INTENT(OUT)               :: b(ns)
   REAL(KIND=dp), INTENT(OUT)               :: bc(ns)
   INTEGER, INTENT(IN)                      :: nsd
   REAL(KIND=dp), INTENT(OUT)               :: aa(nsd,ns)
   REAL(KIND=dp), INTENT(OUT)               :: e(nsd,ns+nmd)
   REAL(KIND=dp), INTENT(OUT)               :: sm(nmd)
   REAL(KIND=dp), INTENT(OUT)               :: am(nsd+nmd)
   REAL(KIND=dp), INTENT(IN)                :: hstep
!
   INTEGER :: is,js,im
!
   REAL(KIND=dp) ::  hstep2
!
   c=0.0_dp
   b=0.0_dp
   bc=0.0_dp
   aa=0.0_dp
   e=0.0_dp
   sm=0.0_dp
   am=0.0_dp
   nm=3
   IF(ns == 2)THEN
      c(1)=0.21132486540518711775E+00_dp
      c(2)=0.78867513459481288225E+00_dp
      b(1)=0.50000000000000000000E+00_dp
      b(2)=0.50000000000000000000E+00_dp
      bc(1)=0.39433756729740644113E+00_dp
      bc(2)=0.10566243270259355887E+00_dp
      aa(1,1)=0.41666666666666666667E-01_dp
      aa(1,2)=-0.19337567297406441127E-01_dp
      aa(2,1)=0.26933756729740644113E+00_dp
      aa(2,2)=0.41666666666666666667E-01_dp
      e(1,1)=-0.28457905077110526160E-02_dp
      e(1,2)=-0.63850024471784160410E-01_dp
      e(1,3)=0.48526095198694517563E-02_dp
      e(1,4)=0.11305688530429939012E+00_dp
      e(1,5)=-0.28884580475413403312E-01_dp
      e(2,1)=0.41122751744511433137E-01_dp
      e(2,2)=-0.18654814888622834132E+00_dp
      e(2,3)=-0.18110185277445209332E-01_dp
      e(2,4)=0.36674109449368040786E+00_dp
      e(2,5)=0.10779872188955481745E+00_dp
      sm(1)=0.00000000000000000000E+00_dp
      sm(2)=0.10000000000000000000E+01_dp
      sm(3)=0.16000000000000000000E+01_dp
      am(1)=0.25279583039343438291E+02_dp
      am(2)=-0.86907830393434382912E+01_dp
      am(3)=-0.80640000000000000000E+00_dp
      am(4)=0.29184000000000000000E+01_dp
      am(5)=0.00000000000000000000E+00_dp
   END IF
   IF(ns == 4)THEN
      c(1)=0.69431844202973712388E-01_dp
      c(2)=0.33000947820757186760E+00_dp
      c(3)=0.66999052179242813240E+00_dp
      c(4)=0.93056815579702628761E+00_dp
      b(1)=0.17392742256872692869E+00_dp
      b(2)=0.32607257743127307131E+00_dp
      b(3)=0.32607257743127307131E+00_dp
      b(4)=0.17392742256872692869E+00_dp
      bc(1)=0.16185132086231030665E+00_dp
      bc(2)=0.21846553629538057030E+00_dp
      bc(3)=0.10760704113589250101E+00_dp
      bc(4)=0.12076101706416622036E-01_dp
      aa(1,1)=0.40381914508467311298E-02_dp
      aa(1,2)=-0.32958609449446961650E-02_dp
      aa(1,3)=0.26447829520668538006E-02_dp
      aa(1,4)=-0.97672296325588161023E-03_dp
      aa(2,1)=0.43563580902396261254E-01_dp
      aa(2,2)=0.13818951406296126013E-01_dp
      aa(2,3)=-0.43401341944349953440E-02_dp
      aa(2,4)=0.14107297391595337720E-02_dp
      aa(3,1)=0.10586435263357640763E+00_dp
      aa(3,2)=0.10651836096505307395E+00_dp
      aa(3,3)=0.13818951406296126013E-01_dp
      aa(3,4)=-0.17580153590805494993E-02_dp
      aa(4,1)=0.14879849619263780300E+00_dp
      aa(4,2)=0.19847049885237718995E+00_dp
      aa(4,3)=0.81671359795877570687E-01_dp
      aa(4,4)=0.40381914508467311298E-02_dp
      e(1,1)=-0.21272768296134340207E-01_dp
      e(1,2)=0.11059138674756969912E-01_dp
      e(1,3)=0.38999255049973564023E-02_dp
      e(1,4)=-0.43986226789008967612E-01_dp
      e(1,5)=0.13581590305438849621E-01_dp
      e(1,6)=0.39922421675314269059E-01_dp
      e(1,7)=-0.79369058065113002021E-03_dp
      e(2,1)=-0.75671119283734809953E-02_dp
      e(2,2)=0.10209394000843457002E-01_dp
      e(2,3)=-0.12880197817980892596E-01_dp
      e(2,4)=-0.56381316813776501277E-01_dp
      e(2,5)=0.37440782682669799960E-02_dp
      e(2,6)=0.11522469441011273193E+00_dp
      e(2,7)=0.21035877343246316334E-02_dp
      e(3,1)=-0.39890571772473709759E+00_dp
      e(3,2)=0.26819725655216894347E+00_dp
      e(3,3)=-0.82551711648854471247E-01_dp
      e(3,4)=-0.85516559106259630212E+00_dp
      e(3,5)=0.24433810515772642570E+00_dp
      e(3,6)=0.10234155624049009806E+01_dp
      e(3,7)=0.25115745967236579242E-01_dp
      e(4,1)=-0.40964796048052939224E+00_dp
      e(4,2)=0.29949323098224574487E+00_dp
      e(4,3)=-0.13867460566101912494E+00_dp
      e(4,4)=-0.98859300714628940382E+00_dp
      e(4,5)=0.24671351779481625627E+00_dp
      e(4,6)=0.12912760231350872304E+01_dp
      e(4,7)=0.13241134766742798418E+00_dp
      sm(1)=0.00000000000000000000E+00_dp
      sm(2)=0.10000000000000000000E+01_dp
      sm(3)=0.16500000000000000000E+01_dp
      am(1)=0.10806374869244001787E+04_dp
      am(2)=-0.66008818661284690206E+03_dp
      am(3)=0.61810154357557529566E+03_dp
      am(4)=-0.31341427826212857229E+03_dp
      am(5)=-0.10187174765625000000E+02_dp
      am(6)=0.31173050390625000000E+02_dp
      am(7)=0.00000000000000000000E+00_dp
   END IF
   IF(ns == 6)THEN
      c(1)=0.33765242898423986094E-01_dp
      c(2)=0.16939530676686774317E+00_dp
      c(3)=0.38069040695840154568E+00_dp
      c(4)=0.61930959304159845432E+00_dp
      c(5)=0.83060469323313225683E+00_dp
      c(6)=0.96623475710157601391E+00_dp
      b(1)=0.85662246189585172520E-01_dp
      b(2)=0.18038078652406930378E+00_dp
      b(3)=0.23395696728634552369E+00_dp
      b(4)=0.23395696728634552369E+00_dp
      b(5)=0.18038078652406930378E+00_dp
      b(6)=0.85662246189585172520E-01_dp
      bc(1)=0.82769839639769234611E-01_dp
      bc(2)=0.14982512785597570103E+00_dp
      bc(3)=0.14489179419935320895E+00_dp
      bc(4)=0.89065173086992314743E-01_dp
      bc(5)=0.30555658668093602753E-01_dp
      bc(6)=0.28924065498159379092E-02_dp
      aa(1,1)=0.90625420195651151857E-03_dp
      aa(1,2)=-0.72859711612531400024E-03_dp
      aa(1,3)=0.79102695861167691135E-03_dp
      aa(1,4)=-0.70675390218535384182E-03_dp
      aa(1,5)=0.45647714224056921122E-03_dp
      aa(1,6)=-0.14836147050330408643E-03_dp
      aa(2,1)=0.11272367531794365387E-01_dp
      aa(2,2)=0.39083482447840698486E-02_dp
      aa(2,3)=-0.14724868010943911900E-02_dp
      aa(2,4)=0.10992669056588431310E-02_dp
      aa(2,5)=-0.67689040729401428165E-03_dp
      aa(2,6)=0.21677950347174141516E-03_dp
      aa(3,1)=0.30008019623627547434E-01_dp
      aa(3,2)=0.36978289259468146662E-01_dp
      aa(3,3)=0.65490339168957822692E-02_dp
      aa(3,4)=-0.16615098173008262274E-02_dp
      aa(3,5)=0.84753461862041607649E-03_dp
      aa(3,6)=-0.25877462623437421721E-03_dp
      aa(4,1)=0.49900269650650898941E-01_dp
      aa(4,2)=0.82003427445271620462E-01_dp
      aa(4,3)=0.54165111295060067982E-01_dp
      aa(4,4)=0.65490339168957822692E-02_dp
      aa(4,5)=-0.11352871017627472322E-02_dp
      aa(4,6)=0.28963081055952389031E-03_dp
      aa(5,1)=0.68475836671617248304E-01_dp
      aa(5,2)=0.11859257878058808400E+00_dp
      aa(5,3)=0.10635984886129551097E+00_dp
      aa(5,4)=0.47961474042181382443E-01_dp
      aa(5,5)=0.39083482447840698486E-02_dp
      aa(5,6)=-0.34600839001342442657E-03_dp
      aa(6,1)=0.79729071619449992615E-01_dp
      aa(6,2)=0.14419100392702230613E+00_dp
      aa(6,3)=0.13628542646896576408E+00_dp
      aa(6,4)=0.81956586217401900627E-01_dp
      aa(6,5)=0.23736460480774324642E-01_dp
      aa(6,6)=0.90625420195651151857E-03_dp
      e(1,1)=-0.16761132335280609813E-01_dp
      e(1,2)=0.10201050166615899799E-01_dp
      e(1,3)=-0.58593121685075943100E-02_dp
      e(1,4)=-0.11907383391366998251E-03_dp
      e(1,5)=0.10615611118132982241E-01_dp
      e(1,6)=-0.30692054230989138447E-01_dp
      e(1,7)=0.10615182045216224925E-01_dp
      e(1,8)=0.22586707045496892369E-01_dp
      e(1,9)=-0.16931992776201068110E-04_dp
      e(2,1)=0.10671755276327262128E-01_dp
      e(2,2)=-0.51098203653251450913E-02_dp
      e(2,3)=0.16062647299186369205E-03_dp
      e(2,4)=0.64818802653621866868E-02_dp
      e(2,5)=-0.12132386914873895089E-01_dp
      e(2,6)=-0.99709737725909584834E-02_dp
      e(2,7)=-0.70287093442894942752E-02_dp
      e(2,8)=0.31243249755879001843E-01_dp
      e(2,9)=0.31763603839792897936E-04_dp
      e(3,1)=-0.40875203230945019464E+00_dp
      e(3,2)=0.28214948905763253599E+00_dp
      e(3,3)=-0.22612660499718519054E+00_dp
      e(3,4)=0.13640993962985420478E+00_dp
      e(3,5)=0.15888529591697266925E+00_dp
      e(3,6)=-0.11667863471317749710E+01_dp
      e(3,7)=0.25224964119340060668E+00_dp
      e(3,8)=0.10440940643938620983E+01_dp
      e(3,9)=0.33914722176493324285E-03_dp
      e(4,1)=-0.29437531285359759661E+01_dp
      e(4,2)=0.20017220470127690267E+01_dp
      e(4,3)=-0.15383035791443948798E+01_dp
      e(4,4)=0.78114323215109899716E+00_dp
      e(4,5)=0.13930345104184182146E+01_dp
      e(4,6)=-0.75958281612589849630E+01_dp
      e(4,7)=0.18220129530415584951E+01_dp
      e(4,8)=0.62663163493155487560E+01_dp
      e(4,9)=0.54279630166374655267E-02_dp
      e(5,1)=-0.79572842006457093076E+01_dp
      e(5,2)=0.53527892762707449170E+01_dp
      e(5,3)=-0.40049139768467199697E+01_dp
      e(5,4)=0.18326058141135591515E+01_dp
      e(5,5)=0.39753886181058367500E+01_dp
      e(5,6)=-0.19423696478604790213E+02_dp
      e(5,7)=0.49362128400107292627E+01_dp
      e(5,8)=0.15601708062381928560E+02_dp
      e(5,9)=0.32142123424873719685E-01_dp
      e(6,1)=-0.78463118056075171475E+01_dp
      e(6,2)=0.53580869574441241664E+01_dp
      e(6,3)=-0.41476905275607763365E+01_dp
      e(6,4)=0.21275912797813913113E+01_dp
      e(6,5)=0.37642416878253538582E+01_dp
      e(6,6)=-0.20329681631523484613E+02_dp
      e(6,7)=0.48515418060343387549E+01_dp
      e(6,8)=0.16604467346259915039E+02_dp
      e(6,9)=0.84559690262225766975E-01_dp
      sm(1)=0.00000000000000000000E+00_dp
      sm(2)=0.10000000000000000000E+01_dp
      sm(3)=0.17500000000000000000E+01_dp
      am(1)=0.58080578375796358720E+05_dp
      am(2)=-0.33214989339522861968E+05_dp
      am(3)=0.28376088288312020853E+05_dp
      am(4)=-0.27923430684614999462E+05_dp
      am(5)=0.29743005589491042677E+05_dp
      am(6)=-0.15525927919158826444E+05_dp
      am(7)=-0.27700591278076171875E+03_dp
      am(8)=0.73086943817138671875E+03_dp
      am(9)=0.00000000000000000000E+00_dp
   END IF
!
   hstep2=hstep*hstep
   DO is=1,ns
      b(is)=hstep*b(is)
      bc(is)=hstep2*bc(is)
      c(is)=hstep*c(is)
      DO js=1,ns
         aa(is,js)=hstep2*aa(is,js)
         e(is,js)=hstep2*e(is,js)
      END DO
   END DO
   DO im=1,nm
      DO is=1,ns
         e(is,ns+im)=hstep2*e(is,ns+im)
      END DO
      am(ns+im)=hstep*am(ns+im)
   END DO
!
   RETURN
!
END SUBROUTINE coefg
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE computeinty(tin,gin,rmuin,maxlines,maxmu,nlines,  &
   atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,atmint5,  &
   atmint6,atmint7,atmint8,outinty,icnu,icnb,icnv,icnr,icni,  &
   icnj,icnh,icnk,itguess,dwavex,dwavey,ilaw,iatm,istar)
!
!   This routine will return values of the specific intensity for the
!   8 filters based on the input values of Tin, gin, and rmuin.
!
!   UPDATE SEPTEMBER 11, 2009
!
!   Modify this routine to use a parameterized limb darkening law when
!   iatm=2.  When iatm=2, compute the intensity at mu=1, then use
!   the limb darkening law to find I(mu).
!
   USE accur

   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: tin
   REAL(KIND=dp), INTENT(IN)                :: gin
   REAL(KIND=dp), INTENT(IN OUT)            :: rmuin
   INTEGER, INTENT(IN)                      :: maxlines
   INTEGER, INTENT(IN)                      :: maxmu
   INTEGER, INTENT(IN)                      :: nlines
   REAL(KIND=dp), INTENT(IN)                :: atmt(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmg(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmmu(maxlines,maxmu)
   INTEGER, INTENT(IN)                      :: nmu(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmint1(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint2(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint3(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint4(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint5(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint6(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint7(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint8(maxlines,maxmu)
   REAL(KIND=dp), INTENT(OUT)               :: outinty(8)
   INTEGER, INTENT(IN)                      :: icnu
   INTEGER, INTENT(IN)                      :: icnb
   INTEGER, INTENT(IN)                      :: icnv
   INTEGER, INTENT(IN)                      :: icnr
   INTEGER, INTENT(IN)                      :: icni
   INTEGER, INTENT(IN)                      :: icnj
   INTEGER, INTENT(IN)                      :: icnh
   INTEGER, INTENT(IN)                      :: icnk
   INTEGER, INTENT(IN OUT)                  :: itguess
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: iatm
   INTEGER, INTENT(IN)                      :: istar
!
   REAL(KIND=dp) :: rsvemu,gnew,tscratch,tempgh,ghinty,yscratch,svefy,dark
   REAL(KIND=dp) :: diff,qqq,tinty,tempgl,glinty,y2scratch,fx,fy,svefx
!
   INTEGER :: indext,nhigh
   INTEGER :: ingh,ingl,i,indexgh,j,ij,nlow,indexgl
!
   DIMENSION tempgh(400),tempgl(1000),gnew(2)
   DIMENSION ghinty(400,8),yscratch(400),tscratch(2),ingl(400)
   DIMENSION glinty(400,8),tinty(2,8),y2scratch(2),ingh(400)
!
!    UPDATE October 23, 2009
!
!     If iatm=2, then we are using a combination of model atmospheres
!     and a limb darkening law.  The model atmosphere intensity for
!     mu=1 will be found, and then a limb darkening law will be
!     used to find the intensity at other values of mu.
!
   outinty=0.0_dp
   DO i=1,400
      ingh(i)=0
      ingl(i)=0
      yscratch(i)=0.0_dp
      tempgh(i)=0.0_dp
      DO j=1,8
         ghinty(i,j)=0.0_dp
         glinty(i,j)=0.0_dp
      END DO
   END DO
   DO i=1,1000
      tempgl(i)=0.0_dp
   END DO
!
!     First, we need to save the input value of mu
!
   indexgh=2
   indexgl=1
   IF(iatm >= 2)rsvemu=rmuin
!
   CALL hunt(atmt,nlines,tin,itguess)
!
   gnew(1)=0.0_dp
   gnew(2)=0.0_dp
   indext=itguess
   tscratch(1)=atmt(indext+1)
!
!   Now search the Tvalues equal to atmT(indexT+1) and find the array
!   of gravities.
!
   nhigh=0
   ingh(1)=1
   ingl(1)=1
   DO  i=0,nlines-(indext+1)
      IF(ABS(atmt(indext+1+i) - atmt(indext+1)) <=  &
                      EPSILON(atmt(indext+1)))THEN
         nhigh=nhigh+1
         tempgh(nhigh)=atmg(indext+1+i)
         ingh(nhigh)=indext+1+i
      ELSE
         EXIT
      END IF
   END DO
!
   CALL locate(tempgh,nhigh,gin,indexgh)
!
!   Here is the case when the input log(g) value is in between
!   two tabulated log(g) values:
!
   IF((indexgh < nhigh).AND.(indexgh > 0))THEN
      gnew(1)=tempgh(indexgh)
      gnew(2)=tempgh(indexgh+1)
   END IF
!
!   If the input log(g) is larger than the largest tabulated log(g), then
!   wing it:  the polint routine will attempt to extrapolate.  This
!   is not too bad if the input log(g) is not too much larger than the
!   largest entry.
!
   IF((indexgh == nhigh).AND.(nhigh > 1))THEN
      gnew(1)=tempgh(nhigh-1)
      gnew(2)=tempgh(nhigh)
   END IF
!
!   Same, but for an input log(g) value smaller than the smallest table
!   entry for that temperature:
!
   IF(indexgh == 0)THEN
      gnew(1)=tempgh(1)
      gnew(2)=tempgh(2)
      indexgh=1
   END IF
!
!   Get the intensities for the gravities corresponding to indexgh
!   and indexgh+1.  The index numbers for these entries in the table
!   are ingh(indexgh) and ingh(indexgh+1).
!
   IF(ilaw > 10)THEN
      DO i=1,8
         dwavex(i,2)=dwavex(i,1)
         dwavey(i,2)=dwavey(i,1)
      END DO
   END IF
!
   IF(iatm >= 2)rmuin=1.0_dp
   CALL indexinty(ingh(indexgh),maxlines,maxmu,atmmu,atmint1,  &
      atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,nmu,  &
      rmuin,outinty,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk)
   DO  j=1,8
      ghinty(1,j)=outinty(j)
   END DO
!
   IF(iatm >= 2)rmuin=1.0_dp
   CALL indexinty(ingh(indexgh+1),maxlines,maxmu,atmmu,atmint1,  &
      atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,nmu,  &
      rmuin,outinty,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk)
   DO  ij=1,8
      ghinty(2,ij)=outinty(ij)
   END DO
!
   DO  i=1,8
      IF((i == 1).AND.(icnu == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 2).AND.(icnb == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 3).AND.(icnv == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 4).AND.(icnr == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 5).AND.(icni == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 6).AND.(icnj == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 7).AND.(icnh == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 8).AND.(icnk == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      DO  j=1,2
         yscratch(j)=ghinty(j,i)
      END DO
      diff=ABS(gnew(1)-gnew(2))
      qqq=0.0_dp
      IF(diff > 1.0E-05_dp)THEN
         qqq=((gnew(2)-gin)*yscratch(1)+(gin-gnew(1))*yscratch(2))/  &
            (gnew(2)-gnew(1))
!
         outinty(i)=qqq
         tinty(1,i)=qqq
      ELSE
         outinty(i)=yscratch(1)
         tinty(1,i)=yscratch(1)
      END IF
   END DO
!
!   Now search the Tvalues equal to atmT(indexT+1) and find the gravities.
!
   tscratch(2)=atmt(indext)
!
   nlow=0
   DO  i=0,indext-1
      IF(ABS(atmt(indext-i) - atmt(indext)) <= EPSILON(atmt(indext)))THEN
         nlow=nlow+1
         tempgl(nlow)=atmg(indext-i)
         ingl(nlow)=indext-i
      ELSE
         EXIT
      END IF
   END DO
   gnew(1)=tempgl(1)
   gnew(2)=tempgl(2)
!
   CALL locate(tempgl,nlow,gin,indexgl)
!
!   Here is the case when the input log(g) value is in between
!   two tabulated log(g) values:
!
   IF((indexgl < nlow).AND.(indexgl > 0))THEN
      gnew(1)=tempgl(indexgl)
      gnew(2)=tempgl(indexgl+1)
   END IF
!
!   If the input log(g) is larger than the largest tabulated log(g), then
!   wing it:  the polint routine will attempt to extrapolate.  This
!   is not too bad if the input log(g) is not too much larger than the
!   largest entry.
!
   IF(indexgl == nlow)THEN
      gnew(1)=tempgl(nlow-1)
      gnew(2)=tempgl(nlow)
   END IF
!
!   Same, but for an input log(g) value smaller than the smallest table
!   entry for that temperature:
!
   IF(indexgl == 0)THEN
      gnew(1)=tempgl(1)
      gnew(2)=tempgl(2)
      indexgl=1
   END IF
!
   IF(iatm >= 2)rmuin=1.0_dp
   CALL indexinty(ingl(indexgl),maxlines,maxmu,atmmu,atmint1,  &
      atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,nmu,  &
      rmuin,outinty,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk)
   DO  j=1,8
      glinty(1,j)=outinty(j)
   END DO
!
   IF(iatm >= 2)rmuin=1.0_dp
   CALL indexinty(ingl(indexgl+1),maxlines,maxmu,atmmu,atmint1,  &
      atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,nmu,  &
      rmuin,outinty,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk)
   DO  j=1,8
      glinty(2,j)=outinty(j)
   END DO
!
   DO  i=1,8
      IF((i == 1).AND.(icnu == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 2).AND.(icnb == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 3).AND.(icnv == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 4).AND.(icnr == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 5).AND.(icni == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 6).AND.(icnj == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 7).AND.(icnh == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 8).AND.(icnk == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      DO  j=1,2
         yscratch(j)=glinty(j,i)
      END DO
      diff=ABS(gnew(1)-gnew(2))
      IF(diff > 1.0E-05_dp)THEN
         qqq=((gnew(2)-gin)*yscratch(1)+(gin-gnew(1))*yscratch(2))/  &
            (gnew(2)-gnew(1))
         outinty(i)=qqq
         tinty(2,i)=qqq
      ELSE
         outinty(i)=yscratch(1)
         tinty(2,i)=yscratch(1)
      END IF
   END DO
!
!   Finally, take the final pass and interpolate between T
!
   DO  i=1,8
      IF((i == 1).AND.(icnu == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 2).AND.(icnb == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 3).AND.(icnv == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 4).AND.(icnr == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 5).AND.(icni == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 6).AND.(icnj == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 7).AND.(icnh == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 8).AND.(icnk == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      DO  j=1,2
         y2scratch(j)=tinty(j,i)
      END DO
      IF(ABS(tscratch(1) - tscratch(2)) >= EPSILON(tscratch(2)))THEN
         qqq=((tscratch(2)-tin)*y2scratch(1)+(tin-tscratch(1))*  &
            y2scratch(2))/(tscratch(2)-tscratch(1))
         outinty(i)=qqq
      ELSE
         outinty(i)=y2scratch(1)
      END IF
   END DO
!
!   UPDATE October 23, 2009
!
!   If iatm=2, we are using a limb darkening law to find the specific
!   intensity at values of mu different than 1.0.  Apply the limb
!   darkening correction here, based on ilaw and the user supplied
!   coefficients.
!
   IF(iatm >= 2)THEN
      DO  i=1,8
         fx=dwavex(i,istar)
         fy=dwavey(i,istar)
!
!   December 15, 2013:  add triangular sampling
!
         IF((ilaw == 5).OR.(ilaw == 15))THEN
            svefx=fx
            svefy=fy
            fx=2.0_dp*SQRT(svefx)*svefy
            fy=SQRT(svefx)*(1.0_dp-2.0_dp*svefy)
         END IF
         IF((ilaw == 6).OR.(ilaw == 16))THEN
            svefx=fx
            svefy=fy
            fx=1.0_dp-SQRT(svefx)*svefy
            fy=1.0_dp-SQRT(svefx)
         END IF
         IF((ilaw == 7).OR.(ilaw == 17))THEN
            svefx=fx
            svefy=fy
            fx=SQRT(svefx)*(1.0_dp-2.0_dp*svefy)
            fy=2.0_dp*SQRT(svefx)*svefy
         END IF
         dark=(1.0_dp-fx+fx*rsvemu)
         IF(ilaw == 2)dark=dark-fy*ABS(rsvemu)*LOG(ABS(rsvemu))
         IF(ilaw == 6)dark=dark-fy*ABS(rsvemu)*LOG(ABS(rsvemu))
         IF(ilaw == 3)dark=dark-fy*(1.0_dp-SQRT(ABS(rsvemu)))
         IF(ilaw == 7)dark=dark-fy*(1.0_dp-SQRT(ABS(rsvemu)))
         IF(ilaw == 4)dark=dark-fy*(1.0_dp-ABS(rsvemu))**2
         IF(ilaw == 5)dark=dark-fy*(1.0_dp-ABS(rsvemu))**2
         IF(ilaw == 12)dark=dark-fy*ABS(rsvemu)*LOG(ABS(rsvemu))
         IF(ilaw == 16)dark=dark-fy*ABS(rsvemu)*LOG(ABS(rsvemu))
         IF(ilaw == 13)dark=dark-fy*(1.0_dp-SQRT(ABS(rsvemu)))
         IF(ilaw == 17)dark=dark-fy*(1.0_dp-SQRT(ABS(rsvemu)))
         IF(ilaw == 14)dark=dark-fy*(1.0_dp-ABS(rsvemu))**2
         IF(ilaw == 15)dark=dark-fy*(1.0_dp-ABS(rsvemu))**2
         outinty(i)=outinty(i)*dark
      END DO
      rmuin=rsvemu
   END IF
!
   RETURN
!
END SUBROUTINE computeinty
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE contaminate(nmaxphase,nphase,xmod,ymodu,contam)
!
!   Will dilute the model using the parameter contam, useful
!   for fitting Kepler data. 
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN)                      :: nphase
   REAL(KIND=dp), INTENT(IN)                :: xmod(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: ymodu(nmaxphase)
   REAL(KIND=dp), INTENT(IN)                :: contam
!
   REAL(KIND=dp), ALLOCATABLE               ::  xscr(:),yscr(:)
   REAL(KIND=dp)                            :: rmed,yoff
!
   INTEGER :: i
!
   ALLOCATE(xscr(nmaxphase+10),yscr(nmaxphase+10))
!
   DO  i=1,nphase
      xscr(i)=xmod(i)
      yscr(i)=ymodu(i)
   END DO
!
   IF(nphase > 1)CALL sort2(nphase,yscr,xscr)
!
   rmed=yscr(nphase/2)
!
   yoff=contam*rmed/(1.0_dp-contam)
!
   DO  i=1,nphase
      ymodu(i)=ymodu(i)+yoff
      ymodu(i)=ymodu(i)*rmed/(rmed+yoff)
   END DO
!
   DEALLOCATE(xscr,yscr)
!
   RETURN
!
END SUBROUTINE contaminate
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE copydiskinty(nrmax,nthetamax,nradius,ntheta,dinty,  &
   savedinty,einty,saveeinty)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nrmax
   INTEGER, INTENT(IN)                      :: nthetamax
   INTEGER, INTENT(IN)                      :: nradius
   INTEGER, INTENT(IN)                      :: ntheta
   REAL(KIND=dp), INTENT(IN)                :: dinty(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: savedinty(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: einty(nthetamax*11)
   REAL(KIND=dp), INTENT(OUT)               :: saveeinty(nthetamax*11)
!
   INTEGER :: ir,ithet,iidx,iz
!
   DO  ir=1,nradius
      DO  ithet=1,ntheta
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(ir-1)*ntheta+ithet
         savedinty(iidx)=dinty(iidx)
      END DO
   END DO
!
   DO  ithet=1,ntheta
      DO  iz=1,11
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(iz-1)*ntheta+ithet
         saveeinty(iidx)=einty(iidx)
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE copydiskinty
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE copyinty(ialphmax1,ibetmax1,nalph1,nalph2,rinty1,  &
   saveinty1,rinty2,saveinty2,mmdx1,mmdx2,ibetlim1,ibetlim2,  &
   ialphmax2,ibetmax2)
!
!   May 1, 2000
!
!   This routine is needed to fix a bug in the output routine---the
!   incorrect intensities for the BB mode were being written.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax1
   INTEGER, INTENT(IN)                      :: ibetmax1
   INTEGER, INTENT(IN)                      :: nalph1
   INTEGER, INTENT(IN)                      :: nalph2
   INTEGER, INTENT(IN)                      :: ialphmax2
   INTEGER, INTENT(IN)                      :: ibetmax2
   REAL(KIND=dp), INTENT(IN)                :: rinty1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(OUT)               :: saveinty1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: rinty2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: saveinty2(ialphmax2*ibetmax2)
   INTEGER, INTENT(IN)                      :: mmdx1(ialphmax1,ibetmax1)
   INTEGER, INTENT(IN)                      :: mmdx2(ialphmax2,ibetmax2)
   INTEGER, INTENT(IN)                      :: ibetlim1(ialphmax1)
   INTEGER, INTENT(IN)                      :: ibetlim2(ialphmax2)
!
   INTEGER :: ialf,ibet,iidx
!
   DO  ialf=1,nalph1
      DO  ibet=1,ibetlim1(ialf)
         iidx=mmdx1(ialf,ibet)
         saveinty1(iidx)=rinty1(iidx)
      END DO
   END DO
!
   DO  ialf=1,nalph2
      DO  ibet=1,ibetlim2(ialf)
         iidx=mmdx2(ialf,ibet)
         saveinty2(iidx)=rinty2(iidx)
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE copyinty
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE copyinty3(ialphmax3,ibetmax3,nalph3,ibetlim3,  &
   mmdx3,rinty3,svinty3)
!
!   May 1, 2000
!
!   This routine is needed to fix a bug in the output routine---the
!   incorrect intensities for the BB mode were being written.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax3
   INTEGER, INTENT(IN)                      :: ibetmax3
   INTEGER, INTENT(IN)                      :: nalph3
   INTEGER, INTENT(IN)                      :: ibetlim3(ialphmax3)
   INTEGER, INTENT(IN)                      :: mmdx3(ialphmax3,ibetmax3)
   REAL(KIND=dp), INTENT(IN)                :: rinty3(ialphmax3*ibetmax3)
   REAL(KIND=dp), INTENT(OUT)               :: svinty3(ialphmax3*ibetmax3)
!
   INTEGER :: ialf,ibet,iidx
!
   DO  ialf=1,nalph3
      DO  ibet=1,ibetlim3(ialf)
         iidx=mmdx3(ialf,ibet)
         svinty3(iidx)=rinty3(iidx)
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE copyinty3
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE copytemp(ialphmax,ibetmax,nalph,tempold,tempnew,  &
   mmdx,ibetlim)
!
!   October 18, 1999
!
!   Copy the temperature array into a new array.  We need to keep
!   the original temperatures for the reflection effect routine
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalph
   REAL(KIND=dp), INTENT(IN)                :: tempold(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: tempnew(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
!
   INTEGER :: ialf,ibet,iidx
!
   DO  ialf=1,nalph
      DO  ibet=1,ibetlim(ialf)
         iidx=mmdx(ialf,ibet)
         tempnew(iidx)=tempold(iidx)
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE copytemp
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE counteclipse(ndynwin,tstart,tend,hh,period,  &
   neclipse,itime,Nbody)
!
!   Will estimate the maximum number of eclipses when
!   using the dynamical integrator
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN OUT)                  :: ndynwin
   REAL(KIND=dp), INTENT(IN)                :: tstart
   REAL(KIND=dp), INTENT(IN)                :: tend
   REAL(KIND=dp), INTENT(IN)                :: hh
   REAL(KIND=dp), INTENT(IN)                :: period
   INTEGER, INTENT(OUT)                     :: neclipse
   INTEGER, INTENT(IN)                      :: itime
   INTEGER, INTENT(IN)                      :: Nbody
!
   INTEGER :: i
!
   REAL(KIND=dp)  :: dynwinlow(1000),dynwinhigh(1000),ttt,tttsum
!
!  Load the dynamical windows, if any
!
   CALL getwin(ndynwin,dynwinlow,dynwinhigh,tstart,tend,hh)
!
   tttsum=0.0_dp
!
   DO i=1,ndynwin
      ttt=(dynwinhigh(i)-dynwinlow(i))/period
      tttsum=tttsum+ttt
   END DO
!
   IF((Nbody.ge.3).and.(itime.ge.2))THEN
      neclipse=nint(1.1_dp*tttsum)+15
   ELSE
      neclipse=1
   END IF
!
   RETURN
!
END SUBROUTINE counteclipse
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE counttable(maxlines,maxmu)
!
!   November 25, 1999
!
!   This routine will read the file with the model atmosphere data.  The
!   name is assumed to be 'ELC.atm', the the form is assumed to be the
!   following:
!
!   Teff   g
!   N_mu
!   mu1    intyU intyB intyV intyR intyI intyJ intyH intyK
!   mu2    intyU intyB intyV intyR intyI intyJ intyH intyK
!   ...
!
!   UPDATE January 9, 2009
!
!   make the variable atmint two dimensional, and have 8 copies called
!   atmint1, atmint2, ...
!
!   This routine will return the number of models, and the maximum
!   value of Nmu
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(OUT)                     :: maxlines
   INTEGER, INTENT(OUT)                     :: maxmu
!
   REAL(KIND=dp)  :: atmt,atmg,atmmu,atmint1,atmint2,atmint3,atmint4
   REAL(KIND=dp)  :: atmint6,atmint7,atmint8,tmax,tmin,gmax,gmin,atmint5
!
   INTEGER :: ios,i,nskip,j,nmu
!
   CHARACTER(LEN=60) :: BLANK
!
!   UPDATE June 14, 2002
!
!   Declare the variable bell to be character*1
!
   CHARACTER(LEN=1) :: bell
!
   ios=0
   OPEN(UNIT=19,FILE='ELC.atm',STATUS='old',ERR=70,IOSTAT=ios)
!
!   Read the header(s).
!
   nskip=0
   DO  i=1,100
      READ(19,80)BLANK
      IF(BLANK(1:2) == '#'.OR.BLANK(1:2) == '!'.OR.BLANK(1:2) ==  &
         '%')nskip=nskip+1
   END DO
!
   REWIND (19)
!
   IF(nskip <= 0)GO TO 30
   DO  i=1,nskip
      READ(19,80)BLANK
   END DO
!
!   Attempt to read in the intensity values.
!
30 tmax=-1000.0_dp
   tmin=10000000.0_dp
   gmax=-10000.0_dp
   gmin=11111.0_dp
   maxmu=-1
   maxlines=0
   DO  i=1,999999  !maxlines
      READ(19,*,END=60)atmt,atmg
      READ(19,*,END=60)nmu
      IF(nmu > maxmu)maxmu=nmu
      IF(atmt > tmax)tmax=atmt
      IF(atmt < tmin)tmin=atmt
      IF(atmg > gmax)gmax=atmg
      IF(atmg < gmin)gmin=atmg
      DO  j=1,nmu
         READ(19,*,END=60)atmmu,atmint1,atmint2,  &
            atmint3,atmint4,atmint5,atmint6,atmint7,atmint8
!
!   Add this line to check for repeated mu values.  If there
!   is a repeat, then add 0.0001 (February 9, 2000).
!
      END DO
   END DO
60 CLOSE(19)
!
   maxlines=i-1
!
70 IF(ios /= 0)THEN
      bell=CHAR(7)
      WRITE(*,90)bell
      STOP
   END IF
!
   RETURN
!
80 FORMAT(a60)
90 FORMAT(a1,'Error:  I can''t find the file ''ELC.atm''!')
!
END SUBROUTINE counttable
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE counttime(ngap,gaplow,gaphigh,ntime,timearray,  &
   tstart,tstop,tstep,nmaxphase,lengthtime)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: lengthtime
   INTEGER, INTENT(IN)                      :: ngap
   REAL(KIND=dp), INTENT(IN)                :: gaplow(9999)
   REAL(KIND=dp), INTENT(IN)                :: gaphigh(9999)
   INTEGER, INTENT(IN OUT)                  :: ntime
   REAL(KIND=dp), INTENT(IN OUT)            :: timearray(lengthtime)
   REAL(KIND=dp), INTENT(IN OUT)            :: tstart
   REAL(KIND=dp), INTENT(IN OUT)            :: tstop
   REAL(KIND=dp), INTENT(IN OUT)            :: tstep
   INTEGER, INTENT(IN)                      :: nmaxphase
!
   INTEGER :: icount,ijk,icounttime
!
   CALL filltime(ntime,timearray,tstart,tstop,tstep,lengthtime)
!
   icount=0
   loop10: DO  icounttime=1,ntime
      DO ijk=1,ngap
         IF((timearray(icounttime) > gaplow(ijk)).AND.  &
            (timearray(icounttime) < gaphigh(ijk)))THEN
            CYCLE loop10
         END IF
      END DO
      icount=icount+1
   END DO loop10
   IF(icount > nmaxphase)THEN
      WRITE(*,20)nmaxphase,icount
      STOP
   END IF
!
20 FORMAT('Error:  Nmaxphase is too small.  Its current ','value'  &
      ,' is ',i7/'Requested light curve has a length of ',i7)
!
   RETURN
!
END SUBROUTINE counttime
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION ddelta(fincr,omegar,ecc,theta)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp)                :: ddelta
!
   REAL(KIND=dp), INTENT(IN)    :: fincr
   REAL(KIND=dp), INTENT(IN)    :: omegar
   REAL(KIND=dp), INTENT(IN)    :: ecc
   REAL(KIND=dp), INTENT(IN)    :: theta
!
   REAL(KIND=dp)                :: t1,t2,t3
!
   t1=1.0_dp-ecc*ecc
   t2=1.0_dp+ecc*COS(theta)
   t3=1.0_dp-(SIN(fincr)*SIN(theta+omegar))**2
   ddelta=t1/t2*SQRT(t3)
!
   RETURN
!
END FUNCTION ddelta
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION deltap(fincr,omegar,ecc,theta)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp)               :: deltap
!
   REAL(KIND=dp), INTENT(IN)   :: fincr
   REAL(KIND=dp), INTENT(IN)   :: omegar
   REAL(KIND=dp), INTENT(IN)   :: ecc
   REAL(KIND=dp), INTENT(IN)   :: theta
!
   REAL(KIND=dp)               :: ttiny,t1,t2,ddelta
!
   ttiny=1.0E-04_dp
!
   t1=ddelta(fincr,omegar,ecc,theta+ttiny)
   t2=ddelta(fincr,omegar,ecc,theta-ttiny)
   deltap=(t1-t2)/(2.0_dp*ttiny)
!
   RETURN
!
END FUNCTION deltap
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION deltapp(fincr,omegar,ecc,theta)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp)                :: deltapp
   REAL(KIND=dp), INTENT(IN)    :: fincr
   REAL(KIND=dp), INTENT(IN)    :: omegar
   REAL(KIND=dp), INTENT(IN)    :: ecc
   REAL(KIND=dp), INTENT(IN)    :: theta
!
   REAL(KIND=dp)                :: ttiny,t1,t2,deltap
!
   ttiny=1.0E-04_dp
!
   t1=deltap(fincr,omegar,ecc,theta+ttiny)
   t2=deltap(fincr,omegar,ecc,theta-ttiny)
   deltapp=(t1-t2)/(2.0_dp*ttiny)
!
   RETURN
!
END FUNCTION deltapp
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE dequa(n,y,f,igr,rmass,nbody,tideparm,isw80)
!
!   from Earnst Haier, modifed by Orosz.  Force equations for the
!   N-body problem, with GR and tidal apsidal motion corrections
!
   USE accur
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: y(n)
   REAL(KIND=dp), INTENT(OUT)               :: f(n)
   INTEGER, INTENT(IN)                      :: igr
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: tideparm(20)
   INTEGER, INTENT(IN)                      :: isw80
!
   REAL(KIND=dp)  ::  d(10,10),m(10),x21_z,rm21,rnu,x21_x,x21_y,v21_x
   REAL(KIND=dp)  ::  v21_y,v21_z,r21norm,r21dot,v21dot,agr,cgrx,bgr
   REAL(KIND=dp)  ::  cgry,cgrz,omega1x,omega1y,omega1z,omega2x,omega2y
   REAL(KIND=dp)  ::  omega2z,omega1norm,omega2norm,tidek1,tidek2,frac1
   REAL(KIND=dp)  ::  frac2,aqp,bqp,qpt,qptx,qpty,qptz
!
   INTEGER :: jj,i,i1,j,j1,jndex2,jndex1
!
!   force equations for first-order system, from E. Hairer
!
!   if iGR = 1, then add GR corrections
!   if iGR = 2, then add tidal corrections
!
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   DO jj=1,nbody
      m(jj)=rmass(jj)
   END DO
   DO i=1,nbody-1
      i1=3*(i-1)+1
      DO j=i+1,nbody
         j1=3*(j-1)+1
         d(i,j)=(SQRT((y(i1)-y(j1))**2+(y(i1+1)-y(j1+1))**2+(y(i1+  &
            2)-y(j1+2))**2))**3
         d(j,i)=d(i,j)
      END DO
   END DO
   DO i=1,nbody
      i1=3*(i-1)+1
      f(nbody*3+i1)=0.0_dp
      f(nbody*3+i1+1)=0.0_dp
      f(nbody*3+i1+2)=0.0_dp
      DO j=1,nbody
         IF(j /= i)THEN
            j1=3*(j-1)+1
            f(nbody*3+i1)=f(nbody*3+i1)+m(j)*(y(j1)-y(i1))/d(i,j)
            f(nbody*3+i1+1)=f(nbody*3+i1+1)+m(j)*(y(j1+1)-y(i1+1))/d(i,j)
            f(nbody*3+i1+2)=f(nbody*3+i1+2)+m(j)*(y(j1+2)-y(i1+2))/d(i,j)
         END IF
      END DO
      f(nbody*3+i1+0)=g*f(nbody*3+i1+0)
      f(nbody*3+i1+1)=g*f(nbody*3+i1+1)
      f(nbody*3+i1+2)=g*f(nbody*3+i1+2)
      f(i1+0)=y(nbody*3+i1+0)
      f(i1+1)=y(nbody*3+i1+1)
      f(i1+2)=y(nbody*3+i1+2)
   END DO
!
   IF(igr == 1)THEN
!
!   add GR correction to the force equations
!
!   corrections for the inner binary
!
      rm21=rmass(1)+rmass(2)
      rnu=rmass(1)*rmass(2)/rm21**2
      x21_x=y(4)-y(1)
      x21_y=y(5)-y(2)
      x21_z=y(6)-y(3)
      jndex2=3*(nbody+1)  ! =12 for 3 bodies, 15 for 4 bodies
      jndex1=3*nbody      ! = 9 for 3 bodies, 12 for 4 bodies
      v21_x=y(jndex2+1)-y(jndex1+1)
      v21_y=y(jndex2+2)-y(jndex1+2)
      v21_z=y(jndex2+3)-y(jndex1+3)
      r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
      r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
      v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
      agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
         r21norm-1.5_dp*rnu*(r21dot)**2
      bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
      cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
      cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
      cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
      f(jndex1+1)=f(jndex1+1)-rmass(2)*cgrx
      f(jndex1+2)=f(jndex1+2)-rmass(2)*cgry
      f(jndex1+3)=f(jndex1+3)-rmass(2)*cgrz
      f(jndex2+1)=f(jndex2+1)+rmass(1)*cgrx
      f(jndex2+2)=f(jndex2+2)+rmass(1)*cgry
      f(jndex2+3)=f(jndex2+3)+rmass(1)*cgrz
!
!   corrections for body 1 to 3
!
      rm21=rmass(1)+rmass(3)
      rnu=rmass(1)*rmass(3)/rm21**2
      x21_x=y(7)-y(1)
      x21_y=y(8)-y(2)
      x21_z=y(9)-y(3)
      jndex2=3*(nbody+1)+3   ! = 15 for three bodies
      jndex1=3*nbody
      v21_x=y(jndex2+1)-y(jndex1+1)
      v21_y=y(jndex2+2)-y(jndex1+2)
      v21_z=y(jndex2+3)-y(jndex1+3)
      r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
      r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
      v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
      agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
         r21norm-1.5_dp*rnu*(r21dot)**2
      bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
      cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
      cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
      cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
      f(jndex1+1)=f(jndex1+1)-rmass(3)*cgrx
      f(jndex1+2)=f(jndex1+2)-rmass(3)*cgry
      f(jndex1+3)=f(jndex1+3)-rmass(3)*cgrz
      f(jndex2+1)=f(jndex2+1)+rmass(1)*cgrx
      f(jndex2+2)=f(jndex2+2)+rmass(1)*cgry
      f(jndex2+3)=f(jndex2+3)+rmass(1)*cgrz
!
!   corrections for body 2 to 3
!
      rm21=rmass(2)+rmass(3)
      rnu=rmass(2)*rmass(3)/rm21**2
      x21_x=y(7)-y(4)
      x21_y=y(8)-y(5)
      x21_z=y(9)-y(6)
      jndex2=3*(nbody+1)+3  ! = 15 for three bodies
      jndex1=3*(nbody+1)    ! = 12 for three bodies
      v21_x=y(jndex2+1)-y(jndex1+1)
      v21_y=y(jndex2+2)-y(jndex1+2)
      v21_z=y(jndex2+3)-y(jndex1+3)
      r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
      r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
      v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
      agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
         r21norm-1.5_dp*rnu*(r21dot)**2
      bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
      cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
      cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
      cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
      f(jndex1+1)=f(jndex1+1)-rmass(3)*cgrx
      f(jndex1+2)=f(jndex1+2)-rmass(3)*cgry
      f(jndex1+3)=f(jndex1+3)-rmass(3)*cgrz
      f(jndex2+1)=f(jndex2+1)+rmass(2)*cgrx
      f(jndex2+2)=f(jndex2+2)+rmass(2)*cgry
      f(jndex2+3)=f(jndex2+3)+rmass(2)*cgrz
!
!   corrections for body 4
!
      IF(nbody >= 4)THEN
!
!   body 1 to 4
!
         rm21=rmass(1)+rmass(4)
         rnu=rmass(1)*rmass(4)/rm21**2
         x21_x=y(10)-y(1)
         x21_y=y(11)-y(2)
         x21_z=y(12)-y(3)
         jndex2=3*(nbody+1)+6  ! = 21 for four bodies
         jndex1=3*nbody
         v21_x=y(jndex2+1)-y(jndex1+1)
         v21_y=y(jndex2+2)-y(jndex1+2)
         v21_z=y(jndex2+3)-y(jndex1+3)
         r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
         r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
         v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
         agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
            r21norm-1.5_dp*rnu*(r21dot)**2
         bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
         cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
         cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
         cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
         f(jndex1+1)=f(jndex1+1)-rmass(4)*cgrx
         f(jndex1+2)=f(jndex1+2)-rmass(4)*cgry
         f(jndex1+3)=f(jndex1+3)-rmass(4)*cgrz
         f(jndex2+1)=f(jndex2+1)+rmass(1)*cgrx
         f(jndex2+2)=f(jndex2+2)+rmass(1)*cgry
         f(jndex2+3)=f(jndex2+3)+rmass(1)*cgrz
!
!   body 2 to 4
!
         rm21=rmass(2)+rmass(4)
         rnu=rmass(2)*rmass(4)/rm21**2
         x21_x=y(10)-y(4)
         x21_y=y(11)-y(5)
         x21_z=y(12)-y(6)
         jndex2=3*(nbody+1)+6  ! = 21 for four bodies
         jndex1=3*nbody+3      ! = 15 for four bodies
         v21_x=y(jndex2+1)-y(jndex1+1)
         v21_y=y(jndex2+2)-y(jndex1+2)
         v21_z=y(jndex2+3)-y(jndex1+3)
         r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
         r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
         v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
         agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
            r21norm-1.5_dp*rnu*(r21dot)**2
         bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
         cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
         cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
         cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
         f(jndex1+1)=f(jndex1+1)-rmass(4)*cgrx
         f(jndex1+2)=f(jndex1+2)-rmass(4)*cgry
         f(jndex1+3)=f(jndex1+3)-rmass(4)*cgrz
         f(jndex2+1)=f(jndex2+1)+rmass(2)*cgrx
         f(jndex2+2)=f(jndex2+2)+rmass(2)*cgry
         f(jndex2+3)=f(jndex2+3)+rmass(2)*cgrz
!
!   body 3 to 4
!
         rm21=rmass(2)+rmass(4)
         rnu=rmass(2)*rmass(4)/rm21**2
         x21_x=y(10)-y(7)
         x21_y=y(11)-y(8)
         x21_z=y(12)-y(9)
         jndex2=3*(nbody+1)+6  ! = 21 for four bodies
         jndex1=3*nbody+6      ! = 18 for four bodies
         v21_x=y(jndex2+1)-y(jndex1+1)
         v21_y=y(jndex2+2)-y(jndex1+2)
         v21_z=y(jndex2+3)-y(jndex1+3)
         r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
         r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
         v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!            xv21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)
!
         agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
            r21norm-1.5_dp*rnu*(r21dot)**2
         bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
         cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
         cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
         cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
         f(jndex1+1)=f(jndex1+1)-rmass(4)*cgrx
         f(jndex1+2)=f(jndex1+2)-rmass(4)*cgry
         f(jndex1+3)=f(jndex1+3)-rmass(4)*cgrz
         f(jndex2+1)=f(jndex2+1)+rmass(3)*cgrx
         f(jndex2+2)=f(jndex2+2)+rmass(3)*cgry
         f(jndex2+3)=f(jndex2+3)+rmass(3)*cgrz
!
!   end if Nbody.ge.4
!
      END IF
!
!  end  if iGR=1
!
   END IF
!
   IF(igr == 2)THEN
!
!   add tidal correction to the force equations, first two
!   bodies
!
      rm21=rmass(1)+rmass(2)
      rnu=rmass(1)*rmass(2)/rm21**2
      x21_x=y(4)-y(1)
      x21_y=y(5)-y(2)
      x21_z=y(6)-y(3)
      jndex2=(nbody+1)*3
      jndex1=(nbody)*3
      v21_x=y(jndex2+1)-y(jndex1+1)
      v21_y=y(jndex2+2)-y(jndex1+2)
      v21_z=y(jndex2+3)-y(jndex1+3)
      r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
      r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
      v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
!  omega below is hut*(2*pi/period) where hut is given by
!
!     hut=(1.0d0+7.5d0*ecc*ecc+5.625d0*ecc**4+
!       0.3125d0*ecc**6)/((1.0d0+3.0d0*ecc*ecc+
!       3.0d0/8.0d0*ecc**4)*dsqrt((1.0d0-ecc*ecc)**3))
!
      omega1x=tideparm(5)!x-component usually zero
      omega1y=tideparm(6)!y-component=omega*sin(i)
      omega1z=tideparm(7)!z-component=-omega*cos(i)
      omega2x=tideparm(8)!x-component usually zero
      omega2y=tideparm(9)!y-component=omega*sin(i)
      omega2z=tideparm(10)!z-component=-omega*cos(i)
      omega1norm=SQRT(omega1x**2+omega1y**2+omega1z**2)
      omega2norm=SQRT(omega2x**2+omega2y**2+omega2z**2)
      tidek1=tideparm(1)!coefficient on the order of 0.005
      tidek2=tideparm(2)!coefficient on the order of 0.005
      frac1=tideparm(3)!this is the radius in AU
      frac2=tideparm(4)!this is the radius in AU
!
!   term for star 1.  Note the factor is 6 and not 12
!
      aqp=5.0_dp*((omega1x*x21_x+omega1y*x21_y+omega1z*x21_z)/  &
         r21norm)**2-omega1norm**2-6.0_dp*g*rmass(2)/r21norm**3
      bqp=-2.0_dp*(omega1x*x21_x+omega1y*x21_y+omega1z*x21_z)
      qpt=tidek1*((frac1/r21norm)**5)/rmass(1)

      qptx=qpt*(aqp*x21_x+bqp*omega1x)
      qpty=qpt*(aqp*x21_y+bqp*omega1y)
      qptz=qpt*(aqp*x21_z+bqp*omega1z)
      f(jndex1+1)=f(jndex1+1)-qptx*rmass(2)
      f(jndex1+2)=f(jndex1+2)-qpty*rmass(2)
      f(jndex1+3)=f(jndex1+3)-qptz*rmass(2)
      f(jndex2+1)=f(jndex2+1)+qptx*rmass(1)
      f(jndex2+2)=f(jndex2+2)+qpty*rmass(1)
      f(jndex2+3)=f(jndex2+3)+qptz*rmass(1)
!
!  do the same for star 2.
!  Note the coefficient is 6 and not 12
!
      aqp=5.0_dp*((omega2x*x21_x+omega2y*x21_y+omega2z*x21_z)/  &
         r21norm)**2-omega2norm**2-6.0_dp*g*rmass(1)/r21norm**3
      bqp=2.0_dp*(omega2x*x21_x+omega2y*x21_y+omega2z*x21_z)
      qpt=tidek2*((frac2/r21norm)**5)/rmass(2)
      qptx=qpt*(-aqp*x21_x+bqp*omega2x)
      qpty=qpt*(-aqp*x21_y+bqp*omega2y)
      qptz=qpt*(-aqp*x21_z+bqp*omega2z)
!
      f(jndex1+1)=f(jndex1+1)+rmass(2)*qptx
      f(jndex1+2)=f(jndex1+2)+rmass(2)*qpty
      f(jndex1+3)=f(jndex1+3)+rmass(2)*qptz
!
      f(jndex2+1)=f(jndex2+1)-qptx*rmass(1)
      f(jndex2+2)=f(jndex2+2)-qpty*rmass(1)
      f(jndex2+3)=f(jndex2+3)-qptz*rmass(1)
!
!   add tidal correction to the force equations, bodies 3 and 4
!
      IF((nbody == 4).AND.(isw80 > 0))THEN
         rm21=rmass(3)+rmass(4)
         rnu=rmass(3)*rmass(4)/rm21**2
         x21_x=y(10)-y(7)
         x21_y=y(11)-y(8)
         x21_z=y(12)-y(9)
         jndex2=3*(nbody+1)+6
         jndex1=3*nbody+6
         v21_x=y(jndex2+1)-y(jndex1+1)
         v21_y=y(jndex2+2)-y(jndex1+2)
         v21_z=y(jndex2+3)-y(jndex1+3)
         r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
         r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
         v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
!  omega below is hut*(2*pi/period) where hut is given by
!
!     hut=(1.0d0+7.5d0*ecc*ecc+5.625d0*ecc**4+
!       0.3125d0*ecc**6)/((1.0d0+3.0d0*ecc*ecc+
!       3.0d0/8.0d0*ecc**4)*dsqrt((1.0d0-ecc*ecc)**3))
!
         omega1x=tideparm(15)!x-component usually zero
         omega1y=tideparm(16)!y-component=omega*sin(i)
         omega1z=tideparm(17)!z-component=-omega*cos(i)
         omega2x=tideparm(18)!x-component usually zero
         omega2y=tideparm(19)!y-component=omega*sin(i)
         omega2z=tideparm(20)!z-component=-omega*cos(i)
         omega1norm=SQRT(omega1x**2+omega1y**2+omega1z**2)
         omega2norm=SQRT(omega2x**2+omega2y**2+omega2z**2)
         tidek1=tideparm(11)!coefficient on the order of 0.005
         tidek2=tideparm(12)!coefficient on the order of 0.005
         frac1=tideparm(13)!this is the radius in AU
         frac2=tideparm(14)!this is the radius in AU
!
!   term for star 3.  Note the factor is 6 and not 12
!
         aqp=5.0_dp*((omega1x*x21_x+omega1y*x21_y+omega1z*x21_z)/  &
            r21norm)**2-omega1norm**2-6.0_dp*g*rmass(4)/r21norm**3
         bqp=-2.0_dp*(omega1x*x21_x+omega1y*x21_y+omega1z*x21_z)
         qpt=tidek1*((frac1/r21norm)**5)/rmass(3)
!
         qptx=qpt*(aqp*x21_x+bqp*omega1x)
         qpty=qpt*(aqp*x21_y+bqp*omega1y)
         qptz=qpt*(aqp*x21_z+bqp*omega1z)
         f(jndex1+1)=f(jndex1+1)-qptx*rmass(4)
         f(jndex1+2)=f(jndex1+2)-qpty*rmass(4)
         f(jndex1+3)=f(jndex1+3)-qptz*rmass(4)
         f(jndex2+1)=f(jndex2+1)+qptx*rmass(3)
         f(jndex2+2)=f(jndex2+2)+qpty*rmass(3)
         f(jndex2+3)=f(jndex2+3)+qptz*rmass(3)
!
!  do the same for star 4.
!  Note the coefficient is 6 and not 12
!
         aqp=5.0_dp*((omega2x*x21_x+omega2y*x21_y+omega2z*x21_z)/  &
            r21norm)**2-omega2norm**2-6.0_dp*g*rmass(3)/r21norm**3
         bqp=2.0_dp*(omega2x*x21_x+omega2y*x21_y+omega2z*x21_z)
         qpt=tidek2*((frac2/r21norm)**5)/rmass(4)
         qptx=qpt*(-aqp*x21_x+bqp*omega2x)
         qpty=qpt*(-aqp*x21_y+bqp*omega2y)
         qptz=qpt*(-aqp*x21_z+bqp*omega2z)
!
         f(jndex1+1)=f(jndex1+1)+rmass(4)*qptx
         f(jndex1+2)=f(jndex1+2)+rmass(4)*qpty
         f(jndex1+3)=f(jndex1+3)+rmass(4)*qptz
!
         f(jndex2+1)=f(jndex2+1)-qptx*rmass(3)
         f(jndex2+2)=f(jndex2+2)-qpty*rmass(3)
         f(jndex2+3)=f(jndex2+3)-qptz*rmass(3)
!
      END IF
   END IF
!
   IF(igr >= 3)THEN
!
!   add tidal correction and GR to the force equations
!
!   GR corrections for body 1 to 2
!
      rm21=rmass(1)+rmass(2)
      rnu=rmass(1)*rmass(2)/rm21**2
      x21_x=y(4)-y(1)
      x21_y=y(5)-y(2)
      x21_z=y(6)-y(3)
      jndex2=3*(nbody+1)
      jndex1=3*nbody
      v21_x=y(jndex2+1)-y(jndex1+1)
      v21_y=y(jndex2+2)-y(jndex1+2)
      v21_z=y(jndex2+3)-y(jndex1+3)
      r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
      r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
      v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
      agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
         r21norm-1.5_dp*rnu*(r21dot)**2
      bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
      cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
      cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
      cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
      f(jndex1+1)=f(jndex1+1)-rmass(2)*cgrx
      f(jndex1+2)=f(jndex1+2)-rmass(2)*cgry
      f(jndex1+3)=f(jndex1+3)-rmass(2)*cgrz
      f(jndex2+1)=f(jndex2+1)+rmass(1)*cgrx
      f(jndex2+2)=f(jndex2+2)+rmass(1)*cgry
      f(jndex2+3)=f(jndex2+3)+rmass(1)*cgrz
!
!   corrections for body 1 to 3
!
      rm21=rmass(1)+rmass(3)
      rnu=rmass(1)*rmass(3)/rm21**2
      x21_x=y(7)-y(1)
      x21_y=y(8)-y(2)
      x21_z=y(9)-y(3)
      jndex2=3*(nbody+1)+3
      jndex1=3*nbody
      v21_x=y(jndex2+1)-y(jndex1+1)
      v21_y=y(jndex2+2)-y(jndex1+2)
      v21_z=y(jndex2+3)-y(jndex1+3)
      r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
      r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
      v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
      agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
         r21norm-1.5_dp*rnu*(r21dot)**2
      bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
      cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
      cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
      cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
      f(jndex1+1)=f(jndex1+1)-rmass(3)*cgrx
      f(jndex1+2)=f(jndex1+2)-rmass(3)*cgry
      f(jndex1+3)=f(jndex1+3)-rmass(3)*cgrz
      f(jndex2+1)=f(jndex2+1)+rmass(1)*cgrx
      f(jndex2+2)=f(jndex2+2)+rmass(1)*cgry
      f(jndex2+3)=f(jndex2+3)+rmass(1)*cgrz
!
!   corrections for body 2 to 3
!
      rm21=rmass(2)+rmass(3)
      rnu=rmass(2)*rmass(3)/rm21**2
      x21_x=y(7)-y(4)
      x21_y=y(8)-y(5)
      x21_z=y(9)-y(6)
      jndex2=3*(nbody+1)+3
      jndex1=3*(nbody+1)
      v21_x=y(jndex2+1)-y(jndex1+1)
      v21_y=y(jndex2+2)-y(jndex1+2)
      v21_z=y(jndex2+3)-y(jndex1+3)
      r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
      r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
      v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
      agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
         r21norm-1.5_dp*rnu*(r21dot)**2
      bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
      cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
      cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
      cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
      f(jndex1+1)=f(jndex1+1)-rmass(3)*cgrx
      f(jndex1+2)=f(jndex1+2)-rmass(3)*cgry
      f(jndex1+3)=f(jndex1+3)-rmass(3)*cgrz
      f(jndex2+1)=f(jndex2+1)+rmass(2)*cgrx
      f(jndex2+2)=f(jndex2+2)+rmass(2)*cgry
      f(jndex2+3)=f(jndex2+3)+rmass(2)*cgrz
!
!   corrections for body 4
!
      IF(nbody >= 4)THEN
!
!   body 1 to 4
!
         rm21=rmass(1)+rmass(4)
         rnu=rmass(1)*rmass(4)/rm21**2
         x21_x=y(10)-y(1)
         x21_y=y(11)-y(2)
         x21_z=y(12)-y(3)
         jndex2=3*(nbody+1)+6 !=21 for four bodies
         jndex1=3*nbody! = 12 for four bodies
         v21_x=y(jndex2+1)-y(jndex1+1)
         v21_y=y(jndex2+2)-y(jndex1+2)
         v21_z=y(jndex2+3)-y(jndex1+3)
         r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
         r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
         v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
         agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
            r21norm-1.5_dp*rnu*(r21dot)**2
         bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
         cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
         cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
         cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
         f(jndex1+1)=f(jndex1+1)-rmass(4)*cgrx
         f(jndex1+2)=f(jndex1+2)-rmass(4)*cgry
         f(jndex1+3)=f(jndex1+3)-rmass(4)*cgrz
         f(jndex2+1)=f(jndex2+1)+rmass(1)*cgrx
         f(jndex2+2)=f(jndex2+2)+rmass(1)*cgry
         f(jndex2+3)=f(jndex2+3)+rmass(1)*cgrz
!
!   body 2 to 4
!
         rm21=rmass(2)+rmass(4)
         rnu=rmass(2)*rmass(4)/rm21**2
         x21_x=y(10)-y(4)
         x21_y=y(11)-y(5)
         x21_z=y(12)-y(6)
         jndex2=3*(nbody+1)+6!=21 for four bodies
         jndex1=3*nbody+3!=15 for four bodies
         v21_x=y(jndex2+1)-y(jndex1+1)
         v21_y=y(jndex2+2)-y(jndex1+2)
         v21_z=y(jndex2+3)-y(jndex1+3)
         r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
         r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
         v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
         agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
            r21norm-1.5_dp*rnu*(r21dot)**2
         bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
         cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
         cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
         cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
         f(jndex1+1)=f(jndex1+1)-rmass(4)*cgrx
         f(jndex1+2)=f(jndex1+2)-rmass(4)*cgry
         f(jndex1+3)=f(jndex1+3)-rmass(4)*cgrz
         f(jndex2+1)=f(jndex2+1)+rmass(2)*cgrx
         f(jndex2+2)=f(jndex2+2)+rmass(2)*cgry
         f(jndex2+3)=f(jndex2+3)+rmass(2)*cgrz
!
!   body 3 to 4
!
         rm21=rmass(2)+rmass(4)
         rnu=rmass(2)*rmass(4)/rm21**2
         x21_x=y(10)-y(7)
         x21_y=y(11)-y(8)
         x21_z=y(12)-y(9)
         jndex2=3*(nbody+1)+6! = 21 for four bodies
         jndex1=3*nbody+6! = 18 for four bodies
         v21_x=y(jndex2+1)-y(jndex1+1)
         v21_y=y(jndex2+2)-y(jndex1+2)
         v21_z=y(jndex2+3)-y(jndex1+3)
         r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
         r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
         v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
         agr=(1.0_dp+3.0_dp*rnu)*v21dot-2.0_dp*(2.0_dp+rnu)*g*rm21/  &
            r21norm-1.5_dp*rnu*(r21dot)**2
         bgr=-2.0_dp*(2.0_dp-rnu)*r21dot*r21norm
         cgrx=-(g/(r21norm**3*speedauperday**2))*(agr*x21_x+bgr*v21_x)
         cgry=-(g/(r21norm**3*speedauperday**2))*(agr*x21_y+bgr*v21_y)
         cgrz=-(g/(r21norm**3*speedauperday**2))*(agr*x21_z+bgr*v21_z)
!
         f(jndex1+1)=f(jndex1+1)-rmass(4)*cgrx
         f(jndex1+2)=f(jndex1+2)-rmass(4)*cgry
         f(jndex1+3)=f(jndex1+3)-rmass(4)*cgrz
         f(jndex2+1)=f(jndex2+1)+rmass(3)*cgrx
         f(jndex2+2)=f(jndex2+2)+rmass(3)*cgry
         f(jndex2+3)=f(jndex2+3)+rmass(3)*cgrz
!
!   end if Nbody.ge.4
!
      END IF
!
!  omega below is hut*(2*pi/period) where hut is given by
!
!     hut=(1.0d0+7.5d0*ecc*ecc+5.625d0*ecc**4+
!       0.3125d0*ecc**6)/((1.0d0+3.0d0*ecc*ecc+
!       3.0d0/8.0d0*ecc**4)*dsqrt((1.0d0-ecc*ecc)**3))
!
      omega1x=tideparm(5)!x-componentusuallyzero
      omega1y=tideparm(6)!y-component=omega*sin(i)
      omega1z=tideparm(7)!z-component=-omega*cos(i)
      omega2x=tideparm(8)!x-componentusuallyzero
      omega2y=tideparm(9)!y-component=omega*sin(i)
      omega2z=tideparm(10)!z-component=-omega*cos(i)
      omega1norm=SQRT(omega1x**2+omega1y**2+omega1z**2)
      omega2norm=SQRT(omega2x**2+omega2y**2+omega2z**2)
      tidek1=tideparm(1)!coefficient on the order of 0.005
      tidek2=tideparm(2)!coefficient on the order of 0.005
      frac1=tideparm(3)!this is the radius in AU
      frac2=tideparm(4)!this is the radius in AU
!
!  reset the vectors for body 1 to body 2
!
      rm21=rmass(1)+rmass(2)
      rnu=rmass(1)*rmass(2)/rm21**2
      x21_x=y(4)-y(1)
      x21_y=y(5)-y(2)
      x21_z=y(6)-y(3)
      jndex2=3*(nbody+1)
      jndex1=3*nbody  !+6
      v21_x=y(jndex2+1)-y(jndex1+1)
      v21_y=y(jndex2+2)-y(jndex1+2)
      v21_z=y(jndex2+3)-y(jndex1+3)
      r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
      r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
      v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
!   term for star 1.  Note the factor is 6 and not 12
!
      aqp=5.0_dp*((omega1x*x21_x+omega1y*x21_y+omega1z*x21_z)/  &
         r21norm)**2-omega1norm**2-6.0_dp*g*rmass(2)/r21norm**3
      bqp=-2.0_dp*(omega1x*x21_x+omega1y*x21_y+omega1z*x21_z)
      qpt=tidek1*((frac1/r21norm)**5)/rmass(1)
      qptx=qpt*(aqp*x21_x+bqp*omega1x)
      qpty=qpt*(aqp*x21_y+bqp*omega1y)
      qptz=qpt*(aqp*x21_z+bqp*omega1z)
!
      f(jndex1+1)=f(jndex1+1)-qptx*rmass(2)
      f(jndex1+2)=f(jndex1+2)-qpty*rmass(2)
      f(jndex1+3)=f(jndex1+3)-qptz*rmass(2)
      f(jndex2+1)=f(jndex2+1)+qptx*rmass(1)
      f(jndex2+2)=f(jndex2+2)+qpty*rmass(1)
      f(jndex2+3)=f(jndex2+3)+qptz*rmass(1)
!
!  do the same for star 2.
!  Note the coefficient is 6 and not 12
!
      aqp=5.0_dp*((omega2x*x21_x+omega2y*x21_y+omega2z*x21_z)/  &
         r21norm)**2-omega2norm**2-6.0_dp*g*rmass(1)/r21norm**3
      bqp=2.0_dp*(omega2x*x21_x+omega2y*x21_y+omega2z*x21_z)
      qpt=tidek2*((frac2/r21norm)**5)/rmass(2)
      qptx=qpt*(-aqp*x21_x+bqp*omega2x)
      qpty=qpt*(-aqp*x21_y+bqp*omega2y)
      qptz=qpt*(-aqp*x21_z+bqp*omega2z)
!
      f(jndex1+1)=f(jndex1+1)+rmass(2)*qptx
      f(jndex1+2)=f(jndex1+2)+rmass(2)*qpty
      f(jndex1+3)=f(jndex1+3)+rmass(2)*qptz
!
      f(jndex2+1)=f(jndex2+1)-qptx*rmass(1)
      f(jndex2+2)=f(jndex2+2)-qpty*rmass(1)
      f(jndex2+3)=f(jndex2+3)-qptz*rmass(1)
!
!   add tidal correction to the force equations, bodies 3 and 4
!
      IF((nbody == 4).AND.(isw80 > 0))THEN
         rm21=rmass(3)+rmass(4)
         rnu=rmass(3)*rmass(4)/rm21**2
         x21_x=y(10)-y(7)
         x21_y=y(11)-y(8)
         x21_z=y(12)-y(9)
         jndex2=21    !  3*(nbody+1)+6
         jndex1=18    !  4*nbody
         v21_x=y(jndex2+1)-y(jndex1+1)
         v21_y=y(jndex2+2)-y(jndex1+2)
         v21_z=y(jndex2+3)-y(jndex1+3)
         r21norm=SQRT(x21_x*x21_x+x21_y*x21_y+x21_z*x21_z)
         r21dot=(x21_x*v21_x+x21_y*v21_y+x21_z*v21_z)/r21norm
         v21dot=(v21_x*v21_x+v21_y*v21_y+v21_z*v21_z)
!
!  omega below is hut*(2*pi/period) where hut is given by
!
!     hut=(1.0d0+7.5d0*ecc*ecc+5.625d0*ecc**4+
!       0.3125d0*ecc**6)/((1.0d0+3.0d0*ecc*ecc+
!       3.0d0/8.0d0*ecc**4)*dsqrt((1.0d0-ecc*ecc)**3))
!
         omega1x=tideparm(15)!x-component usually zero
         omega1y=tideparm(16)!y-component=omega*sin(i)
         omega1z=tideparm(17)!z-component=-omega*cos(i)
         omega2x=tideparm(18)!x-component usually zero
         omega2y=tideparm(19)!y-component=omega*sin(i)
         omega2z=tideparm(20)!z-component=-omega*cos(i)
         omega1norm=SQRT(omega1x**2+omega1y**2+omega1z**2)
         omega2norm=SQRT(omega2x**2+omega2y**2+omega2z**2)
         tidek1=tideparm(11)!coefficient on the order of 0.005
         tidek2=tideparm(12)!coefficient on the order of 0.005
         frac1=tideparm(13)!this is the radius in AU
         frac2=tideparm(14)!this is the radius in AU
!
!   term for star 3.  Note the factor is 6 and not 12
!
         aqp=5.0_dp*((omega1x*x21_x+omega1y*x21_y+omega1z*x21_z)/  &
            r21norm)**2-omega1norm**2-6.0_dp*g*rmass(4)/r21norm**3
         bqp=-2.0_dp*(omega1x*x21_x+omega1y*x21_y+omega1z*x21_z)
         qpt=tidek1*((frac1/r21norm)**5)/rmass(3)

         qptx=qpt*(aqp*x21_x+bqp*omega1x)
         qpty=qpt*(aqp*x21_y+bqp*omega1y)
         qptz=qpt*(aqp*x21_z+bqp*omega1z)
         f(jndex1+1)=f(jndex1+1)-qptx*rmass(4)
         f(jndex1+2)=f(jndex1+2)-qpty*rmass(4)
         f(jndex1+3)=f(jndex1+3)-qptz*rmass(4)
         f(jndex2+1)=f(jndex2+1)+qptx*rmass(3)
         f(jndex2+2)=f(jndex2+2)+qpty*rmass(3)
         f(jndex2+3)=f(jndex2+3)+qptz*rmass(3)
!
!  do the same for star 4.
!  Note the coefficient is 6 and not 12
!
         aqp=5.0_dp*((omega2x*x21_x+omega2y*x21_y+omega2z*x21_z)/  &
            r21norm)**2-omega2norm**2-6.0_dp*g*rmass(3)/r21norm**3
         bqp=2.0_dp*(omega2x*x21_x+omega2y*x21_y+omega2z*x21_z)
         qpt=tidek2*((frac2/r21norm)**5)/rmass(4)
         qptx=qpt*(-aqp*x21_x+bqp*omega2x)
         qpty=qpt*(-aqp*x21_y+bqp*omega2y)
         qptz=qpt*(-aqp*x21_z+bqp*omega2z)
!
         f(jndex1+1)=f(jndex1+1)+rmass(4)*qptx
         f(jndex1+2)=f(jndex1+2)+rmass(4)*qpty
         f(jndex1+3)=f(jndex1+3)+rmass(4)*qptz
!
         f(jndex2+1)=f(jndex2+1)-qptx*rmass(3)
         f(jndex2+2)=f(jndex2+2)-qpty*rmass(3)
         f(jndex2+3)=f(jndex2+3)-qptz*rmass(3)
!
      END IF
   END IF
!
   IF(igr > 4)RETURN
!
   RETURN
!
END SUBROUTINE dequa
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE detailrefl(ialphmax1,ibetmax1,nalph1,ibetlim1,  &
   nalph2,ibetlim2,ratio1,ratio2,xarray1,yarray1,zarray1,gradx1,  &
   grady1,gradz1,garray1,surf1,xarray2,yarray2,zarray2,gradx2,  &
   grady2,gradz2,garray2,surf2,temp1,temp2,tempold1,tempold2,  &
   dbolx,dboly,ilaw,alb1,alb2,teff2,tgrav1,tgrav2,rlx,iidint,  &
   redge,betarim,gpole1,gpole2,tpole1,tpole2,coprat1,coprat2,  &
   bdist,mmdx1,mmdx2,ialphmax2,ibetmax2,ioutflag)
!
!   October 15, 1999
!
!    This routine will alter the temperatures on star istar by
!    means of 'detailed reflection' (R. E. Wilson 1990, ApJ, 356, 613).
!    The arrays ratio1 and ratio2 store the 'reflection' factors for
!    each surface element.  These can be iterated to any accuracy desired.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax1
   INTEGER, INTENT(IN)                      :: ibetmax1
   INTEGER, INTENT(IN)                      :: nalph1
   INTEGER, INTENT(IN)                      :: nalph2
   INTEGER, INTENT(IN)                      :: ialphmax2
   INTEGER, INTENT(IN)                      :: ibetmax2
   INTEGER, INTENT(IN)                      :: ibetlim1(ialphmax1)
   INTEGER, INTENT(IN)                      :: ibetlim2(ialphmax2)
   REAL(KIND=dp), INTENT(OUT)               :: ratio1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(OUT)               :: ratio2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: xarray1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: yarray1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: zarray1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: gradx1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: grady1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: gradz1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: garray1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: surf1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: xarray2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: yarray2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: zarray2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: gradx2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: grady2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: gradz2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: garray2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: surf2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: temp1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(OUT)               :: temp2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: tempold1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: tempold2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: dbolx(8,2)
   REAL(KIND=dp), INTENT(IN)                :: dboly(8,2)
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(IN)                :: alb1
   REAL(KIND=dp), INTENT(IN)                :: alb2
   REAL(KIND=dp), INTENT(IN OUT)            :: teff2
   REAL(KIND=dp), INTENT(IN)                :: tgrav1
   REAL(KIND=dp), INTENT(IN)                :: tgrav2
   REAL(KIND=dp), INTENT(IN)                :: rlx
   INTEGER, INTENT(IN)                      :: iidint
   REAL(KIND=dp), INTENT(IN)                :: redge
   REAL(KIND=dp), INTENT(IN)                :: betarim
   REAL(KIND=dp), INTENT(IN)                :: gpole1
   REAL(KIND=dp), INTENT(IN)                :: gpole2
   REAL(KIND=dp), INTENT(IN OUT)            :: tpole1
   REAL(KIND=dp), INTENT(IN OUT)            :: tpole2
   REAL(KIND=dp), INTENT(IN OUT)            :: coprat1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN OUT)            :: coprat2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: bdist
   INTEGER, INTENT(IN)                      :: mmdx1(ialphmax1,ibetmax1)
   INTEGER, INTENT(IN)                      :: mmdx2(ialphmax2,ibetmax2)
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp) :: darkboly1,darkbolx2,darkboly2,dint1,dint2,div1,div2
   REAL(KIND=dp) :: diff1max,diff2max,t4g2,t4g1,summ,xflip2,yflip2,zflip2
   REAL(KIND=dp) :: dist1,dist2,term1,foreshort1,xflip1,yflip1,zflip1
   REAL(KIND=dp) :: term2,foreshort2,term3,ttt,zrim,xa,xb,ya,yb,za,zb
   REAL(KIND=dp) :: zcross,fpboverfa,tnew,diff,fpaoverfb,c1,c2,darkbolx1
!
   INTEGER :: i,j,ialf,ibet,jjdx,i1,j2,izz,jzz
   INTEGER :: ilength1,iidx
!
   CHARACTER(LEN=60) :: instring1
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!   December 15, 2013:  new triangular sampling for quad law
!
!          IF((ilaw.eq.5).or.(ilaw.eq.15))THEN
!            saveflimbx=flimbx
!            saveflimby=flimby
!            flimbx=2.0d0*dsqrt(saveflimbx)*saveflimby
!            flimby=dsqrt(saveflimbx)*(1.0d0-2.0d0*saveflimby)
!          END IF
!
!   UPDATE September 4, 1012
!
!   if ilaw > 10, force the coefficients of star 2 to equal those
!   of star 1
!
   c1=0.0_dp
   iidx=1
   darkbolx1=dbolx(1,1)
   darkboly1=dboly(1,1)
   darkbolx2=dbolx(1,2)
   darkboly2=dboly(1,2)
!
!   Define the integrated  limb darkening coefficients.  The equation is
!
!   dint=2*pi*int_0^1{mu*(1-x*(1-mu))d(mu)}  for the linear law, etc.
!
   dint1=pie*(1.0_dp-darkbolx1/3.0_dp)
   dint2=pie*(1.0_dp-darkbolx2/3.0_dp)
   IF((ilaw == 2).OR.(ilaw == 12))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp+2.0_dp*darkboly1/9.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp+2.0_dp*darkboly2/9.0_dp)
   END IF
   IF((ilaw == 6).OR.(ilaw == 16))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp+2.0_dp*darkboly1/9.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp+2.0_dp*darkboly2/9.0_dp)
   END IF
   IF((ilaw == 3).OR.(ilaw == 13))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp-darkboly1/5.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp-darkboly2/5.0_dp)
   END IF
   IF((ilaw == 7).OR.(ilaw == 17))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp-darkboly1/5.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp-darkboly2/5.0_dp)
   END IF
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic law, ilaw=4
!
   IF((ilaw == 4).OR.(ilaw == 14))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp-darkboly1/6.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp-darkboly2/6.0_dp)
   END IF
   IF((ilaw == 5).OR.(ilaw == 15))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp-darkboly1/6.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp-darkboly2/6.0_dp)
   END IF
!
   IF(teff2 > 0.0_dp)THEN
      c1=(tpole2/tpole1)**(4)*(dint1/dint2)
      c1=c1*alb1/dint1
   END IF
   div1=gpole1
   div2=gpole2
!
!   If teff2 < 0, then star 2 does not exist (X-ray binary mode usually).
!   In this case, we simply set C1=rLx, which is the ratio of the X-ray
!   luminosity to that of the star 1's optical luminosity.  The coordinates,
!   gradients, etc of star 2 have been adjusted correctly above.
!
!   For the mode with 2 normal stars where star 2 is reasonably spherical,
!   you can input rLx = [(Teff2/Teff1)**4]*[(surface_area2/surface_area1)],
!   set Teff2=-Teff2, and get basically the same light curve.  This
!   is the "inverse square law" discussed by Wilson.
!
   IF(teff2 <= 0.0_dp)THEN
      c1=rlx*alb1
      c1=c1/dint1
   END IF
   diff1max=-1.0_dp
   diff2max=-1.0_dp
!
   t4g2=4.0_dp*tgrav2
   t4g1=4.0_dp*tgrav1
   loop70:  DO  ialf=1,nalph1/2
      DO  ibet=1,ibetlim1(ialf)/2
         summ=0.0_dp
         loop20:  DO  i=1,nalph2
            DO  j=1,ibetlim2(i)/2
               iidx=mmdx1(ialf,ibet)
               jjdx=mmdx2(i,j)
!
!  ! move the center of the second star
!
               xflip2=bdist-xarray2(jjdx)
               yflip2=-yarray2(jjdx)
               zflip2=zarray2(jjdx)
               dist1=(xarray1(iidx)-xflip2)**2+(yarray1(iidx)-yflip2)  &
                  **2+(zarray1(iidx)-zflip2)**2
               dist1=SQRT(dist1)
               term1=(xflip2-xarray1(iidx))*gradx1(iidx)+(yflip2-  &
                  yarray1(iidx))*grady1(iidx)+(zflip2-zarray1(iidx))* &
                  gradz1(iidx)
               foreshort1=(term1/(dist1))
!
!   UPDATE March 22, 2002
!
!   If Teff < 0, then bail out here.
!
               IF(teff2 < 0.0_dp)GO TO 50
!
               IF(foreshort1 <= 0.0_dp)CYCLE
!
               dist2=dist1
!
               xflip1=bdist-xarray1(iidx)
               yflip1=-yarray1(iidx)
               zflip1=zarray1(iidx)
               term2=(xflip1-xarray2(jjdx))*gradx2(jjdx)+(yflip1-  &
                  yarray2(jjdx))*grady2(jjdx)+(zflip1-zarray2(jjdx))* &
                  gradz2(jjdx)
               foreshort2=(term2/(dist2))
!
               IF(foreshort2 <= -0.05_dp)CYCLE loop20
               IF(foreshort2 <= 0.0_dp)CYCLE
               IF(teff2 <= 0.0_dp)CYCLE
               term3=(garray2(jjdx)/div2)**(t4g2)*surf2(jjdx)*  &
                  coprat2(jjdx)*foreshort1*foreshort2/(dist2*dist2)
!
               IF((ilaw == 1).OR.(ilaw == 11))THEN
                  term3=term3*(1.0_dp-darkbolx2+darkbolx2*foreshort2)
               END IF
               IF((ilaw == 2).OR.(ilaw == 12))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*foreshort2*LOG(foreshort2)
                  ELSE
                     ttt=0.0_dp
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 6).OR.(ilaw == 16))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*foreshort2*LOG(foreshort2)
                  ELSE
                     ttt=0.0_dp
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 3).OR.(ilaw == 13))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*(1.0_dp-SQRT(foreshort2))
                  ELSE
                     ttt=darkboly2
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 7).OR.(ilaw == 17))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*(1.0_dp-SQRT(foreshort2))
                  ELSE
                     ttt=darkboly2
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic limb darkening law, ilaw=4
!
               IF((ilaw == 4).OR.(ilaw == 14))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*(1.0_dp-(foreshort2))**2
                  ELSE
                     ttt=darkboly2
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 5).OR.(ilaw == 15))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*(1.0_dp-(foreshort2))**2
                  ELSE
                     ttt=darkboly2
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
!
!   If there is a disk, we need to check which lines of sight are blocked
!
               IF(iidint >= 1)THEN
                  zrim=redge*TAN(betarim*degtorad)
                  xa=xarray1(iidx)
                  ya=yarray1(iidx)
                  za=zarray1(iidx)
                  xb=bdist-xarray2(jjdx)
                  yb=-yarray2(jjdx)
                  zb=zarray2(jjdx)
                  CALL zheight(xa,ya,za,xb,yb,zb,redge,zcross)
                  IF((zb >= 0.0_dp).AND.(zcross < zrim))term3=0.0_dp
                  IF((zb < 0.0_dp).AND.(zcross > -zrim))term3=0.0_dp
               END IF
               summ=summ+term3
            END DO
         END DO loop20
!
         loop40:  DO  i=1,nalph2
            DO  j=ibetlim2(i),ibetlim2(i)/2+1,-1
               iidx=mmdx1(ialf,ibet)
               jjdx=mmdx2(i,j)
!
!   move the center of the second star
!
               xflip2=bdist-xarray2(jjdx)
               yflip2=-yarray2(jjdx)
               zflip2=zarray2(jjdx)
               dist1=(xarray1(iidx)-xflip2)**2+(yarray1(iidx)-yflip2)  &
                  **2+(zarray1(iidx)-zflip2)**2
               dist1=SQRT(dist1)
               term1=(xflip2-xarray1(iidx))*gradx1(iidx)+(yflip2-  &
                  yarray1(iidx))*grady1(iidx)+(zflip2-zarray1(iidx))* &
                  gradz1(iidx)
               foreshort1=(term1/(dist1))
!
               IF(foreshort1 <= 0.0_dp)CYCLE
!
               dist2=dist1
!
               xflip1=bdist-xarray1(iidx)
               yflip1=-yarray1(iidx)
               zflip1=zarray1(iidx)
               term2=(xflip1-xarray2(jjdx))*gradx2(jjdx)+(yflip1-  &
                  yarray2(jjdx))*grady2(jjdx)+(zflip1-zarray2(jjdx))* &
                  gradz2(jjdx)
               foreshort2=(term2/(dist2))
!
               IF(foreshort2 <= 0.0_dp)CYCLE loop40
               IF(teff2 <= 0.0_dp)CYCLE
               term3=(garray2(jjdx)/div2)**(t4g2)*surf2(jjdx)*  &
                  coprat2(jjdx)*foreshort1*foreshort2/(dist2*dist2)
!
               IF((ilaw == 1).OR.(ilaw == 11))THEN
                  term3=term3*(1.0_dp-darkbolx2+darkbolx2*foreshort2)
               END IF
               IF((ilaw == 2).OR.(ilaw == 12))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*foreshort2*LOG(foreshort2)
                  ELSE
                     ttt=0.0_dp
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 6).OR.(ilaw == 16))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*foreshort2*LOG(foreshort2)
                  ELSE
                     ttt=0.0_dp
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 3).OR.(ilaw == 13))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*(1.0_dp-SQRT(foreshort2))
                  ELSE
                     ttt=darkboly2
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 7).OR.(ilaw == 17))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*(1.0_dp-SQRT(foreshort2))
                  ELSE
                     ttt=darkboly2
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic limb darkening law, ilaw=4
!
               IF((ilaw == 4).OR.(ilaw == 14))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*(1.0_dp-(foreshort2))**2
                  ELSE
                     ttt=darkboly2
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 5).OR.(ilaw == 15))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly2*(1.0_dp-(foreshort2))**2
                  ELSE
                     ttt=darkboly2
                  END IF
                  term3=term3*(1.0_dp-darkbolx2*(1.0_dp-foreshort2)-ttt)
               END IF
!
!   If there is a disk, we need to check which lines of sight are blocked
!
               IF(iidint >= 1)THEN
                  zrim=redge*TAN(betarim*degtorad)
                  xa=xarray1(iidx)
                  ya=yarray1(iidx)
                  za=zarray1(iidx)
                  xb=bdist-xarray2(jjdx)
                  yb=-yarray2(jjdx)
                  zb=zarray2(jjdx)
                  CALL zheight(xa,ya,za,xb,yb,zb,redge,zcross)
                  IF((zb >= 0.0_dp).AND.(zcross < zrim))term3=0.0_dp
                  IF((zb < 0.0_dp).AND.(zcross > -zrim))term3=0.0_dp
               END IF
               summ=summ+term3
            END DO
         END DO loop40
!
!   Check to see if the point on star 1 can actually see any point on
!   star 2.  If not, then the summ will be zero.
!
         IF(ABS(summ) <= EPSILON(summ))CYCLE loop70
!
!   If Teff2 < 0, we assume star 2 is a point source.  Thus the integration
!   over the surface of star 2 reduces to the foreshorting angle of
!   the specific ialf-ibet element on star 1.  If there is a disk we have
!   to compute which points on star A are shielded by the disk rim.
!
50       IF((teff2 <= 0.0_dp).AND.(iidint >= 1))THEN
            zrim=redge*TAN(betarim*degtorad)
            xa=xarray1(iidx)
            ya=yarray1(iidx)
            za=zarray1(iidx)
            xb=bdist
            yb=0.0_dp
            zb=0.0_dp
            CALL zheight(xa,ya,za,xb,yb,zb,redge,zcross)
            IF(summ < 0.0_dp)summ=0.0_dp
            IF((za >= 0.0_dp).AND.(zcross < zrim))summ=0.0_dp
            IF((za < 0.0_dp).AND.(zcross > -zrim))summ=0.0_dp
         END IF
!
         fpboverfa=c1/((garray1(iidx)/div1)**(t4g1))*summ
         ratio1(iidx)=1.0_dp+fpboverfa
         tnew=tempold1(iidx)*ratio1(iidx)**0.25_dp
         diff=tnew-tempold1(iidx)
         IF(diff > diff1max)diff1max=diff
         temp1(iidx)=tnew
!    IF(summ > 0.0_dp)jcount=jcount+1
      END DO
   END DO loop70
!
!   Now go to star 2 and compute the irradation from star 1
!
   IF(teff2 <= 0.0_dp)GO TO 140
   c2=(tpole1/tpole2)**(4)*(dint2/dint1)
   c2=c2*alb2/dint2
!
   loop130:  DO  ialf=1,nalph2/2
      DO  ibet=1,ibetlim2(ialf)/2
         summ=0.0_dp
         loop90:  DO  i=1,nalph1
            DO  j=1,ibetlim1(i)/2
               iidx=mmdx2(ialf,ibet)
               jjdx=mmdx1(i,j)
!
!   move the center of the first star
!
               xflip1=bdist-xarray1(jjdx)
               yflip1=-yarray1(jjdx)
               zflip1=zarray1(jjdx)
               dist1=(xflip1-xarray2(iidx))**2+(yflip1-yarray2(iidx))  &
                  **2+(zflip1-zarray2(iidx))**2
               dist1=SQRT(dist1)
               term1=(xflip1-xarray2(iidx))*gradx2(iidx)+(yflip1-  &
                  yarray2(iidx))*grady2(iidx)+(zflip1-zarray2(iidx))* &
                  gradz2(iidx)
               foreshort1=(term1/(dist1))
               IF(foreshort1 < 0.0_dp)CYCLE
!
               dist2=dist1
               xflip2=bdist-xarray2(iidx)
               yflip2=-yarray2(iidx)
               zflip2=zarray2(iidx)
!
               term2=(xflip2-xarray1(jjdx))*gradx1(jjdx)+(yflip2-  &
                  yarray1(jjdx))*grady1(jjdx)+(zflip2-zarray1(jjdx))* &
                  gradz1(jjdx)
               foreshort2=(term2/(dist2))
               IF(foreshort2 < 0.0_dp)CYCLE loop90
               term3=(garray1(jjdx)/div1)**(t4g1)*surf1(jjdx)*  &
                  coprat1(jjdx)*foreshort1*foreshort2/(dist2*dist2)
!
               IF((ilaw == 1).OR.(ilaw == 11))THEN
                  term3=term3*(1.0_dp-darkbolx1+darkbolx1*foreshort2)
               END IF
               IF((ilaw == 2).OR.(ilaw == 12))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*foreshort2*LOG(foreshort2)
                  ELSE
                     ttt=0.0_dp
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 6).OR.(ilaw == 16))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*foreshort2*LOG(foreshort2)
                  ELSE
                     ttt=0.0_dp
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 3).OR.(ilaw == 13))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*(1.0_dp-SQRT(foreshort2))
                  ELSE
                     ttt=darkboly1
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 7).OR.(ilaw == 17))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*(1.0_dp-SQRT(foreshort2))
                  ELSE
                     ttt=darkboly1
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic limb darkening law, ilaw=4
!
               IF((ilaw == 4).OR.(ilaw == 14))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*(1.0_dp-(foreshort2))**2
                  ELSE
                     ttt=darkboly1
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 5).OR.(ilaw == 15))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*(1.0_dp-(foreshort2))**2
                  ELSE
                     ttt=darkboly1
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
!
!   If there is a disk, we need to check which lines of sight are blocked.
!
               IF(iidint >= 1)THEN
                  zrim=redge*TAN(betarim*degtorad)
                  xa=xarray1(jjdx)
                  ya=yarray1(jjdx)
                  za=zarray1(jjdx)
!
!   move the center of the second star to be consistent
!   with the disk coordinates
!
                  xb=bdist-xarray2(iidx)
                  yb=-yarray2(iidx)
                  zb=zarray2(iidx)
                  CALL zheight(xa,ya,za,xb,yb,zb,redge,zcross)
                  IF((zb >= 0.0_dp).AND.(zcross < zrim))term3=0.0_dp
                  IF((zb < 0.0_dp).AND.(zcross > -zrim))term3=0.0_dp
               END IF
               summ=summ+term3
            END DO
         END DO loop90
!
         loop110:  DO  i=1,nalph1
            DO  j=ibetlim1(i),ibetlim1(i)/2+1,-1
               iidx=mmdx2(ialf,ibet)
               jjdx=mmdx1(i,j)
!
!   move the center of the first star
!
               xflip1=bdist-xarray1(jjdx)
               yflip1=-yarray1(jjdx)
               zflip1=zarray1(jjdx)
               dist1=(xflip1-xarray2(iidx))**2+(yflip1-yarray2(iidx))  &
                  **2+(zflip1-zarray2(iidx))**2
               dist1=SQRT(dist1)
               term1=(xflip1-xarray2(iidx))*gradx2(iidx)+(yflip1-  &
                  yarray2(iidx))*grady2(iidx)+(zflip1-zarray2(iidx))* &
                  gradz2(iidx)
               foreshort1=(term1/(dist1))
               IF(foreshort1 < 0.0_dp)CYCLE
!
               dist2=dist1
!
               xflip2=bdist-xarray2(iidx)
               yflip2=-yarray2(iidx)
               zflip2=zarray2(iidx)
!
               term2=(xflip2-xarray1(jjdx))*gradx1(jjdx)+(yflip2-  &
                  yarray1(jjdx))*grady1(jjdx)+(zflip2-zarray1(jjdx))* &
                  gradz1(jjdx)
               foreshort2=(term2/(dist2))
               IF(foreshort2 < 0.0_dp)CYCLE loop110
               term3=(garray1(jjdx)/div1)**(t4g1)*surf1(jjdx)*  &
                  coprat1(jjdx)*foreshort1*foreshort2/(dist2*dist2)
!
               IF((ilaw == 1).OR.(ilaw == 11))THEN
                  term3=term3*(1.0_dp-darkbolx1+darkbolx1*foreshort2)
               END IF
               IF((ilaw == 2).OR.(ilaw == 12))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*foreshort2*LOG(foreshort2)
                  ELSE
                     ttt=0.0_dp
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 6).OR.(ilaw == 16))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*foreshort2*LOG(foreshort2)
                  ELSE
                     ttt=0.0_dp
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 3).OR.(ilaw == 13))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*(1.0_dp-SQRT(foreshort2))
                  ELSE
                     ttt=darkboly1
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 7).OR.(ilaw == 17))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*(1.0_dp-SQRT(foreshort2))
                  ELSE
                     ttt=darkboly1
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic limb darkening law, ilaw=4
!
               IF((ilaw == 4).OR.(ilaw == 14))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*(1.0_dp-(foreshort2))**2
                  ELSE
                     ttt=darkboly1
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
               IF((ilaw == 5).OR.(ilaw == 15))THEN
                  IF(foreshort2 > 0.0_dp)THEN
                     ttt=darkboly1*(1.0_dp-(foreshort2))**2
                  ELSE
                     ttt=darkboly1
                  END IF
                  term3=term3*(1.0_dp-darkbolx1*(1.0_dp-foreshort2)-ttt)
               END IF
!
!   If there is a disk, we need to check which lines of sight are blocked.
!
               IF(iidint >= 1)THEN
                  zrim=redge*TAN(betarim*degtorad)
                  xa=xarray1(jjdx)
                  ya=yarray1(jjdx)
                  za=zarray1(jjdx)
!
!   move the ceenter of the second star to be consistent with
!   the disk coordinates
!
                  xb=bdist-xarray2(iidx)
                  yb=-yarray2(iidx)
                  zb=zarray2(iidx)
                  CALL zheight(xa,ya,za,xb,yb,zb,redge,zcross)
                  IF((zb >= 0.0_dp).AND.(zcross < zrim))term3=0.0_dp
                  IF((zb < 0.0_dp).AND.(zcross > -zrim))term3=0.0_dp
               END IF
               summ=summ+term3
            END DO
         END DO loop110
!
!   Check to see if the point on star 2 can actually see any point on
!   star 1.  If not, then the summ will be zero.
!
         IF(ABS(summ) <= EPSILON(summ))CYCLE loop130
!
         fpaoverfb=c2/((garray2(iidx)/div2)**(t4g2))*summ
         ratio2(iidx)=1.0_dp+fpaoverfb
         tnew=tempold2(iidx)*ratio2(iidx)**0.25_dp
         diff=tnew-tempold2(iidx)
         IF(diff > diff2max)diff2max=diff
         temp2(iidx)=tnew
      END DO
   END DO loop130
!
!   Now use symmetry to fill in the other quadrants on the star.
!
140 CONTINUE
!
   DO  ialf=1,nalph1/2
      DO  ibet=1,ibetlim1(ialf)/2
         i1=nalph1-(ialf-1)
         j2=ibetlim1(ialf)-(ibet-1)
         iidx=mmdx1(ialf,ibet)
!
         izz=ialf
         jzz=j2
         jjdx=mmdx1(izz,jzz)
         ratio1(jjdx)=ratio1(iidx)
         temp1(jjdx)=temp1(iidx)

         izz=i1
         jzz=ibet
         jjdx=mmdx1(izz,jzz)
         ratio1(jjdx)=ratio1(iidx)
         temp1(jjdx)=temp1(iidx)
!
         izz=i1
         jzz=j2
         jjdx=mmdx1(izz,jzz)
         ratio1(jjdx)=ratio1(iidx)
         temp1(jjdx)=temp1(iidx)
!
      END DO
   END DO
!
   IF(teff2 <= 0.0_dp)GO TO 190
   DO  ialf=1,nalph2/2
      DO  ibet=1,ibetlim2(ialf)/2
         i1=nalph1-(ialf-1)
         j2=ibetlim2(ialf)-(ibet-1)
         iidx=mmdx2(ialf,ibet)
         i1=nalph2-(ialf-1)
         j2=ibetlim2(ialf)-(ibet-1)

         izz=ialf
         jzz=j2
         jjdx=mmdx2(izz,jzz)
         ratio2(jjdx)=ratio2(iidx)
         temp2(jjdx)=temp2(iidx)
!
         izz=i1
         jzz=ibet
         jjdx=mmdx2(izz,jzz)
         ratio2(jjdx)=ratio2(iidx)
         temp2(jjdx)=temp2(iidx)

         izz=i1
         jzz=j2
         jjdx=mmdx2(izz,jzz)
         ratio2(jjdx)=ratio2(iidx)
         temp2(jjdx)=temp2(iidx)
!
      END DO
   END DO
!
!   Update the ratio arrays.
!
   CALL copytemp(ialphmax1,ibetmax1,nalph1,ratio1,coprat1,mmdx1,ibetlim1)
   CALL copytemp(ialphmax2,ibetmax2,nalph2,ratio2,coprat2,mmdx2,ibetlim2)
!
190 IF(diff2max < 0.0_dp)diff2max=0.0_dp
   IF(diff1max < 0.0_dp)diff1max=0.0_dp
!
   CALL pspacestring('Maximum temperature change for star 1',4,  &
      diff1max,instring1,ilength1)
!   k1=lnblnk(instring1)
   IF(ioutflag == 1)WRITE(2,200)TRIM(instring1)
!
   CALL pspacestring('Maximum temperature change for star 2',4,  &
      diff2max,instring1,ilength1)
!   k1=lnblnk(instring1)
   IF(ioutflag == 1)WRITE(2,200)TRIM(instring1)
!
200 FORMAT(/a,1X,'K.')
!
   RETURN
!
END SUBROUTINE detailrefl
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE dhamil(n,y,ham,rmass,nbody)
!
!   from Ernst Hairer
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: y(n)
   REAL(KIND=dp), INTENT(OUT)               :: ham
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
!
   INTEGER :: nprob,jj,i,i1,j,j1,nfcn
!
   REAL(KIND=dp)  :: d(6,6),m(6),pot,ak
!
   COMMON /count/ nfcn,nprob
!
   nfcn=nfcn+1
   nprob=4
   WRITE(*,*) 'DHAMIL'
   IF(nprob == 4)THEN
      ak=2.95912208286E-04_dp
      ak=(0.01720209895_dp)**2
      DO jj=1,nbody
         m(jj)=rmass(jj)
      END DO
      DO i=1,nbody-1
         i1=3*(i-1)+1
         DO j=i+1,nbody
            j1=3*(j-1)+1
            d(i,j)=SQRT((y(i1)-y(j1))**2+(y(i1+1)-y(j1+1))**2+(y(i1+2)-y(j1+2))**2)
            d(j,i)=d(i,j)
         END DO
      END DO
      ham=0.0_dp
      DO i=1,nbody
         i1=nbody*3+3*(i-1)+1
         ham=ham+m(i)*(y(i1)**2+y(i1+1)**2+y(i1+2)**2)
      END DO
      ham=ham/2
      pot=0.0_dp
      DO i=2,nbody
         DO j=1,i-1
            pot=pot+m(i)*m(j)/d(i,j)
         END DO
      END DO
      ham=ham-ak*pot
   END IF
   RETURN
!
END SUBROUTINE dhamil
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE disksetup(nthetamax,nrmax,ntheta,nradius,betarim,  &
   rinner,router,reff2,rl2,separ,tdisk,xi,dtemp,dx,dy,dz,drad,  &
   tedge,xedge,yedge,zedge,redge,stepr,stepz,bdist,ivrt,reper,  &
   rsper,ioutflag,diskrad,diskthick)
!
!   November 1, 1999
!
!   This routine will return the x, y, and z-coordinates of the grid
!   points on the disk.  Also, the temperatures of each point are returned.
!
!   November 29, 1999
!
!   Use as the radial coordinate zeta=2*dsqrt(r).  This will give more
!   points near the inner edge where the temperature is changing rapidly.
!
!   February 12, 2001
!
!   Put in the general case for eccentric orbits.  The flat ivrt=0 means
!   to setup the disk at periastron.  The values of rsmall and redge
!   are saved and used for other phases.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nthetamax
   INTEGER, INTENT(IN)                      :: nrmax
   INTEGER, INTENT(IN)                      :: ntheta
   INTEGER, INTENT(IN)                      :: nradius
   REAL(KIND=dp), INTENT(IN)                :: betarim
   REAL(KIND=dp), INTENT(IN)                :: rinner
   REAL(KIND=dp), INTENT(IN)                :: router
   REAL(KIND=dp), INTENT(IN)                :: reff2
   REAL(KIND=dp), INTENT(IN)                :: rl2
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: tdisk
   REAL(KIND=dp), INTENT(IN)                :: xi
   REAL(KIND=dp), INTENT(OUT)               :: dtemp(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: dx(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: dy(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: dz(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: drad(nrmax)
   REAL(KIND=dp), INTENT(OUT)               :: tedge(nthetamax*11)
   REAL(KIND=dp), INTENT(OUT)               :: xedge(nthetamax*11)
   REAL(KIND=dp), INTENT(OUT)               :: yedge(nthetamax*11)
   REAL(KIND=dp), INTENT(OUT)               :: zedge(nthetamax*11)
   REAL(KIND=dp), INTENT(OUT)               :: redge
   REAL(KIND=dp), INTENT(OUT)               :: stepr
   REAL(KIND=dp), INTENT(OUT)               :: stepz
   REAL(KIND=dp), INTENT(IN)                :: bdist
   INTEGER, INTENT(IN)                      :: ivrt
   REAL(KIND=dp), INTENT(OUT)               :: reper
   REAL(KIND=dp), INTENT(OUT)               :: rsper
   INTEGER, INTENT(IN)                      :: ioutflag
   REAL(KIND=dp), INTENT(OUT)               :: diskrad
   REAL(KIND=dp), INTENT(OUT)               :: diskthick
!
   REAL(KIND=dp) :: rsmall,betarad,steptheta,zetain,zetaout
   REAL(KIND=dp) :: stepzeta,tdummy,theta,zeta,r,thetar,tlast,zrim,z
!
   INTEGER :: ir,ithet,iidx,iz,ilength1,ilength2,ilength3
!
   CHARACTER(LEN=40) :: instring1,instring2,instring3
!
!   Start with the disk face.  It is assumed that the lower face is exactly
!   the same as the upper face, but with a negative z-value.  In practice,
!   however, we never see the bottom face.
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   IF(ivrt == 0)THEN
      redge=router*reff2
      rsmall=rinner*rl2
      reper=redge
      rsper=rsmall
   ELSE
      redge=reper
      rsmall=rsper
   END IF
   betarad=betarim*degtorad
   steptheta=360.0_dp/REAL(ntheta,KIND=dp)
   stepr=(redge-rsmall)/REAL(nradius-1,KIND=dp)
!
!   Transform r into zeta.
!
   zetain=2.0_dp*SQRT(rsmall)
   zetaout=2.0_dp*SQRT(redge)
   stepzeta=(zetaout-zetain)/REAL(nradius-1,KIND=dp)
!
!  UPDATE DECEMBEE 17, 2001
!
!  If tdisk is negative, we should ignore the disk flux.
!  If this is the case, then assign a dummy disk temperature.
!
   tdummy=10000.0_dp
   IF(tdisk > 0.0_dp)tdummy=tdisk
!
   theta=0.0_dp
   zeta=zetain
   DO  ir=1,nradius
      zeta=zetain+REAL(ir-1,KIND=dp)*stepzeta
      drad(ir)=zeta
      r=0.25_dp*zeta*zeta
!
!  theta goes from zero to 360-step
!
      DO  ithet=1,ntheta
         theta=REAL(ithet,KIND=dp)*steptheta-0.5_dp*steptheta
         thetar=theta*degtorad
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(ir-1)*ntheta+ithet
         dx(iidx)=bdist-r*COS(thetar)
         dy(iidx)=r*SIN(thetar)
         dz(iidx)=r*TAN(betarad)
!
!  UPDATE DECEMBEE 17, 2001
!
!  If tdisk is negative, we should ignore the disk flux.
!  If this is the case, then assign a dummy disk temperature.
!
         dtemp(iidx)=tdummy*(r/rsmall)**(xi)
         tlast=dtemp(iidx)
      END DO
   END DO
!
   zrim=redge*TAN(betarad)
   stepz=zrim*0.2_dp
!
   DO  iz=-5,5
      z=REAL(iz,KIND=dp)*stepz
!
!   theta goes from zero to 360-step
!
      DO  ithet=1,ntheta
         theta=REAL(ithet,KIND=dp)*steptheta-0.5_dp*steptheta
         thetar=theta*degtorad
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(iz+6-1)*ntheta+ithet
         xedge(iidx)=bdist-redge*COS(thetar)
         yedge(iidx)=redge*SIN(thetar)
         zedge(iidx)=z
         tedge(iidx)=tlast
      END DO
   END DO
!
   CALL pspacestring('Inner disk radius',5,rsmall*separ,instring1,ilength1)
!   k1=lnblnk(instring1)
   CALL pspacestring('Outer disk radius',5,redge*separ,instring2,ilength2)
!   k2=lnblnk(instring2)
   CALL pspacestring('Temperature at outer edge',3,tlast,instring3,ilength3)
!   k3=lnblnk(instring3)
   IF(ioutflag == 1)WRITE(2,500)TRIM(instring1),TRIM(instring2),TRIM(instring3)
!
   diskrad=redge*separ
   diskthick=2.0_dp*diskrad*TAN(betarad)
!
!   UPDATE DECEMBER 17, 2001
!
!   Add an if-then clause in case the disk temperature is negative.
!
   IF(tdisk > 0.0_dp)THEN
      iidx=(6-1)*ntheta+1
!            IF(ioutflag.eq.1)WRITE(2,60)tlast,xedge(iidx),yedge(iidx),
!     &       zedge(iidx)
   ELSE
      IF(ioutflag == 1)WRITE(2,70)
   END IF
!
!   Scale the step size in zeta by 1/cos^2(betarim) for use in the
!   flux summing routine.
!
   stepr=stepzeta/(COS(betarad)*COS(betarad))
!
500 FORMAT(/'Info:',1X,a,1X,'solar radii.',/1X,a,1X,'solar',1X,  &
      'radii.',/1X,a,1X,'K.')
70 FORMAT('disk temperature negative, will ignore disk flux')
!
   RETURN
!
END SUBROUTINE disksetup
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE diskvisib(nrmax,nthetamax,nradius,ntheta,phase,  &
   finc,q,betarim,dx,dy,dz,xedge,yedge,zedge,diskproj,edgeproj,  &
   dvisib,evisib,nskydisk,xskydisk,yskydisk,zskydisk,nskyedge,  &
   xskyedge,yskyedge,ntop2,xtop2horiz,ytop2horiz,nhoriz1,  &
   xhoriz1,yhoriz1,ndtop,dtopx,dtopy,iecheck,neclipse,bdist,  &
   tertincl,tertbdist,tertphase,tertq,axisscale,isw30,isw7,  &
   tertomega)
!
!   November 8, 1999
!
!   This routine will return an array of projection angles for the
!   disk (diskproj) and for the edge (edgeproj).  It will also check
!   for eclipses by star 1, the top of star 2, and the rim of the disk.
!   If any part of the disk is blocked, then the visibility of that
!   element is set to zero (dvisib, evisib).  For elements that are not
!   blocked, the visibilities are set to the projection.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nrmax
   INTEGER, INTENT(IN)                      :: nthetamax
   INTEGER, INTENT(IN)                      :: nradius
   INTEGER, INTENT(IN)                      :: ntheta
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: betarim
   REAL(KIND=dp), INTENT(IN)                :: dx(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: dy(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: dz(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: xedge(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: yedge(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: zedge(nthetamax*11)
   REAL(KIND=dp), INTENT(OUT)               :: diskproj(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: edgeproj(nthetamax*11)
   REAL(KIND=dp), INTENT(OUT)               :: dvisib(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: evisib(nthetamax*11)
   INTEGER, INTENT(OUT)                     :: nskydisk
   REAL(KIND=dp), INTENT(OUT)               :: xskydisk(nthetamax*nrmax)
   REAL(KIND=dp), INTENT(OUT)               :: yskydisk(nthetamax*nrmax)
   REAL(KIND=dp), INTENT(OUT)               :: zskydisk(nthetamax*nrmax)
   INTEGER, INTENT(OUT)                     :: nskyedge
   REAL(KIND=dp), INTENT(OUT)               :: xskyedge(nthetamax*11)
   REAL(KIND=dp), INTENT(OUT)               :: yskyedge(nthetamax*11)
   INTEGER, INTENT(IN)                      :: ntop2
   REAL(KIND=dp), INTENT(IN)                :: xtop2horiz(ntop2)
   REAL(KIND=dp), INTENT(IN)                :: ytop2horiz(ntop2)
   INTEGER, INTENT(IN)                      :: nhoriz1
   REAL(KIND=dp), INTENT(IN)                :: xhoriz1(nhoriz1)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz1(nhoriz1)
   INTEGER, INTENT(IN)                      :: ndtop
   REAL(KIND=dp), INTENT(IN)                :: dtopx(2*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: dtopy(2*nthetamax)
   INTEGER, INTENT(IN)                      :: iecheck
   INTEGER, INTENT(OUT)                     :: neclipse
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp) :: xxoff,yyoff,xxoff1,yyoff1
   REAL(KIND=dp) :: tertxcen,tertycen,tomrad,phaser,fincr,steptheta
   REAL(KIND=dp) :: betarad,cophase,siphase,cofinc,sifinc,cobet,sibet
   REAL(KIND=dp) :: thetar,t1,t2,t3,proj,angdiff,front,xx,yy,zz,xp,yp
   REAL(KIND=dp) :: diskxtran,diskytran,theta
!
   INTEGER :: i,j,infront,ithet,ir,iyes,iz,icut,iidx
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!    November 18, 2012
!
!    If there is a third body, offset all x and y sky coordinates
!
   xxoff=0.0_dp
   yyoff=0.0_dp
   IF((isw30 >= 3).AND.(isw7 >= 2))THEN
      xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      tomrad=tertomega*degtorad
      xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
      yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
   END IF
!
!  initialize the visibilities
!
!          radcon=pie/180.0d0
!
   DO  i=1,nrmax
      DO  j=1,nthetamax
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(i-1)*ntheta+j
         dvisib(iidx)=0.0_dp
         diskproj(iidx)=0.0_dp
      END DO
   END DO
!
   DO  i=1,nthetamax
      DO  j=1,11
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(j-1)*ntheta+i
         evisib(iidx)=0.0_dp
         edgeproj(iidx)=0.0_dp
      END DO
   END DO
!
   phaser=phase*degtorad
   fincr=finc*degtorad
   nskydisk=0
   nskyedge=0
   neclipse=0
   infront=0
   IF((phase >= 90.0_dp).AND.(phase <= 270.0_dp))infront=1
!
!   Start with the disk face.  Loop over theta and r, compute the projection
!   factors from the standard coordinates, check for eclipses, etc.
!
   steptheta=360.0_dp/REAL(ntheta,KIND=dp)
   betarad=betarim*degtorad
!
!   Put the trig calls outside of the loop.
!
   cophase=COS(phaser)
   siphase=SIN(phaser)
   cofinc=COS(fincr)
   sifinc=SIN(fincr)
   cobet=COS(betarad)
   sibet=SIN(betarad)
   DO  ir=1,nradius
!
!   theta goes from zero to 360-step
!
      DO  ithet=1,ntheta
         theta=REAL(ithet,KIND=dp)*steptheta-0.5_dp*steptheta
         thetar=theta*degtorad
         iidx=(ir-1)*ntheta+ithet
         t1=-cophase*sifinc*sibet*COS(thetar)
         t2=-siphase*sifinc*sibet*SIN(thetar)
         t3=cofinc*cobet
         proj=t1+t2+t3
!
!   This projection factor accounts for points below the rim (in cases of
!   large beta_rim and high inclination).
!
!   old statement:
!
!            front=dcos(phaser-thetar)
!
!   The correct new statement:
!
         angdiff=(theta-phase)*degtorad
         front=sifinc*COS(angdiff)
!
         IF((ir == nradius).AND.(front > 0.0_dp).AND.(proj <= 0.0_dp)) THEN
            proj=sifinc*COS(angdiff)
         END IF
         diskproj(iidx)=proj
         IF(proj <= 0.0_dp)CYCLE
         xx=dx(iidx)
         yy=dy(iidx)
         zz=dz(iidx)
         xp=diskxtran(xx,yy,phase,q,1,bdist)
         yp=diskytran(xx,yy,zz,phase,fincr,q,1,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
         IF(infront /= 1)THEN
            IF(iecheck >= 0)THEN
               iyes=-100
               CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,icut)
               IF(iyes == 100)THEN
                  neclipse=neclipse+1
!
!   eclipsed by star 1
!
                  CYCLE
               END IF
            END IF
         END IF
!
!   Check to see of the top of the star 2 blocks the point in question.
!   Front < 0 for points that are further away than star 2.  These points
!   could be blocked by star 2.  Points with front > 0 in the inner ring
!   may be inside the top horizon of star 2 due to roundoff error.  The
!   if-then block should make sure that points in the inner ring that
!   are in front of star 2 are included.
!
         IF(front < 0.0_dp)THEN
            iyes=-100
            CALL insidecircle(ntop2,xtop2horiz,ytop2horiz,xp,yp,iyes,icut)
            IF(iyes == 100)CYCLE
         END IF
!
!   Finally, check to see of the point in question is beneath the disk
!   rim.  If so, then it is invisible to the observer.  To check this
!   we simply see of the point in question is *inside* the top horizon of
!   the disk.
!
         IF(ir /= nradius)THEN
            iyes=-100
            CALL insidecircle(ndtop,dtopx,dtopy,xp,yp,iyes,icut)
            IF(iyes /= 100)CYCLE
         END IF
         nskydisk=nskydisk+1
         xskydisk(nskydisk)=xp
         yskydisk(nskydisk)=yp
         zskydisk(nskydisk)=proj
         dvisib(iidx)=proj
      END DO
   END DO
!
!  theta goes from zero to 360-step
!
   DO  ithet=1,ntheta
      theta=REAL(ithet,KIND=dp)*steptheta-0.5_dp*steptheta
      thetar=theta*degtorad
!
      DO  iz=1,11
!
!   Old statement:
!
!              proj=dsin(fincr)*dcos(phaser-thetar)
!
!   The correct new statements:
!
         angdiff=(theta-phase)*degtorad
         proj=sifinc*COS(angdiff)
         iidx=(iz-1)*ntheta+ithet
         edgeproj(iidx)=proj
         IF(proj <= 0.0_dp)CYCLE
         xx=xedge(iidx)
         yy=yedge(iidx)
         zz=zedge(iidx)
         xp=diskxtran(xx,yy,phase,q,1,bdist)
         yp=diskytran(xx,yy,zz,phase,fincr,q,1,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
         IF(infront /= 1)THEN
            IF(iecheck >= 0)THEN
               iyes=-100
               CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,icut)
               IF(iyes == 100)THEN
                  neclipse=neclipse+1
!
!   eclipsed by star 1
!
                  CYCLE
               END IF
            END IF
         END IF
         nskyedge=nskyedge+1
         xskyedge(nskyedge)=xp
         yskyedge(nskyedge)=yp
         evisib(iidx)=proj
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE diskvisib
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION diskxtran(xx,yy,phase,q,istar,bdist)
!
!   will return the coordinate of a point (xx,yy,zz) projected on the sky
!
!   (xx,yy,zz) refers to the coordinates in the rotating system
!
!   UPDATE March 26, 2002
!
!   The variables zz and fincr are not used in diskxtran (they are in
!   diskytran).  To suppress compiler warnings, define two fake variables
!   and assign their values to fincr and zz.  This is simpler than
!   changing the argument list of calls to diskxtran.
!
!   Also, get rid of historical text (commented out code).
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: xx
   REAL(KIND=dp), INTENT(IN)                :: yy
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: q
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: bdist
!
   REAL(KIND=dp) :: diskxtran,overq,phaser,qphaser
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   overq=q
   IF(istar == 2)overq=1.0_dp/q
   phaser=phase*degtorad
   qphaser=phaser
   diskxtran=-(xx*SIN(qphaser)+yy*COS(qphaser))+bdist*(overq/  &
      (1.0_dp+overq))*SIN(qphaser)
!
   RETURN
!
END FUNCTION diskxtran
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION diskytran(xx,yy,zz,phase,fincr,q,istar,bdist)
!
!   will return the coordinate of a point (xx,yy,zz) projected
!   on the sky
!
!   (xx,yy,zz) refers to the coordinates in the rotating system
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: xx
   REAL(KIND=dp), INTENT(IN)                :: yy
   REAL(KIND=dp), INTENT(IN)                :: zz
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: fincr
   REAL(KIND=dp), INTENT(IN)                :: q
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: bdist
!
   REAL(KIND=dp) :: overq,phaser,diskytran,qphaser
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   overq=q
   IF(istar == 2)overq=1.0_dp/q
   phaser=phase*degtorad
   qphaser=phaser
   diskytran=-(-xx*COS(fincr)*COS(qphaser)+yy*COS(fincr)*  &
      SIN(qphaser)-zz*SIN(fincr))+bdist*(-(overq/(1.0_dp+overq))*  &
      COS(fincr)*COS(qphaser))
   RETURN
!
END FUNCTION diskytran
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE distorttime(nmaxphase,nphase,xmod,yeclipse,rv,  &
   gamma,pconj)
!
!   February 5, 2001
!
!   This routine will apply a phase shift to a light or velocity curve
!
   USE accur
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN OUT)                  :: nmaxphase
   INTEGER, INTENT(IN)                      :: nphase
   REAL(KIND=dp), INTENT(OUT)               :: xmod(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: yeclipse(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: rv(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: gamma
   REAL(KIND=dp), INTENT(IN OUT)            :: pconj
!
   REAL(KIND=dp)  :: ttt
!
   INTEGER :: i
!
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   DO  i=1,nphase
      IF(yeclipse(i) > 0.0_dp)THEN
         IF(xmod(i) < 0.5_dp)THEN
            ttt=(rv(i)-gamma)/speedlightkm*(xmod(i)-pconj)
            xmod(i)=xmod(i)+ttt
         ELSE
            ttt=(rv(i)-gamma)/speedlightkm*(xmod(i)-(pconj+1.0_dp))
            xmod(i)=xmod(i)+ttt
         END IF
      END IF
   END DO
!
   RETURN
!
END SUBROUTINE distorttime
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE divdiff(odetime,zzq,nstep,timeinterp,ibody,timein,  &
   xout,velout,ii,ndyn)
!
!   divided differences for finding solution at arbitrary times
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   REAL(KIND=dp), INTENT(IN)                :: odetime(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: zzq(6,60,2)
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN)                :: timeinterp(6)
   INTEGER, INTENT(IN)                      :: ibody
   REAL(KIND=dp), INTENT(IN)                :: timein
   REAL(KIND=dp), INTENT(OUT)               :: xout
   REAL(KIND=dp), INTENT(OUT)               :: velout
   INTEGER, INTENT(IN OUT)                  :: ii
!
   REAL(KIND=dp)  :: xx,a
!
   INTEGER :: jj,i
!
   DIMENSION xx(6),a(6)
!
!   old dimensions
!
!          DIMENSION zzq(6,60,Ndyn)
!
   CALL hunt(odetime,nstep,timein,ii)
!
   IF(ii <= 0)ii=1
!
   DO jj=1,6
      xx(jj)=odetime(ii)+timeinterp(jj)
   END DO
!
   DO i=1,6
      a(i)=zzq(i,ibody,ii)
   END DO
!
   xout=a(6)
   velout=xout
!
   DO i=5,2,-1
      xout=a(i)+(timein-xx(i))*xout
      velout=xout+(timein-xx(i-1))*velout
   END DO
!
   xout=a(1)+(timein-xx(1))*xout
!
   RETURN
!
END SUBROUTINE divdiff
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE dmomen(n,y,dang,rmass,nbody)
!
!   from Ernst Hairer
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: y(n)
   REAL(KIND=dp), INTENT(OUT)               :: dang(3)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
!
   INTEGER :: jj, nd2,id,id1,id2,i1,i2,i
!
   REAL(KIND=dp)  ::  m(6)
!
   DO jj=1,nbody
      m(jj)=rmass(jj)
   END DO
   nd2=n/2
   DO id=1,3
      dang(id)=0.0_dp
      DO i=1,6
         id1=MOD(id,3)+1
         id2=MOD(id+1,3)+1
         i1=(i-1)*3+id1
         i2=(i-1)*3+id2
         dang(id)=dang(id)+m(i)*(y(i1)*y(nd2+i2)-y(i2)*y(nd2+i1))
      END DO
   END DO
   RETURN
!
END SUBROUTINE dmomen
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!

SUBROUTINE dummyhoriz(ibetmax2,nbet2,nhoriz2,xhoriz2,yhoriz2,  &
   ntop2,xtop2horiz,ytop2horiz)
!
!  November 1, 1999
!
!  This routine is called if Teff2 < 0, in which case star 2 is invisible
!  (X-ray binary mode usually).  The horizon of star 2 is moved off to
!  a suitably large distance so that star 1 is never eclipsed.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ibetmax2
   INTEGER, INTENT(IN)                      :: nbet2
   INTEGER, INTENT(OUT)                     :: nhoriz2
   REAL(KIND=dp), INTENT(OUT)               :: xhoriz2(ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: yhoriz2(ibetmax2)
   INTEGER, INTENT(OUT)                     :: ntop2
   REAL(KIND=dp), INTENT(OUT)               :: xtop2horiz(ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: ytop2horiz(ibetmax2)
!
   REAL(KIND=dp) :: y,theta,thetar,x,r,steptheta
!
   INTEGER :: i
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   nhoriz2=nbet2
   ntop2=nbet2
!
   steptheta=360.0_dp/REAL(nbet2,KIND=dp)
   r=10.0_dp
   DO  i=1,nbet2
      theta=REAL(i,KIND=dp)*steptheta
      thetar=theta*degtorad
      x=r*COS(thetar)
      y=r*SIN(thetar)
      xhoriz2(i)=x+999.99E02_dp
      yhoriz2(i)=y+999.99E02_dp
      xtop2horiz(i)=x+999.99E02_dp
      ytop2horiz(i)=y+999.99E02_dp
   END DO
!
   RETURN
!
END SUBROUTINE dummyhoriz
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE dummyvalues(ialphmax2,ibetmax2,nalph2,nbet2,x2,y2,  &
   z2,surf2,gradx2,grady2,gradz2,g2,xend2,darkbol2,temp2,  &
   ibetlim2,mmdx2,ioutflag)
!
!  November 1, 1999
!
!  This routine is called when Teff2 < 0.  In this case, star 2 is invisible
!  (usually X-ray binary mode).  The coordinates are set to 0.0, the
!  gradients are set to 0.0, the gravities are set to 1.0, and the
!  limbdarkening coefficients are set to 0.0
!
!  UPDATE March 22, 2002
!
!  Add ibetlim2 to the argument list.  Dimension it below:
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax2
   INTEGER, INTENT(IN)                      :: ibetmax2
   INTEGER, INTENT(IN)                      :: nalph2
   INTEGER, INTENT(IN)                      :: nbet2
   REAL(KIND=dp), INTENT(OUT)               :: x2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: y2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: z2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: surf2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: gradx2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: grady2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: gradz2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: g2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: xend2(4)
   REAL(KIND=dp), INTENT(OUT)               :: darkbol2
   REAL(KIND=dp), INTENT(OUT)               :: temp2(ialphmax2*ibetmax2)
   INTEGER, INTENT(OUT)                     :: ibetlim2(ialphmax2)
   INTEGER, INTENT(OUT)                     :: mmdx2(ialphmax2,ibetmax2)
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp)    :: reff,psi0,tpole
!
   INTEGER   :: mmcount,ialf,ibet,iidx
!
   mmcount=0
!
   DO  ialf=1,nalph2
!
!   UPDATE March 22, 2002
!
!   Define the values of ibetlim2, and assign gradients values of 1
!
      ibetlim2(ialf)=4*nbet2
      DO  ibet=1,4*nbet2
         mmcount=mmcount+1
         mmdx2(ialf,ibet)=mmcount
         iidx=mmcount
         x2(iidx)=0.0_dp
         y2(iidx)=0.0_dp
         z2(iidx)=0.0_dp
         gradx2(iidx)=1.0_dp
         grady2(iidx)=1.0_dp
         gradz2(iidx)=1.0_dp
         g2(iidx)=1.0_dp
         surf2(iidx)=1.762429E-02_dp
         temp2(iidx)=1.0_dp
      END DO
   END DO
!
   xend2(1)=9.9999999_dp
   xend2(2)=9.9999999_dp
   reff=9.9999999_dp
   psi0=-9.999999_dp
   tpole=-9.99999_dp
!
   darkbol2=0.0_dp
!
   IF(ioutflag == 1)THEN
      WRITE(3,30)reff
      WRITE(3,40)reff
      WRITE(3,50)xend2(1)
      WRITE(3,60)xend2(2)
      WRITE(3,70)psi0
      WRITE(3,80)reff
      WRITE(3,90)reff
      WRITE(3,100)tpole
   END IF
!
30 FORMAT(f9.6,11X,'R_eff (star 2)')
40 FORMAT(f9.6,11X,'R_pole (star 2)')
50 FORMAT(f9.6,11X,'x(point) (star 2)')
60 FORMAT(f9.6,11X,'x(end) (star 2)')
70 FORMAT(f12.6,8X,'potential at fill2*L1')
80 FORMAT(e16.9,4X,'surface area (star 2)')
90 FORMAT(e16.9,4X,'volume (star 2)')
100 FORMAT(f10.4,10X,'polar temperature (star 2)')
!
   RETURN
!
END SUBROUTINE dummyvalues
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE dump(iunit,n,x,y)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                     :: iunit
   INTEGER, INTENT(IN)                     :: n
   REAL(KIND=dp), INTENT(IN OUT)           :: x(n)
   REAL(KIND=dp), INTENT(IN OUT)           :: y(n)
!
   INTEGER :: i
!
   CHARACTER(LEN=2) :: ext
!
   WRITE(ext,20)iunit
!
   OPEN(UNIT=iunit,FILE='fort.'//ext,STATUS='unknown')
   DO  i=1,n
      WRITE(iunit,30) x(i),y(i)
   END DO
!
   CLOSE(iunit)
!
20 FORMAT(i2)
30 FORMAT(f8.5,3X,f11.8)
!
   RETURN
!
END SUBROUTINE dump
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE dynlim(tstart,tend,h,ndynwin,dynwinlow,  &
   dynwinhigh,icount)
!
!   will see if the number of integration steps
!   exceeds the value of Ndyn, and return the number
!   of integration steps needed
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: tstart
   REAL(KIND=dp), INTENT(IN)                :: tend
   REAL(KIND=dp), INTENT(IN)                :: h
   INTEGER, INTENT(IN)                      :: ndynwin
   REAL(KIND=dp), INTENT(IN)                :: dynwinlow(ndynwin)
   REAL(KIND=dp), INTENT(IN)                :: dynwinhigh(ndynwin)
   INTEGER, INTENT(OUT)                     :: icount
!
   INTEGER :: nstep,i,j
!
   REAL(KIND=dp)  :: x,xend,xsave
!
   icount=0
   x=tstart
   xend=tend
   xsave=x
   nstep=nint((xend-x)/h)
   icount=nstep
!
   IF(ndynwin > 1)THEN
      DO i=1,nstep
         xsave=xsave+h
         DO j=1,ndynwin
            IF((xsave > dynwinlow(j)).AND.(xsave < dynwinhigh(j))) THEN
               icount=icount+1
            END IF
         END DO
      END DO
   END IF
!
   icount=icount+10
!
   RETURN
!
END SUBROUTINE dynlim
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE edgecor(nrow,xrow,yrow,phor1,phor2,corr)
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nrow
   REAL(KIND=dp), INTENT(IN OUT)            :: xrow(2000)
   REAL(KIND=dp), INTENT(IN OUT)            :: yrow(2000)
   REAL(KIND=dp), INTENT(IN OUT)            :: phor1
   REAL(KIND=dp), INTENT(IN OUT)            :: phor2
   REAL(KIND=dp), INTENT(OUT)               :: corr
!
   REAL(KIND=dp) :: corr1,corr2,diff,diffsmall,dphi,halfdphi,xpad,ypad,t1,t2
!
   INTEGER :: npad,i,index
!
   DIMENSION xpad(9999),ypad(9999)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   corr=0.0_dp
   corr1=0.0_dp
   corr2=0.0_dp
!
!    First, sort the array and pad it (make the angle go from
!    -2pi to 4pi to avoid edge effects
!
   IF(nrow > 1)CALL sort2(nrow,xrow,yrow)
   CALL addphipad(nrow,xrow,yrow,xpad,ypad)
   npad=nrow*3
!
!   Find the phi value of the visible pixel nearest to the
!   first limb (phor1)
!
   dphi=pie/REAL(nrow,KIND=dp)
   halfdphi=0.5_dp*dphi
   diffsmall=123456789.0_dp
   index=1
!
   IF(phor1 > 0.0_dp)THEN
      DO  i=1,npad
         IF(ypad(i) <= 0.0_dp)CYCLE
         diff=ABS(phor1-xpad(i))
         IF(diff < diffsmall)THEN
            index=i
            diffsmall=diff
         END IF
      END DO
!
!   Make sure the difference is less than dphi
!
      IF(diffsmall > dphi)GO TO 20
!
!   if the difference is greater than 0.5dphi, then add a small
!   correction
!
      IF(diffsmall < halfdphi)THEN
         corr1=ypad(index)*(diffsmall-dphi)/dphi
         t1=diffsmall-halfdphi
         t2=(t1/halfdphi)**2
         corr1=t2*0.5_dp*diffsmall*ypad(index)
      END IF
   END IF
!
20 CONTINUE
!
!   Check the other limb
!
   index=1
   diffsmall=123456789.0_dp
   IF(phor2 > 0.0_dp)THEN
      DO  i=1,npad
         IF(ypad(i) <= 0.0_dp)CYCLE
         diff=ABS(phor2-xpad(i))
         IF(diff < diffsmall)THEN
            index=i
            diffsmall=diff
         END IF
      END DO
!
!   Make sure the difference is less than dphi
!
      IF(diffsmall > dphi)GO TO 40
!
!   if the difference is greater than 0.5dphi, then add a small
!   correction
!
      IF(diffsmall < halfdphi)THEN
         corr2=ypad(index)*(diffsmall-dphi)/dphi
         t1=diffsmall-halfdphi
         t2=(t1/halfdphi)**2
         corr2=t2*0.5_dp*diffsmall*ypad(index)
      END IF
   END IF
!
40 corr=corr1+corr2
!
   corr=0.0_dp
!
   RETURN
!
END SUBROUTINE edgecor
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION ellec(k)
!
!   From Numerical Recipes
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)             :: k
!
   REAL(KIND=dp) :: m1,a1,a2,a3,a4,b1,b2,b3,b4,ee1,ee2,ellec
!
! Computes polynomial approximation for the complete elliptic
! integral of the second kind (Hasting's approximation):
!
   m1=1.0_dp-k*k
   a1=0.44325141463_dp
   a2=0.06260601220_dp
   a3=0.04757383546_dp
   a4=0.01736506451_dp
   b1=0.24998368310_dp
   b2=0.09200180037_dp
   b3=0.04069697526_dp
   b4=0.00526449639_dp
   ee1=1.0_dp+m1*(a1+m1*(a2+m1*(a3+m1*a4)))
   ee2=m1*(b1+m1*(b2+m1*(b3+m1*b4)))*LOG(1.0_dp/m1)
   ellec=ee1+ee2
   RETURN
!
END FUNCTION ellec
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION ellk (k)
!
!   from Numerical Recipes
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)             :: k
!
   REAL(KIND=dp) :: a0,a1,a2,a3,a4,b0,b1,b2,b3,b4,ellk
   REAL(KIND=dp) :: ek1,ek2, m1
!
! Computes polynomial approximation for the complete elliptic
! integral of the first kind (Hasting's approximation):
!
   m1=1.0_dp-k*k
   a0=1.38629436112_dp
   a1=0.09666344259_dp
   a2=0.03590092383_dp
   a3=0.03742563713_dp
   a4=0.01451196212_dp
   b0=0.5_dp
   b1=0.12498593597_dp
   b2=0.06880248576_dp
   b3=0.03328355346_dp
   b4=0.00441787012_dp
   ek1=a0+m1*(a1+m1*(a2+m1*(a3+m1*a4)))
   ek2=(b0+m1*(b1+m1*(b2+m1*(b3+m1*b4))))*LOG(m1)
   ellk=ek1-ek2
   RETURN
!
END FUNCTION ellk
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE equa(n,q,f,ipar,rmass,nbody)
!
!   from Ernst Hairer.  Gives the Newtonian equations of motion
!   for the N-body problem
!
   USE accur
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: q(n)
   REAL(KIND=dp), INTENT(OUT)               :: f(n)
   INTEGER, INTENT(IN OUT)                  :: ipar(*)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
!
   REAL(KIND=dp) :: d(10,10)
!
   INTEGER :: i,i1,j,j1
!
   ipar(12)=ipar(12)+1
!
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   DO i=1,nbody-1
      i1=3*(i-1)+1
      DO j=i+1,nbody
         j1=3*(j-1)+1
         d(i,j)=(SQRT((q(i1)-q(j1))**2+(q(i1+1)-q(j1+1))**2+(q(i1+  &
            2)-q(j1+2))**2))**3
         d(j,i)=d(i,j)
      END DO
   END DO
!
   DO i=1,nbody
      i1=3*(i-1)+1
      f(i1)=0.0_dp
      f(i1+1)=0.0_dp
      f(i1+2)=0.0_dp
      DO j=1,nbody
         IF(j /= i)THEN
            j1=3*(j-1)+1
            f(i1)=f(i1)+rmass(j)*(q(j1)-q(i1))/d(i,j)
            f(i1+1)=f(i1+1)+rmass(j)*(q(j1+1)-q(i1+1))/d(i,j)
            f(i1+2)=f(i1+2)+rmass(j)*(q(j1+2)-q(i1+2))/d(i,j)
         END IF
      END DO
      f(i1)=g*f(i1)
      f(i1+1)=g*f(i1+1)
      f(i1+2)=g*f(i1+2)
   END DO
!
   RETURN
!
END SUBROUTINE equa
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE fakehorizon(nhoriz3,xhoriz3,yhoriz3,xxx,yyy,reff3)
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nhoriz3
   REAL(KIND=dp), INTENT(OUT)               :: xhoriz3(nhoriz3)
   REAL(KIND=dp), INTENT(OUT)               :: yhoriz3(nhoriz3)
   REAL(KIND=dp), INTENT(IN)                :: xxx
   REAL(KIND=dp), INTENT(IN)                :: yyy
   REAL(KIND=dp), INTENT(IN)                :: reff3
!
   REAL(KIND=dp)  :: theta
!
   INTEGER :: i
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   DO  i=1,360
      theta=REAL(i,KIND=dp)*degtorad
      xhoriz3(i)=reff3*COS(theta)+xxx
      yhoriz3(i)=reff3*SIN(theta)+yyy
   END DO
!
   RETURN
!
END SUBROUTINE fakehorizon
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE fastanalytic(nphase,nmaxphase,xmod,ymodu,ymodb,ymodv,ymodr,ymodi,  &
   ymodj,ymodh,ymodk,ymods1,ymods2,ymods3,ymodd,rv1,rv2,drv1,drv2,nrvphase,  &
   xrvmod,fracs1,fracs2,fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,period,t0,  &
   ecc,argper,omega1,finc,ilaw,dwavex,dwavey,bigi,bigbeta,sw29,sw30,ialign,  &
   ikeep,pshift,reff1,reff2,darkint1,darkint2,idark2,dphase,irvfilt,q,separ,  &
   gamma,isw27,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,icnrv1,icnrv2,  &
   timearray,sw9,sw23,sw24,isw7,sa3,third,contam,pconj,beam1,beam2,ngap,  &
   gaplow,gaphigh,tertperiod,tertt0,tertecos,tertesin,tertincl,tertomega,  &
   tertq,itconj,tertconj,isw30,darkint3,omegadot,odetime,nstep,mandel,  &
   contams0,contams1,contams2,contams3,iseason,ndyn,p2tconj,p2period,p2ecos,  &
   p2esin,p2incl,p2omega,p2q,p2ratrad,p3tconj,p3period,p3ecos,p3esin,p3incl,  &
   p3omega,p3q,p3ratrad,p4tconj,p4period,p4ecos,p4esin,p4incl,p4omega,p4q,  &
   p4ratrad,p5tconj,p5period,p5ecos,p5esin,p5incl,p5omega,p5q,p5ratrad,  &
   p6tconj,p6period,p6ecos,p6esin,p6incl,p6omega,p6q,p6ratrad,p7tconj,  &
   p7period,p7ecos,p7esin,p7incl,p7omega,p7q,p7ratrad,p8tconj,p8period,  &
   p8ecos,p8esin,p8incl,p8omega,p8q,p8ratrad,rv3,nsc,xsc,ysc,darkint4,  &
   fourth,ymods4,ymods5,darkint5,rv4,isw87,tertratrad,sdarkint6,sdarkint7,  &
   sdarkint8,sdarkint9,sdarkint10,sqtertecos,sqtertesin,sqp2ecos,sqp2esin,  &
   sqp3ecos,sqp3esin,sqp4ecos,sqp4esin,sqp5ecos,sqp5esin,sqp6ecos,sqp6esin,  &
   sqp7ecos,sqp7esin,sqp8ecos,sqp8esin,body01posx,body01posy,body01posz,  &
   body02posx,body02posy,body02posz,body03posx,body03posy,body03posz,  &
   body04posx,body04posy,body04posz,body05posx,body05posy,body05posz,  &
   body06posx,body06posy,body06posz,body07posx,body07posy,body07posz,  &
   body08posx,body08posy,body08posz,body09posx,body09posy,body09posz,  &
   body10posx,body10posy,body10posz,body01velx,body01vely,body01velz,  &
   body02velx,body02vely,body02velz,body03velx,body03vely,body03velz,  &
   body04velx,body04vely,body04velz,body05velx,body05vely,body05velz,  &
   body06velx,body06vely,body06velz,body07velx,body07vely,body07velz,  &
   body08velx,body08vely,body08velz,body09velx,body09vely,body09velz,  &
   body10velx,body10vely,body10velz,bigi2,bigi3,bigi4,bigbeta2,bigbeta3,  &
   bigbeta4,omega2,omega3,omega4,omega5,omega6,omega7,omega8,omega9,omega10,  &
   drv3,drv4,drv5,rv5,it2,iatm,lengthtime,iversion,tesscontam,tessfilt,  &
   tessbin)                                                        
!
!   UPDATE December 9, 2009
!
!   This is a new routine that will compute light curves using the
!   analytic expressions of Giminez.  This routine tries to do as little
!   as possible when computing the curves.
!
!   UPDATE March 15, 2011
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: lengthtime
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(OUT)                     :: nphase
   INTEGER, INTENT(IN)                      :: nmaxphase
   REAL(KIND=dp), INTENT(OUT)               :: xmod(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodu(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodb(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodv(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodr(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodi(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodj(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodh(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodk(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods2(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods3(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodd(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: rv1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: rv2(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv2(nmaxphase)
   INTEGER, INTENT(OUT)                     :: nrvphase
   REAL(KIND=dp), INTENT(OUT)               :: xrvmod(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: fracs1(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs2(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs3(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs4(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs5(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs6(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs7(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs8(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN OUT)            :: period
   REAL(KIND=dp), INTENT(IN OUT)            :: t0
   REAL(KIND=dp), INTENT(IN OUT)            :: ecc
   REAL(KIND=dp), INTENT(IN OUT)            :: argper
   REAL(KIND=dp), INTENT(IN OUT)            :: omega1
   REAL(KIND=dp), INTENT(IN OUT)            :: finc
   INTEGER, INTENT(IN OUT)                  :: ilaw
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: bigi
   REAL(KIND=dp), INTENT(IN OUT)            :: bigbeta
   REAL(KIND=dp), INTENT(IN OUT)            :: sw29
   REAL(KIND=dp), INTENT(IN OUT)            :: sw30
   INTEGER, INTENT(IN OUT)                  :: ialign
   INTEGER, INTENT(IN OUT)                  :: ikeep
   REAL(KIND=dp), INTENT(IN OUT)            :: pshift
   REAL(KIND=dp), INTENT(IN OUT)            :: reff1
   REAL(KIND=dp), INTENT(IN OUT)            :: reff2
   REAL(KIND=dp), INTENT(IN OUT)            :: darkint1(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: darkint2(8)
   INTEGER, INTENT(IN OUT)                  :: idark2
   REAL(KIND=dp), INTENT(IN OUT)            :: dphase
   INTEGER, INTENT(IN OUT)                  :: irvfilt
   REAL(KIND=dp), INTENT(IN OUT)            :: q
   REAL(KIND=dp), INTENT(IN OUT)            :: separ
   REAL(KIND=dp), INTENT(IN OUT)            :: gamma
   INTEGER, INTENT(IN OUT)                  :: isw27
   INTEGER, INTENT(IN)                      :: icnu
   INTEGER, INTENT(IN)                      :: icnb
   INTEGER, INTENT(IN)                      :: icnv
   INTEGER, INTENT(IN)                      :: icnr
   INTEGER, INTENT(IN)                      :: icni
   INTEGER, INTENT(IN)                      :: icnj
   INTEGER, INTENT(IN)                      :: icnh
   INTEGER, INTENT(IN)                      :: icnk
   INTEGER, INTENT(IN)                      :: icnrv1
   INTEGER, INTENT(IN)                      :: icnrv2
   REAL(KIND=dp), INTENT(IN OUT)            :: timearray(lengthtime)
   REAL(KIND=dp), INTENT(IN OUT)            :: sw9
   REAL(KIND=dp), INTENT(IN OUT)            :: sw23
   REAL(KIND=dp), INTENT(IN OUT)            :: sw24
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN OUT)            :: sa3
   REAL(KIND=dp), INTENT(IN OUT)            :: third(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: contam
   REAL(KIND=dp), INTENT(IN OUT)            :: pconj
   REAL(KIND=dp), INTENT(IN OUT)            :: beam1
   REAL(KIND=dp), INTENT(IN OUT)            :: beam2
   INTEGER, INTENT(IN)                      :: ngap
   REAL(KIND=dp), INTENT(IN)                :: gaplow(9999)
   REAL(KIND=dp), INTENT(IN)                :: gaphigh(9999)
   REAL(KIND=dp), INTENT(IN OUT)            :: tertperiod
   REAL(KIND=dp), INTENT(IN OUT)            :: tertt0
   REAL(KIND=dp), INTENT(IN OUT)            :: tertecos
   REAL(KIND=dp), INTENT(IN OUT)            :: tertesin
   REAL(KIND=dp), INTENT(IN OUT)            :: tertincl
   REAL(KIND=dp), INTENT(IN OUT)            :: tertomega
   REAL(KIND=dp), INTENT(IN OUT)            :: tertq
   INTEGER, INTENT(IN OUT)                  :: itconj
   REAL(KIND=dp), INTENT(IN OUT)            :: tertconj
   INTEGER, INTENT(IN OUT)                  :: isw30
   REAL(KIND=dp), INTENT(IN OUT)            :: darkint3(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: omegadot
   REAL(KIND=dp), INTENT(IN OUT)            :: odetime(ndyn)
   INTEGER, INTENT(IN OUT)                  :: nstep
   INTEGER, INTENT(IN OUT)                  :: mandel
   REAL(KIND=dp), INTENT(IN OUT)            :: contams0
   REAL(KIND=dp), INTENT(IN OUT)            :: contams1
   REAL(KIND=dp), INTENT(IN OUT)            :: contams2
   REAL(KIND=dp), INTENT(IN OUT)            :: contams3
   INTEGER, INTENT(IN OUT)                  :: iseason
   REAL(KIND=dp), INTENT(IN OUT)            :: p2tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p2period
   REAL(KIND=dp), INTENT(IN OUT)            :: p2ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p2esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p2incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p2omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p2q
   REAL(KIND=dp), INTENT(IN OUT)            :: p2ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p3tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p3period
   REAL(KIND=dp), INTENT(IN OUT)            :: p3ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p3esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p3incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p3omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p3q
   REAL(KIND=dp), INTENT(IN OUT)            :: p3ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p4tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p4period
   REAL(KIND=dp), INTENT(IN OUT)            :: p4ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p4esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p4incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p4omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p4q
   REAL(KIND=dp), INTENT(IN OUT)            :: p4ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p5tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p5period
   REAL(KIND=dp), INTENT(IN OUT)            :: p5ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p5esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p5incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p5omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p5q
   REAL(KIND=dp), INTENT(IN OUT)            :: p5ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p6tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p6period
   REAL(KIND=dp), INTENT(IN OUT)            :: p6ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p6esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p6incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p6omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p6q
   REAL(KIND=dp), INTENT(IN OUT)            :: p6ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p7tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p7period
   REAL(KIND=dp), INTENT(IN OUT)            :: p7ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p7esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p7incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p7omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p7q
   REAL(KIND=dp), INTENT(IN OUT)            :: p7ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p8tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p8period
   REAL(KIND=dp), INTENT(IN OUT)            :: p8ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: p8esin
   REAL(KIND=dp), INTENT(IN OUT)            :: p8incl
   REAL(KIND=dp), INTENT(IN OUT)            :: p8omega
   REAL(KIND=dp), INTENT(IN OUT)            :: p8q
   REAL(KIND=dp), INTENT(IN OUT)            :: p8ratrad
   REAL(KIND=dp), INTENT(OUT)               :: rv3(nmaxphase)
   INTEGER, INTENT(IN)                      :: nsc
   REAL(KIND=dp), INTENT(IN)                :: xsc(9999)
   REAL(KIND=dp), INTENT(IN)                :: ysc(9999)
   REAL(KIND=dp), INTENT(IN OUT)            :: darkint4(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: fourth(8)
   REAL(KIND=dp), INTENT(OUT)               :: ymods4(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods5(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: darkint5(8)
   REAL(KIND=dp), INTENT(OUT)               :: rv4(nmaxphase)
   INTEGER, INTENT(IN)                      :: isw87
   REAL(KIND=dp), INTENT(IN OUT)            :: tertratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint6(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint7(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint8(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint9(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sdarkint10(8)
   REAL(KIND=dp), INTENT(IN OUT)            :: sqtertecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqtertesin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp2ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp2esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp3ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp3esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp4ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp4esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp5ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp5esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp6ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp6esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp7ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp7esin
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp8ecos
   REAL(KIND=dp), INTENT(IN OUT)            :: sqp8esin
   REAL(KIND=dp), INTENT(IN)                :: body01posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10velz(ndyn)
   REAL(KIND=dp), INTENT(IN OUT)            :: bigi2
   REAL(KIND=dp), INTENT(IN OUT)            :: bigi3
   REAL(KIND=dp), INTENT(IN OUT)            :: bigi4
   REAL(KIND=dp), INTENT(IN OUT)            :: bigbeta2
   REAL(KIND=dp), INTENT(IN OUT)            :: bigbeta3
   REAL(KIND=dp), INTENT(IN OUT)            :: bigbeta4
   REAL(KIND=dp), INTENT(IN OUT)            :: omega2
   REAL(KIND=dp), INTENT(IN OUT)            :: omega3
   REAL(KIND=dp), INTENT(IN OUT)            :: omega4
   REAL(KIND=dp), INTENT(IN OUT)            :: omega5
   REAL(KIND=dp), INTENT(IN OUT)            :: omega6
   REAL(KIND=dp), INTENT(IN OUT)            :: omega7
   REAL(KIND=dp), INTENT(IN OUT)            :: omega8
   REAL(KIND=dp), INTENT(IN OUT)            :: omega9
   REAL(KIND=dp), INTENT(IN OUT)            :: omega10
   REAL(KIND=dp), INTENT(OUT)               :: drv3(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv4(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv5(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: rv5(nmaxphase)
   INTEGER, INTENT(IN OUT)                  :: it2
   INTEGER, INTENT(IN)                      :: iatm
   INTEGER, INTENT(IN)                      :: iversion
   REAL(KIND=dp), INTENT(IN)                :: tesscontam
   INTEGER, INTENT(IN)                      :: tessfilt
   REAL(KIND=dp), INTENT(IN)                :: tessbin
!
!   INTEGER, PARAMETER :: mm=100
   INTEGER, PARAMETER :: nmumax=10001
!
!   integer scalars
!
   INTEGER :: icount,icounttime,ii,ijk,iloopin,iloopout,ioverlap,irossiter,j
   INTEGER :: jlo,kk,ll,nbody,neclipse1,nloopin,nloopout,nmu,ntime 
!
!   integer array
!
   INTEGER, DIMENSION(8) :: icnarray
!
!   real scalars
!
   REAL(KIND=dp) :: aa1,aa10,aa2,aa3,aa4,aa5,aa6,aa7,aa8,aa9,argrad,axisscale
   REAL(KIND=dp) :: axisscale2,axisscale3,axisscale4,axisscale5,axisscale6
   REAL(KIND=dp) :: axisscale7,axisscale8,bb1,bb10,bb2,bb3,bb4,bb5,bb6,bb7,bb8
   REAL(KIND=dp) :: bb9,bdist,bigbeta5,bige,bigi5,centx1,centx10,centx10a
   REAL(KIND=dp) :: centx2,centx3,centx3a,centx4,centx4a,centx5,centx5a,centx6
   REAL(KIND=dp) :: centx6a,centx7,centx7a,centx8,centx8a,centx9,centx9a,centy1
   REAL(KIND=dp) :: centy10,centy10a,centy2,centy3,centy3a,centy4,centy4a
   REAL(KIND=dp) :: centy5,centy5a,centy6,centy6a,centy7,centy7a,centy8,centy8a
   REAL(KIND=dp) :: centy9,centy9a,coeff1,delta,delx,dely,diff1,diff2,dop1,dop2
   REAL(KIND=dp) :: dummyphase,em,eshift,fakebeta,fakei,fincr,hutfac,offset1
   REAL(KIND=dp) :: offset2,offset3,offset4,offset5,pconj2,pconj3,pconj3_2
   REAL(KIND=dp) :: pconj3_3,pconj3_4,pconj3_5,pconj3_6,pconj3_7,pconj3_8
   REAL(KIND=dp) :: pconj4,pconj4_2,pconj4_3,pconj4_4,pconj4_5,pconj4_6
   REAL(KIND=dp) :: pconj4_7,pconj4_8,phase,phasein,phaseout,phaser,phper1
   REAL(KIND=dp) :: phper2,phper3a,phper3b,phper4a,phper4b,phper5a,phper5b
   REAL(KIND=dp) :: phper6a,phper6b,phper7a,phper7b,phper8a,phper8b,ppp,pstart
   REAL(KIND=dp) :: pstartout,pstep,pstop,pstopout,reff10,reff3,reff4,reff5
   REAL(KIND=dp) :: reff6,reff7,reff8,reff9,rnu,rot1,rot10,rot2,rot3,rot4,rot5
   REAL(KIND=dp) :: rot6,rot7,rot8,rot9,sa1,saveargper,small,smet,smet2,smet3
   REAL(KIND=dp) :: smet4,smet5,smet6,smet7,smet8,sneed,tempbeta,tertarg
   REAL(KIND=dp) :: tertarg2,tertarg3,tertarg4,tertarg5,tertarg6,tertarg7
   REAL(KIND=dp) :: tertarg8,tertargrad,tertargrad2,tertargrad3,tertargrad4
   REAL(KIND=dp) :: tertargrad5,tertargrad6,tertargrad7,tertargrad8,tertbdist
   REAL(KIND=dp) :: tertbdist2,tertbdist3,tertbdist4,tertbdist5,tertbdist6
   REAL(KIND=dp) :: tertbdist7,tertbdist8,tertecc,tertecc2,tertecc3,tertecc4
   REAL(KIND=dp) :: tertecc5,tertecc6,tertecc7,tertecc8,tertmass,tertmass2
   REAL(KIND=dp) :: tertmass3,tertmass4,tertmass5,tertmass6,tertmass7,tertmass8
   REAL(KIND=dp) :: tertphase,tertphase2,tertphase3,tertphase4,tertphase5
   REAL(KIND=dp) :: tertphase6,tertphase7,tertphase8,tertppp,tertppp2,tertppp3
   REAL(KIND=dp) :: tertppp4,tertppp5,tertppp6,tertppp7,tertppp8,tertrnu
   REAL(KIND=dp) :: tertrnu2,tertrnu3,tertrnu4,tertrnu5,tertrnu6,tertrnu7
   REAL(KIND=dp) :: tertrnu8,tertsep,tertsep2,tertsep3,tertsep4,tertsep5
   REAL(KIND=dp) :: tertsep6,tertsep7,tertsep8,tertt02,tertt03,tertt04,tertt05
   REAL(KIND=dp) :: tertt06,tertt07,tertt08,tertxcen,tertycen,timein,tol,tomrad
   REAL(KIND=dp) :: tomrad2,tomrad3,tomrad4,tomrad5,tomrad6,tomrad7,tomrad8
   REAL(KIND=dp) :: total_mass,tshift,tstart,tstep,tstop,tt1,tt12,tt13,tt14
   REAL(KIND=dp) :: tt15,tt16,tt17,tt18,tt2,tt3,ttiny,vel1,vel2,velout1
   REAL(KIND=dp) :: velout10,velout2,velout3,velout4,velout5,velout6,velout7
   REAL(KIND=dp) :: velout8,velout9,xp,xtran,xx,xxoff,xxoff1,yp,ytran,yy,yyoff
   REAL(KIND=dp) :: yyoff1,zeighth,zfifth,zfirst,zfourth,zninth,zsecond
   REAL(KIND=dp) :: zseventh,zsixth,ztenth,zthird,zz             
!
!   real arrays
!
   REAL(KIND=dp), DIMENSION(8) :: corr1,corr1a,corr1tran2,corr1tran3,corr1tran4
   REAL(KIND=dp), DIMENSION(8) :: corr1tran5,corr1tran6,corr1tran7,corr1tran8
   REAL(KIND=dp), DIMENSION(8) :: corr1tran9,corr1tran10,corr2,corr2a
   REAL(KIND=dp), DIMENSION(8) :: corr2tran1,corr2tran3,corr2tran4,corr2tran5
   REAL(KIND=dp), DIMENSION(8) :: corr3tran1,corr3tran2,corr3tran4,corr3tran5
   REAL(KIND=dp), DIMENSION(8) :: corr4tran1,corr4tran2,corr4tran3,corr4tran5
   REAL(KIND=dp), DIMENSION(8) :: corr5tran1,corr5tran2,corr5tran3,corr5tran4
   REAL(KIND=dp), DIMENSION(8) :: corr6tran1,corr7tran1,corr8tran1,corr9tran1
   REAL(KIND=dp), DIMENSION(8) :: corr10tran1,donvel1,donvel2,donvel3,donvel4
   REAL(KIND=dp), DIMENSION(8) :: donvel5,donvel6,donvel7,donvel8,donvel9
   REAL(KIND=dp), DIMENSION(8) :: donvel10,gimvel1,gimvel2,gimvel3,gimvel4
   REAL(KIND=dp), DIMENSION(8) :: gimvel5,gimvel6,gimvel7,gimvel8,gimvel9
   REAL(KIND=dp), DIMENSION(8) :: gimvel10,refflux1,refflux2,refflux3,refflux4
   REAL(KIND=dp), DIMENSION(8) :: refflux5,refflux6,refflux7,refflux8,refflux9
   REAL(KIND=dp), DIMENSION(8) :: refflux10                                    
   REAL(KIND=dp), DIMENSION(10)   :: aalist,bblist,radlist,rotlist,zlist
   REAL(KIND=dp), DIMENSION(10,2) :: xylist
   REAL(KIND=dp), DIMENSION(10,8) :: corrlist,donvellist,reffluxlist
   REAL(KIND=dp), DIMENSION(nmumax,5) :: table51a,table51b,table51c,table51d
   REAL(KIND=dp), DIMENSION(nmumax,5) :: table51e,table52a,table52b,table52c
   REAL(KIND=dp), DIMENSION(nmumax,5) :: table52d,table52e,table53a,table53b
   REAL(KIND=dp), DIMENSION(nmumax,5) :: table53c,table53d,table53e,table54a
   REAL(KIND=dp), DIMENSION(nmumax,5) :: table54b,table54c,table54d,table54e
   REAL(KIND=dp), DIMENSION(nmumax,5) :: table55a,table55b,table55c,table55d
   REAL(KIND=dp), DIMENSION(nmumax,5) :: table55e,table56a,table56b,table56c
   REAL(KIND=dp), DIMENSION(nmumax,5) :: table56d,table56e,table57a,table57b
   REAL(KIND=dp), DIMENSION(nmumax,5) :: table57c,table57d,table57e,table58a
   REAL(KIND=dp), DIMENSION(nmumax,5) :: table58b,table58c,table58d,table58e 
!
!   old dimensions
!
!          DIMENSION zzq(6,60,Ndyn)
!
!  Set the "tolerance" for the Short method
!
   tol=2.0_dp
!
!  Set the flag for the Rossiter effect for the Short method
!
   irossiter=0
   IF(mandel >= 3)irossiter=1
!
   ii=100
!
   nbody=isw30
!
   neclipse1=0
!
!   initialize some variables
!
   centx1=0.0_dp
   centy1=0.0_dp
   centx2=0.0_dp
   centy2=0.0_dp
   centx3=0.0_dp
   centy3=0.0_dp
   centx4=0.0_dp
   centy4=0.0_dp
   centx5=0.0_dp
   centy5=0.0_dp
   centx6=0.0_dp
   centy6=0.0_dp
   centx7=0.0_dp
   centy7=0.0_dp
   centx8=0.0_dp
   centy8=0.0_dp
   centx9=0.0_dp
   centy9=0.0_dp
   centx10=0.0_dp
   centy10=0.0_dp
!
   icnarray(1)=icnu
   icnarray(2)=icnb
   icnarray(3)=icnv
   icnarray(4)=icnr
   icnarray(5)=icni
   icnarray(6)=icnj
   icnarray(7)=icnh
   icnarray(8)=icnk
!
   nphase=0
   nrvphase=0
   xmod=0.0_dp
   xrvmod=0.0_dp
   ymodu=0.0_dp
   ymodb=0.0_dp
   ymodv=0.0_dp
   ymodr=0.0_dp
   ymodi=0.0_dp
   ymodj=0.0_dp
   ymodh=0.0_dp
   ymodk=0.0_dp
   ymods1=0.0_dp
   ymods2=0.0_dp
   ymods3=0.0_dp
   ymods4=0.0_dp
   ymods5=0.0_dp
   ymodd=0.0_dp
   rv1=0.0_dp
   rv2=0.0_dp
   rv3=0.0_dp
   rv4=0.0_dp
   rv5=0.0_dp
   drv1=0.0_dp
   drv2=0.0_dp
   drv3=0.0_dp
   drv4=0.0_dp
   drv5=0.0_dp
   fracs1=0.0_dp
   fracs2=0.0_dp
   fracs3=0.0_dp
   fracs4=0.0_dp
   fracs5=0.0_dp
   fracs6=0.0_dp
   fracs7=0.0_dp
   fracs8=0.0_dp
!
   vel1=0.0_dp
   vel2=0.0_dp
!
!  Set up the model atmosphere table is iatm=3
!
   IF(iatm == 3)THEN
      tol=2.0_dp
      nmu=1001
      CALL filltable5(nmumax,nmu,icnarray,ilaw,nbody,dwavex,  &
         dwavey,table51a,table51b,table51c,table51d,table51e,  &
         table52a,table52b,table52c,table52d,table52e,table53a,  &
         table53b,table53c,table53d,table53e,table54a,table54b,  &
         table54c,table54d,table54e,table55a,table55b,table55c,  &
         table55d,table54e,table56a,table56b,table56c,table56d,  &
         table56e,table57a,table57b,table57c,table57d,table57e,  &
         table58a,table58b,table58c,table58d,table58e)
   END IF
!
!  Items for the Rossiter effect in the Short method
!
   hutfac=(1.0_dp+7.5_dp*ecc*ecc+5.625_dp*ecc**4+0.3125_dp*ecc**6)/  &
      ((1.0_dp+3.0_dp*ecc*ecc+3.0_dp/8.0_dp*ecc**4)*SQRT((1.0_dp-ecc*ecc)**3))

   rot1=twopie*omega1*hutfac/period
   rot2=twopie*omega2*hutfac/period
   rot3=0.0_dp
   rot4=0.0_dp
   rot5=0.0_dp
   rot6=0.0_dp
   rot7=0.0_dp
   rot8=0.0_dp
   rot9=0.0_dp
   rot10=0.0_dp
   IF(nbody >= 3)rot3=twopie*omega3/tertperiod
   IF(nbody >= 4)rot4=twopie*omega4/p2period
   IF(nbody >= 5)rot5=twopie*omega5/p3period
   IF(nbody >= 6)rot6=twopie*omega6/p4period
   IF(nbody >= 7)rot7=twopie*omega7/p5period
   IF(nbody >= 8)rot8=twopie*omega8/p6period
   IF(nbody >= 9)rot9=twopie*omega9/p7period
   IF(nbody >= 10)rot10=twopie*omega10/p8period
!
   aa1=SIN(degtorad*bigi)*COS(bigbeta*degtorad)
   bb1=SIN(bigi*degtorad)*SIN(bigbeta*degtorad)

   aa2=SIN(degtorad*bigi2)*COS(bigbeta2*degtorad)
   bb2=SIN(bigi2*degtorad)*SIN(bigbeta2*degtorad)

   aa3=SIN(degtorad*bigi3)*COS(bigbeta3*degtorad)
   bb3=SIN(bigi3*degtorad)*SIN(bigbeta3*degtorad)

   aa4=SIN(degtorad*bigi4)*COS(bigbeta4*degtorad)
   bb4=SIN(bigi4*degtorad)*SIN(bigbeta4*degtorad)
!
   aa5=0.0_dp
   bb5=0.0_dp
   aa6=0.0_dp
   bb6=0.0_dp
   aa7=0.0_dp
   bb7=0.0_dp
   aa8=0.0_dp
   bb8=0.0_dp
   aa9=0.0_dp
   bb9=0.0_dp
   aa10=0.0_dp
   bb10=0.0_dp
!
   bigi5=90.0_dp
   bigbeta5=0.0_dp
!
   aalist(1)=aa1
   aalist(2)=aa2
   aalist(3)=aa3
   aalist(4)=aa4
   aalist(5)=aa5
   aalist(6)=aa6
   aalist(7)=aa7
   aalist(8)=aa8
   aalist(9)=aa9
   aalist(10)=aa10
   bblist(1)=bb1
   bblist(2)=bb2
   bblist(3)=bb3
   bblist(4)=bb4
   bblist(5)=bb5
   bblist(6)=bb6
   bblist(7)=bb7
   bblist(8)=bb8
   bblist(9)=bb9
   bblist(10)=bb10
   rotlist(1)=rot1
   rotlist(2)=rot2
   rotlist(3)=rot3
   rotlist(4)=rot4
   rotlist(5)=rot5
   rotlist(6)=rot6
   rotlist(7)=rot7
   rotlist(8)=rot8
   rotlist(9)=rot9
   rotlist(10)=rot10
!
   saveargper=argper
!
   DO j=1,8
      gimvel1(j)=0.0_dp
      gimvel2(j)=0.0_dp
   END DO
   centx1=0.0_dp
   centx2=0.0_dp
   centx3=0.0_dp
   centy1=0.0_dp
   centy2=0.0_dp
   centy3=0.0_dp
   icounttime=0
   nloopout=0
   iloopout=0
   nloopin=0
   iloopin=0
   tstep=sw9
   tstart=sw23
   tstop=sw24
   sa1=reff1*reff1*4.0_dp*pie
   sneed=sa1*sa3
   reff3=SQRT(sneed/4.0_dp/pie)
!
   IF(ABS(tertratrad) <= EPSILON(tertratrad))THEN
      reff3=0.0_dp
   ELSE
      reff3=reff1/tertratrad
   END IF
!
   IF(ABS(p2ratrad) <= EPSILON(p2ratrad))THEN
      reff4=0.0_dp
   ELSE
      reff4=reff1/p2ratrad
   END IF
!
   IF(ABS(p3ratrad) <= EPSILON(p3ratrad))THEN
      reff5=0.0_dp
   ELSE
      reff5=reff1/p3ratrad
   END IF
!
   IF(ABS(p4ratrad) <= EPSILON(p4ratrad))THEN
      reff6=0.0_dp
   ELSE
      reff6=reff1/p4ratrad
   END IF
!
   IF(ABS(p5ratrad) <= EPSILON(p5ratrad))THEN
      reff7=0.0_dp
   ELSE
      reff7=reff1/p5ratrad
   END IF
!
   IF(ABS(p6ratrad) <= EPSILON(p6ratrad))THEN
      reff8=0.0_dp
   ELSE
      reff8=reff1/p6ratrad
   END IF
!
   IF(ABS(p7ratrad) <= EPSILON(p7ratrad))THEN
      reff9=0.0_dp
   ELSE
      reff9=reff1/p7ratrad
   END IF
!
   IF(ABS(p8ratrad) <= EPSILON(p8ratrad))THEN
      reff10=0.0_dp
   ELSE
      reff10=reff1/p8ratrad
   END IF
!
!  If we are using the Short method to produce the light curves,
!  fill the radlist array
!
   IF(mandel >= 2)THEN
      radlist(1)=reff1
      radlist(2)=reff2
      radlist(3)=reff3
      radlist(4)=reff4
      radlist(5)=reff5
      radlist(6)=reff6
      radlist(7)=reff7
      radlist(8)=reff8
      radlist(9)=reff9
      radlist(10)=reff10
   END IF
!
!  isw30 is Nbody
!
   IF(isw30 > 2)THEN
      fincr=finc*degtorad
      ppp=period*24.0_dp
      coeff1=7.737294491_dp
      total_mass=(separ)**(3)*coeff1/(ppp*ppp)
      tertmass=total_mass/tertq
      tt1=(total_mass+tertmass)*(tertperiod*secinday)**2*gmsun
      smet=(tt1/(fourpiesquared))**(1.0_dp/3.0_dp)
      tertsep=smet/solarrad
      axisscale=tertsep/separ
      tt1=(total_mass)*(period*secinday)**2*gmsun
      smet=(tt1/(fourpiesquared))**(1.0_dp/3.0_dp)
!
      IF(p2q <= 0.0_dp)THEN
         tertmass2=0.0_dp
      ELSE
         tertmass2=total_mass/p2q
      END IF
      tt12=(total_mass+tertmass2)*(p2period*secinday)**2*gmsun
      smet2=(tt12/(fourpiesquared))**(1.0_dp/3.0_dp)
      tertsep2=smet2/solarrad
      axisscale2=tertsep2/separ
      tt12=(total_mass)*(period*secinday)**2*gmsun
      smet2=(tt12/(fourpiesquared))**(1.0_dp/3.0_dp)
!
      IF(p3q <= 0.0_dp)THEN
         tertmass3=0.0_dp
      ELSE
         tertmass3=total_mass/p3q
      END IF
      tt13=(total_mass+tertmass3)*(p3period*secinday)**2*gmsun
      smet3=(tt13/(fourpiesquared))**(1.0_dp/3.0_dp)
      tertsep3=smet3/solarrad
      axisscale3=tertsep3/separ
      tt13=(total_mass)*(period*secinday)**2*gmsun
      smet3=(tt13/(fourpiesquared))**(1.0_dp/3.0_dp)
!
      IF(p4q <= 0.0_dp)THEN
         tertmass4=0.0_dp
      ELSE
         tertmass4=total_mass/p4q
      END IF
      tt14=(total_mass+tertmass4)*(p4period*secinday)**2*gmsun
      smet4=(tt14/(fourpiesquared))**(1.0_dp/3.0_dp)
      tertsep4=smet4/solarrad
      axisscale4=tertsep4/separ
      tt14=(total_mass)*(period*secinday)**2*gmsun
      smet4=(tt14/(fourpiesquared))**(1.0_dp/3.0_dp)
!
      IF(p5q <= 0.0_dp)THEN
         tertmass5=0.0_dp
      ELSE
         tertmass5=total_mass/p5q
      END IF
      tt15=(total_mass+tertmass5)*(p5period*secinday)**2*gmsun
      smet5=(tt15/(fourpiesquared))**(1.0_dp/3.0_dp)
      tertsep5=smet5/solarrad
      axisscale5=tertsep5/separ
      tt15=(total_mass)*(period*secinday)**2*gmsun
      smet5=(tt15/(fourpiesquared))**(1.0_dp/3.0_dp)
!
      IF(p5q <= 0.0_dp)THEN
         tertmass6=0.0_dp
      ELSE
         tertmass6=total_mass/p6q
      END IF
      tt16=(total_mass+tertmass6)*(p6period*secinday)**2*gmsun
      smet6=(tt16/(fourpiesquared))**(1.0_dp/3.0_dp)
      tertsep6=smet6/solarrad
      axisscale6=tertsep6/separ
      tt16=(total_mass)*(period*secinday)**2*gmsun
      smet6=(tt16/(fourpiesquared))**(1.0_dp/3.0_dp)
!
      IF(p7q <= 0.0_dp)THEN
         tertmass7=0.0_dp
      ELSE
         tertmass7=total_mass/p7q
      END IF
      tt17=(total_mass+tertmass7)*(p7period*secinday)**2*gmsun
      smet7=(tt17/(fourpiesquared))**(1.0_dp/3.0_dp)
      tertsep7=smet7/solarrad
      axisscale7=tertsep7/separ
      tt17=(total_mass)*(period*secinday)**2*gmsun
      smet7=(tt17/(fourpiesquared))**(1.0_dp/3.0_dp)
!
      IF(p8q <= 0.0_dp)THEN
         tertmass8=0.0_dp
      ELSE
         tertmass8=total_mass/p8q
      END IF
      tt18=(total_mass+tertmass8)*(p8period*secinday)**2*gmsun
      smet8=(tt18/(fourpiesquared))**(1.0_dp/3.0_dp)
      tertsep8=smet8/solarrad
      axisscale8=tertsep8/separ
      tt18=(total_mass)*(period*secinday)**2*gmsun
      smet8=(tt18/(fourpiesquared))**(1.0_dp/3.0_dp)
!
      tertecc=SQRT(tertecos**2+tertesin**2)
      tertargrad=ATAN2(tertesin,tertecos)
      IF((ABS(sqtertecos) > EPSILON(sqtertecos)).AND. &
         (ABS(sqtertesin) > EPSILON(sqtertesin)))THEN
         tertargrad=ATAN2(sqtertesin,sqtertecos)
         tertecc=sqtertecos**2+sqtertesin**2
      END IF
      IF(tertargrad < 0.0_dp)tertargrad=tertargrad+twopie
      IF(tertargrad > twopie)tertargrad=tertargrad-twopie
      tertarg=(ATAN2(tertesin,tertecos))*radtodeg
      IF(tertarg < 0.0_dp)tertarg=tertarg+360.0_dp
      IF(tertarg > 360.0_dp)tertarg=tertarg-360.0_dp
      IF(tertecc > 0.995_dp)tertecc=0.995_dp
!
      tertecc2=SQRT(p2ecos**2+p2esin**2)
      tertargrad2=ATAN2(p2esin,p2ecos)
      IF((ABS(sqp2ecos) > EPSILON(sqp2ecos)).AND. &
         (ABS(sqp2esin) > EPSILON(sqp2esin)))THEN
         tertargrad2=ATAN2(sqp2esin,sqp2ecos)
         tertecc2=sqp2ecos**2+sqp2esin**2
      END IF
      IF(tertargrad2 < 0.0_dp)tertargrad2=tertargrad2+twopie
      IF(tertargrad2 > twopie)tertargrad2=tertargrad2-twopie
      tertarg2=(ATAN2(p2esin,p2ecos))*radtodeg
      IF(tertarg2 < 0.0_dp)tertarg2=tertarg2+360.0_dp
      IF(tertarg2 > 360.0_dp)tertarg2=tertarg2-360.0_dp
      IF(tertecc2 > 0.995_dp)tertecc2=0.995_dp
!
      tertecc3=SQRT(p3ecos**2+p3esin**2)
      tertargrad3=ATAN2(p3esin,p3ecos)
      IF((ABS(sqp3ecos) > EPSILON(sqp3ecos)).AND.  &
         (ABS(sqp3esin) > EPSILON(sqp3esin)))THEN
         tertargrad3=ATAN2(sqp3esin,sqp3ecos)
         tertecc3=sqp3ecos**2+sqp3esin**2
      END IF
      IF(tertargrad3 < 0.0_dp)tertargrad3=tertargrad3+twopie
      IF(tertargrad3 > twopie)tertargrad3=tertargrad3-twopie
      tertarg3=(ATAN2(p3esin,p3ecos))*radtodeg
      IF(tertarg3 < 0.0_dp)tertarg3=tertarg3+360.0_dp
      IF(tertarg3 > 360.0_dp)tertarg3=tertarg3-360.0_dp
      IF(tertecc3 > 0.995_dp)tertecc3=0.995_dp
!
      tertecc4=SQRT(p4ecos**2+p4esin**2)
      tertargrad4=ATAN2(p4esin,p4ecos)
      IF((ABS(sqp4ecos) > EPSILON(sqp4ecos)).AND.  &
         (ABS(sqp4esin) > EPSILON(sqp4esin)))THEN
         tertargrad4=ATAN2(sqp4esin,sqp4ecos)
         tertecc4=sqp4ecos**2+sqp4esin**2
      END IF
      IF(tertargrad4 < 0.0_dp)tertargrad4=tertargrad4+twopie
      IF(tertargrad4 > twopie)tertargrad4=tertargrad4-twopie
      tertarg4=(ATAN2(p4esin,p4ecos))*radtodeg
      IF(tertarg4 < 0.0_dp)tertarg4=tertarg4+360.0_dp
      IF(tertarg4 > 360.0_dp)tertarg4=tertarg4-360.0_dp
      IF(tertecc4 > 0.995_dp)tertecc4=0.995_dp
!
      tertecc5=SQRT(p5ecos**2+p5esin**2)
      tertargrad5=ATAN2(p5esin,p5ecos)
      IF((ABS(sqp5ecos) > EPSILON(sqp5ecos)).AND.  &
         (ABS(sqp5esin) > EPSILON(sqp5esin)))THEN
         tertargrad5=ATAN2(sqp5esin,sqp5ecos)
         tertecc5=sqp5ecos**2+sqp5esin**2
      END IF
      IF(tertargrad5 < 0.0_dp)tertargrad5=tertargrad5+twopie
      IF(tertargrad5 > twopie)tertargrad5=tertargrad5-twopie
      tertarg5=(ATAN2(p5esin,p5ecos))*radtodeg
      IF(tertarg5 < 0.0_dp)tertarg5=tertarg5+360.0_dp
      IF(tertarg5 > 360.0_dp)tertarg5=tertarg5-360.0_dp
      IF(tertecc5 > 0.995_dp)tertecc5=0.995_dp
!
      tertecc6=SQRT(p6ecos**2+p6esin**2)
      tertargrad6=ATAN2(p6esin,p6ecos)
      IF((ABS(sqp6ecos) > EPSILON(sqp6ecos)).AND.  &
         (ABS(sqp6esin) > EPSILON(sqp6esin)))THEN
         tertargrad6=ATAN2(sqp6esin,sqp6ecos)
         tertecc6=sqp6ecos**2+sqp6esin**2
      END IF
      IF(tertargrad6 < 0.0_dp)tertargrad6=tertargrad6+twopie
      IF(tertargrad6 > twopie)tertargrad6=tertargrad6-twopie
      tertarg6=(ATAN2(p6esin,p6ecos))*radtodeg
      IF(tertarg6 < 0.0_dp)tertarg6=tertarg6+360.0_dp
      IF(tertarg6 > 360.0_dp)tertarg6=tertarg6-360.0_dp
      IF(tertecc6 > 0.995_dp)tertecc6=0.995_dp
!
      tertecc7=SQRT(p7ecos**2+p7esin**2)
      tertargrad7=ATAN2(p7esin,p7ecos)
      IF((ABS(sqp7ecos) > EPSILON(sqp7ecos)).AND.  &
         (ABS(sqp7esin) > EPSILON(sqp7esin)))THEN
         tertargrad7=ATAN2(sqp7esin,sqp7ecos)
         tertecc7=sqp7ecos**2+sqp7esin**2
      END IF
      IF(tertargrad7 < 0.0_dp)tertargrad7=tertargrad7+twopie
      IF(tertargrad7 > twopie)tertargrad7=tertargrad7-twopie
      tertarg7=(ATAN2(p7esin,p7ecos))*radtodeg
      IF(tertarg7 < 0.0_dp)tertarg7=tertarg7+360.0_dp
      IF(tertarg7 > 360.0_dp)tertarg7=tertarg7-360.0_dp
      IF(tertecc7 > 0.995_dp)tertecc7=0.995_dp
!
      tertecc8=SQRT(p8ecos**2+p8esin**2)
      tertargrad8=ATAN2(p8esin,p8ecos)
      IF((ABS(sqp8ecos) > EPSILON(sqp8ecos)).AND. &
         (ABS(sqp8esin) > EPSILON(sqp8esin)))THEN
         tertargrad8=ATAN2(sqp8esin,sqp8ecos)
         tertecc8=sqp8ecos**2+sqp8esin**2
      END IF
      IF(tertargrad8 < 0.0_dp)tertargrad8=tertargrad8+twopie
      IF(tertargrad8 > twopie)tertargrad8=tertargrad8-twopie
      tertarg8=(ATAN2(p8esin,p8ecos))*radtodeg
      IF(tertarg8 < 0.0_dp)tertarg8=tertarg8+360.0_dp
      IF(tertarg8 > 360.0_dp)tertarg8=tertarg8-360.0_dp
      IF(tertecc8 > 0.995_dp)tertecc8=0.995_dp
!
      CALL findconj(tertargrad,tertecc,pconj3,pconj4,phper3a,phper3b)
      CALL findconj(tertargrad2,tertecc2,pconj3_2,pconj4_2,phper3a,phper3b)
      CALL findconj(tertargrad3,tertecc3,pconj3_3,pconj4_3,phper3a,phper3b)
      CALL findconj(tertargrad4,tertecc4,pconj3_4,pconj4_4,phper4a,phper4b)
      CALL findconj(tertargrad5,tertecc5,pconj3_5,pconj4_5,phper5a,phper5b)
      CALL findconj(tertargrad6,tertecc6,pconj3_6,pconj4_6,phper6a,phper6b)
      CALL findconj(tertargrad7,tertecc7,pconj3_7,pconj4_7,phper7a,phper7b)
      CALL findconj(tertargrad8,tertecc8,pconj3_8,pconj4_8,phper8a,phper8b)
!
!   end if isw30 > 2
!
   END IF
!
   IF(isw7 == 2)CALL filltime(ntime,timearray,tstart,tstop,tstep,lengthtime)
!
   IF(ialign > 0)THEN
      bigi=finc
      bigbeta=0.0_dp
   END IF
!
!pgi$l novector
!
   DO  kk=1,8
      refflux1(kk)=darkint1(kk)
      refflux2(kk)=darkint2(kk)
      refflux3(kk)=darkint3(kk)
      refflux4(kk)=darkint4(kk)
      refflux5(kk)=darkint5(kk)
      refflux6(kk)=sdarkint6(kk)
      refflux7(kk)=sdarkint7(kk)
      refflux8(kk)=sdarkint8(kk)
      refflux9(kk)=sdarkint9(kk)
      refflux10(kk)=sdarkint10(kk)
!
!   If using the Short method to produce the light curves,
!   fill up the reffluxlist array
!
      IF(mandel >= 2)THEN
         reffluxlist(1,kk)=refflux1(kk)
         reffluxlist(2,kk)=refflux2(kk)
         reffluxlist(3,kk)=refflux3(kk)
         reffluxlist(4,kk)=refflux4(kk)
         reffluxlist(5,kk)=refflux5(kk)
         reffluxlist(6,kk)=refflux6(kk)
         reffluxlist(7,kk)=refflux7(kk)
         reffluxlist(8,kk)=refflux8(kk)
         reffluxlist(9,kk)=refflux9(kk)
         reffluxlist(10,kk)=refflux10(kk)
      END IF
      donvellist(1,kk)=0.0_dp
      donvellist(2,kk)=0.0_dp
      donvellist(3,kk)=0.0_dp
      donvellist(4,kk)=0.0_dp
      donvellist(5,kk)=0.0_dp
      donvellist(6,kk)=0.0_dp
      donvellist(7,kk)=0.0_dp
      donvellist(8,kk)=0.0_dp
      donvellist(9,kk)=0.0_dp
      donvellist(10,kk)=0.0_dp
      corr1(kk)=0.0_dp
      corr2(kk)=0.0_dp
      corr1a(kk)=0.0_dp
      corr2a(kk)=0.0_dp
      corr1tran2(kk)=0.0_dp
      corr1tran3(kk)=0.0_dp
      corr1tran4(kk)=0.0_dp
      corr1tran5(kk)=0.0_dp
      corr1tran6(kk)=0.0_dp
      corr1tran7(kk)=0.0_dp
      corr1tran8(kk)=0.0_dp
      corr1tran9(kk)=0.0_dp
      corr1tran10(kk)=0.0_dp
      corr2tran1(kk)=0.0_dp
      corr2tran3(kk)=0.0_dp
      corr2tran4(kk)=0.0_dp
      corr2tran5(kk)=0.0_dp
      corr3tran1(kk)=0.0_dp
      corr3tran2(kk)=0.0_dp
      corr3tran4(kk)=0.0_dp
      corr3tran5(kk)=0.0_dp
      corr4tran1(kk)=0.0_dp
      corr4tran2(kk)=0.0_dp
      corr4tran3(kk)=0.0_dp
      corr4tran5(kk)=0.0_dp
      corr5tran1(kk)=0.0_dp
      corr5tran2(kk)=0.0_dp
      corr5tran3(kk)=0.0_dp
      corr5tran4(kk)=0.0_dp
      corr6tran1(kk)=0.0_dp
      corr7tran1(kk)=0.0_dp
      corr8tran1(kk)=0.0_dp
      corr9tran1(kk)=0.0_dp
      corr10tran1(kk)=0.0_dp
      IF(idark2 >= 1)darkint2(kk)=0.0_dp
   END DO
!
   IF(ecc <= 0.0_dp)argper=90.0_dp
   bdist=1.0_dp
   pstart=0.0_dp
   pstop=360.0_dp-dphase
   pconj=pie
   pconj2=0.0_dp
   pstep=dphase
   pstartout=0.0_dp
   pstopout=0.0_dp
   IF(ecc > 0.0_dp)THEN
      pstartout=0.0_dp
      pstopout=360.0_dp-dphase
   END IF
   argrad=argper*degtorad
   fincr=finc*degtorad
!
   icount=0
!
   CALL findconj(argrad,ecc,pconj,pconj2,phper1,phper2)
!
   eshift=0.0_dp
   IF(ikeep == 1)eshift=phper1+pconj-0.5_dp
   IF(ikeep == 2)eshift=phper2+pconj2
   IF(ABS(ecc) <= EPSILON(ecc))THEN
      eshift=0.0_dp
      pconj=0.0_dp
   END IF
!
   ttiny=0.0_dp
   IF(ecc <= 0.0_dp)ttiny=1.0E-06_dp
!
   IF((isw7 == 2).AND.(ecc > 0.0_dp))THEN
      pstartout=360.0_dp*(timearray(1)-t0)/period
      pstopout=360.0_dp*(timearray(ntime)-t0)/period
      dphase=360.0_dp*tstep/period
   END IF
!
   nloopout=INT((pstopout+ttiny-pstartout)/dphase)
   phaseout=pstartout-dphase
!
!          do 999 phaseout=pstartout,pstopout+ttiny,dphase
!
   loop30: DO  iloopout=1,nloopout+1
      phaseout=phaseout+dphase
!
      argper=saveargper+(timearray(icounttime+1)-t0)*omegadot/365.25_dp
      argrad=argper*degtorad
      IF((icount >= 1).AND.(ngap >= 1))THEN
         DO ijk=1,ngap
            IF((timearray(icounttime) > gaplow(ijk)).AND.  &
               (timearray(icounttime) < gaphigh(ijk)))THEN
               icounttime=icounttime+1
               CYCLE loop30
            END IF
         END DO
         DO ijk=1,ngap
            IF((timearray(icounttime) > gaplow(ijk)).AND.  &
               (timearray(icounttime) < gaphigh(ijk)))THEN
               icounttime=icounttime+1
               CYCLE loop30
            END IF
         END DO
      END IF
!
      IF(ecc > 0.0_dp)THEN
         em=phaseout*degtorad
         CALL gete(em,ecc,bige)
         CALL checkangle(bige)
!
         rnu=2.0_dp*ATAN(SQRT((1.0_dp+ecc)/(1.0_dp-ecc))*TAN(bige/2.0_dp))
         CALL checkangle(rnu)
!
         bdist=(1.0_dp-ecc*COS(bige))
         pstart=MOD(rnu*radtodeg+argper+90.0_dp,360.0_dp)
         pstop=MOD(rnu*radtodeg+argper+90.0_dp,360.0_dp)
      END IF
      pstep=dphase
!
      IF((isw7 == 2).AND.(ABS(ecc) <= EPSILON(ecc)))THEN
         pstart=360.0_dp*(timearray(1)-t0)/period
         pstop=360.0_dp*(timearray(ntime)-t0)/period
         pstep=360.0_dp*tstep/period
      END IF
!
!   Add the third body phases here if needed
!
      IF((isw30 >= 3).AND.(isw7 >= 2).AND.(isw27 <= 1))THEN
         IF(iloopout == 1)THEN
            IF(itconj == 2)THEN
               tertt0=0.0_dp
               tertt02=0.0_dp
               tertt03=0.0_dp
               tertt04=0.0_dp
               tertt05=0.0_dp
               tertt06=0.0_dp
               tertt07=0.0_dp
               tertt08=0.0_dp
               CALL gett0(tertincl,tertperiod,tertecc,tertarg,tertt0,tertconj)
               IF(isw30 >= 4)CALL gett0(p2incl,p2period,tertecc2,  &
                  tertarg2,tertt02,p2tconj)
               IF(isw30 >= 5)CALL gett0(p3incl,p3period,tertecc3,  &
                  tertarg3,tertt03,p3tconj)
               IF(isw30 >= 6)CALL gett0(p4incl,p4period,tertecc4,  &
                  tertarg4,tertt04,p4tconj)
               IF(isw30 >= 7)CALL gett0(p5incl,p5period,tertecc5,  &
                  tertarg5,tertt05,p5tconj)
               IF(isw30 >= 8)CALL gett0(p6incl,p6period,tertecc6,  &
                  tertarg6,tertt06,p6tconj)
               IF(isw30 >= 9)CALL gett0(p7incl,p7period,tertecc7,  &
                  tertarg7,tertt07,p7tconj)
               IF(isw30 >= 10)CALL gett0(p8incl,p8period,tertecc8,  &
                  tertarg8,tertt08,p8tconj)
            END IF
            IF(itconj == 1)THEN
               CALL gett0tran(tertincl,tertperiod,tertecc,tertarg,tertt0,tertconj)
               IF(isw30 >= 4)CALL gett0tran(p2incl,p2period,  &
                  tertecc2,tertarg2,tertt02,p2tconj)
               IF(isw30 >= 5)CALL gett0tran(p3incl,p3period,  &
                  tertecc3,tertarg3,tertt03,p3tconj)
               IF(isw30 >= 6)CALL gett0tran(p4incl,p4period,  &
                  tertecc4,tertarg4,tertt04,p4tconj)
               IF(isw30 >= 7)CALL gett0tran(p5incl,p5period,  &
                  tertecc5,tertarg5,tertt05,p5tconj)
               IF(isw30 >= 8)CALL gett0tran(p6incl,p6period,  &
                  tertecc6,tertarg6,tertt06,p6tconj)
               IF(isw30 >= 9)CALL gett0tran(p7incl,p7period,  &
                  tertecc7,tertarg7,tertt07,p7tconj)
               IF(isw30 >= 10)CALL gett0tran(p8incl,p8period,  &
                  tertecc8,tertarg8,tertt08,p8tconj)
!
            END IF
         END IF
         tertbdist=0.0_dp
         tertbdist2=0.0_dp
         tertbdist3=0.0_dp
         tertbdist4=0.0_dp
         tertbdist5=0.0_dp
         tertbdist6=0.0_dp
         tertbdist7=0.0_dp
         tertbdist8=0.0_dp
         IF(tertperiod <= 0.0_dp)THEN
            tertphase=0.0_dp
         ELSE
            tertphase=(timearray(icounttime+1)-tertt0)/tertperiod
         END IF
         tertphase=360.0_dp*tertphase
         CALL tertnu(tertphase,tertecc,tertbdist,tertrnu)
         tertphase=MOD(tertrnu*radtodeg+tertarg+90.0_dp,360.0_dp)
         IF(tertphase < 0.0_dp)tertphase=tertphase+360.0_dp
         IF(tertphase > 360.0_dp)tertphase=tertphase-360.0_dp
         tertppp=MOD(tertphase,360.0_dp)
         IF(tertppp < 0.0_dp)tertppp=tertppp+360.0_dp
         IF(tertppp > 360.0_dp)tertppp=tertppp-360.0_dp
!
         IF(isw30 >= 4)THEN
            IF(p2period <= 0.0_dp)THEN
               tertphase2=0.0_dp
            ELSE
               tertphase2=(timearray(icounttime+1)-tertt02)/p2period
            END IF
            tertphase2=360.0_dp*tertphase2
            CALL tertnu(tertphase2,tertecc2,tertbdist2,tertrnu2)
            tertphase2=MOD(tertrnu2*radtodeg+tertarg2+90.0_dp,360.0_dp)
            IF(tertphase2 < 0.0_dp)tertphase2=tertphase2+360.0_dp
            IF(tertphase2 > 360.0_dp)tertphase2=tertphase2-360.0_dp
            tertppp2=MOD(tertphase2,360.0_dp)
            IF(tertppp2 < 0.0_dp)tertppp2=tertppp2+360.0_dp
            IF(tertppp2 > 360.0_dp)tertppp2=tertppp2-360.0_dp
         END IF
!
         IF(isw30 >= 5)THEN
            IF(p3period <= 0.0_dp)THEN
               tertphase3=0.0_dp
            ELSE
               tertphase3=(timearray(icounttime+1)-tertt03)/p3period
            END IF
            tertphase3=360.0_dp*tertphase3
            CALL tertnu(tertphase3,tertecc3,tertbdist3,tertrnu3)
            tertphase3=MOD(tertrnu3*radtodeg+tertarg3+90.0_dp,360.0_dp)
            IF(tertphase3 < 0.0_dp)tertphase3=tertphase3+360.0_dp
            IF(tertphase3 > 360.0_dp)tertphase3=tertphase3-360.0_dp
            tertppp3=MOD(tertphase3,360.0_dp)
            IF(tertppp3 < 0.0_dp)tertppp3=tertppp3+360.0_dp
            IF(tertppp3 > 360.0_dp)tertppp3=tertppp3-360.0_dp
         END IF
!
         IF(isw30 >= 6)THEN
            IF(p4period <= 0.0_dp)THEN
               tertphase4=0.0_dp
            ELSE
               tertphase4=(timearray(icounttime+1)-tertt04)/p4period
            END IF
            tertphase4=360.0_dp*tertphase4
            CALL tertnu(tertphase4,tertecc4,tertbdist4,tertrnu4)
            tertphase4=MOD(tertrnu4*radtodeg+tertarg4+90.0_dp,360.0_dp)
            IF(tertphase4 < 0.0_dp)tertphase4=tertphase4+360.0_dp
            IF(tertphase4 > 360.0_dp)tertphase4=tertphase4-360.0_dp
            tertppp4=MOD(tertphase4,360.0_dp)
            IF(tertppp4 < 0.0_dp)tertppp4=tertppp4+360.0_dp
            IF(tertppp4 > 360.0_dp)tertppp4=tertppp4-360.0_dp
         END IF
!
         IF(isw30 >= 7)THEN
            IF(p5period <= 0.0_dp)THEN
               tertphase5=0.0_dp
            ELSE
               tertphase5=(timearray(icounttime+1)-tertt05)/p5period
            END IF
            tertphase5=360.0_dp*tertphase5
            CALL tertnu(tertphase5,tertecc5,tertbdist5,tertrnu5)
            tertphase5=MOD(tertrnu5*radtodeg+tertarg5+90.0_dp,360.0_dp)
            IF(tertphase5 < 0.0_dp)tertphase5=tertphase5+360.0_dp
            IF(tertphase5 > 360.0_dp)tertphase5=tertphase5-360.0_dp
            tertppp5=MOD(tertphase5,360.0_dp)
            IF(tertppp5 < 0.0_dp)tertppp5=tertppp5+360.0_dp
            IF(tertppp5 > 360.0_dp)tertppp5=tertppp5-360.0_dp
         END IF
!
         IF(isw30 >= 8)THEN
            IF(p6period <= 0.0_dp)THEN
               tertphase6=0.0_dp
            ELSE
               tertphase6=(timearray(icounttime+1)-tertt06)/p6period
            END IF
            tertphase6=360.0_dp*tertphase6
            CALL tertnu(tertphase6,tertecc6,tertbdist6,tertrnu6)
            tertphase6=MOD(tertrnu6*radtodeg+tertarg6+90.0_dp,360.0_dp)
            IF(tertphase6 < 0.0_dp)tertphase6=tertphase6+360.0_dp
            IF(tertphase6 > 360.0_dp)tertphase6=tertphase6-360.0_dp
            tertppp6=MOD(tertphase6,360.0_dp)
            IF(tertppp6 < 0.0_dp)tertppp6=tertppp6+360.0_dp
            IF(tertppp6 > 360.0_dp)tertppp6=tertppp6-360.0_dp
         END IF
!
         IF(isw30 >= 9)THEN
            IF(p7period <= 0.0_dp)THEN
               tertphase7=0.0_dp
            ELSE
               tertphase7=(timearray(icounttime+1)-tertt07)/p7period
            END IF
            tertphase7=360.0_dp*tertphase7
            CALL tertnu(tertphase7,tertecc7,tertbdist7,tertrnu7)
            tertphase7=MOD(tertrnu7*radtodeg+tertarg7+90.0_dp,360.0_dp)
            IF(tertphase7 < 0.0_dp)tertphase7=tertphase7+360.0_dp
            IF(tertphase7 > 360.0_dp)tertphase7=tertphase7-360.0_dp
            tertppp7=MOD(tertphase7,360.0_dp)
            IF(tertppp7 < 0.0_dp)tertppp7=tertppp7+360.0_dp
            IF(tertppp7 > 360.0_dp)tertppp7=tertppp7-360.0_dp
         END IF
!
         IF(isw30 >= 10)THEN
            IF(p8period <= 0.0_dp)THEN
               tertphase8=0.0_dp
            ELSE
               tertphase8=(timearray(icounttime+1)-tertt08)/p8period
            END IF
            tertphase8=360.0_dp*tertphase8
            CALL tertnu(tertphase8,tertecc8,tertbdist8,tertrnu8)
            tertphase8=MOD(tertrnu8*radtodeg+tertarg8+90.0_dp,360.0_dp)
            IF(tertphase8 < 0.0_dp)tertphase8=tertphase8+360.0_dp
            IF(tertphase8 > 360.0_dp)tertphase8=tertphase8-360.0_dp
            tertppp8=MOD(tertphase8,360.0_dp)
            IF(tertppp8 < 0.0_dp)tertppp8=tertppp8+360.0_dp
            IF(tertppp8 > 360.0_dp)tertppp8=tertppp8-360.0_dp
         END IF
!
      END IF
!
      phasein=0.0_dp
      nloopin=0
      nloopin=INT((pstop+ttiny-pstart)/pstep)
      phasein=pstart-pstep
!
!            do 10 phasein=pstart,pstop+ttiny,pstep
!
      jlo=100
      loop10:  DO  iloopin=1,nloopin+1
         phasein=phasein+pstep
!
         IF((icount >= 1).AND.(ngap >= 1))THEN
            DO ijk=1,ngap
               IF((timearray(icounttime) > gaplow(ijk)).AND.  &
                  (timearray(icounttime) < gaphigh(ijk)))THEN
                  icounttime=icounttime+1
                  CYCLE loop10
               END IF
            END DO
         END IF
!
         icount=icount+1
         icounttime=icounttime+1
         phase=MOD(phasein,360.0_dp)
!
!   add the third body phases if needed
!
         IF((isw30 >= 3).AND.(isw7 >= 2).AND.(isw27 <= 1))THEN
            IF(iloopout == 1)THEN
               IF(itconj == 2)THEN
                  CALL gett0(tertincl,tertperiod,tertecc,tertarg,tertt0, &
                      tertconj)
               END IF
               IF(itconj == 1)THEN
                  CALL gett0tran(tertincl,tertperiod,tertecc,tertarg, &
                      tertt0,tertconj)
               END IF
!
               IF(isw30 >= 4)THEN
                  IF(itconj == 2)THEN
                     CALL gett0(p2incl,p2period,tertecc2,tertarg2, &
                        tertt02,p2tconj)
                  END IF
                  IF(itconj == 1)THEN
                     CALL gett0tran(p2incl,p2period,tertecc2,tertarg2, &
                         tertt02,p2tconj)
                  END IF
               END IF
!
               IF(isw30 >= 5)THEN
                  IF(itconj == 2)THEN
                     CALL gett0(p3incl,p3period,tertecc3,tertarg3,  &
                         tertt03,p3tconj)
                  END IF
                  IF(itconj == 1)THEN
                     CALL gett0tran(p3incl,p3period,tertecc3,tertarg3, &
                        tertt03,p3tconj)
                  END IF
               END IF
!
               IF(isw30 >= 6)THEN
                  IF(itconj == 2)THEN
                     CALL gett0(p4incl,p4period,tertecc4,tertarg4, &
                        tertt04,p4tconj)
                  END IF
                  IF(itconj == 1)THEN
                     CALL gett0tran(p4incl,p4period,tertecc4,tertarg4, &
                        tertt04,p4tconj)
                  END IF
               END IF
!
               IF(isw30 >= 7)THEN
                  IF(itconj == 2)THEN
                     CALL gett0(p5incl,p5period,tertecc5,tertarg5,  &
                         tertt05,p5tconj)
                  END IF
                  IF(itconj == 1)THEN
                     CALL gett0tran(p5incl,p5period,tertecc5,tertarg5, &
                         tertt05,p5tconj)
                  END IF
               END IF
!
               IF(isw30 >= 8)THEN
                  IF(itconj == 2)THEN
                     CALL gett0(p6incl,p6period,tertecc6,tertarg6,  &
                        tertt06,p6tconj)
                  END IF
                  IF(itconj == 1)THEN
                     CALL gett0tran(p6incl,p6period,tertecc6,tertarg6, &
                        tertt06,p6tconj)
                  END IF
               END IF
!
               IF(isw30 >= 9)THEN
                  IF(itconj == 2)THEN
                     CALL gett0(p7incl,p7period,tertecc7,tertarg7, &
                        tertt07,p7tconj)
                  END IF
                  IF(itconj == 1)THEN
                     CALL gett0tran(p7incl,p7period,tertecc7,tertarg7, &
                        tertt07,p7tconj)
                  END IF
               END IF
!
               IF(isw30 >= 10)THEN
                  IF(itconj == 2)THEN
                     CALL gett0(p8incl,p8period,tertecc8,tertarg8, &
                        tertt08,p8tconj)
                  END IF
                  IF(itconj == 1)THEN
                     CALL gett0tran(p8incl,p8period,tertecc8,tertarg8, &
                        tertt08,p8tconj)
                  END IF
               END IF
!
            END IF
!
            tertphase=(timearray(icounttime)-tertt0)/tertperiod
            tertphase=360.0_dp*tertphase
            CALL tertnu(tertphase,tertecc,tertbdist,tertrnu)
            tertphase=MOD(tertrnu*radtodeg+tertarg+90.0_dp,360.0_dp)
            IF(tertphase < 0.0_dp)tertphase=tertphase+360.0_dp
            IF(tertphase > 360.0_dp)tertphase=tertphase-360.0_dp
!
            IF(isw30 >= 4)THEN
               IF(p2period <= 0.0_dp)THEN
                  tertphase2=0.0_dp
               ELSE
                  tertphase2=(timearray(icounttime)-tertt02)/p2period
               END IF
               tertphase2=360.0_dp*tertphase2
               CALL tertnu(tertphase2,tertecc2,tertbdist2,tertrnu2)
               tertphase2=MOD(tertrnu2*radtodeg+tertarg2+90.0_dp,360.0_dp)
               IF(tertphase2 < 0.0_dp)tertphase2=tertphase2+360.0_dp
               IF(tertphase2 > 360.0_dp)tertphase2=tertphase2-360.0_dp
            END IF
!
            IF(isw30 >= 5)THEN
               IF(p3period <= 0.0_dp)THEN
                  tertphase3=0.0_dp
               ELSE
                  tertphase3=(timearray(icounttime)-tertt03)/p3period
               END IF
               tertphase3=360.0_dp*tertphase3
               CALL tertnu(tertphase3,tertecc3,tertbdist3,tertrnu3)
               tertphase3=MOD(tertrnu3*radtodeg+tertarg3+90.0_dp,360.0_dp)
               IF(tertphase3 < 0.0_dp)tertphase3=tertphase3+360.0_dp
               IF(tertphase3 > 360.0_dp)tertphase3=tertphase3-360.0_dp
            END IF
!
            IF(isw30 >= 6)THEN
               IF(p4period <= 0.0_dp)THEN
                  tertphase4=0.0_dp
               ELSE
                  tertphase4=(timearray(icounttime)-tertt04)/p4period
               END IF
               tertphase4=360.0_dp*tertphase4
               CALL tertnu(tertphase4,tertecc4,tertbdist4,tertrnu4)
               tertphase4=MOD(tertrnu4*radtodeg+tertarg4+90.0_dp,360.0_dp)
               IF(tertphase4 < 0.0_dp)tertphase4=tertphase4+360.0_dp
               IF(tertphase4 > 360.0_dp)tertphase4=tertphase4-360.0_dp
            END IF
!
            IF(isw30 >= 7)THEN
               IF(p5period <= 0.0_dp)THEN
                  tertphase5=0.0_dp
               ELSE
                  tertphase5=(timearray(icounttime)-tertt05)/p5period
               END IF
               tertphase5=360.0_dp*tertphase5
               CALL tertnu(tertphase5,tertecc5,tertbdist5,tertrnu5)
               tertphase5=MOD(tertrnu5*radtodeg+tertarg5+90.0_dp,360.0_dp)
               IF(tertphase5 < 0.0_dp)tertphase5=tertphase5+360.0_dp
               IF(tertphase5 > 360.0_dp)tertphase5=tertphase5-360.0_dp
            END IF
!
            IF(isw30 >= 8)THEN
               IF(p6period <= 0.0_dp)THEN
                  tertphase6=0.0_dp
               ELSE
                  tertphase6=(timearray(icounttime)-tertt06)/p6period
               END IF
               tertphase6=360.0_dp*tertphase6
               CALL tertnu(tertphase6,tertecc6,tertbdist6,tertrnu6)
               tertphase6=MOD(tertrnu6*radtodeg+tertarg6+90.0_dp,360.0_dp)
               IF(tertphase6 < 0.0_dp)tertphase6=tertphase6+360.0_dp
               IF(tertphase6 > 360.0_dp)tertphase6=tertphase6-360.0_dp
            END IF
!
            IF(isw30 >= 9)THEN
               IF(p7period <= 0.0_dp)THEN
                  tertphase7=0.0_dp
               ELSE
                  tertphase7=(timearray(icounttime)-tertt07)/p7period
               END IF
               tertphase7=360.0_dp*tertphase7
               CALL tertnu(tertphase7,tertecc7,tertbdist7,tertrnu7)
               tertphase7=MOD(tertrnu7*radtodeg+tertarg7+90.0_dp,360.0_dp)
               IF(tertphase7 < 0.0_dp)tertphase7=tertphase7+360.0_dp
               IF(tertphase7 > 360.0_dp)tertphase7=tertphase7-360.0_dp
            END IF
!
            IF(isw30 >= 10)THEN
               IF(p8period <= 0.0_dp)THEN
                  tertphase8=0.0_dp
               ELSE
                  tertphase8=(timearray(icounttime)-tertt08)/p8period
               END IF
               tertphase8=360.0_dp*tertphase8
               CALL tertnu(tertphase8,tertecc8,tertbdist8,tertrnu8)
               tertphase8=MOD(tertrnu8*radtodeg+tertarg8+90.0_dp,360.0_dp)
               IF(tertphase8 < 0.0_dp)tertphase8=tertphase8+360.0_dp
               IF(tertphase8 > 360.0_dp)tertphase8=tertphase8-360.0_dp
            END IF
!
            xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
            yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
!
            tomrad=tertomega*degtorad
            tomrad2=p2omega*degtorad
            tomrad3=p3omega*degtorad
            tomrad4=p4omega*degtorad
            tomrad5=p5omega*degtorad
            tomrad6=p6omega*degtorad
            tomrad7=p7omega*degtorad
            tomrad8=p8omega*degtorad
!
            xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
            yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
            xx=0.0_dp
            yy=0.0_dp
            zz=0.0_dp
            xp=xtran(xx,yy,phase,q,1,bdist)+xxoff
            yp=ytran(xx,yy,zz,phase,fincr,q,1,bdist)+yyoff
            centx1=xp
            centy1=yp
!
            xx=0.0_dp
            yy=0.0_dp
            zz=0.0_dp
            xp=xtran(xx,yy,phase+180.0_dp,q,2,bdist)+xxoff
            yp=ytran(xx,yy,zz,phase+180.0_dp,fincr,q,2,bdist)+yyoff
!
            centx2=xp
            centy2=yp
!
            centx3a=tertxcen(1,tertincl,tertbdist,tertphase,tertq,axisscale)
            centy3a=tertycen(1,tertincl,tertbdist,tertphase,tertq,axisscale)
!
            centx3=centx3a*COS(tomrad)-centy3a*SIN(tomrad)
            centy3=centx3a*SIN(tomrad)+centy3a*COS(tomrad)
!
            IF((isw30 >= 3).AND.(isw27 < 2).AND.(isw7 >= 2))THEN

               IF(isw30 >= 4)THEN
                  centx4a=tertxcen(1,p2incl,tertbdist2,tertphase2,p2q,axisscale2)
                  centy4a=tertycen(1,p2incl,tertbdist2,tertphase2,p2q,axisscale2)
                  centx4=centx4a*COS(tomrad2)-centy4a*SIN(tomrad2)
                  centy4=centx4a*SIN(tomrad2)+centy4a*COS(tomrad2)
               END IF
!
               IF(isw30 >= 5)THEN
                  centx5a=tertxcen(1,p3incl,tertbdist3,tertphase3,p3q,axisscale3)
                  centy5a=tertycen(1,p3incl,tertbdist3,tertphase3,p3q,axisscale3)
                  centx5=centx5a*COS(tomrad3)-centy5a*SIN(tomrad3)
                  centy5=centx5a*SIN(tomrad3)+centy5a*COS(tomrad3)
               END IF
!
               IF(isw30 >= 6)THEN
                  centx6a=tertxcen(1,p4incl,tertbdist4,tertphase4,p4q,axisscale4)
                  centy6a=tertycen(1,p4incl,tertbdist4,tertphase4,p4q,axisscale4)
                  centx6=centx6a*COS(tomrad4)-centy6a*SIN(tomrad4)
                  centy6=centx6a*SIN(tomrad4)+centy6a*COS(tomrad4)
               END IF
!
               IF(isw30 >= 7)THEN
                  centx7a=tertxcen(1,p5incl,tertbdist5,tertphase5,p5q,axisscale5)
                  centy7a=tertycen(1,p5incl,tertbdist5,tertphase5,p5q,axisscale5)
                  centx7=centx7a*COS(tomrad5)-centy7a*SIN(tomrad5)
                  centy7=centx7a*SIN(tomrad5)+centy7a*COS(tomrad5)
               END IF
!
               IF(isw30 >= 8)THEN
                  centx8a=tertxcen(1,p6incl,tertbdist6,tertphase6,p6q,axisscale6)
                  centy8a=tertycen(1,p6incl,tertbdist6,tertphase6,p6q,axisscale6)
                  centx8=centx8a*COS(tomrad6)-centy8a*SIN(tomrad6)
                  centy8=centx8a*SIN(tomrad6)+centy8a*COS(tomrad6)
               END IF
!
               IF(isw30 >= 9)THEN
                  centx9a=tertxcen(1,p7incl,tertbdist7,tertphase7,p7q,axisscale7)
                  centy9a=tertycen(1,p7incl,tertbdist7,tertphase7,p7q,axisscale7)
                  centx9=centx9a*COS(tomrad7)-centy9a*SIN(tomrad7)
                  centy9=centx9a*SIN(tomrad7)+centy9a*COS(tomrad7)
               END IF
!
               IF(isw30 >= 10)THEN
                  centx10a=tertxcen(1,p8incl,tertbdist8,tertphase8,p8q,axisscale8)
                  centy10a=tertycen(1,p8incl,tertbdist8,tertphase8,p8q,axisscale8)
                  centx10=centx10a*COS(tomrad8)-centy10a*SIN(tomrad8)
                  centy10=centx10a*SIN(tomrad8)+centy10a*COS(tomrad8)
               END IF
            END IF
         END IF
!
         IF((isw30 >= 3).AND.(isw27 >= 2).AND.(isw7 >= 2))THEN
            timein=timearray(icounttime)
            CALL lttskyvel(odetime,nstep,timein,centx1,centy1,  &
               velout1,ndyn,body01posx,body01posy,body01posz,  &
               body01velx,body01vely,body01velz,ii)
            centx1=centx1/separ
            centy1=centy1/separ
            CALL lttskyvel(odetime,nstep,timein,centx2,centy2,  &
               velout2,ndyn,body02posx,body02posy,body02posz,  &
               body02velx,body02vely,body02velz,ii)
            centx2=centx2/separ
            centy2=centy2/separ
            CALL lttskyvel(odetime,nstep,timein,centx3,centy3,  &
               velout3,ndyn,body03posx,body03posy,body03posz,  &
               body03velx,body03vely,body03velz,ii)
            centx3=centx3/separ
            centy3=centy3/separ
            velout4=0.0_dp
            velout5=0.0_dp
            velout6=0.0_dp
            velout7=0.0_dp
            velout8=0.0_dp
            velout9=0.0_dp
            velout10=0.0_dp
            IF(isw30 >= 4)THEN
               CALL lttskyvel(odetime,nstep,timein,centx4,centy4,  &
                  velout4,ndyn,body04posx,body04posy,body04posz,  &
                  body04velx,body04vely,body04velz,ii)
               centx4=centx4/separ
               centy4=centy4/separ
            END IF
            IF(isw30 >= 5)THEN
               CALL lttskyvel(odetime,nstep,timein,centx5,centy5,  &
                  velout5,ndyn,body05posx,body05posy,body05posz,  &
                  body05velx,body05vely,body05velz,ii)
               centx5=centx5/separ
               centy5=centy5/separ
            END IF
            IF(isw30 >= 6)THEN
               CALL lttskyvel(odetime,nstep,timein,centx6,centy6,  &
                  velout6,ndyn,body06posx,body06posy,body06posz,  &
                  body06velx,body06vely,body06velz,ii)
               centx6=centx6/separ
               centy6=centy6/separ
            END IF
            IF(isw30 >= 7)THEN
               CALL lttskyvel(odetime,nstep,timein,centx7,centy7,  &
                  velout7,ndyn,body07posx,body07posy,body07posz,  &
                  body07velx,body07vely,body07velz,ii)
               centx7=centx7/separ
               centy7=centy7/separ
            END IF
            IF(isw30 >= 8)THEN
               CALL lttskyvel(odetime,nstep,timein,centx8,centy8,  &
                  velout8,ndyn,body08posx,body08posy,body08posz,  &
                  body08velx,body08vely,body08velz,ii)
               centx8=centx8/separ
               centy8=centy8/separ
            END IF
            IF(isw30 >= 9)THEN
               CALL lttskyvel(odetime,nstep,timein,centx9,centy9,  &
                  velout9,ndyn,body09posx,body09posy,body09posz,  &
                  body09velx,body09vely,body09velz,ii)
               centx9=centx9/separ
               centy9=centy9/separ
            END IF
            IF(isw30 >= 10)THEN
               CALL lttskyvel(odetime,nstep,timein,centx10,centy10,  &
                  velout10,ndyn,body10posx,body10posy,body10posz,  &
                  body10velx,body10vely,body10velz,ii)
               centx10=centx10/separ
               centy10=centy10/separ
            END IF
         END IF
!
         IF(phase < 0.0_dp)phase=phase+360.0_dp
         IF((ecc > 0.0_dp).OR.(ABS(pshift) > EPSILON(pshift)))THEN
            tshift=pshift+eshift
!
         END IF
!
! this is for star 2
!
         dummyphase=MOD(phase+180.0_dp,360.0_dp)
!
         phaser=phase*degtorad
         delta=(COS(fincr)**2+(SIN(fincr)*SIN(phaser))**2)
         delta=bdist*SQRT(delta)
!
         DO kk=1,8
            corr1(kk)=0.0_dp
            corr2(kk)=0.0_dp
            corr1a(kk)=0.0_dp
            corr2a(kk)=0.0_dp
         END DO
!
         IF(isw30 <= 2)THEN
!
!    no body 3, so do normally
!
            IF(mandel < 2)THEN
!
!  Gimemez method
!
               IF(delta > (reff1+reff2))THEN
                  DO kk=1,8
                     corr1(kk)=0.0_dp
                     corr2(kk)=0.0_dp
                     gimvel1(kk)=0.0_dp
                     gimvel2(kk)=0.0_dp
                  END DO
!
               ELSE
!
                  centx1=xtran(0.0_dp,0.0_dp,phase,q,1,bdist)
                  centy1=ytran(0.0_dp,0.0_dp,0.0_dp,phase,fincr,q,1,bdist)
                  centx2=xtran(0.0_dp,0.0_dp,phase+180.0_dp,q,2,bdist)
                  centy2=ytran(0.0_dp,0.0_dp,0.0_dp,phase+180.0_dp,fincr, q,2,bdist)
!
!  figure out the phases
!
                  tt1=ABS(phaser-twopie*pconj)
                  tt2=ABS(phaser-twopie*(pconj+1.0_dp))
                  tt3=ABS(phaser-twopie*(pconj-1.0_dp))
                  small=123456789.0_dp
                  IF(tt1 <= small)small=tt1
                  IF(tt2 <= small)small=tt2
                  IF(tt3 <= small)small=tt3
                  diff1=small
                  tt1=ABS(phaser-twopie*pconj2)
                  tt2=ABS(phaser-twopie*(pconj2+1.0_dp))
                  tt3=ABS(phaser-twopie*(pconj2-1.0_dp))
                  small=123456789.0_dp
                  IF(tt1 <= small)small=tt1
                  IF(tt2 <= small)small=tt2
                  IF(tt3 <= small)small=tt3
                  diff2=small
!
!  star 1 in back
!
                  IF(diff1 < diff2)THEN
                     DO kk=1,8
                        corr1(kk)=0.0_dp
                        gimvel1(kk)=0.0_dp
                     END DO
                  ELSE
                     tempbeta=bigbeta
                     delx=centx1-centx2
                     dely=centy1-centy2
                     CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                        delta,reff2,reff1,refflux1,gimvel1,omega1,period,  &
                        bigi,tempbeta,delx,dely,corr2tran1,mandel,1)
!
                     DO kk=1,8
                        corr1(kk)=corr2tran1(kk)
                     END DO
                     DO kk=1,8
                        gimvel1(kk)=gimvel1(kk)*reff1*separ*solarrad/ 1000.0_dp/secinday
                        IF((reff1 < reff2).AND.(delta <= reff2-reff1)) THEN
                           gimvel1(kk)=0.0_dp
                        END IF
                     END DO
!
                  END IF
!
!  star 2 in back
!
                  IF(diff2 < diff1)THEN
                     DO kk=1,8
                        corr2(kk)=0.0_dp
                        gimvel2(kk)=0.0_dp
                     END DO
                  ELSE
                     DO kk=1,8
                        corr2(kk)=0.0_dp
                        gimvel2(kk)=0.0_dp
                     END DO
                     tempbeta=bigbeta2
                     delx=centx2-centx1
                     dely=centy2-centy1
                     CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                        delta,reff1,reff2,refflux2,gimvel2,omega2,period,  &
                        bigi2,tempbeta,delx,dely,corr1tran2,mandel,2)
!
                     DO kk=1,8
                        corr2(kk)=corr1tran2(kk)
                     END DO

                     DO kk=1,8
                        gimvel2(kk)=gimvel2(kk)*reff2*separ*solarrad/ 1000.0_dp/secinday
                        IF((reff2 < reff1).AND.(delta <= reff1-reff2)) THEN
                           gimvel2(kk)=0.0_dp
                        END IF
                     END DO
                  END IF
!
               END IF
            ELSE
!
!  Using the Short method, star 2 in front of star 1
!
               IF(delta > (reff1+reff2))THEN
                  DO kk=1,8
                     corr1(kk)=0.0_dp
                     corr2(kk)=0.0_dp
                     gimvel1(kk)=0.0_dp
                     gimvel2(kk)=0.0_dp
                  END DO
!
               ELSE
!
                  centx1=xtran(0.0_dp,0.0_dp,phase,q,1,bdist)
                  centy1=ytran(0.0_dp,0.0_dp,0.0_dp,phase,fincr,q,1,bdist)
                  centx2=xtran(0.0_dp,0.0_dp,phase+180.0_dp,q,2,bdist)
                  centy2=ytran(0.0_dp,0.0_dp,0.0_dp,phase+180.0_dp,fincr,q,2,bdist)
!
!  figure out the phases
!
                  tt1=ABS(phaser-twopie*pconj)
                  tt2=ABS(phaser-twopie*(pconj+1.0_dp))
                  tt3=ABS(phaser-twopie*(pconj-1.0_dp))
                  small=123456789.0_dp
                  IF(tt1 <= small)small=tt1
                  IF(tt2 <= small)small=tt2
                  IF(tt3 <= small)small=tt3
                  diff1=small
                  tt1=ABS(phaser-twopie*pconj2)
                  tt2=ABS(phaser-twopie*(pconj2+1.0_dp))
                  tt3=ABS(phaser-twopie*(pconj2-1.0_dp))
                  small=123456789.0_dp
                  IF(tt1 <= small)small=tt1
                  IF(tt2 <= small)small=tt2
                  IF(tt3 <= small)small=tt3
                  diff2=small
                  IF(diff1 < diff2)THEN
                     DO kk=1,8
                        corr1(kk)=0.0_dp
                        gimvel1(kk)=0.0_dp
                     END DO
                  ELSE
                     IF(iatm <= 2)THEN
                        CALL shortmethod2(ilaw,1,centx2,centy2,centx1,  &
                           centy1,reff2,reff1,dwavex,dwavey,refflux1,  &
                           corr1,rot1,aa1,bb1,donvel1,tol,irossiter)
                     END IF
                     IF(iatm == 3)THEN
                        CALL atmshortmethod2(ilaw,centx2,centy2,  &
                           centx1,centy1,reff2,reff1,  &
                           refflux1,corr1,rot1,aa1,bb1,donvel1,tol,  &
                           irossiter,table51a,table52a,table53a,table54a,  &
                           table55a,table56a,table57a,table58a,nmumax,nmu)
                     END IF
                     DO kk=1,8
                        gimvel1(kk)=-donvel1(kk)*reff1*separ*solarrad/  &
                           1000.0_dp/86400.0_dp
                     END DO
                  END IF
!
                  IF(diff2 < diff1)THEN
                     DO kk=1,8
                        corr2(kk)=0.0_dp
                        gimvel2(kk)=0.0_dp
                     END DO
                  ELSE
                     IF(iatm <= 2)THEN
                        CALL shortmethod2(ilaw,2,centx1,centy1,centx2,  &
                           centy2,reff1,reff2,dwavex,dwavey,refflux2,  &
                           corr2,rot2,aa2,bb2,donvel2,tol,irossiter)
                     END IF
                     IF(iatm == 3)THEN
                        CALL atmshortmethod2(ilaw,centx1,centy1,  &
                           centx2,centy2,reff1,reff2,  &
                           refflux2,corr2,rot2,aa2,bb2,donvel2,tol,  &
                           irossiter,table51b,table52b,table53b,table54b,  &
                           table55b,table56b,table57b,table58b,nmumax,nmu)
                     END IF
                     DO kk=1,8
                        gimvel2(kk)=-donvel2(kk)*reff2*separ*solarrad/  &
                           1000.0_dp/86400.0_dp
                     END DO
                  END IF
               END IF
            END IF
         END IF
!
         IF(isw30 >= 3)THEN
!
!   body 3 or more, use the dynamical integrator
!
            DO kk=1,8
               gimvel1(kk)=0.0_dp
               gimvel2(kk)=0.0_dp
               gimvel3(kk)=0.0_dp
               gimvel4(kk)=0.0_dp
               gimvel5(kk)=0.0_dp
               donvel1(kk)=0.0_dp
               donvel2(kk)=0.0_dp
               donvel3(kk)=0.0_dp
               donvel4(kk)=0.0_dp
               donvel5(kk)=0.0_dp
               donvel6(kk)=0.0_dp
               donvel7(kk)=0.0_dp
               donvel8(kk)=0.0_dp
               donvel9(kk)=0.0_dp
               donvel10(kk)=0.0_dp
               corr1tran2(kk)=0.0_dp
               corr1tran3(kk)=0.0_dp
               corr1tran4(kk)=0.0_dp
               corr1tran5(kk)=0.0_dp
               corr1tran6(kk)=0.0_dp
               corr1tran7(kk)=0.0_dp
               corr1tran8(kk)=0.0_dp
               corr1tran9(kk)=0.0_dp
               corr1tran10(kk)=0.0_dp
               corr2tran1(kk)=0.0_dp
               corr2tran3(kk)=0.0_dp
               corr2tran4(kk)=0.0_dp
               corr2tran5(kk)=0.0_dp
               corr3tran1(kk)=0.0_dp
               corr3tran2(kk)=0.0_dp
               corr3tran4(kk)=0.0_dp
               corr3tran5(kk)=0.0_dp
               corr4tran1(kk)=0.0_dp
               corr4tran2(kk)=0.0_dp
               corr4tran3(kk)=0.0_dp
               corr4tran5(kk)=0.0_dp
               corr5tran1(kk)=0.0_dp
               corr5tran2(kk)=0.0_dp
               corr5tran3(kk)=0.0_dp
               corr5tran4(kk)=0.0_dp
               corr6tran1(kk)=0.0_dp
               corr7tran1(kk)=0.0_dp
               corr8tran1(kk)=0.0_dp
               corr9tran1(kk)=0.0_dp
               corr10tran1(kk)=0.0_dp
            END DO
            phaser=phase*degtorad
!
!  We have a choice of the Short multibody method (mandel.eq.2)
!  or the Mandel&Agol or Gimenez (mandel.eq.0 or .eq.1).  When
!  using the Short method, we have to determine if there is
!  the potential for a multibody overlap.  If so, call the
!  general routine.  If not, then call the two body routine
!  separately for each combination of pairs of bodies.  In the
!  case of multibody overlap,  we have
!  to fill up the zlist and xylist arrays with the coordinates
!  at each time step.
!
            ioverlap=0
            IF(mandel >= 2)THEN
!
!  do a simple test over potential overlaps
!
               IF(nbody == 3)THEN
                  delta=SQRT((centx1-centx2)**2+(centy1-centy2)**2)
                  IF(delta <= reff1+reff2)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx3)**2+(centy1-centy3)**2)
                  IF(delta <= reff1+reff3)ioverlap=ioverlap+1
!
                  delta=SQRT((centx2-centx3)**2+(centy2-centy3)**2)
                  IF(delta <= reff2+reff3)ioverlap=ioverlap+1
               END IF
               IF(nbody == 4)THEN
                  delta=SQRT((centx1-centx2)**2+(centy1-centy2)**2)
                  IF(delta <= reff1+reff2)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx3)**2+(centy1-centy3)**2)
                  IF(delta <= reff1+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx4)**2+(centy1-centy4)**2)
                  IF(delta <= reff1+reff4)ioverlap=ioverlap+1
!
                  delta=SQRT((centx2-centx3)**2+(centy2-centy3)**2)
                  IF(delta <= reff2+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx4)**2+(centy2-centy4)**2)
                  IF(delta <= reff2+reff4)ioverlap=ioverlap+1
!
                  delta=SQRT((centx3-centx4)**2+(centy3-centy4)**2)
                  IF(delta <= reff3+reff4)ioverlap=ioverlap+1
               END IF
               IF(nbody == 5)THEN
                  delta=SQRT((centx1-centx2)**2+(centy1-centy2)**2)
                  IF(delta <= reff1+reff2)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx3)**2+(centy1-centy3)**2)
                  IF(delta <= reff1+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx4)**2+(centy1-centy4)**2)
                  IF(delta <= reff1+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx5)**2+(centy1-centy5)**2)
                  IF(delta <= reff1+reff5)ioverlap=ioverlap+1
!
                  delta=SQRT((centx2-centx3)**2+(centy2-centy3)**2)
                  IF(delta <= reff2+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx4)**2+(centy2-centy4)**2)
                  IF(delta <= reff2+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx5)**2+(centy2-centy5)**2)
                  IF(delta <= reff2+reff5)ioverlap=ioverlap+1
!
                  delta=SQRT((centx3-centx4)**2+(centy3-centy4)**2)
                  IF(delta <= reff3+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx5)**2+(centy3-centy5)**2)
                  IF(delta <= reff3+reff5)ioverlap=ioverlap+1
!
                  delta=SQRT((centx4-centx5)**2+(centy4-centy5)**2)
                  IF(delta <= reff4+reff5)ioverlap=ioverlap+1
               END IF
               IF(nbody == 6)THEN
                  delta=SQRT((centx1-centx2)**2+(centy1-centy2)**2)
                  IF(delta <= reff1+reff2)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx3)**2+(centy1-centy3)**2)
                  IF(delta <= reff1+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx4)**2+(centy1-centy4)**2)
                  IF(delta <= reff1+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx5)**2+(centy1-centy5)**2)
                  IF(delta <= reff1+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx6)**2+(centy1-centy6)**2)
                  IF(delta <= reff1+reff6)ioverlap=ioverlap+1
!
                  delta=SQRT((centx2-centx3)**2+(centy2-centy3)**2)
                  IF(delta <= reff2+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx4)**2+(centy2-centy4)**2)
                  IF(delta <= reff2+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx5)**2+(centy2-centy5)**2)
                  IF(delta <= reff2+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx6)**2+(centy2-centy6)**2)
                  IF(delta <= reff2+reff6)ioverlap=ioverlap+1
!
                  delta=SQRT((centx3-centx4)**2+(centy3-centy4)**2)
                  IF(delta <= reff3+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx5)**2+(centy3-centy5)**2)
                  IF(delta <= reff3+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx6)**2+(centy3-centy6)**2)
                  IF(delta <= reff3+reff6)ioverlap=ioverlap+1
!
                  delta=SQRT((centx4-centx5)**2+(centy4-centy5)**2)
                  IF(delta <= reff4+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx6)**2+(centy4-centy6)**2)
                  IF(delta <= reff4+reff6)ioverlap=ioverlap+1
!
                  delta=SQRT((centx5-centx6)**2+(centy5-centy6)**2)
                  IF(delta <= reff5+reff6)ioverlap=ioverlap+1
               END IF
               IF(nbody == 7)THEN
                  delta=SQRT((centx1-centx2)**2+(centy1-centy2)**2)
                  IF(delta <= reff1+reff2)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx3)**2+(centy1-centy3)**2)
                  IF(delta <= reff1+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx4)**2+(centy1-centy4)**2)
                  IF(delta <= reff1+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx5)**2+(centy1-centy5)**2)
                  IF(delta <= reff1+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx6)**2+(centy1-centy6)**2)
                  IF(delta <= reff1+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx7)**2+(centy1-centy7)**2)
                  IF(delta <= reff1+reff7)ioverlap=ioverlap+1
!
                  delta=SQRT((centx2-centx3)**2+(centy2-centy3)**2)
                  IF(delta <= reff2+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx4)**2+(centy2-centy4)**2)
                  IF(delta <= reff2+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx5)**2+(centy2-centy5)**2)
                  IF(delta <= reff2+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx6)**2+(centy2-centy6)**2)
                  IF(delta <= reff2+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx7)**2+(centy2-centy7)**2)
                  IF(delta <= reff2+reff7)ioverlap=ioverlap+1
!
                  delta=SQRT((centx3-centx4)**2+(centy3-centy4)**2)
                  IF(delta <= reff3+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx5)**2+(centy3-centy5)**2)
                  IF(delta <= reff3+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx6)**2+(centy3-centy6)**2)
                  IF(delta <= reff3+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx7)**2+(centy3-centy7)**2)
                  IF(delta <= reff3+reff7)ioverlap=ioverlap+1
!
                  delta=SQRT((centx4-centx5)**2+(centy4-centy5)**2)
                  IF(delta <= reff4+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx6)**2+(centy4-centy6)**2)
                  IF(delta <= reff4+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx7)**2+(centy4-centy7)**2)
                  IF(delta <= reff4+reff7)ioverlap=ioverlap+1
!
                  delta=SQRT((centx5-centx6)**2+(centy5-centy6)**2)
                  IF(delta <= reff5+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx5-centx7)**2+(centy5-centy7)**2)
                  IF(delta <= reff5+reff7)ioverlap=ioverlap+1
!
                  delta=SQRT((centx6-centx7)**2+(centy6-centy7)**2)
                  IF(delta <= reff6+reff7)ioverlap=ioverlap+1
!
               END IF
               IF(nbody == 8)THEN
                  delta=SQRT((centx1-centx2)**2+(centy1-centy2)**2)
                  IF(delta <= reff1+reff2)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx3)**2+(centy1-centy3)**2)
                  IF(delta <= reff1+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx4)**2+(centy1-centy4)**2)
                  IF(delta <= reff1+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx5)**2+(centy1-centy5)**2)
                  IF(delta <= reff1+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx6)**2+(centy1-centy6)**2)
                  IF(delta <= reff1+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx7)**2+(centy1-centy7)**2)
                  IF(delta <= reff1+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx8)**2+(centy1-centy8)**2)
                  IF(delta <= reff1+reff8)ioverlap=ioverlap+1
!
                  delta=SQRT((centx2-centx3)**2+(centy2-centy3)**2)
                  IF(delta <= reff2+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx4)**2+(centy2-centy4)**2)
                  IF(delta <= reff2+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx5)**2+(centy2-centy5)**2)
                  IF(delta <= reff2+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx6)**2+(centy2-centy6)**2)
                  IF(delta <= reff2+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx7)**2+(centy2-centy7)**2)
                  IF(delta <= reff2+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx8)**2+(centy2-centy8)**2)
                  IF(delta <= reff2+reff8)ioverlap=ioverlap+1
!
                  delta=SQRT((centx3-centx4)**2+(centy3-centy4)**2)
                  IF(delta <= reff3+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx5)**2+(centy3-centy5)**2)
                  IF(delta <= reff3+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx6)**2+(centy3-centy6)**2)
                  IF(delta <= reff3+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx7)**2+(centy3-centy7)**2)
                  IF(delta <= reff3+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx8)**2+(centy3-centy8)**2)
                  IF(delta <= reff3+reff8)ioverlap=ioverlap+1
!
                  delta=SQRT((centx4-centx5)**2+(centy4-centy5)**2)
                  IF(delta <= reff4+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx6)**2+(centy4-centy6)**2)
                  IF(delta <= reff4+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx7)**2+(centy4-centy7)**2)
                  IF(delta <= reff4+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx8)**2+(centy4-centy8)**2)
                  IF(delta <= reff4+reff8)ioverlap=ioverlap+1
!
                  delta=SQRT((centx5-centx6)**2+(centy5-centy6)**2)
                  IF(delta <= reff5+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx5-centx7)**2+(centy5-centy7)**2)
                  IF(delta <= reff5+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx5-centx8)**2+(centy5-centy8)**2)
                  IF(delta <= reff5+reff8)ioverlap=ioverlap+1
!
                  delta=SQRT((centx6-centx7)**2+(centy6-centy7)**2)
                  IF(delta <= reff6+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx6-centx8)**2+(centy6-centy8)**2)
                  IF(delta <= reff6+reff8)ioverlap=ioverlap+1
!
                  delta=SQRT((centx7-centx8)**2+(centy7-centy8)**2)
                  IF(delta <= reff7+reff8)ioverlap=ioverlap+1
!
               END IF
               IF(nbody == 9)THEN
                  delta=SQRT((centx1-centx2)**2+(centy1-centy2)**2)
                  IF(delta <= reff1+reff2)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx3)**2+(centy1-centy3)**2)
                  IF(delta <= reff1+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx4)**2+(centy1-centy4)**2)
                  IF(delta <= reff1+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx5)**2+(centy1-centy5)**2)
                  IF(delta <= reff1+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx6)**2+(centy1-centy6)**2)
                  IF(delta <= reff1+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx7)**2+(centy1-centy7)**2)
                  IF(delta <= reff1+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx8)**2+(centy1-centy8)**2)
                  IF(delta <= reff1+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx9)**2+(centy1-centy9)**2)
                  IF(delta <= reff1+reff9)ioverlap=ioverlap+1
!
                  delta=SQRT((centx2-centx3)**2+(centy2-centy3)**2)
                  IF(delta <= reff2+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx4)**2+(centy2-centy4)**2)
                  IF(delta <= reff2+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx5)**2+(centy2-centy5)**2)
                  IF(delta <= reff2+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx6)**2+(centy2-centy6)**2)
                  IF(delta <= reff2+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx7)**2+(centy2-centy7)**2)
                  IF(delta <= reff2+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx8)**2+(centy2-centy8)**2)
                  IF(delta <= reff2+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx9)**2+(centy2-centy9)**2)
                  IF(delta <= reff2+reff9)ioverlap=ioverlap+1
!
                  delta=SQRT((centx3-centx4)**2+(centy3-centy4)**2)
                  IF(delta <= reff3+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx5)**2+(centy3-centy5)**2)
                  IF(delta <= reff3+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx6)**2+(centy3-centy6)**2)
                  IF(delta <= reff3+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx7)**2+(centy3-centy7)**2)
                  IF(delta <= reff3+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx8)**2+(centy3-centy8)**2)
                  IF(delta <= reff3+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx9)**2+(centy3-centy9)**2)
                  IF(delta <= reff3+reff9)ioverlap=ioverlap+1
!
                  delta=SQRT((centx4-centx5)**2+(centy4-centy5)**2)
                  IF(delta <= reff4+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx6)**2+(centy4-centy6)**2)
                  IF(delta <= reff4+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx7)**2+(centy4-centy7)**2)
                  IF(delta <= reff4+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx8)**2+(centy4-centy8)**2)
                  IF(delta <= reff4+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx9)**2+(centy4-centy9)**2)
                  IF(delta <= reff4+reff9)ioverlap=ioverlap+1
!
                  delta=SQRT((centx5-centx6)**2+(centy5-centy6)**2)
                  IF(delta <= reff5+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx5-centx7)**2+(centy5-centy7)**2)
                  IF(delta <= reff5+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx5-centx8)**2+(centy5-centy8)**2)
                  IF(delta <= reff5+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx5-centx9)**2+(centy5-centy9)**2)
                  IF(delta <= reff5+reff9)ioverlap=ioverlap+1
!
                  delta=SQRT((centx6-centx7)**2+(centy6-centy7)**2)
                  IF(delta <= reff6+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx6-centx8)**2+(centy6-centy8)**2)
                  IF(delta <= reff6+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx6-centx9)**2+(centy6-centy9)**2)
                  IF(delta <= reff6+reff9)ioverlap=ioverlap+1
!
                  delta=SQRT((centx7-centx8)**2+(centy7-centy8)**2)
                  IF(delta <= reff7+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx7-centx9)**2+(centy7-centy9)**2)
                  IF(delta <= reff7+reff9)ioverlap=ioverlap+1
!
                  delta=SQRT((centx8-centx9)**2+(centy8-centy9)**2)
                  IF(delta <= reff8+reff9)ioverlap=ioverlap+1

               END IF
               IF(nbody == 10)THEN
                  delta=SQRT((centx1-centx2)**2+(centy1-centy2)**2)
                  IF(delta <= reff1+reff2)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx3)**2+(centy1-centy3)**2)
                  IF(delta <= reff1+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx4)**2+(centy1-centy4)**2)
                  IF(delta <= reff1+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx5)**2+(centy1-centy5)**2)
                  IF(delta <= reff1+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx6)**2+(centy1-centy6)**2)
                  IF(delta <= reff1+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx7)**2+(centy1-centy7)**2)
                  IF(delta <= reff1+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx8)**2+(centy1-centy8)**2)
                  IF(delta <= reff1+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx9)**2+(centy1-centy9)**2)
                  IF(delta <= reff1+reff9)ioverlap=ioverlap+1
                  delta=SQRT((centx1-centx10)**2+(centy1-centy10)**2)
                  IF(delta <= reff1+reff10)ioverlap=ioverlap+1
!
                  delta=SQRT((centx2-centx3)**2+(centy2-centy3)**2)
                  IF(delta <= reff2+reff3)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx4)**2+(centy2-centy4)**2)
                  IF(delta <= reff2+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx5)**2+(centy2-centy5)**2)
                  IF(delta <= reff2+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx6)**2+(centy2-centy6)**2)
                  IF(delta <= reff2+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx7)**2+(centy2-centy7)**2)
                  IF(delta <= reff2+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx8)**2+(centy2-centy8)**2)
                  IF(delta <= reff2+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx9)**2+(centy2-centy9)**2)
                  IF(delta <= reff2+reff9)ioverlap=ioverlap+1
                  delta=SQRT((centx2-centx10)**2+(centy2-centy10)**2)
                  IF(delta <= reff2+reff10)ioverlap=ioverlap+1
!
                  delta=SQRT((centx3-centx4)**2+(centy3-centy4)**2)
                  IF(delta <= reff3+reff4)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx5)**2+(centy3-centy5)**2)
                  IF(delta <= reff3+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx6)**2+(centy3-centy6)**2)
                  IF(delta <= reff3+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx7)**2+(centy3-centy7)**2)
                  IF(delta <= reff3+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx8)**2+(centy3-centy8)**2)
                  IF(delta <= reff3+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx9)**2+(centy3-centy9)**2)
                  IF(delta <= reff3+reff9)ioverlap=ioverlap+1
                  delta=SQRT((centx3-centx10)**2+(centy3-centy10)**2)
                  IF(delta <= reff3+reff10)ioverlap=ioverlap+1
!
                  delta=SQRT((centx4-centx5)**2+(centy4-centy5)**2)
                  IF(delta <= reff4+reff5)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx6)**2+(centy4-centy6)**2)
                  IF(delta <= reff4+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx7)**2+(centy4-centy7)**2)
                  IF(delta <= reff4+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx8)**2+(centy4-centy8)**2)
                  IF(delta <= reff4+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx9)**2+(centy4-centy9)**2)
                  IF(delta <= reff4+reff9)ioverlap=ioverlap+1
                  delta=SQRT((centx4-centx10)**2+(centy4-centy10)**2)
                  IF(delta <= reff4+reff10)ioverlap=ioverlap+1
!
                  delta=SQRT((centx5-centx6)**2+(centy5-centy6)**2)
                  IF(delta <= reff5+reff6)ioverlap=ioverlap+1
                  delta=SQRT((centx5-centx7)**2+(centy5-centy7)**2)
                  IF(delta <= reff5+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx5-centx8)**2+(centy5-centy8)**2)
                  IF(delta <= reff5+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx5-centx9)**2+(centy5-centy9)**2)
                  IF(delta <= reff5+reff9)ioverlap=ioverlap+1
                  delta=SQRT((centx5-centx10)**2+(centy5-centy10)**2)
                  IF(delta <= reff5+reff10)ioverlap=ioverlap+1
!
                  delta=SQRT((centx6-centx7)**2+(centy6-centy7)**2)
                  IF(delta <= reff6+reff7)ioverlap=ioverlap+1
                  delta=SQRT((centx6-centx8)**2+(centy6-centy8)**2)
                  IF(delta <= reff6+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx6-centx9)**2+(centy6-centy9)**2)
                  IF(delta <= reff6+reff9)ioverlap=ioverlap+1
                  delta=SQRT((centx6-centx10)**2+(centy6-centy10)**2)
                  IF(delta <= reff6+reff10)ioverlap=ioverlap+1
!
                  delta=SQRT((centx7-centx8)**2+(centy7-centy8)**2)
                  IF(delta <= reff7+reff8)ioverlap=ioverlap+1
                  delta=SQRT((centx7-centx9)**2+(centy7-centy9)**2)
                  IF(delta <= reff7+reff9)ioverlap=ioverlap+1
                  delta=SQRT((centx7-centx10)**2+(centy7-centy10)**2)
                  IF(delta <= reff7+reff10)ioverlap=ioverlap+1
!
                  delta=SQRT((centx8-centx9)**2+(centy8-centy9)**2)
                  IF(delta <= reff8+reff9)ioverlap=ioverlap+1
                  delta=SQRT((centx8-centx10)**2+(centy8-centy10)**2)
                  IF(delta <= reff8+reff10)ioverlap=ioverlap+1
!
                  delta=SQRT((centx9-centx10)**2+(centy9-centy10)**2)
                  IF(delta <= reff9+reff10)ioverlap=ioverlap+1

               END IF

            END IF
!
!  potential for multibody overlap, call the general routine
!
            IF((mandel >= 2).AND.(ioverlap >= 2))THEN
               CALL hunt(odetime,nstep,timein,jlo)
!
               CALL hermskycoord(ndyn,nstep,odetime,timein,zfirst,  &
                  jlo,body01posz,body01velz)
               zlist(1)=zfirst
               CALL hermskycoord(ndyn,nstep,odetime,timein,zsecond,  &
                  jlo,body02posz,body02velz)
               zlist(2)=zsecond
               CALL hermskycoord(ndyn,nstep,odetime,timein,zthird,  &
                  jlo,body03posz,body03velz)
               zlist(3)=zthird
               IF(nbody >= 4)THEN
                  CALL hermskycoord(ndyn,nstep,odetime,timein,  &
                     zfourth,jlo,body04posz,body04velz)
                  zlist(4)=zfourth
               END IF
               IF(nbody >= 5)THEN
                  CALL hermskycoord(ndyn,nstep,odetime,timein,zfifth,  &
                     jlo,body05posz,body05velz)
                  zlist(5)=zfifth
               END IF
               IF(nbody >= 6)THEN
                  CALL hermskycoord(ndyn,nstep,odetime,timein,zsixth,  &
                     jlo,body06posz,body06velz)
                  zlist(6)=zsixth
               END IF
               IF(nbody >= 7)THEN
                  CALL hermskycoord(ndyn,nstep,odetime,timein,  &
                     zseventh,jlo,body07posz,body07velz)
                  zlist(7)=zseventh
               END IF
               IF(nbody >= 8)THEN
                  CALL hermskycoord(ndyn,nstep,odetime,timein,  &
                     zeighth,jlo,body08posz,body08velz)
                  zlist(8)=zeighth
               END IF
               IF(nbody >= 9)THEN
                  CALL hermskycoord(ndyn,nstep,odetime,timein,zninth,  &
                     jlo,body09posz,body09velz)
                  zlist(9)=zninth
               END IF
               IF(nbody >= 10)THEN
                  CALL hermskycoord(ndyn,nstep,odetime,timein,ztenth,  &
                     jlo,body10posz,body10velz)
                  zlist(10)=ztenth
               END IF
!
               DO j=nbody+1,10
                  zlist(j)=-999.9_dp-REAL(j,KIND=dp)
               END DO
               xylist(1,1)=centx1
               xylist(1,2)=centy1
               xylist(2,1)=centx2
               xylist(2,2)=centy2
               xylist(3,1)=centx3
               xylist(3,2)=centy3
               xylist(4,1)=centx4
               xylist(4,2)=centy4
               xylist(5,1)=centx5
               xylist(5,2)=centy5
               xylist(6,1)=centx6
               xylist(6,2)=centy6
               xylist(7,1)=centx7
               xylist(7,2)=centy7
               xylist(8,1)=centx8
               xylist(8,2)=centy8
               xylist(9,1)=centx9
               xylist(9,2)=centy9
               xylist(10,1)=centx10
               xylist(10,2)=centy10
               IF(iatm <= 2)THEN
                  CALL shortmethod(nbody,ilaw,zlist,xylist,radlist,  &
                     dwavex,dwavey,reffluxlist,corrlist,rotlist,aalist,  &
                     bblist,donvellist,tol)
               END IF
               IF(iatm == 3)THEN
                  CALL atmshortmethod(nbody,zlist,xylist,  &
                     radlist,reffluxlist,corrlist,rotlist,  &
                     aalist,bblist,donvellist,tol,nmumax,nmu,table51a,  &
                     table52a,table53a,table54a,table55a,table56a,  &
                     table57a,table58a,table51b,table52b,table53b,  &
                     table54b,table55b,table56b,table57b,table58b,  &
                     table51c,table52c,table53c,table54c,table55c,  &
                     table56c,table57c,table58c,table51d,table52d,  &
                     table53d,table54d,table55d,table56d,table57d,  &
                     table58d,table51e,table52e,table53e,table54e,  &
                     table55e,table56e,table57e,table58e)
               END IF
!
               DO kk=1,8
                  donvel1(kk)=donvellist(1,kk)
                  donvel2(kk)=donvellist(2,kk)
                  donvel3(kk)=donvellist(3,kk)
                  donvel4(kk)=donvellist(4,kk)
                  donvel5(kk)=donvellist(5,kk)
               END DO
            END IF
!
            IF((mandel >= 2).AND.(ioverlap <= 1))THEN
!
!   find the z-distances of each body.  Larger z distance
!   means closer to observer
!
               CALL hunt(odetime,nstep,timein,jlo)
               CALL hermskycoord(ndyn,nstep,odetime,timein,zfirst,  &
                  jlo,body01posz,body01velz)
               CALL hermskycoord(ndyn,nstep,odetime,timein,zsecond,  &
                  jlo,body02posz,body02velz)
               CALL hermskycoord(ndyn,nstep,odetime,timein,zthird,  &
                  jlo,body03posz,body03velz)
               IF(nbody >= 4)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zfourth,jlo,body04posz,body04velz)
               IF(nbody >= 5)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zfifth,jlo,body05posz,body05velz)
               IF(nbody >= 6)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zsixth,jlo,body06posz,body06velz)
               IF(nbody >= 7)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zseventh,jlo,body07posz,body07velz)
               IF(nbody >= 8)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zeighth,jlo,body08posz,body08velz)
               IF(nbody >= 9)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zninth,jlo,body09posz,body09velz)
               IF(nbody >= 10)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,ztenth,jlo,body10posz,body10velz)
!
!   consider body 1 and body 2
!
               delta=SQRT((centx1-centx2)**2+(centy1-centy2)**2)
               IF(delta <= reff1+reff2)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   2, then body 1 is in back.
!
                  IF(zfirst < zsecond)THEN
!
!   star 2 in front of star 1
!
                     IF(iatm <= 2)THEN
                        CALL shortmethod2(ilaw,1,centx2,centy2,centx1,  &
                           centy1,reff2,reff1,dwavex,dwavey,refflux1,  &
                           corr2tran1,rot1,aa1,bb1,donvel1,tol,irossiter)
                     END IF
                     IF(iatm == 3)THEN
                        CALL atmshortmethod2(ilaw,centx2,centy2,  &
                           centx1,centy1,reff2,reff1,  &
                           refflux1,corr2tran1,rot1,aa1,bb1,donvel1,tol,  &
                           irossiter,table51a,table52a,table53a,table54a,  &
                           table55a,table56a,table57a,table58a,nmumax,nmu)
                     END IF
                  ELSE
!
!   star 1 in front of star 2
!
                     IF(iatm <= 2)THEN
                        CALL shortmethod2(ilaw,2,centx1,centy1,centx2,  &
                           centy2,reff1,reff2,dwavex,dwavey,refflux2,  &
                           corr1tran2,rot2,aa2,bb2,donvel2,tol,irossiter)
                     END IF
                     IF(iatm == 3)THEN
                        CALL atmshortmethod2(ilaw,centx1,centy1,  &
                           centx2,centy2,reff1,reff2,  &
                           refflux2,corr1tran2,rot2,aa2,bb2,donvel2,tol,  &
                           irossiter,table51b,table52b,table53b,table54b,  &
                           table55b,table56b,table57b,table58b,nmumax,nmu)
                     END IF
                  END IF
               END IF
!
!   consider body 1 and body 3
!
               delta=SQRT((centx1-centx3)**2+(centy1-centy3)**2)
               IF(delta <= reff1+reff3)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   3, then body 1 is in back.
!
                  IF(zfirst < zthird)THEN
!
!   star 3 in front of star 1
!
                     IF(iatm <= 2)THEN
                        CALL shortmethod2(ilaw,1,centx3,centy3,centx1,  &
                           centy1,reff3,reff1,dwavex,dwavey,refflux1,  &
                           corr3tran1,rot1,aa1,bb1,donvel1,tol,irossiter)
                     END IF
                     IF(iatm == 3)THEN
                        CALL atmshortmethod2(ilaw,centx3,centy3,  &
                           centx1,centy1,reff3,reff1,  &
                           refflux1,corr3tran1,rot1,aa1,bb1,donvel1,tol,  &
                           irossiter,table51a,table52a,table53a,table54a,  &
                           table55a,table56a,table57a,table58a,nmumax,nmu)
                     END IF
                  ELSE
!
!   star 1 in front of star 3
!
                     IF(iatm <= 2)THEN
                        CALL shortmethod2(ilaw,3,centx1,centy1,centx3,  &
                           centy3,reff1,reff3,dwavex,dwavey,refflux3,  &
                           corr1tran3,rot3,aa3,bb3,donvel3,tol,irossiter)
                     END IF
                     IF(iatm == 3)THEN
                        CALL atmshortmethod2(ilaw,centx1,centy1,  &
                           centx3,centy3,reff1,reff3,  &
                           refflux3,corr1tran3,rot3,aa3,bb3,donvel3,tol,  &
                           irossiter,table51c,table52c,table53c,table54c,  &
                           table55c,table56c,table57c,table58c,nmumax,nmu)
                     END IF
                  END IF
               END IF
!
!   consider body 1 and body 4
!
               IF(isw30 >= 4)THEN
                  delta=SQRT((centx1-centx4)**2+(centy1-centy4)**2)
                  IF(delta <= reff1+reff4)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   4, then body 1 is in back.
!
                     IF(zfirst < zfourth)THEN
!
!   star 4 in front of star 1
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,1,centx4,centy4,  &
                              centx1,centy1,reff4,reff1,dwavex,dwavey,  &
                              refflux1,corr4tran1,rot1,aa1,bb1,donvel1,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx4,centy4,  &
                              centx1,centy1,reff4,reff1,  &
                              refflux1,corr4tran1,rot1,aa1,bb1,donvel1,tol,  &
                              irossiter,table51a,table52a,table53a,  &
                              table54a,table55a,table56a,table57a,table58a, nmumax,nmu)
                        END IF
                     ELSE
!
!   star 1 in front of star 4
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,4,centx1,centy1,  &
                              centx4,centy4,reff1,reff4,dwavex,dwavey,  &
                              refflux4,corr1tran4,rot4,aa4,bb4,donvel4,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx1,centy1,  &
                              centx4,centy4,reff1,reff4,  &
                              refflux4,corr1tran4,rot4,aa4,bb4,donvel4,tol,  &
                              irossiter,table51d,table52d,table53d,  &
                              table54d,table55d,table56d,table57d,table58d, nmumax,nmu)
                        END IF
                     END IF
                  END IF
!
!  end if isw30.ge.4
!
               END IF
!
!   consider body 1 and body 5
!
               IF(isw30 >= 5)THEN
                  delta=SQRT((centx1-centx5)**2+(centy1-centy5)**2)
                  IF(delta <= reff1+reff5)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   5, then body 1 is in back.
!
                     IF(zfirst < zfifth)THEN
!
!   star 5 in front of star 1
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,1,centx5,centy5,  &
                              centx1,centy1,reff5,reff1,dwavex,dwavey,  &
                              refflux1,corr5tran1,rot1,aa1,bb1,donvel1,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx5,centy5,  &
                              centx1,centy1,reff5,reff1,  &
                              refflux1,corr5tran1,rot1,aa1,bb1,donvel1,tol,  &
                              irossiter,table51a,table52a,table53a,  &
                              table54a,table55a,table56a,table57a,table58a, nmumax,nmu)
                        END IF
                     ELSE
!
!   star 1 in front of star 5
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,5,centx1,centy1,  &
                              centx5,centy5,reff1,reff5,dwavex,dwavey,  &
                              refflux5,corr1tran5,rot5,aa5,bb5,donvel5,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx1,centy1,  &
                              centx5,centy5,reff1,reff5,  &
                              refflux5,corr1tran5,rot5,aa5,bb5,donvel5,tol,  &
                              irossiter,table51e,table52e,table53e,  &
                              table54e,table55e,table56e,table57e,table58e, nmumax,nmu)
                        END IF
                     END IF
                  END IF
!
!  end if isw30.ge.5
!
               END IF
!
!   consider body 1 and body 6
!
               IF(isw30 >= 6)THEN
                  delta=SQRT((centx1-centx6)**2+(centy1-centy6)**2)
                  IF(delta <= reff1+reff6)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   6, then body 1 is in back.
!
                     IF(zfirst < zsixth)THEN
!
!   star 6 in front of star 1
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,1,centx6,centy6,  &
                              centx1,centy1,reff6,reff1,dwavex,dwavey,  &
                              refflux1,corr6tran1,rot1,aa1,bb1,donvel1,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx6,centy6,  &
                              centx1,centy1,reff6,reff1,  &
                              refflux1,corr6tran1,rot1,aa1,bb1,donvel1,tol,  &
                              irossiter,table51a,table52a,table53a,  &
                              table54a,table55a,table56a,table57a,table58a, nmumax,nmu)
                        END IF

                     ELSE
!
!   star 1 in front of star 6
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,6,centx1,centy1,  &
                              centx6,centy6,reff1,reff6,dwavex,dwavey,  &
                              refflux6,corr1tran6,rot6,aa6,bb6,donvel6,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx1,centy1,  &
                              centx6,centy6,reff1,reff6,  &
                              refflux6,corr1tran6,rot6,aa6,bb6,donvel6,tol,  &
                              irossiter,table51e,table52e,table53e,  &
                              table54e,table55e,table56e,table57e,table58e, nmumax,nmu)
                        END IF

                     END IF
                  END IF
!
!  end if isw30.ge.6
!
               END IF
!
!   consider body 1 and body 7
!
               IF(isw30 >= 7)THEN
                  delta=SQRT((centx1-centx7)**2+(centy1-centy7)**2)
                  IF(delta <= reff1+reff7)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   7, then body 1 is in back.
!
                     IF(zfirst < zseventh)THEN
!
!   star 7 in front of star 1
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,1,centx7,centy7,  &
                              centx1,centy1,reff7,reff1,dwavex,dwavey,  &
                              refflux1,corr7tran1,rot1,aa1,bb1,donvel1,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx7,centy7,  &
                              centx1,centy1,reff7,reff1,  &
                              refflux1,corr7tran1,rot1,aa1,bb1,donvel1,tol,  &
                              irossiter,table51a,table52a,table53a,  &
                              table54a,table55a,table56a,table57a,table58a, nmumax,nmu)
                        END IF

                     ELSE
!
!   star 1 in front of star 7
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,7,centx1,centy1,  &
                              centx7,centy7,reff1,reff7,dwavex,dwavey,  &
                              refflux7,corr1tran7,rot7,aa7,bb7,donvel7,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx1,centy1,  &
                              centx7,centy7,reff1,reff7,  &
                              refflux7,corr1tran7,rot7,aa7,bb7,donvel7,tol,  &
                              irossiter,table51e,table52e,table53e,  &
                              table54e,table55e,table56e,table57e,table58e, nmumax,nmu)
                        END IF

                     END IF
                  END IF
!
!  end if isw30.ge.7
!
               END IF
!
!   consider body 1 and body 8
!
               IF(isw30 >= 8)THEN
                  delta=SQRT((centx1-centx8)**2+(centy1-centy8)**2)
                  IF(delta <= reff1+reff8)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   8, then body 1 is in back.
!
                     IF(zfirst < zeighth)THEN
!
!   star 8 in front of star 1
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,1,centx8,centy8,  &
                              centx1,centy1,reff8,reff1,dwavex,dwavey,  &
                              refflux1,corr8tran1,rot1,aa1,bb1,donvel1,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx8,centy8,  &
                              centx1,centy1,reff8,reff1,  &
                              refflux1,corr8tran1,rot1,aa1,bb1,donvel1,tol,  &
                              irossiter,table51a,table52a,table53a,  &
                              table54a,table55a,table56a,table57a,table58a, nmumax,nmu)
                        END IF

                     ELSE
!
!   star 1 in front of star 8
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,8,centx1,centy1,  &
                              centx8,centy8,reff1,reff8,dwavex,dwavey,  &
                              refflux8,corr1tran8,rot8,aa8,bb8,donvel8,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx1,centy1,  &
                              centx8,centy8,reff1,reff8,  &
                              refflux8,corr1tran8,rot8,aa8,bb8,donvel8,tol,  &
                              irossiter,table51e,table52e,table53e,  &
                              table54e,table55e,table56e,table57e,table58e, nmumax,nmu)
                        END IF

                     END IF
                  END IF
!
!  end if isw30.ge.8
!
               END IF
!
!   consider body 1 and body 9
!
               IF(isw30 >= 9)THEN
                  delta=SQRT((centx1-centx9)**2+(centy1-centy9)**2)
                  IF(delta <= reff1+reff9)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   9, then body 1 is in back.
!
                     IF(zfirst < zninth)THEN
!
!   star 9 in front of star 1
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,1,centx9,centy9,  &
                              centx1,centy1,reff9,reff1,dwavex,dwavey,  &
                              refflux1,corr9tran1,rot1,aa1,bb1,donvel1,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx9,centy9,  &
                              centx1,centy1,reff9,reff1,  &
                              refflux1,corr9tran1,rot1,aa1,bb1,donvel1,tol,  &
                              irossiter,table51a,table52a,table53a,  &
                              table54a,table55a,table56a,table57a,table58a, nmumax,nmu)
                        END IF

                     ELSE
!
!   star 1 in front of star 9
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,9,centx1,centy1,  &
                              centx9,centy9,reff1,reff9,dwavex,dwavey,  &
                              refflux9,corr1tran9,rot9,aa9,bb9,donvel9,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx1,centy1,  &
                              centx9,centy9,reff1,reff9,  &
                              refflux9,corr1tran9,rot9,aa9,bb9,donvel9,tol,  &
                              irossiter,table51e,table52e,table53e,  &
                              table54e,table55e,table56e,table57e,table58e, nmumax,nmu)
                        END IF

                     END IF
                  END IF
!
!  end if isw30.ge.9
!
               END IF
!
!   consider body 1 and body 10
!
               IF(isw30 >= 10)THEN
                  delta=SQRT((centx1-centx10)**2+(centy1-centy10)**2)
                  IF(delta <= reff1+reff10)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   10, then body 1 is in back.
!
                     IF(zfirst < ztenth)THEN
!
!   star 10 in front of star 1
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,1,centx10,centy10,  &
                              centx1,centy1,reff10,reff1,dwavex,dwavey,  &
                              refflux1,corr10tran1,rot1,aa1,bb1,donvel1, tol,irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx10,centy10,  &
                              centx1,centy1,reff10,reff1,  &
                              refflux1,corr10tran1,rot1,aa1,bb1,donvel1,  &
                              tol,irossiter,table51a,table52a,table53a,  &
                              table54a,table55a,table56a,table57a,table58a, nmumax,nmu)
                        END IF

                     ELSE
!
!   star 1 in front of star 10
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,10,centx1,centy1,  &
                              centx10,centy10,reff1,reff10,dwavex,dwavey,  &
                              refflux10,corr1tran10,rot10,aa10,bb10, donvel10,tol,irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx1,centy1,  &
                              centx10,centy10,reff1,reff10,  &
                              refflux10,corr1tran10,rot10,aa10,bb10,  &
                              donvel10,tol,irossiter,table51e,table52e,  &
                              table53e,table54e,table55e,table56e,table57e,  &
                              table58e,nmumax,nmu)
                        END IF

                     END IF
                  END IF
!
!  end if isw30.ge.10
!
               END IF
!
!   consider body 2 and body 3
!
               delta=SQRT((centx2-centx3)**2+(centy2-centy3)**2)
               IF(delta <= reff2+reff3)THEN
!
!   if the z-coordinate of body 2 is less than the z-coordinate of body
!   3, then body 2 is in back.
!
                  IF(zsecond < zthird)THEN
!
!   star 3 in front of star 2
!
                     IF(iatm <= 2)THEN
                        CALL shortmethod2(ilaw,2,centx3,centy3,centx2,  &
                           centy2,reff3,reff2,dwavex,dwavey,refflux2,  &
                           corr3tran2,rot2,aa2,bb2,donvel2,tol,irossiter)
                     END IF
                     IF(iatm == 3)THEN
                        CALL atmshortmethod2(ilaw,centx3,centy3,  &
                           centx2,centy2,reff3,reff2,  &
                           refflux2,corr3tran2,rot2,aa2,bb2,donvel2,tol,  &
                           irossiter,table51b,table52b,table53b,table54b,  &
                           table55b,table56b,table57b,table58b,nmumax,nmu)
                     END IF

                  ELSE
!
!   star 2 in front of star 3
!
                     IF(iatm <= 2)THEN
                        CALL shortmethod2(ilaw,3,centx2,centy2,centx3,  &
                           centy3,reff2,reff3,dwavex,dwavey,refflux3,  &
                           corr2tran3,rot3,aa3,bb3,donvel3,tol,irossiter)
                     END IF
                     IF(iatm == 3)THEN
                        CALL atmshortmethod2(ilaw,centx2,centy2,  &
                           centx3,centy3,reff2,reff3,  &
                           refflux3,corr2tran3,rot3,aa3,bb3,donvel3,tol,  &
                           irossiter,table51c,table52c,table53c,table54c,  &
                           table55c,table56c,table57c,table58c,nmumax,nmu)
                     END IF

                  END IF
               END IF
!
!   consider body 2 and body 4
!
               IF(isw30 >= 4)THEN
                  delta=SQRT((centx2-centx4)**2+(centy2-centy4)**2)
                  IF(delta <= reff2+reff4)THEN
!
                     IF(zsecond < zfourth)THEN
!
!   star 4 in front of star 2
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,2,centx4,centy4,  &
                              centx2,centy2,reff4,reff2,dwavex,dwavey,  &
                              refflux2,corr4tran2,rot2,aa2,bb2,donvel2,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx4,centy4,  &
                              centx2,centy2,reff4,reff2,  &
                              refflux2,corr4tran2,rot2,aa2,bb2,donvel2,tol,  &
                              irossiter,table51b,table52b,table53b,  &
                              table54b,table55b,table56b,table57b,table58b, nmumax,nmu)

                        END IF
                     ELSE
!
!   star 2 in front of star 4
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,4,centx2,centy2,  &
                              centx4,centy4,reff2,reff4,dwavex,dwavey,  &
                              refflux4,corr2tran4,rot4,aa4,bb4,donvel4,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx2,centy2,  &
                              centx4,centy4,reff2,reff4,  &
                              refflux4,corr2tran4,rot4,aa4,bb4,donvel4,tol,  &
                              irossiter,table51d,table52d,table53d,  &
                              table54d,table55d,table56d,table57d,table58d, nmumax,nmu)
                        END IF

                     END IF
                  END IF
!
!   end if isw30.ge.4
!
               END IF
!
!   consider body 2 and body 5
!
               IF(isw30 >= 5)THEN
                  delta=SQRT((centx2-centx5)**2+(centy2-centy5)**2)
                  IF(delta <= reff2+reff5)THEN
!
!   if the z-coordinate of body 2 is less than the z-coordinate of body
!   5, then body 2 is in back.
!
                     IF(zsecond < zfifth)THEN
!
!   star 5 in front of star 2
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,2,centx5,centy5,  &
                              centx2,centy2,reff5,reff2,dwavex,dwavey,  &
                              refflux2,corr5tran2,rot2,aa2,bb2,donvel2,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx5,centy5,  &
                              centx2,centy2,reff5,reff2,  &
                              refflux2,corr5tran2,rot2,aa2,bb2,donvel2,tol,  &
                              irossiter,table51b,table52b,table53b,  &
                              table54b,table55b,table56b,table57b,table58b, nmumax,nmu)
                        END IF

                     ELSE
!
!   star 2 in front of star 5
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,5,centx2,centy2,  &
                              centx5,centy5,reff2,reff5,dwavex,dwavey,  &
                              refflux5,corr2tran5,rot5,aa5,bb5,donvel5,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx2,centy2,  &
                              centx5,centy5,reff2,reff5,  &
                              refflux5,corr2tran5,rot5,aa5,bb5,donvel5,tol,  &
                              irossiter,table51e,table52e,table53e,  &
                              table54e,table55e,table56e,table57e,table58e, nmumax,nmu)
                        END IF

                     END IF
                  END IF
!
!   end if isw30.ge.5
!
               END IF
!
!   consider body 3 and body 4
!
               IF(isw30 >= 4)THEN
                  delta=SQRT((centx3-centx4)**2+(centy3-centy4)**2)
                  IF(delta <= reff3+reff4)THEN
!
!   if the z-coordinate of body 3 is less than the z-coordinate of body
!   4, then body 3 is in back.
!
                     IF(zthird < zfourth)THEN
!
!   star 4 in front of star 3
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,3,centx4,centy4,  &
                              centx3,centy3,reff4,reff3,dwavex,dwavey,  &
                              refflux3,corr4tran3,rot3,aa3,bb3,donvel3,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx4,centy4,  &
                              centx3,centy3,reff4,reff3,  &
                              refflux3,corr4tran3,rot3,aa3,bb3,donvel3,tol,  &
                              irossiter,table51c,table52c,table53c,  &
                              table54c,table55c,table56c,table57c,table58c, nmumax,nmu)
                        END IF

                     ELSE
!
!   star 3 in front of star 4
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,4,centx3,centy3,  &
                              centx4,centy4,reff3,reff4,dwavex,dwavey,  &
                              refflux4,corr3tran4,rot4,aa4,bb4,donvel4,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx3,centy3,  &
                              centx4,centy4,reff3,reff4,  &
                              refflux4,corr3tran4,rot4,aa4,bb4,donvel4,tol,  &
                              irossiter,table51d,table52d,table53d,  &
                              table54d,table55d,table56d,table57d,table58d, nmumax,nmu)
                        END IF

                     END IF
                  END IF
!
!   end if isw30.ge.4
!
               END IF
!
!   consider body 3 and body 5
!
               IF(isw30 >= 5)THEN
                  delta=SQRT((centx3-centx5)**2+(centy3-centy5)**2)
                  IF(delta <= reff3+reff5)THEN
!
!   if the z-coordinate of body 3 is less than the z-coordinate of body
!   5, then body 3 is in back.
!
                     IF(zthird < zfifth)THEN
!
!   star 5 in front of star 3
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,3,centx5,centy5,  &
                              centx3,centy3,reff5,reff3,dwavex,dwavey,  &
                              refflux3,corr5tran3,rot3,aa3,bb3,donvel3,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx5,centy5,  &
                              centx3,centy3,reff5,reff3,  &
                              refflux3,corr5tran3,rot3,aa3,bb3,donvel3,tol,  &
                              irossiter,table51c,table52c,table53c,  &
                              table54c,table55c,table56c,table57c,table58c, nmumax,nmu)
                        END IF

                     ELSE
!
!   star 3 in front of star 5
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,5,centx3,centy3,  &
                              centx5,centy5,reff3,reff5,dwavex,dwavey,  &
                              refflux5,corr3tran5,rot5,aa5,bb5,donvel5,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx3,centy3,  &
                              centx5,centy5,reff3,reff5,  &
                              refflux5,corr3tran5,rot5,aa5,bb5,donvel5,tol,  &
                              irossiter,table51e,table52e,table53e,  &
                              table54e,table55e,table56e,table57e,table58e, nmumax,nmu)
                        END IF

                     END IF
                  END IF
!
!   end if isw30.ge.5
!
               END IF
!
!   consider body 4 and body 5
!
               IF(isw30 >= 5)THEN
                  delta=SQRT((centx4-centx5)**2+(centy4-centy5)**2)
                  IF(delta <= reff4+reff5)THEN
!
!   if the z-coordinate of body 4 is less than the z-coordinate of body
!   5, then body 4 is in back.
!
                     IF(zfourth < zfifth)THEN
!
!   star 5 in front of star 4
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,4,centx5,centy5,  &
                              centx4,centy4,reff5,reff4,dwavex,dwavey,  &
                              refflux4,corr5tran4,rot4,aa4,bb4,donvel4,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx5,centy5,  &
                              centx4,centy4,reff5,reff4,  &
                              refflux4,corr5tran4,rot4,aa4,bb4,donvel4,tol,  &
                              irossiter,table51d,table52d,table53d,  &
                              table54d,table55d,table56d,table57d,table58d, nmumax,nmu)
                        END IF

                     ELSE
!
!   star 4 in front of star 5
!
                        IF(iatm <= 2)THEN
                           CALL shortmethod2(ilaw,5,centx4,centy4,  &
                              centx5,centy5,reff4,reff5,dwavex,dwavey,  &
                              refflux5,corr3tran5,rot5,aa5,bb5,donvel5,tol, irossiter)
                        END IF
                        IF(iatm == 3)THEN
                           CALL atmshortmethod2(ilaw,centx4,centy4,centx5, &
                              centy5,reff4,reff5,refflux5,corr3tran5,rot5, &
                              aa5,bb5,donvel5,tol,irossiter,table51e,table52e,&
                              table53e,table54e,table55e,table56e,table57e, &
                              table58e, nmumax,nmu)
                        END IF

                     END IF
                  END IF
!
!   end if isw30.ge.5
!
               END IF
!
!  end if mandel.eq.2
!
            END IF
!
            IF(mandel <= 1)THEN
!
!   find the z-distances of each body.  Larger z distance
!   means closer to observer
!
               CALL hunt(odetime,nstep,timein,jlo)
               CALL hermskycoord(ndyn,nstep,odetime,timein,zfirst,  &
                  jlo,body01posz,body01velz)
               CALL hermskycoord(ndyn,nstep,odetime,timein,zsecond,  &
                  jlo,body02posz,body02velz)
               CALL hermskycoord(ndyn,nstep,odetime,timein,zthird,  &
                  jlo,body03posz,body03velz)
               IF(nbody >= 4)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zfourth,jlo,body04posz,body04velz)
               IF(nbody >= 5)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zfifth,jlo,body05posz,body05velz)
               IF(nbody >= 6)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zsixth,jlo,body06posz,body06velz)
               IF(nbody >= 7)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zseventh,jlo,body07posz,body07velz)
               IF(nbody >= 8)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zeighth,jlo,body08posz,body08velz)
               IF(nbody >= 9)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,zninth,jlo,body09posz,body09velz)
               IF(nbody >= 10)CALL hermskycoord(ndyn,nstep,odetime,  &
                  timein,ztenth,jlo,body10posz,body10velz)
!
!   consider body 1 and body 2
!
               delta=SQRT((centx1-centx2)**2+(centy1-centy2)**2)
               IF(delta <= reff1+reff2)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   2, then body 1 is in back.
!
                  IF(zfirst < zsecond)THEN
                     delx=centx1-centx2
                     dely=centy1-centy2
                     CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                        delta,reff2,reff1,refflux1,gimvel1,omega1,period,  &
                        bigi,bigbeta,delx,dely,corr2tran1,mandel,1)
                     IF((reff1 < reff2).AND.(delta <= reff2-reff1))THEN
                        DO kk=1,8
                           gimvel1(kk)=0.0_dp
                        END DO
                     END IF
                  ELSE
                     delx=centx2-centx1
                     dely=centy2-centy1
                     CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                        delta,reff1,reff2,refflux2,gimvel2,omega2,period,  &
                        bigi2,bigbeta2,delx,dely,corr1tran2,mandel,2)
                     IF((reff2 < reff1).AND.(delta <= reff1-reff2))THEN
                        DO kk=1,8
                           gimvel2(kk)=0.0_dp
                        END DO
                     END IF
                  END IF
               END IF
!
!   consider body 1 and body 3
!
               delta=SQRT((centx1-centx3)**2+(centy1-centy3)**2)
               IF(delta < reff1+reff3)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   3, then body 1 is in back.
!
                  IF(zfirst < zthird)THEN
                     delx=centx1-centx3
                     dely=centy1-centy3
                     CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                        delta,reff3,reff1,refflux1,gimvel1,omega1,period,  &
                        bigi,bigbeta,delx,dely,corr3tran1,mandel,1)
                     IF((reff1 < reff3).AND.(delta <= reff3-reff1))THEN
                        DO kk=1,8
                           gimvel1(kk)=0.0_dp
                        END DO
                     END IF
                  ELSE
                     delx=centx3-centx1
                     dely=centy3-centy1
                     CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                        delta,reff1,reff3,refflux3,gimvel3,omega3,  &
                        tertperiod,bigi3,bigbeta3,delx,dely,corr1tran3, &
                              mandel,3)
                     IF((reff3 < reff1).AND.(delta <= reff1-reff3))THEN
                        DO kk=1,8
                           gimvel3(kk)=0.0_dp
                        END DO
                     END IF
                  END IF
               END IF
!
!   consider body 1 and body 4
!
               IF(isw30 >= 4)THEN
                  delta=SQRT((centx1-centx4)**2+(centy1-centy4)**2)
                  IF(delta < reff1+reff4)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   3, then body 1 is in back.
!
                     IF(zfirst < zfourth)THEN
                        delx=centx1-centx4
                        dely=centy1-centy4
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff4,reff1,refflux1,gimvel1,omega1,  &
                           period,bigi,bigbeta,delx,dely,corr4tran1,mandel,1)
                        IF((reff1 < reff4).AND.(delta <= reff4-reff1))THEN
                           DO kk=1,8
                              gimvel1(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx4-centx1
                        dely=centy4-centy1
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff1,reff4,refflux4,gimvel4,omega4,  &
                           p2period,bigi4,bigbeta4,delx,dely,corr1tran4, &
                              mandel,4)
                        IF((reff4 < reff1).AND.(delta <= reff1-reff4))THEN
                           DO kk=1,8
                              gimvel4(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!   end if Nbody = 4
!
               END IF
!
!   consider body 1 and body 5
!
               IF(isw30 >= 5)THEN
                  delta=SQRT((centx1-centx5)**2+(centy1-centy5)**2)
                  IF(delta < reff1+reff5)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   5, then body 1 is in back.
!
                     IF(zfirst < zfifth)THEN
                        delx=centx1-centx5
                        dely=centy1-centy5
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff5,reff1,refflux1,gimvel1,omega1,  &
                           period,bigi,bigbeta,delx,dely,corr5tran1,mandel,1)
                        IF((reff1 < reff5).AND.(delta <= reff5-reff1))THEN
                           DO kk=1,8
                              gimvel1(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx5-centx1
                        dely=centy5-centy1
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff1,reff5,refflux5,gimvel5,omega5,  &
                           p3period,fakei,fakebeta,delx,dely,corr1tran5, &
                              mandel,5)
                        IF((reff5 < reff1).AND.(delta <= reff1-reff5))THEN
                           DO kk=1,8
                              gimvel5(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!  end if Nbody = 5
!
               END IF
!
!   consider body 1 and body 6
!
               IF(isw30 >= 6)THEN
                  delta=SQRT((centx1-centx6)**2+(centy1-centy6)**2)
                  IF(delta < reff1+reff6)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   6, then body 1 is in back.
!
                     IF(zfirst < zsixth)THEN
                        delx=centx1-centx6
                        dely=centy1-centy6
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff6,reff1,refflux1,gimvel1,omega1,  &
                           period,bigi,bigbeta,delx,dely,corr6tran1,mandel,1)
                        IF((reff1 < reff6).AND.(delta <= reff6-reff1))THEN
                           DO kk=1,8
                              gimvel1(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx6-centx1
                        dely=centy6-centy1
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff1,reff6,refflux6,gimvel6,omega6,  &
                           p4period,fakei,fakebeta,delx,dely,corr1tran6, &
                             mandel,6)
                        IF((reff6 < reff1).AND.(delta <= reff1-reff6))THEN
                           DO kk=1,8
                              gimvel6(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!  end if Nbody = 6
!
               END IF
!
!   consider body 1 and body 7
!
               IF(isw30 >= 7)THEN
                  delta=SQRT((centx1-centx7)**2+(centy1-centy7)**2)
                  IF(delta < reff1+reff7)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   7, then body 1 is in back.
!
                     IF(zfirst < zseventh)THEN
                        delx=centx1-centx7
                        dely=centy1-centy7
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff7,reff1,refflux1,gimvel1,omega1,  &
                           period,bigi,bigbeta,delx,dely,corr7tran1,mandel,1)
                        IF((reff1 < reff7).AND.(delta <= reff7-reff1))THEN
                           DO kk=1,8
                              gimvel1(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx7-centx1
                        dely=centy7-centy1
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff1,reff7,refflux7,gimvel7,omega7,  &
                           p5period,fakei,fakebeta,delx,dely,corr1tran7, &
                               mandel,7)
                        IF((reff7 < reff1).AND.(delta <= reff1-reff7))THEN
                           DO kk=1,8
                              gimvel7(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!  end if Nbody = 7
!
               END IF
!
!   consider body 1 and body 8
!
               IF(isw30 >= 8)THEN
                  delta=SQRT((centx1-centx8)**2+(centy1-centy8)**2)
                  IF(delta < reff1+reff8)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   8, then body 1 is in back.
!
                     IF(zfirst < zeighth)THEN
                        delx=centx1-centx8
                        dely=centy1-centy8
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff8,reff1,refflux1,gimvel1,omega1,  &
                           period,bigi,bigbeta,delx,dely,corr8tran1,mandel,1)
                        IF((reff1 < reff8).AND.(delta <= reff8-reff1))THEN
                           DO kk=1,8
                              gimvel1(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx8-centx1
                        dely=centy8-centy1
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff1,reff8,refflux8,gimvel8,omega8,  &
                           p6period,fakei,fakebeta,delx,dely,corr1tran8, &
                              mandel,8)
                        IF((reff8 < reff1).AND.(delta <= reff1-reff8))THEN
                           DO kk=1,8
                              gimvel8(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!  end if Nbody = 8
!
               END IF
!
!   consider body 1 and body 9
!
               IF(isw30 >= 9)THEN
                  delta=SQRT((centx1-centx9)**2+(centy1-centy9)**2)
                  IF(delta < reff1+reff9)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   9, then body 1 is in back.
!
                     IF(zfirst < zninth)THEN
                        delx=centx1-centx9
                        dely=centy1-centy9
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff9,reff1,refflux1,gimvel1,omega1,  &
                           period,bigi,bigbeta,delx,dely,corr9tran1,mandel,1)
                        IF((reff1 < reff9).AND.(delta <= reff9-reff1)) THEN
                           DO kk=1,8
                              gimvel1(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx9-centx1
                        dely=centy9-centy1
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff1,reff9,refflux9,gimvel9,omega9,  &
                           p7period,fakei,fakebeta,delx,dely,corr1tran9, &
                              mandel,9)
                        IF((reff9 < reff1).AND.(delta <= reff1-reff9)) THEN
                           DO kk=1,8
                              gimvel9(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!  end if Nbody = 9
!
               END IF
!
!   consider body 1 and body 10
!
               IF(isw30 >= 10)THEN
                  delta=SQRT((centx1-centx10)**2+(centy1-centy10)**2)
                  IF(delta < reff1+reff10)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   9, then body 1 is in back.
!
                     IF(zfirst < ztenth)THEN
                        delx=centx1-centx10
                        dely=centy1-centy10
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff10,reff1,refflux1,gimvel1,omega1,  &
                           period,bigi,bigbeta,delx,dely,corr10tran1,mandel,1)
                        IF((reff1 < reff10).AND.(delta <= reff10-reff1))THEN
                           DO kk=1,8
                              gimvel1(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx10-centx1
                        dely=centy10-centy1
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff1,reff10,refflux10,gimvel10,omega10,  &
                           p8period,fakei,fakebeta,delx,dely,corr1tran10, &
                              mandel,10)
                        IF((reff10 < reff1).AND.(delta <= reff1-reff10) )THEN
                           DO kk=1,8
                              gimvel10(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!  end if Nbody = 9
!
               END IF
!
!   consider body 2 and body 3
!
               delta=SQRT((centx2-centx3)**2+(centy2-centy3)**2)
               IF(delta < reff2+reff3)THEN
!
!   if the z-coordinate of body 2 is less than the z-coordinate of body
!   3, then body 2 is in back.
!
                  IF(zsecond < zthird)THEN
                     delx=centx2-centx3
                     dely=centy2-centy3
                     CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                        delta,reff3,reff2,refflux2,gimvel2,omega2,period,  &
                        bigi2,bigbeta2,delx,dely,corr3tran2,mandel,2)
                     IF((reff2 < reff3).AND.(delta <= reff3-reff2)) THEN
                        DO kk=1,8
                           gimvel2(kk)=0.0_dp
                        END DO
                     END IF
                  ELSE
                     delx=centx3-centx2
                     dely=centy3-centy2
                     CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                        delta,reff2,reff3,refflux3,gimvel3,omega3,  &
                        tertperiod,bigi3,bigbeta3,delx,dely,corr2tran3, &
                           mandel,3)
                     IF((reff3 < reff2).AND.(delta <= reff2-reff3)) THEN
                        DO kk=1,8
                           gimvel3(kk)=0.0_dp
                        END DO
                     END IF
                  END IF
               END IF
!
!   consider body 2 and body 4
!
               IF(isw30 >= 4)THEN
                  delta=SQRT((centx2-centx4)**2+(centy2-centy4)**2)
                  IF(delta < reff2+reff4)THEN
!
!   if the z-coordinate of body 2 is less than the z-coordinate of body
!   4, then body 2 is in back.
!
                     IF(zsecond < zfourth)THEN
                        delx=centx2-centx4
                        dely=centy2-centy4
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff4,reff2,refflux2,gimvel2,omega2,  &
                           period,bigi2,bigbeta2,delx,dely,corr4tran2, &
                              mandel,2)
                        IF((reff2 < reff4).AND.(delta <= reff4-reff2)) THEN
                           DO kk=1,8
                              gimvel2(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx4-centx2
                        dely=centy4-centy2
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff2,reff4,refflux4,gimvel4,omega4,  &
                           p2period,bigi4,bigbeta4,delx,dely,corr2tran4, &
                             mandel,4)
                        IF((reff4 < reff2).AND.(delta <= reff2-reff4)) THEN
                           DO kk=1,8
                              gimvel4(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!   end if Nbody = 4
!
               END IF
!
!   consider body 2 and body 5
!
               IF(isw30 >= 5)THEN
                  delta=SQRT((centx2-centx5)**2+(centy2-centy5)**2)
                  IF(delta < reff2+reff5)THEN
!
!   if the z-coordinate of body 1 is less than the z-coordinate of body
!   5, then body 1 is in back.
!
                     IF(zsecond < zfifth)THEN
                        delx=centx2-centx5
                        dely=centy2-centy5
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff5,reff2,refflux2,gimvel2,omega2,  &
                           period,bigi2,bigbeta2,delx,dely,corr5tran2, &
                               mandel,2)
                        IF((reff2 < reff5).AND.(delta <= reff5-reff2)) THEN
                           DO kk=1,8
                              gimvel2(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx5-centx2
                        dely=centy5-centy2
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff2,reff5,refflux5,gimvel5,omega5,  &
                           p2period,bigi5,bigbeta5,delx,dely,corr2tran5, &
                              mandel,5)
                        IF((reff5 < reff2).AND.(delta <= reff2-reff5)) THEN
                           DO kk=1,8
                              gimvel5(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!   end if Nbody = 5
!
               END IF
!
!   consider body 3 and body 4
!
               IF(isw30 >= 4)THEN
                  delta=SQRT((centx3-centx4)**2+(centy3-centy4)**2)
                  IF(delta < reff3+reff4)THEN
!
!   if the z-coordinate of body 3 is less than the z-coordinate of body
!   4, then body 3 is in back.
!
                     IF(zthird < zfourth)THEN
                        delx=centx3-centx4
                        dely=centy3-centy4
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff4,reff3,refflux3,gimvel3,omega3,  &
                           period,bigi3,bigbeta3,delx,dely,corr4tran3, &
                              mandel,3)
                        IF((reff3 < reff4).AND.(delta <= reff4-reff3)) THEN
                           DO kk=1,8
                              gimvel3(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx4-centx3
                        dely=centy4-centy3
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff3,reff4,refflux4,gimvel4,omega4,  &
                           p2period,bigi4,bigbeta4,delx,dely,corr2tran4, &
                              mandel,4)
                        IF((reff4 < reff3).AND.(delta <= reff3-reff4)) THEN
                           DO kk=1,8
                              gimvel4(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!   end if Nbody = 4
!
               END IF
!
!   consider body 3 and body 5
!
               IF(isw30 >= 5)THEN
                  delta=SQRT((centx3-centx5)**2+(centy3-centy5)**2)
                  IF(delta < reff3+reff5)THEN
!
!   if the z-coordinate of body 3 is less than the z-coordinate of body
!   5, then body 3 is in back.
!
                     IF(zthird < zfifth)THEN
                        delx=centx3-centx5
                        dely=centy3-centy5
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff5,reff3,refflux3,gimvel3,omega3,  &
                           period,bigi3,bigbeta3,delx,dely,corr5tran3, &
                              mandel,3)
                        IF((reff3 < reff5).AND.(delta <= reff5-reff3)) THEN
                           DO kk=1,8
                              gimvel3(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx5-centx3
                        dely=centy5-centy3
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff3,reff5,refflux5,gimvel5,omega5,  &
                           p2period,bigi5,bigbeta5,delx,dely,corr2tran5, &
                                mandel,5)
                        IF((reff5 < reff3).AND.(delta <= reff3-reff5)) THEN
                           DO kk=1,8
                              gimvel5(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!   end if Nbody = 5
!
               END IF
!
!   consider body 4 and body 5
!
               IF(isw30 >= 5)THEN
                  delta=SQRT((centx4-centx5)**2+(centy4-centy5)**2)
                  IF(delta < reff4+reff5)THEN
!
!   if the z-coordinate of body 4 is less than the z-coordinate of body
!   5, then body 4 is in back.
!
                     IF(zfourth < zfifth)THEN
                        delx=centx4-centx5
                        dely=centy4-centy5
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff5,reff4,refflux4,gimvel4,omega4,  &
                           period,bigi4,bigbeta4,delx,dely,corr5tran4, &
                                mandel,4)
                        IF((reff4 < reff5).AND.(delta <= reff5-reff4)) THEN
                           DO kk=1,8
                              gimvel4(kk)=0.0_dp
                           END DO
                        END IF
                     ELSE
                        delx=centx5-centx4
                        dely=centy5-centy4
                        CALL fixedanalyticg(isw27,ilaw,dwavex,dwavey,  &
                           delta,reff4,reff5,refflux5,gimvel5,omega5,  &
                           p2period,bigi5,bigbeta5,delx,dely,corr2tran5, &
                               mandel,5)
                        IF((reff5 < reff4).AND.(delta <= reff4-reff5)) THEN
                           DO kk=1,8
                              gimvel5(kk)=0.0_dp
                           END DO
                        END IF
                     END IF
                  END IF
!
!   end if Nbody = 5
!
               END IF
!
!   end if mandel.eq.1
!
            END IF
!
!   Record LTT corrected sky coordinates if it2 >= 2
!
            IF(it2 == 3)THEN
               WRITE(91,40)timein,separ*centx1,separ*centy1,zfirst/  &
                  auinsolarrad,-velout1,reff1*separ
               WRITE(92,40)timein,separ*centx2,separ*centy2,zsecond/  &
                  auinsolarrad,-velout2,reff2*separ
               WRITE(93,40)timein,separ*centx3,separ*centy3,zthird/  &
                  auinsolarrad,-velout3,reff3*separ
               IF(nbody >= 4)WRITE(94,40)timein,separ*centx4,separ*  &
                  centy4,zfourth/auinsolarrad,-velout4,reff4*separ
               IF(nbody >= 5)WRITE(95,40)timein,separ*centx5,separ*  &
                  centy5,zfifth/auinsolarrad,-velout5,reff5*separ
               IF(nbody >= 6)WRITE(96,40)timein,separ*centx6,separ*  &
                  centy6,zsixth/auinsolarrad,-velout6,reff6*separ
               IF(nbody >= 7)WRITE(97,40)timein,separ*centx7,separ*  &
                  centy7,zseventh/auinsolarrad,-velout7,reff7*separ
               IF(nbody >= 8)WRITE(98,40)timein,separ*centx8,separ*  &
                  centy8,zeighth/auinsolarrad,-velout8,reff8*separ
               IF(nbody >= 9)WRITE(99,40)timein,separ*centx9,separ*  &
                  centy9,zninth/auinsolarrad,-velout9,reff9*separ
               IF(nbody >= 10)WRITE(100,40)timein,separ*centx10,  &
                  separ*centy10,ztenth/auinsolarrad,-velout10,reff10*separ
            END IF
            IF(it2 == 2)THEN
               WRITE(91,40)timein,auinsolarrad*centx1*separ,  &
                  auinsolarrad*centy1*separ,zfirst,-velout1*1000.0_dp/  &
                  auperdaytompersec,reff1*auinsolarrad*separ
               WRITE(92,40)timein,auinsolarrad*centx2*separ,  &
                  auinsolarrad*centy2*separ,zsecond,-velout2*1000.0_dp/  &
                  auperdaytompersec,reff2*auinsolarrad*separ
               WRITE(93,40)timein,auinsolarrad*centx3*separ,  &
                  auinsolarrad*centy3*separ,zthird,-velout3*1000.0_dp/  &
                  auperdaytompersec,reff3*auinsolarrad*separ
               IF(nbody >= 4)WRITE(94,40)timein,auinsolarrad*centx4*  &
                  separ,auinsolarrad*centy4*separ,zfourth,-velout4*  &
                  1000.0_dp/auperdaytompersec,reff4*auinsolarrad*separ
               IF(nbody >= 5)WRITE(95,40)timein,auinsolarrad*centx5*  &
                  separ,auinsolarrad*centy5*separ,zfifth,-velout5*1000.0_dp  &
                  /auperdaytompersec,reff5*auinsolarrad*separ
               IF(nbody >= 6)WRITE(96,40)timein,auinsolarrad*centx6*  &
                  separ,auinsolarrad*centy6*separ,zsixth,-velout6*1000.0_dp  &
                  /auperdaytompersec,reff6*auinsolarrad*separ
               IF(nbody >= 7)WRITE(97,40)timein,auinsolarrad*centx7*  &
                  separ,auinsolarrad*centy7*separ,zseventh,-velout7*  &
                  1000.0_dp/auperdaytompersec,reff7*auinsolarrad*separ
               IF(nbody >= 8)WRITE(98,40)timein,auinsolarrad*centx8*  &
                  separ,auinsolarrad*centy8*separ,zeighth,-velout8*  &
                  1000.0_dp/auperdaytompersec,reff8*auinsolarrad*separ
               IF(nbody >= 9)WRITE(99,40)timein,auinsolarrad*centx9*  &
                  separ,auinsolarrad*centy9*separ,zninth,-velout9*1000.0_dp  &
                  /auperdaytompersec,reff9*auinsolarrad*separ
               IF(nbody >= 10)WRITE(99,40)timein,auinsolarrad*  &
                  centx10*separ,auinsolarrad*centy10*separ,ztenth,-  &
                  velout10*1000.0_dp/auperdaytompersec,reff10*auinsolarrad*separ
            END IF
!
!   end if Nbody > 3
!
         END IF
!
         CALL getrefvel(1,phase,finc,q,separ,period,gamma,vel1,ecc,argrad)
         CALL getrefvel(2,dummyphase,finc,q,separ,period,gamma,  &
            vel2,ecc,argrad+pie)
!
         DO ll=1,8
            dop1=0.0_dp
            dop2=0.0_dp
            IF(isw30 <= 2)THEN
               offset1=darkint1(ll)+corr1(ll)+corr1a(ll)
               offset2=darkint2(ll)+corr2(ll)+corr2a(ll)
               offset3=third(ll)
               offset4=fourth(ll)
               IF(offset2 < 0.0_dp)offset2=0.0_dp
               IF(ll == irvfilt)THEN
                  dop1=(vel1-gamma)/speedlightkm
                  dop2=(vel2-gamma)/speedlightkm
                  offset1=offset1*(1.0_dp-beam1*dop1)
                  offset2=offset2*(1.0_dp-beam2*dop2)
               END IF
               IF(ll == 1)ymodu(icount)=pie*(third(1)+offset1+offset2)
               IF(ll == 2)ymodb(icount)=pie*(third(2)+offset1+offset2)
               IF(ll == 3)ymodv(icount)=pie*(third(3)+offset1+offset2)
               IF(ll == 4)ymodr(icount)=pie*(third(4)+offset1+offset2)
               IF(ll == 5)ymodi(icount)=pie*(third(5)+offset1+offset2)
               IF(ll == 6)ymodj(icount)=pie*(third(6)+offset1+offset2)
               IF(ll == 7)ymodh(icount)=pie*(third(7)+offset1+offset2)
               IF(ll == 8)ymodk(icount)=pie*(third(8)+offset1+offset2)
!
               IF(ll == irvfilt)THEN
                  ymods1(icount)=pie*(offset1)
                  ymods2(icount)=pie*(offset2)
                  ymods3(icount)=pie*(third(ll))
                  IF(offset1 <= 0.0_dp)gimvel1(irvfilt)=0.0_dp
                  IF(offset2 <= 0.0_dp)gimvel2(irvfilt)=0.0_dp
                  rv1(icount)=vel1+gimvel1(irvfilt)
                  rv2(icount)=vel2+gimvel2(irvfilt)
                  rv3(icount)=0.0_dp
                  rv4(icount)=0.0_dp
                  rv5(icount)=0.0_dp
                  drv1(icount)=gimvel1(irvfilt)
                  drv2(icount)=gimvel2(irvfilt)
                  drv3(icount)=0.0_dp
                  drv4(icount)=0.0_dp
                  drv5(icount)=0.0_dp
               END IF
!
               IF(ll == 1)THEN
                  fracs1(icount,1)=pie*(offset1)
                  fracs1(icount,2)=pie*(offset2)
                  fracs1(icount,3)=0.0_dp
                  fracs1(icount,4)=pie*(offset3)
               END IF
               IF(ll == 2)THEN
                  fracs2(icount,1)=pie*(offset1)
                  fracs2(icount,2)=pie*(offset2)
                  fracs2(icount,3)=0.0_dp
                  fracs2(icount,4)=pie*(offset3)
               END IF
               IF(ll == 3)THEN
                  fracs3(icount,1)=pie*(offset1)
                  fracs3(icount,2)=pie*(offset2)
                  fracs3(icount,3)=0.0_dp
                  fracs3(icount,4)=pie*(offset3)
               END IF
               IF(ll == 4)THEN
                  fracs4(icount,1)=pie*(offset1)
                  fracs4(icount,2)=pie*(offset2)
                  fracs4(icount,3)=0.0_dp
                  fracs4(icount,4)=pie*(offset3)
               END IF
               IF(ll == 5)THEN
                  fracs5(icount,1)=pie*(offset1)
                  fracs5(icount,2)=pie*(offset2)
                  fracs5(icount,3)=0.0_dp
                  fracs5(icount,4)=pie*(offset3)
               END IF
               IF(ll == 6)THEN
                  fracs6(icount,1)=pie*(offset1)
                  fracs6(icount,2)=pie*(offset2)
                  fracs6(icount,3)=0.0_dp
                  fracs6(icount,4)=pie*(offset3)
               END IF
               IF(ll == 7)THEN
                  fracs7(icount,1)=pie*(offset1)
                  fracs7(icount,2)=pie*(offset2)
                  fracs7(icount,3)=0.0_dp
                  fracs7(icount,4)=pie*(offset3)
               END IF
               IF(ll == 8)THEN
                  fracs8(icount,1)=pie*(offset1)
                  fracs8(icount,2)=pie*(offset2)
                  fracs8(icount,3)=0.0_dp
                  fracs8(icount,4)=pie*(offset3)
               END IF
!
!  end if isw30 <= 2
!
            END IF
!
            IF(isw30 > 2)THEN
               IF((mandel >= 2).AND.(ioverlap >= 2))THEN
                  offset1=darkint1(ll)+corrlist(1,ll)
                  offset2=darkint2(ll)+corrlist(2,ll)
                  offset3=darkint3(ll)+corrlist(3,ll)
                  offset4=darkint4(ll)+corrlist(4,ll)
                  offset5=darkint5(ll)+corrlist(5,ll)
               ELSE
                  offset1=darkint1(ll)+corr2tran1(ll)+corr3tran1(ll)+  &
                     corr4tran1(ll)+corr5tran1(ll)+corr6tran1(ll)+  &
                     corr7tran1(ll)+corr8tran1(ll)+corr9tran1(ll)+  &
                     corr10tran1(ll)
                  offset2=darkint2(ll)+corr1tran2(ll)+corr3tran2(ll)+  &
                     corr4tran2(ll)+corr5tran2(ll)
                  offset3=darkint3(ll)+corr1tran3(ll)+corr2tran3(ll)+  &
                     corr4tran3(ll)+corr5tran3(ll)
                  offset4=darkint4(ll)+corr1tran4(ll)+corr2tran4(ll)+  &
                     corr3tran4(ll)+corr5tran4(ll)
                  offset5=darkint5(ll)+corr1tran5(ll)+corr2tran5(ll)+  &
                     corr3tran5(ll)+corr4tran5(ll)
               END IF
!
               IF(offset2 < 0.0_dp)offset2=0.0_dp
               IF(offset3 < 0.0_dp)offset3=0.0_dp
               IF(offset4 < 0.0_dp)offset4=0.0_dp
               IF(offset5 < 0.0_dp)offset5=0.0_dp
               IF(ll == irvfilt)THEN
                  dop1=(vel1-gamma)/speedlightkm
                  dop2=(vel2-gamma)/speedlightkm
                  offset1=offset1*(1.0_dp-beam1*dop1)
                  offset2=offset2*(1.0_dp-beam2*dop2)
               END IF
               IF(ll == 1)ymodu(icount)=pie*(offset1+offset2+offset3+  &
                  offset4+offset5)
               IF(ll == 2)ymodb(icount)=pie*(offset1+offset2+offset3+  &
                  offset4+offset5)
               IF(ll == 3)ymodv(icount)=pie*(offset1+offset2+offset3+  &
                  offset4+offset5)
               IF(ll == 4)ymodr(icount)=pie*(offset1+offset2+offset3+  &
                  offset4+offset5)
               IF(ll == 5)ymodi(icount)=pie*(offset1+offset2+offset3+  &
                  offset4+offset5)
               IF(ll == 6)ymodj(icount)=pie*(offset1+offset2+offset3+  &
                  offset4+offset5)
               IF(ll == 7)ymodh(icount)=pie*(offset1+offset2+offset3+  &
                  offset4+offset5)
               IF(ll == 8)ymodk(icount)=pie*(offset1+offset2+offset3+  &
                  offset4+offset5)
!
               IF(isw30 < 3)THEN
                  rv1(icount)=vel1
                  rv2(icount)=vel2
                  rv3(icount)=0.0_dp
                  rv4(icount)=0.0_dp
                  rv5(icount)=0.0_dp
               ELSE
                  IF(mandel <= 1)THEN
                     rv1(icount)=-velout1+gamma-gimvel1(irvfilt)*separ*  &
                        reff1*solarrad/1000.0_dp/secinday
                     rv2(icount)=-velout2+gamma-gimvel2(irvfilt)*separ*  &
                        reff2*solarrad/1000.0_dp/secinday
                     rv3(icount)=-velout3+gamma-gimvel3(irvfilt)*separ*  &
                        reff3*solarrad/1000.0_dp/secinday
                     rv4(icount)=-velout4+gamma-gimvel4(irvfilt)*separ*  &
                        reff4*solarrad/1000.0_dp/secinday
                     rv5(icount)=-velout5+gamma-gimvel5(irvfilt)*separ*  &
                        reff5*solarrad/1000.0_dp/secinday
                     drv1(icount)=-gimvel1(irvfilt)*reff1*separ*  &
                        solarrad/1000.0_dp/secinday
                     drv2(icount)=-gimvel2(irvfilt)*reff2*separ*  &
                        solarrad/1000.0_dp/secinday
                     drv3(icount)=-gimvel3(irvfilt)*reff3*separ*  &
                        solarrad/1000.0_dp/secinday
                     drv4(icount)=-gimvel4(irvfilt)*reff4*separ*  &
                        solarrad/1000.0_dp/secinday
                     drv5(icount)=-gimvel5(irvfilt)*reff5*separ*  &
                        solarrad/1000.0_dp/secinday
                  END IF
                  IF(mandel >= 2)THEN
                     rv1(icount)=-velout1+gamma+donvel1(irvfilt)*separ*  &
                        reff1*solarrad/1000.0_dp/secinday
                     rv2(icount)=-velout2+gamma+donvel2(irvfilt)*separ*  &
                        reff2*solarrad/1000.0_dp/secinday
                     rv3(icount)=-velout3+gamma+donvel3(irvfilt)*separ*  &
                        reff3*solarrad/1000.0_dp/secinday
                     rv4(icount)=-velout4+gamma+donvel4(irvfilt)*separ*  &
                        reff4*solarrad/1000.0_dp/secinday
                     rv5(icount)=-velout5+gamma+donvel5(irvfilt)*separ*  &
                        reff5*solarrad/1000.0_dp/secinday
                     drv1(icount)=+donvel1(irvfilt)*separ*reff1*  &
                        solarrad/1000.0_dp/secinday
                     drv2(icount)=+donvel2(irvfilt)*separ*reff2*  &
                        solarrad/1000.0_dp/secinday
                     drv3(icount)=+donvel3(irvfilt)*separ*reff3*  &
                        solarrad/1000.0_dp/secinday
                     drv4(icount)=+donvel4(irvfilt)*separ*reff4*  &
                        solarrad/1000.0_dp/secinday
                     drv5(icount)=+donvel5(irvfilt)*separ*reff5*  &
                        solarrad/1000.0_dp/secinday
                  END IF
               END IF
               IF(ll == irvfilt)THEN
                  ymods1(icount)=pie*(offset1)
                  ymods2(icount)=pie*(offset2)
                  ymods3(icount)=pie*(offset3)
                  ymods4(icount)=pie*(offset4)
                  ymods5(icount)=pie*(offset5)
               END IF
!
               IF(ll == 1)THEN
                  fracs1(icount,1)=pie*(offset1)
                  fracs1(icount,2)=pie*(offset2)
                  fracs1(icount,3)=0.0_dp
                  fracs1(icount,4)=pie*(offset3)
               END IF
               IF(ll == 2)THEN
                  fracs2(icount,1)=pie*(offset1)
                  fracs2(icount,2)=pie*(offset2)
                  fracs2(icount,3)=0.0_dp
                  fracs2(icount,4)=pie*(offset3)
               END IF
               IF(ll == 3)THEN
                  fracs3(icount,1)=pie*(offset1)
                  fracs3(icount,2)=pie*(offset2)
                  fracs3(icount,3)=0.0_dp
                  fracs3(icount,4)=pie*(offset3)
               END IF
               IF(ll == 4)THEN
                  fracs4(icount,1)=pie*(offset1)
                  fracs4(icount,2)=pie*(offset2)
                  fracs4(icount,3)=0.0_dp
                  fracs4(icount,4)=pie*(offset3)
               END IF
               IF(ll == 5)THEN
                  fracs5(icount,1)=pie*(offset1)
                  fracs5(icount,2)=pie*(offset2)
                  fracs5(icount,3)=0.0_dp
                  fracs5(icount,4)=pie*(offset3)
               END IF
               IF(ll == 6)THEN
                  fracs6(icount,1)=pie*(offset1)
                  fracs6(icount,2)=pie*(offset2)
                  fracs6(icount,3)=0.0_dp
                  fracs6(icount,4)=pie*(offset3)
               END IF
               IF(ll == 7)THEN
                  fracs7(icount,1)=pie*(offset1)
                  fracs7(icount,2)=pie*(offset2)
                  fracs7(icount,3)=0.0_dp
                  fracs7(icount,4)=pie*(offset3)
               END IF
               IF(ll == 8)THEN
                  fracs8(icount,1)=pie*(offset1)
                  fracs8(icount,2)=pie*(offset2)
                  fracs8(icount,3)=0.0_dp
                  fracs8(icount,4)=pie*(offset3)
               END IF
!
!  end if isw30 <= 2
!
            END IF
!
         END DO
!
         IF(isw7 <= 1)xmod(icount)=phase/360.0_dp
         IF(ecc > 0.0_dp)xmod(icount)=em/(twopie)
         IF(isw7 >= 2)xmod(icount)=timearray(icounttime)
         xrvmod(icount)=xmod(icount)
!
      END DO loop10
!
!  continue the big loop if eccentric
!
   END DO loop30
!
   nphase=icount
   nrvphase=icount
!
   IF(isw7 <= 1)THEN
      IF((ecc > 0.0_dp).OR.(ABS(pshift) > EPSILON(pshift)))THEN
         tshift=pshift+eshift
!
!   UPDATE September 10, 2001
!
!   Add the if-then clauses.
!
         IF((ecc > 0.0_dp).AND.(ikeep == 1))tshift=pshift+eshift-pconj
         IF((ecc > 0.0_dp).AND.(ikeep == 2))tshift=pshift+eshift-pconj2
         IF(icnu /= 430)CALL shiftlc(nmaxphase,nphase,xmod,ymodu,tshift,0)
         IF(icnb /= 430)CALL shiftlc(nmaxphase,nphase,xmod,ymodb,tshift,0)
         IF(icnv /= 430)CALL shiftlc(nmaxphase,nphase,xmod,ymodv,tshift,0)
         IF(icnr /= 430)CALL shiftlc(nmaxphase,nphase,xmod,ymodr,tshift,0)
         IF(icni /= 430)CALL shiftlc(nmaxphase,nphase,xmod,ymodi,tshift,0)
         IF(icnj /= 430)CALL shiftlc(nmaxphase,nphase,xmod,ymodj,tshift,0)
         IF(icnh /= 430)CALL shiftlc(nmaxphase,nphase,xmod,ymodh,tshift,0)
         IF(icnk /= 430)CALL shiftlc(nmaxphase,nphase,xmod,ymodk,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymods1,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymods2,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymods3,tshift,0)
         CALL shiftlc(nmaxphase,nphase,xmod,ymodd,tshift,1)
         IF(icnrv1 /= 430)CALL shiftlc(nmaxphase,nphase,xrvmod,rv1,tshift,0)
         IF(icnrv2 /= 430)CALL shiftlc(nmaxphase,nphase,xrvmod,drv1,tshift,0)
         IF(icnrv1 /= 430)CALL shiftlc(nmaxphase,nphase,xrvmod,rv2,tshift,0)
         IF(icnrv2 /= 430)CALL shiftlc(nmaxphase,nphase,xrvmod,drv2,tshift,1)
      END IF
   END IF
!
!   If requested, bin the light and velocity curves.  sw29 will be
!   the binsize for the photometry, in minutes, and sw30 will be the bin
!   size for the RV curves, in minutes
!
   IF(sw29 > 0.0_dp)THEN
      IF(isw7 <= 1)THEN
         IF(icnu /= 430)CALL binlc(nmaxphase,nphase,xmod,ymodu,period,sw29)
      ELSE
         IF(icnu /= 430)CALL binlctime(nmaxphase,nphase,xmod,  &
            ymodu,period,sw29,nsc,xsc,ysc,isw87)
      END IF
   END IF
   IF(sw30 > 0.0_dp)THEN
      IF(icnrv1 /= 430)CALL binlc(nmaxphase,nrvphase,xrvmod,rv1,period,sw30)
   END IF
   IF(sw30 > 0.0_dp)THEN
      IF(icnrv2 /= 430)CALL binlc(nmaxphase,nrvphase,xrvmod,rv2,period,sw30)
   END IF
   IF(sw30 > 0.0_dp)THEN
      IF(icnrv1 /= 430)CALL binlc(nmaxphase,nrvphase,xrvmod,drv1,period,sw30)
   END IF
   IF(sw30 > 0.0_dp)THEN
      IF(icnrv2 /= 430)CALL binlc(nmaxphase,nrvphase,xrvmod,drv2,period,sw30)
   END IF
!
   IF(iseason >= 1)THEN
      IF(nphase > 1)CALL scontaminate(nmaxphase,nphase,xmod,  &
         ymodu,contams0,contams1,contams2,contams3)
   ELSE
      IF((contam > 0.0_dp).AND.(contam < 1.0_dp))THEN
         IF(nphase > 1)CALL contaminate(nmaxphase,nphase,xmod,ymodu,contam)
      END IF
   END IF
!
!  If iversion=1, then there is TESS data.  Check to see
!  what filter is needed, and if the binning is needed
!
   IF((tessbin > 0.0_dp).AND.(iversion == 1))THEN
      IF((isw7 <= 1).AND.(tessfilt == 1))THEN
         IF(icnu /= 430)CALL binlc(nmaxphase,nphase,xmod,ymodu,period,tessbin)
      ELSE
         IF(icnu /= 430)CALL binlctime(nmaxphase,nphase,xmod,  &
            ymodu,period,tessbin,0,xsc,ysc,0)
      END IF
!
      IF((isw7 <= 1).AND.(tessfilt == 2))THEN
         IF(icnb /= 430)CALL binlc(nmaxphase,nphase,xmod,ymodb,period,tessbin)
      ELSE
         IF(icnb /= 430)CALL binlctime(nmaxphase,nphase,xmod,  &
            ymodb,period,tessbin,0,xsc,ysc,0)
      END IF
!
      IF((isw7 <= 1).AND.(tessfilt == 3))THEN
         IF(icnv /= 430)CALL binlc(nmaxphase,nphase,xmod,ymodv,period,tessbin)
      ELSE
         IF(icnv /= 430)CALL binlctime(nmaxphase,nphase,xmod,  &
            ymodv,period,tessbin,0,xsc,ysc,0)
      END IF
!
      IF((isw7 <= 1).AND.(tessfilt == 4))THEN
         IF(icnr /= 430)CALL binlc(nmaxphase,nphase,xmod,ymodr,period,tessbin)
      ELSE
         IF(icnr /= 430)CALL binlctime(nmaxphase,nphase,xmod,  &
            ymodr,period,tessbin,0,xsc,ysc,0)
      END IF
!
      IF((isw7 <= 1).AND.(tessfilt == 5))THEN
         IF(icni /= 430)CALL binlc(nmaxphase,nphase,xmod,ymodi,period,tessbin)
      ELSE
         IF(icni /= 430)CALL binlctime(nmaxphase,nphase,xmod,  &
            ymodi,period,tessbin,0,xsc,ysc,0)
      END IF
!
      IF((isw7 <= 1).AND.(tessfilt == 6))THEN
         IF(icnj /= 430)CALL binlc(nmaxphase,nphase,xmod,ymodj,period,tessbin)
      ELSE
         IF(icnj /= 430)CALL binlctime(nmaxphase,nphase,xmod,  &
            ymodj,period,tessbin,0,xsc,ysc,0)
      END IF
!
      IF((isw7 <= 1).AND.(tessfilt == 7))THEN
         IF(icnh /= 430)CALL binlc(nmaxphase,nphase,xmod,ymodh,period,tessbin)
      ELSE
         IF(icnh /= 430)CALL binlctime(nmaxphase,nphase,xmod,  &
            ymodh,period,tessbin,0,xsc,ysc,0)
      END IF
!
      IF((isw7 <= 1).AND.(tessfilt == 8))THEN
         IF(icnk /= 430)CALL binlc(nmaxphase,nphase,xmod,ymodk,period,tessbin)
      ELSE
         IF(icnk /= 430)CALL binlctime(nmaxphase,nphase,xmod,  &
            ymodk,period,tessbin,0,xsc,ysc,0)
      END IF
   END IF
!
!  See if there is TESS contamination
!
   IF(iversion == 1)THEN
      IF((tesscontam > 0.0_dp).AND.(tesscontam < 1.0_dp))THEN
!
         IF((nphase > 1).AND.(icnu /= 430).AND.(tessfilt == 1))  &
            CALL contaminate(nmaxphase,nphase,xmod,ymodu,tesscontam)
!
         IF((nphase > 1).AND.(icnb /= 430).AND.(tessfilt == 2))  &
            CALL contaminate(nmaxphase,nphase,xmod,ymodb,tesscontam)
!
         IF((nphase > 1).AND.(icnv /= 430).AND.(tessfilt == 3))  &
            CALL contaminate(nmaxphase,nphase,xmod,ymodv,tesscontam)
!
         IF((nphase > 1).AND.(icnr /= 430).AND.(tessfilt == 4))  &
            CALL contaminate(nmaxphase,nphase,xmod,ymodr,tesscontam)
!
         IF((nphase > 1).AND.(icni /= 430).AND.(tessfilt == 5))  &
            CALL contaminate(nmaxphase,nphase,xmod,ymodi,tesscontam)
!
         IF((nphase > 1).AND.(icnj /= 430).AND.(tessfilt == 6))  &
            CALL contaminate(nmaxphase,nphase,xmod,ymodj,tesscontam)
!
         IF((nphase > 1).AND.(icnh /= 430).AND.(tessfilt == 7))  &
            CALL contaminate(nmaxphase,nphase,xmod,ymodh,tesscontam)
!
         IF((nphase > 1).AND.(icnk /= 430).AND.(tessfilt == 8))  &
            CALL contaminate(nmaxphase,nphase,xmod,ymodk,tesscontam)
!
      END IF
   END IF
!
   argper=saveargper
!
   RETURN
!
40 FORMAT(f14.7,2X,10(f19.15,1X,f19.15,1X,f18.14,1X,f15.9,1X,f16.9))
!
END SUBROUTINE fastanalytic
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE fastpot(q,omega,x,y,z,psi,psix,psiy,psiz,bdist,  &
   cox,coy,tidephi,itide,ecc,thetamis,phimis)
!
!   May 6, 2000
!
!   This routine computes the potential and its derivatives.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: x
   REAL(KIND=dp), INTENT(IN)                :: y
   REAL(KIND=dp), INTENT(IN)                :: z
   REAL(KIND=dp), INTENT(OUT)               :: psi
   REAL(KIND=dp), INTENT(OUT)               :: psix
   REAL(KIND=dp), INTENT(OUT)               :: psiy
   REAL(KIND=dp), INTENT(OUT)               :: psiz
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: cox
   REAL(KIND=dp), INTENT(IN)                :: coy
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   INTEGER, INTENT(IN)                      :: itide
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
!
   REAL(KIND=dp) :: hutfac,pn,pd,omegah,rst,rx,a,rst3,rx3,term1,term2
   REAL(KIND=dp) :: term4,term5,term6,cpm,spm,stm,s2pm,s2tm,dterm1,dterm2
   REAL(KIND=dp) :: dterm3,tider,psicos,rr,w1,t1,twx,twy,twz,term3
!
   INTEGER :: ii
!
   DIMENSION pn(0:100),pd(0:100)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!   UPDATE January 24, 2011
!
!   Add in the Hut factor to Omega
!
   hutfac=(1.0_dp+7.5_dp*ecc*ecc+5.625_dp*ecc**4+0.3125_dp*ecc**6)/  &
      ((1.0_dp+3.0_dp*ecc*ecc+3.0_dp/8.0_dp*ecc**4)*SQRT((1.0_dp-ecc*ecc)**3))
   omegah=omega*hutfac
   IF(itide < 2)THEN
      rst=SQRT(x**2+y**2+z**2)
      rx=SQRT((x-bdist)**2+y**2+z**2)
      a=((1.0_dp+q)/2.0_dp)*omegah**2
      rst3=rst*rst*rst
      rx3=rx*rx*rx
      IF((ABS(thetamis) <= EPSILON(thetamis)).AND.(ABS(phimis) &
           <= EPSILON(phimis)))THEN
         term1=x*x
         term2=y*y
         term3=0.0_dp
         term4=0.0_dp
         term5=0.0_dp
         term6=0.0_dp
         cpm=1.0_dp
         spm=0.0_dp
         stm=0.0_dp
         s2pm=0.0_dp
         s2tm=0.0_dp
      ELSE
         cpm=COS(phimis)
         spm=SIN(phimis)
         stm=SIN(thetamis)
         s2pm=SIN(2.0_dp*phimis)
         s2tm=SIN(2.0_dp*thetamis)
         term1=x*x*(1.0_dp-cpm*cpm*stm*stm)
         term2=y*y*(1.0_dp-spm*spm*stm*stm)
         term3=z*z*stm*stm
         term4=-x*y*stm*stm*s2pm
         term5=-x*z*cpm*s2tm
         term6=-y*z*spm*s2tm
      END IF
      psi=1.0_dp/rst+q/rx-q*x/bdist/bdist+a*(term1+term2+term3+term4+term5+term6)
      dterm1=2.0_dp*x*(1.0_dp-cpm*cpm*stm*stm)
      dterm2=-y*stm*stm*s2pm
      dterm3=-z*cpm*s2tm
      psix=-x/rst3-q*(x-bdist)/rx3-q/bdist/bdist+a*(dterm1+dterm2+dterm3)
      dterm1=2.0_dp*y*(1.0_dp-spm*spm*stm*stm)
      dterm2=-x*stm*stm*s2tm
      dterm3=-z*spm*s2tm
      psiy=-y/rst3-q*y/rx3+a*(dterm1+dterm2+dterm3)
      dterm1=2.0_dp*z*stm*stm
      dterm2=-x*cpm*s2tm
      dterm3=-y*spm*s2tm
      psiz=-z/rst3-q*z/rx3+a*(dterm1+dterm2+dterm3)
!
      RETURN
   END IF
!
   tider=tidephi*degtorad
   psicos=cox*COS(tider)+coy*SIN(tider)
   rr=x*x+y*y+z*z
   w1=(SQRT(rr))**3
   w1=1.0_dp/w1
   psi=1.0_dp/SQRT(rr)+q
   psix=-x*w1
   psiy=-y*w1
   psiz=-z*w1
!
   CALL lpn(itide,psicos,pn,pd)
   DO  ii=2,itide
      t1=-q*rr**(0.5_dp*REAL(ii,KIND=dp))*pn(ii)
      psi=psi+t1
      twx=REAL(ii,KIND=dp)*x*q*rr**(0.5_dp*REAL(ii,KIND=dp)-1.0_dp)*pn(ii)
      twy=REAL(ii,KIND=dp)*y*q*rr**(0.5_dp*REAL(ii,KIND=dp)-1.0_dp)*pn(ii)
      twz=REAL(ii,KIND=dp)*z*q*rr**(0.5_dp*REAL(ii,KIND=dp)-1.0_dp)*pn(ii)
      psix=psix+twx
      psiy=psiy+twy
      psiz=psiz+twz
   END DO
!
   RETURN
!
END SUBROUTINE fastpot
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE fastsplint(xa,ya,y2a,n,x,y,klo,khi)
!
!   November 12, 1999
!
!   This is a spline interpolation routine taken from Numerical Recipes.
!   The indices klo and khi are already determined.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: xa(n)
   REAL(KIND=dp), INTENT(IN)                :: ya(n)
   REAL(KIND=dp), INTENT(IN)                :: y2a(n)
   REAL(KIND=dp), INTENT(IN)                :: x
   REAL(KIND=dp), INTENT(OUT)               :: y
   INTEGER, INTENT(IN OUT)                  :: klo
   INTEGER, INTENT(IN OUT)                  :: khi
!
   REAL(KIND=dp) ::  a,b,h
!
   INTEGER :: k
!
10 IF(khi-klo > 1)THEN
      k=(khi+klo)/2
      IF(xa(k) > x)THEN
         khi=k
      ELSE
         klo=k
      END IF
      GO TO 10
   END IF
   h=xa(khi)-xa(klo)
   IF(ABS(h) <= EPSILON(h))THEN
      WRITE(*,*)klo,khi,n
      WRITE(*,*)'bad xa input in fastsplint'
      STOP
   END IF
   a=(xa(khi)-x)/h
   b=(x-xa(klo))/h
   y=a*ya(klo)+b*ya(khi)+((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.0_dp
   RETURN
!
END SUBROUTINE fastsplint
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE filltable5(nmumax,nmu,icnarray,ilaw,nbody,dwavex,  &
   dwavey,table51a,table51b,table51c,table51d,table51e,table52a,  &
   table52b,table52c,table52d,table52e,table53a,table53b,  &
   table53c,table53d,table53e,table54a,table54b,table54c,  &
   table54d,table54e,table55a,table55b,table55c,table55d,  &
   table55e,table56a,table56b,table56c,table56d,table56e,  &
   table57a,table57b,table57c,table57d,table57e,table58a,  &
   table58b,table58c,table58d,table58e)
!
!  Will fill out the Table5 variables as needed
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmumax
   INTEGER, INTENT(IN)                      :: nmu
   INTEGER, INTENT(IN)                      :: icnarray(8)
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN)                :: dwavey(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: table51a(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table51b(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table51c(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table51d(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table51e(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table52a(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table52b(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table52c(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table52d(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table52e(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table53a(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table53b(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table53c(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table53d(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table53e(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table54a(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table54b(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table54c(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table54d(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table54e(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table55a(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table55b(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table55c(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table55d(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table55e(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table56a(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table56b(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table56c(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table56d(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table56e(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table57a(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table57b(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table57c(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table57d(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table57e(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table58a(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table58b(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table58c(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table58d(nmumax,5)
   REAL(KIND=dp), INTENT(IN OUT)            :: table58e(nmumax,5)
!
   INTEGER :: i
!
   REAL(KIND=dp)  :: mu,inten,ldx,ldy,xsave,ysave
!
   DIMENSION mu(nmumax),inten(nmumax)
!
!  filter 1, star 1
!
   IF((icnarray(1) /= 0).AND.(icnarray(1) /= 430))THEN
      ldx=dwavex(1,1)
      ldy=dwavey(1,1)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51a)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51a)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51a)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51a)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51a)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51a)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51a)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 2, star 1
!
   IF((icnarray(2) /= 0).AND.(icnarray(2) /= 430))THEN
      ldx=dwavex(2,1)
      ldy=dwavey(2,1)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52a)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52a)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52a)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52a)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52a)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52a)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52a)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 3, star 1
!
   IF((icnarray(3) /= 0).AND.(icnarray(3) /= 430))THEN
      ldx=dwavex(3,1)
      ldy=dwavey(3,1)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53a)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53a)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53a)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53a)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53a)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53a)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53a)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 4, star 1
!
   IF((icnarray(4) /= 0).AND.(icnarray(4) /= 430))THEN
      ldx=dwavex(4,1)
      ldy=dwavey(4,1)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54a)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54a)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54a)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54a)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54a)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54a)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54a)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 5, star 1
!
   IF((icnarray(5) /= 0).AND.(icnarray(5) /= 430))THEN
      ldx=dwavex(5,1)
      ldy=dwavey(5,1)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55a)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55a)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55a)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55a)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55a)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55a)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55a)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 6, star 1
!
   IF((icnarray(6) /= 0).AND.(icnarray(6) /= 430))THEN
      ldx=dwavex(6,1)
      ldy=dwavey(6,1)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56a)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56a)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56a)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56a)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56a)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56a)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56a)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 7, star 1
!
   IF((icnarray(7) /= 0).AND.(icnarray(7) /= 430))THEN
      ldx=dwavex(7,1)
      ldy=dwavey(7,1)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57a)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57a)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57a)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57a)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57a)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57a)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57a)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 8, star 1
!
   IF((icnarray(8) /= 0).AND.(icnarray(8) /= 430))THEN
      ldx=dwavex(8,1)
      ldy=dwavey(8,1)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58a)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58a)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58a)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58a)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58a)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58a)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58a)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!   Move on to star 2
!
!
!  filter 1, star 2
!
   IF((icnarray(1) /= 0).AND.(icnarray(1) /= 430))THEN
      ldx=dwavex(1,2)
      ldy=dwavey(1,2)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51b)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51b)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51b)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51b)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51b)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51b)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51b)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 2, star 2
!
   IF((icnarray(2) /= 0).AND.(icnarray(2) /= 430))THEN
      ldx=dwavex(2,2)
      ldy=dwavey(2,2)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52b)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52b)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52b)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52b)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52b)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52b)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52b)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 3, star 2
!
   IF((icnarray(3) /= 0).AND.(icnarray(3) /= 430))THEN
      ldx=dwavex(3,2)
      ldy=dwavey(3,2)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53b)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53b)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53b)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53b)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53b)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53b)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53b)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 4, star 2
!
   IF((icnarray(4) /= 0).AND.(icnarray(4) /= 430))THEN
      ldx=dwavex(4,2)
      ldy=dwavey(4,2)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54b)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54b)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54b)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54b)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54b)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54b)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54b)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 5, star 2
!
   IF((icnarray(5) /= 0).AND.(icnarray(5) /= 430))THEN
      ldx=dwavex(5,2)
      ldy=dwavey(5,2)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55b)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55b)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55b)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55b)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55b)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55b)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55b)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 6, star 2
!
   IF((icnarray(6) /= 0).AND.(icnarray(6) /= 430))THEN
      ldx=dwavex(6,2)
      ldy=dwavey(6,2)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56b)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56b)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56b)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56b)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56b)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56b)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56b)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 7, star 2
!
   IF((icnarray(7) /= 0).AND.(icnarray(7) /= 430))THEN
      ldx=dwavex(7,2)
      ldy=dwavey(7,2)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57b)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57b)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57b)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57b)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57b)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57b)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57b)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 8, star 2
!
   IF((icnarray(8) /= 0).AND.(icnarray(8) /= 430))THEN
      ldx=dwavex(8,2)
      ldy=dwavey(8,2)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58b)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58b)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58b)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58b)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58b)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58b)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58b)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!   If there are only two stars, then return
!
   IF(nbody <= 2)RETURN
!
!  move on to star 3
!
!  filter 1, star 3
!
   IF((icnarray(1) /= 0).AND.(icnarray(1) /= 430))THEN
      ldx=dwavex(1,3)
      ldy=dwavey(1,3)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51c)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51c)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51c)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51c)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51c)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51c)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51c)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 2, star 3
!
   IF((icnarray(2) /= 0).AND.(icnarray(2) /= 430))THEN
      ldx=dwavex(2,3)
      ldy=dwavey(2,3)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52c)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52c)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52c)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52c)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52c)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52c)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52c)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 3, star 3
!
   IF((icnarray(3) /= 0).AND.(icnarray(3) /= 430))THEN
      ldx=dwavex(3,3)
      ldy=dwavey(3,3)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53c)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53c)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53c)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53c)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53c)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53c)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53c)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 4, star 3
!
   IF((icnarray(4) /= 0).AND.(icnarray(4) /= 430))THEN
      ldx=dwavex(4,3)
      ldy=dwavey(4,3)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54c)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54c)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54c)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54c)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54c)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54c)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54c)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 5, star 3
!
   IF((icnarray(5) /= 0).AND.(icnarray(5) /= 430))THEN
      ldx=dwavex(5,3)
      ldy=dwavey(5,3)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55c)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55c)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55c)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55c)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55c)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55c)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55c)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 6, star 3
!
   IF((icnarray(6) /= 0).AND.(icnarray(6) /= 430))THEN
      ldx=dwavex(6,3)
      ldy=dwavey(6,3)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56c)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56c)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56c)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56c)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56c)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56c)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56c)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 7, star 3
!
   IF((icnarray(7) /= 0).AND.(icnarray(7) /= 430))THEN
      ldx=dwavex(7,3)
      ldy=dwavey(7,3)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57c)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57c)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57c)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57c)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57c)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57c)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57c)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 8, star 3
!
   IF((icnarray(8) /= 0).AND.(icnarray(8) /= 430))THEN
      ldx=dwavex(8,3)
      ldy=dwavey(8,3)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58c)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58c)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58c)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58c)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58c)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58c)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58c)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!   If there are only three stars, then return
!
   IF(nbody <= 3)RETURN
!
!  move on to star 4
!
!  filter 1, star 4
!
   IF((icnarray(1) /= 0).AND.(icnarray(1) /= 430))THEN
      ldx=dwavex(1,4)
      ldy=dwavey(1,4)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51d)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51d)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51d)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51d)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51d)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51d)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51d)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 2, star 4
!
   IF((icnarray(2) /= 0).AND.(icnarray(2) /= 430))THEN
      ldx=dwavex(2,4)
      ldy=dwavey(2,4)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52d)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52d)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52d)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52d)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52d)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52d)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52d)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 3, star 4
!
   IF((icnarray(3) /= 0).AND.(icnarray(3) /= 430))THEN
      ldx=dwavex(3,4)
      ldy=dwavey(3,4)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53d)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53d)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53d)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53d)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53d)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53d)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53d)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 4, star 4
!
   IF((icnarray(4) /= 0).AND.(icnarray(4) /= 430))THEN
      ldx=dwavex(4,4)
      ldy=dwavey(4,4)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54d)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54d)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54d)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54d)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54d)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54d)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54d)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 5, star 4
!
   IF((icnarray(5) /= 0).AND.(icnarray(5) /= 430))THEN
      ldx=dwavex(5,4)
      ldy=dwavey(5,4)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55d)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55d)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55d)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55d)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55d)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55d)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55d)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 6, star 4
!
   IF((icnarray(6) /= 0).AND.(icnarray(6) /= 430))THEN
      ldx=dwavex(6,4)
      ldy=dwavey(6,4)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56d)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56d)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56d)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56d)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56d)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56d)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56d)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 7, star 4
!
   IF((icnarray(7) /= 0).AND.(icnarray(7) /= 430))THEN
      ldx=dwavex(7,4)
      ldy=dwavey(7,4)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57d)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57d)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57d)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57d)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57d)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57d)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57d)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 8, star 4
!
   IF((icnarray(8) /= 0).AND.(icnarray(8) /= 430))THEN
      ldx=dwavex(8,4)
      ldy=dwavey(8,4)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58d)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58d)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58d)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58d)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58d)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58d)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58d)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!   If Nbody is less than or equal to 5 return
!
   IF(nbody <= 4)RETURN
!
!  move on to star 5
!
!  filter 1, star 5
!
   IF((icnarray(1) /= 0).AND.(icnarray(1) /= 430))THEN
      ldx=dwavex(1,5)
      ldy=dwavey(1,5)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51e)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51e)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51e)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51e)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51e)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51e)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table51e)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 2, star 5
!
   IF((icnarray(2) /= 0).AND.(icnarray(2) /= 430))THEN
      ldx=dwavex(2,5)
      ldy=dwavey(2,5)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52e)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52e)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52e)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52e)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52e)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52e)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table52e)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 3, star 5
!
   IF((icnarray(3) /= 0).AND.(icnarray(3) /= 430))THEN
      ldx=dwavex(3,5)
      ldy=dwavey(3,5)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53e)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53e)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53e)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53e)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53e)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53e)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table53e)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 4, star 5
!
   IF((icnarray(4) /= 0).AND.(icnarray(4) /= 430))THEN
      ldx=dwavex(4,5)
      ldy=dwavey(4,5)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54e)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54e)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54e)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54e)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54e)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54e)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table54e)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 5, star 5
!
   IF((icnarray(5) /= 0).AND.(icnarray(5) /= 430))THEN
      ldx=dwavex(5,5)
      ldy=dwavey(5,5)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55e)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55e)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55e)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55e)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55e)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55e)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table55e)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 6, star 5
!
   IF((icnarray(6) /= 0).AND.(icnarray(6) /= 430))THEN
      ldx=dwavex(6,5)
      ldy=dwavey(6,5)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56e)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56e)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56e)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56e)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56e)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56e)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table56e)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 7, star 5
!
   IF((icnarray(7) /= 0).AND.(icnarray(7) /= 430))THEN
      ldx=dwavex(7,5)
      ldy=dwavey(7,5)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57e)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57e)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57e)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57e)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57e)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57e)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table57e)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
!  filter 8, star 5
!
   IF((icnarray(8) /= 0).AND.(icnarray(8) /= 430))THEN
      ldx=dwavex(8,5)
      ldy=dwavey(8,5)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58e)
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58e)
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58e)
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58e)
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-mu(i+1))**2
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58e)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         mu(1)=0.0_dp
         inten(1)=1.0_dp-ldx
         DO i=1,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*mu(i+1)*LOG(mu(i+1))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58e)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         DO i=0,nmu-1
            mu(i+1)=REAL(i,KIND=dp)/REAL(nmu-1,KIND=dp)
            inten(i+1)=1.0_dp-ldx*(1.0_dp-mu(i+1))-ldy*(1.0_dp-SQRT(mu(i+1)))
         END DO
         CALL atmtotable5(nmu,nmumax,mu,inten,table58e)
      END IF
!
!   end if icnarray not zero and not 430
!
   END IF
!
   RETURN
!
END SUBROUTINE filltable5
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE filltime(ntime,timearray,tstart,tstop,tstep,lengthtime)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: lengthtime
   INTEGER, INTENT(OUT)                     :: ntime
   REAL(KIND=dp), INTENT(OUT)               :: timearray(lengthtime)
   REAL(KIND=dp), INTENT(IN)                :: tstart
   REAL(KIND=dp), INTENT(IN)                :: tstop
   REAL(KIND=dp), INTENT(IN)                :: tstep
!
   REAL(KIND=dp)  ::  tt
!
   INTEGER ::  i
!
   ntime=0
   DO  i=1,lengthtime
      tt=tstart+REAL(i-1,KIND=dp)*tstep
      IF(tt > tstop)EXIT
      ntime=ntime+1
      timearray(ntime)=tt
   END DO
   timearray(ntime+1)=timearray(ntime)+tstep
   ntime=ntime+1
!
   RETURN
!
END SUBROUTINE filltime
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE findconj(tertargrad,tertecc,pconj3,pconj4,phper2a,  &
   phper2b)
!
!   Will return the conjunction phases of primary and secondary
!   given the eccentricity and argument of periastron.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: tertargrad
   REAL(KIND=dp), INTENT(IN)                       :: tertecc
   REAL(KIND=dp), INTENT(OUT)                      :: pconj3
   REAL(KIND=dp), INTENT(OUT)                      :: pconj4
   REAL(KIND=dp), INTENT(OUT)                      :: phper2a
   REAL(KIND=dp), INTENT(OUT)                      :: phper2b
!
   REAL(KIND=dp) :: trc,htrc,ecan,xmc
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   threehalfpie=1.5_dp*pie
!
   trc=halfpie-tertargrad
   CALL checkangle(trc)
!
   htrc=0.5_dp*trc
   IF(ABS(halfpie-htrc) < 7.0E-06_dp)GO TO 10
   IF(ABS(threehalfpie-htrc) < 7.0E-06_dp)GO TO 10
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-tertecc)/(1.0_dp+tertecc))*TAN(htrc))
   GO TO 20
10 ecan=pie
20 xmc=ecan-tertecc*SIN(ecan)
   phper2a=1.0_dp-xmc/(twopie)
   IF(xmc < 0.0_dp)xmc=xmc+twopie
   pconj3=(xmc+tertargrad)/(twopie)-0.25_dp
!
!   Make sure the conjunction phase is between 0 and 1
!
   IF(pconj3 > 1.0_dp)pconj3=pconj3-1.0_dp
   trc=halfpie-tertargrad+pie
   CALL checkangle(trc)
!
   htrc=0.5_dp*trc
   IF(ABS(halfpie-htrc) < 7.0E-06_dp)GO TO 30
   IF(ABS(threehalfpie-htrc) < 7.0E-06_dp)GO TO 30
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-tertecc)/(1.0_dp+tertecc))*TAN(htrc))
   GO TO 40
30 ecan=pie
40 xmc=ecan-tertecc*SIN(ecan)
   phper2b=1.0_dp-xmc/(twopie)
   IF(xmc < 0.0_dp)xmc=xmc+twopie
   pconj4=(xmc+tertargrad)/(twopie)-0.25_dp
!
!   Make sure the conjunction phase is between 0 and 1
!
   IF(pconj4 > 1.0_dp)pconj4=pconj4-1.0_dp
!
   RETURN
!
END SUBROUTINE findconj
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE findfill(istar,overq,omega,critpsi,x0,usepot,psi0,  &
   fill,bdist,tidephi,itide,ecc,thetamis,phimis,ioutflag)
!
!  May 16, 2000.
!
!  This routine will find the filling factor needed to achieve the
!  surface potential usepot.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: overq
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: critpsi
   REAL(KIND=dp), INTENT(IN)                :: x0
   REAL(KIND=dp), INTENT(IN)                :: usepot
   REAL(KIND=dp), INTENT(OUT)               :: psi0
   REAL(KIND=dp), INTENT(OUT)               :: fill
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   INTEGER, INTENT(IN)                      :: itide
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp)  ::  xsmall,xbig,cox,coy
   REAL(KIND=dp)  ::  crit,y,z
   REAL(KIND=dp)  ::  psismall,psmall,psix,psiy,psiz,psixx,delta
!
   INTEGER :: i
!
   crit=critpsi
   IF(istar == 2)THEN
      crit=critpsi/overq+0.5_dp*(overq-1.0_dp)/overq
   END IF
   IF(usepot <= crit)THEN
      fill=1.0_dp
      IF(ioutflag >= 1)WRITE(2,20)istar,usepot,crit,istar
      psi0=critpsi
      RETURN
   END IF
!
   xsmall=0.5_dp*x0
   xbig=x0
   y=0.0_dp
   z=0.0_dp
!
!   UPDATE November 14, 2009
!
!   Make the modifications needed to have the tidal approximation.
!   Initialize cox=1.0 and coy=0.0
!
   cox=1.0_dp
   coy=0.0_dp
!
   psi0=critpsi
   psismall=critpsi
   DO  i=1,45
      CALL poten(overq,omega,xsmall,y,z,psismall,psix,psixx,psiy,  &
         psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
      psmall=psismall
      IF(istar == 2)THEN
         psmall=psismall/overq+0.5_dp*(overq-1.0_dp)/overq
      END IF
      IF(psmall > usepot)THEN
         xsmall=0.5_dp*(xbig-xsmall)+xsmall
      ELSE
         delta=0.5_dp*(xbig-xsmall)
         xbig=xsmall
         xsmall=xbig-delta
      END IF
   END DO
!
   psi0=psismall
   fill=xsmall/x0
   IF(ioutflag >= 1)WRITE(2,30)istar,fill
!
20 FORMAT(/'Info:  The value of usepot',i1,' = ',f11.5,' is less'  &
      ,' ',/'than the critical potential = ',f11.5,'. Setting fill' ,i1,'=1.0')
30 FORMAT(/'Info:  fill',i1,' has been set to ',f9.7)
   RETURN
!
END SUBROUTINE findfill
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE findl1(q,omega,x0,iflag,bdist,tidephi,ecc,  &
   thetamis,phimis)
!
!   October 6, 1999
!
!   This routine returns the distance to L1 when given Q.  This is more
!   or less stolen from the Avni code.
!
!   February 15, 2000
!
!   The iflag is added because the potential computation needs to be
!   modified in some cases, specifically when star 2 is not synchronous.
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(OUT)               :: x0
   INTEGER, INTENT(IN)                      :: iflag
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
!
   REAL(KIND=dp)  :: x,y,z
   REAL(KIND=dp)  :: cox,coy,dx,psix,psixx,psiy,psiz,psi
!
   INTEGER :: i
!
   x=0.2_dp*bdist
   x=0.99_dp*bdist
   IF(bdist > 1.7_dp)x=0.450_dp*bdist
   y=0.0_dp
   z=0.0_dp
!
!   UPDATE November 14, 2009
!
!   Make the modifications to use the tidal potential option.
!   cox=1.0 and coy=0.0
!
   cox=1.0_dp
   coy=0.0_dp
!
!   UPDATE MARCH 5, 2008
!
!   Make the number of loops 60, to ensure convergence for extreme values
!   of the mass ratio or omega.
!
   DO  i=1,60
      CALL poten(q,omega,x,y,z,psi,psix,psixx,psiy,psiz,iflag,  &
         bdist,cox,coy,tidephi,1,ecc,thetamis,phimis)
      dx=-psix/psixx
      IF(ABS(dx) < 2.0_dp*epsilon(dx))EXIT
!
!      IF(PRECISION(dx).ge.18)THEN
!        IF(ABS(dx) < 1.0E-19_dp)EXIT
!      ELSE
!        IF(ABS(dx) < 1.0E-16_dp)EXIT
!      END IF
!
      x=x+dx
      dx=ABS(dx)
   END DO
!
!   here is the distance to L1
!
   x0=x
!
   RETURN
!
END SUBROUTINE findl1
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE findprimaryeclipse(nbody,odetime,nstep,nprim,  &
   eprim,nsec,esec,ndyn,distprim,distsec,reff1,reff2,separ,  &
   ibody1,ibody2,nmeclipse,durprim1,dursec1,durprim2,dursec2,  &
   thrimpact,inopt,frontpos_x,frontpos_y,frontpos_z,  &
   frontvel_x,frontvel_y,frontvel_z,backpos_x,backpos_y,  &
   backpos_z,backvel_x,backvel_y,backvel_z)
!
!   Will find the times of eclipse between ibody1 and ibody2.
!   also returns times of ingress and egress if ELC is the
!   calling program.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmeclipse
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: odetime(ndyn)
   INTEGER, INTENT(IN)                      :: nstep
   INTEGER, INTENT(OUT)                     :: nprim
   REAL(KIND=dp), INTENT(OUT)               :: eprim(nmeclipse)
   INTEGER, INTENT(OUT)                     :: nsec
   REAL(KIND=dp), INTENT(OUT)               :: esec(nmeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: distprim(nmeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: distsec(nmeclipse)
   REAL(KIND=dp), INTENT(IN)                :: reff1
   REAL(KIND=dp), INTENT(IN)                :: reff2
   REAL(KIND=dp), INTENT(IN)                :: separ
   INTEGER, INTENT(IN)                      :: ibody1
   INTEGER, INTENT(IN)                      :: ibody2
   REAL(KIND=dp), INTENT(OUT)               :: durprim1(nmeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: dursec1(nmeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: durprim2(nmeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: dursec2(nmeclipse)
   REAL(KIND=dp), INTENT(IN)                :: thrimpact
   INTEGER, INTENT(IN)                      :: inopt
   REAL(KIND=dp), INTENT(IN)                :: frontpos_x(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: frontpos_y(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: frontpos_z(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: frontvel_x(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: frontvel_y(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: frontvel_z(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: backpos_x(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: backpos_y(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: backpos_z(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: backvel_x(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: backvel_y(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: backvel_z(ndyn)
!
   REAL(KIND=dp)  :: xx,dd,ttiny,vx1,ffunc,tmid,ddist
   REAL(KIND=dp)  :: timein,xp,yp,xs,ys,vx,vy,deriv,dx1,dy1,vy1
   REAL(KIND=dp)  :: deriv1,diff,timemid,veloutx1,velouty1,dx,dy,sumdist
   REAL(KIND=dp)  :: veloutx2,velouty2,ddd,tmidsave,aaa,bbb
!
   INTEGER :: ij,jlo,i,neclipse1,neclipse2,jj,kback,kbis,jdx
!
   DIMENSION xx(15),dd(15)
!
!   old dimension
!
!          DIMENSION zzq(6,60,Ndyn)
!
!   reset the distance arrays to large numbers
!
   DO ij=1,nmeclipse
      distprim(ij)=9999999.9_dp
      distsec(ij)=9999999.9_dp
      durprim1(ij)=0.0_dp
      durprim2(ij)=0.0_dp
      dursec1(ij)=0.0_dp
      dursec2(ij)=0.0_dp
   END DO
   nprim=0
   nsec=0
!
   jlo=100
   neclipse1=0
   neclipse2=0
   ttiny=1.0E-14_dp
   sumdist=(reff1+reff2)*separ
   IF(sumdist <= 0.0_dp)sumdist=ttiny
   DO i=1,nstep-1
!
      IF(frontpos_z(i) < backpos_z(i))THEN
!
!  body1 in back
!
         timein=odetime(i)
         CALL lttsky(odetime,nstep,timein,xp,yp,ndyn,frontpos_x,  &
            frontpos_y,frontpos_z,frontvel_x,frontvel_y,frontvel_z,jlo)
         CALL lttsky(odetime,nstep,timein,xs,ys,ndyn,backpos_x,  &
            backpos_y,backpos_z,backvel_x,backvel_y,backvel_z,jlo)
!
         dx=xp-xs
         dy=yp-ys
!
         vx=frontvel_x(i)-backvel_x(i)
         vy=frontvel_y(i)-backvel_y(i)
         deriv=dx*vx+dy*vy
         xx(1)=odetime(i)
         dd(1)=deriv
!
         timein=odetime(i+1)
         CALL lttsky(odetime,nstep,timein,xp,yp,ndyn,frontpos_x,  &
            frontpos_y,frontpos_z,frontvel_x,frontvel_y,frontvel_z,jlo)
         CALL lttsky(odetime,nstep,timein,xs,ys,ndyn,backpos_x,  &
            backpos_y,backpos_z,backvel_x,backvel_y,backvel_z,jlo)
         dx1=xp-xs
         dy1=yp-ys
         vx1=frontvel_x(i+1)-backvel_x(i+1)
         vy1=frontvel_y(i+1)-backvel_y(i+1)
         deriv1=dx1*vx1+dy1*vy1
         xx(2)=odetime(i+1)
         dd(2)=deriv1
!
         IF((deriv < 0.0_dp).AND.(deriv1 >= 0.0_dp))THEN
!
!   sign change
!
            DO jj=3,4!15
               diff=dd(jj-1)-dd(jj-2)
               IF(ABS(diff) <= EPSILON(diff))THEN
                  xx(jj)=xx(jj-1)
               ELSE
                  xx(jj)=xx(jj-1)-dd(jj-1)*((xx(jj-1)-xx(jj-2))/(diff))
               END IF
               IF(ABS(xx(jj)-xx(jj-1)) < ttiny)GO TO 10
               timemid=xx(jj)
               CALL lttsky(odetime,nstep,timemid,xp,yp,ndyn,  &
                  frontpos_x,frontpos_y,frontpos_z,frontvel_x,  &
                  frontvel_y,frontvel_z,jlo)
               CALL lttsky(odetime,nstep,timemid,xs,ys,ndyn,  &
                  backpos_x,backpos_y,backpos_z,backvel_x,backvel_y, &
                   backvel_z,jlo)
               CALL hunt(odetime,nstep,timemid,jlo)
               CALL hermskyvel(ndyn,nstep,odetime,timemid,veloutx1,jlo,frontvel_x)
               CALL hermskyvel(ndyn,nstep,odetime,timemid,velouty1,jlo,frontvel_y)
               CALL hermskyvel(ndyn,nstep,odetime,timemid,veloutx2,jlo,backvel_x)
               CALL hermskyvel(ndyn,nstep,odetime,timemid,velouty2,jlo,backvel_y)
               dx=xp-xs
               dy=yp-ys
               vx=veloutx1-veloutx2
               vy=velouty1-velouty2
               deriv1=dx*vx+dy*vy
               dd(jj)=deriv1
            END DO
10          ddd=SQRT(dx*dx+dy*dy)/sumdist
            IF(yp < ys)ddd=-ddd
            IF((ABS(thrimpact) <= EPSILON(thrimpact)).OR.(ABS(ddd)  &
                  <= thrimpact))THEN
               neclipse1=neclipse1+1
               IF(neclipse1 > nmeclipse)THEN
                  WRITE(*,*)'Nmaxeclipse is too small for eclipse 1',  &
                     neclipse1,timemid,ddd,nbody,ibody1,ibody2,nstep
                  neclipse1=nmeclipse
               END IF
               eprim(neclipse1)=timemid
               distprim(neclipse1)=ddd
               nprim=neclipse1
!
!   find ingress and egress points only if ELC
!   is the calling program
!
               IF(inopt == 0)THEN
                  tmidsave=timemid
                  aaa=timemid
                  bbb=timemid-10.0_dp
                  DO kback=-1,-150,-1
                     IF(i+kback <= 0)GO TO 30
                     timein=odetime(i+kback)
                     CALL lttsky(odetime,nstep,timein,xp,yp,ndyn,  &
                        frontpos_x,frontpos_y,frontpos_z,frontvel_x,  &
                        frontvel_y,frontvel_z,jlo)
                     CALL lttsky(odetime,nstep,timein,xs,ys,ndyn,  &
                        backpos_x,backpos_y,backpos_z,backvel_x,  &
                        backvel_y,backvel_z,jlo)
                     ddist=SQRT((xp-xs)**2+(yp-ys)**2)
                     ffunc=ddist-sumdist
                     IF(ffunc < 0.0_dp)THEN
                        aaa=timein
                     ELSE
                        bbb=timein
                        GO TO 30
                     END IF
                  END DO
!
30                DO kbis=1,30 
                     tmid=0.5_dp*(bbb+aaa)
                     CALL lttsky(odetime,nstep,tmid,xp,yp,ndyn,  &
                        frontpos_x,frontpos_y,frontpos_z,frontvel_x,  &
                        frontvel_y,frontvel_z,jlo)
                     CALL lttsky(odetime,nstep,tmid,xs,ys,ndyn,  &
                        backpos_x,backpos_y,backpos_z,backvel_x, &
                        backvel_y,backvel_z,jlo)
                     ddist=SQRT((xp-xs)**2+(yp-ys)**2)
                     ffunc=ddist-sumdist
                     IF(ffunc < 0.0_dp)THEN
                        aaa=tmid
                     ELSE
                        bbb=tmid
                     END IF
                  END DO
!
                  durprim1(neclipse1)=tmid
!
                  aaa=tmidsave
                  bbb=tmidsave+10.0_dp
                  DO kback=1,150
                     IF(i+kback > ndyn)GO TO 40
                     timein=odetime(i+kback)
                     CALL lttsky(odetime,nstep,timein,xp,yp,ndyn,  &
                        frontpos_x,frontpos_y,frontpos_z,frontvel_x,  &
                        frontvel_y,frontvel_z,jlo)
                     CALL lttsky(odetime,nstep,timein,xs,ys,ndyn,  &
                        backpos_x,backpos_y,backpos_z,backvel_x, &
                        backvel_y,backvel_z,jlo)
                     ddist=SQRT((xp-xs)**2+(yp-ys)**2)
                     ffunc=ddist-sumdist
                     IF(ffunc < 0.0_dp)THEN
                        aaa=timein
                     ELSE
                        bbb=timein
                        GO TO 40
                     END IF
                  END DO
!
40                DO kbis=1,30
                     tmid=0.5_dp*(bbb+aaa)
                     CALL lttsky(odetime,nstep,tmid,xp,yp,ndyn,  &
                        frontpos_x,frontpos_y,frontpos_z,frontvel_x,  &
                        frontvel_y,frontvel_z,jlo)
                     CALL lttsky(odetime,nstep,tmid,xs,ys,ndyn,  &
                        backpos_x,backpos_y,backpos_z,backvel_x, &
                        backvel_y,backvel_z,jlo)
                     ddist=SQRT((xp-xs)**2+(yp-ys)**2)
                     ffunc=ddist-sumdist
                     IF(ffunc < 0.0_dp)THEN
                        aaa=tmid
                     ELSE
                        bbb=tmid
                     END IF
                  END DO
!
                  durprim2(neclipse1)=tmid
!
               END IF
            END IF
         END IF
      END IF
!
      IF(backpos_z(i) < frontpos_z(i))THEN
!
!   body2 in back
!
         timein=odetime(i)
         CALL lttsky(odetime,nstep,timein,xp,yp,ndyn,frontpos_x,  &
            frontpos_y,frontpos_z,frontvel_x,frontvel_y,frontvel_z, jlo)
         CALL lttsky(odetime,nstep,timein,xs,ys,ndyn,backpos_x,  &
            backpos_y,backpos_z,backvel_x,backvel_y,backvel_z,jlo)
         dx=xp-xs
         dy=yp-ys
         vx=frontvel_x(i)-backvel_x(i)
         vy=frontvel_y(i)-backvel_y(i)
         deriv=dx*vx+dy*vy
         xx(1)=odetime(i)
         dd(1)=deriv
!
         timein=odetime(i+1)
         CALL lttsky(odetime,nstep,timein,xp,yp,ndyn,frontpos_x,  &
            frontpos_y,frontpos_z,frontvel_x,frontvel_y,frontvel_z, jlo)
         CALL lttsky(odetime,nstep,timein,xs,ys,ndyn,backpos_x,  &
            backpos_y,backpos_z,backvel_x,backvel_y,backvel_z,jlo)
         dx1=xp-xs
         dy1=yp-ys
         vx1=frontvel_x(i+1)-backvel_x(i+1)
         vy1=frontvel_y(i+1)-backvel_y(i+1)
         deriv1=dx1*vx1+dy1*vy1
         xx(2)=odetime(i+1)
         dd(2)=deriv1
!
         IF((deriv < 0.0_dp).AND.(deriv1 >= 0.0_dp))THEN
!
!    sign change
!
            DO jj=3,4       
               diff=dd(jj-1)-dd(jj-2)
               IF(ABS(diff) <= EPSILON(diff))THEN
                  xx(jj)=xx(jj-1)
               ELSE
                  xx(jj)=xx(jj-1)-dd(jj-1)*((xx(jj-1)-xx(jj-2))/(diff) )
               END IF
               IF(ABS(xx(jj)-xx(jj-1)) < ttiny)GO TO 20
               timemid=xx(jj)
               CALL lttsky(odetime,nstep,timemid,xp,yp,ndyn,  &
                  frontpos_x,frontpos_y,frontpos_z,frontvel_x,  &
                  frontvel_y,frontvel_z,jlo)
               CALL lttsky(odetime,nstep,timemid,xs,ys,ndyn,  &
                  backpos_x,backpos_y,backpos_z,backvel_x,backvel_y,backvel_z,jlo)
               CALL hunt(odetime,nstep,timemid,jlo)
               CALL hermskyvel(ndyn,nstep,odetime,timemid,veloutx1,jlo,frontvel_x)
               CALL hermskyvel(ndyn,nstep,odetime,timemid,velouty1,jlo,frontvel_y)
               CALL hermskyvel(ndyn,nstep,odetime,timemid,veloutx2,jlo,backvel_x)
               CALL hermskyvel(ndyn,nstep,odetime,timemid,velouty2,jlo,backvel_y)
!
               dx=xp-xs
               dy=yp-ys
               vx=veloutx1-veloutx2
               vy=velouty1-velouty2
               deriv1=dx*vx+dy*vy
               dd(jj)=deriv1
            END DO
20          ddd=SQRT(dx*dx+dy*dy)/sumdist
            IF(yp < ys)ddd=-ddd
            IF((thrimpact <= 0.0_dp).OR.(ABS(ddd) <= thrimpact))THEN
               neclipse2=neclipse2+1
               IF(neclipse2 > nmeclipse)THEN
                  WRITE(*,*)'Nmaxeclipse is too small for eclipse 2',  &
                     neclipse2,timemid,ddd,nbody,ibody1,ibody2,nstep
                  eprim(neclipse1)=timemid
                  distprim(neclipse1)=ddd
                  nprim=neclipse1
                  neclipse2=nmeclipse
               END IF
               esec(neclipse2)=timemid
               distsec(neclipse2)=SQRT(dx*dx+dy*dy)/sumdist
               nsec=neclipse2
!
!   find ingress and egress points only if ELC was the
!   calling program
!
               IF(inopt == 0)THEN
                  tmidsave=timemid
                  aaa=timemid
                  bbb=timemid-10.0_dp
                  DO kback=-1,-150,-1
                     jdx=i+kback
                     IF(jdx < 1)jdx=1
                     timein=odetime(jdx)
                     CALL lttsky(odetime,nstep,timein,xp,yp,ndyn,  &
                        frontpos_x,frontpos_y,frontpos_z,frontvel_x,  &
                        frontvel_y,frontvel_z,jlo)
                     CALL lttsky(odetime,nstep,timein,xs,ys,ndyn,  &
                        backpos_x,backpos_y,backpos_z,backvel_x,  &
                        backvel_y,backvel_z,jlo)
                     ddist=SQRT((xp-xs)**2+(yp-ys)**2)
                     ffunc=ddist-sumdist
                     IF(ffunc < 0.0_dp)THEN
                        aaa=timein
                     ELSE
                        bbb=timein
                        GO TO 50
                     END IF
                  END DO
!
50                DO kbis=1,30    !20
                     tmid=0.5_dp*(bbb+aaa)
                     CALL lttsky(odetime,nstep,tmid,xp,yp,ndyn,  &
                        frontpos_x,frontpos_y,frontpos_z,frontvel_x,  &
                        frontvel_y,frontvel_z,jlo)
                     CALL lttsky(odetime,nstep,tmid,xs,ys,ndyn,  &
                        backpos_x,backpos_y,backpos_z,backvel_x, &
                        backvel_y,backvel_z,jlo)
                     ddist=SQRT((xp-xs)**2+(yp-ys)**2)
                     ffunc=ddist-sumdist
                     IF(ffunc < 0.0_dp)THEN
                        aaa=tmid
                     ELSE
                        bbb=tmid
                     END IF
                  END DO
!
                  dursec1(neclipse2)=tmid
!
                  aaa=tmidsave
                  bbb=tmidsave+10.0_dp
                  DO kback=1,150
                     IF(jdx > ndyn)jdx=ndyn
                     timein=odetime(i+kback)
                     CALL lttsky(odetime,nstep,timein,xp,yp,ndyn,  &
                        frontpos_x,frontpos_y,frontpos_z,frontvel_x,  &
                        frontvel_y,frontvel_z,jlo)
                     CALL lttsky(odetime,nstep,timein,xs,ys,ndyn,  &
                        backpos_x,backpos_y,backpos_z,backvel_x, &
                        backvel_y,backvel_z,jlo)
                     ddist=SQRT((xp-xs)**2+(yp-ys)**2)
                     ffunc=ddist-sumdist
                     IF(ffunc < 0.0_dp)THEN
                        aaa=timein
                     ELSE
                        bbb=timein
                        GO TO 60
                     END IF
                  END DO
!
60                DO kbis=1,30        !20
                     tmid=0.5_dp*(bbb+aaa)
                     CALL lttsky(odetime,nstep,tmid,xp,yp,ndyn,  &
                        frontpos_x,frontpos_y,frontpos_z,frontvel_x,  &
                        frontvel_y,frontvel_z,jlo)
                     CALL lttsky(odetime,nstep,tmid,xs,ys,ndyn,  &
                        backpos_x,backpos_y,backpos_z,backvel_x, &
                        backvel_y,backvel_z,jlo)
                     ddist=SQRT((xp-xs)**2+(yp-ys)**2)
                     ffunc=ddist-sumdist
                     IF(ffunc < 0.0_dp)THEN
                        aaa=tmid
                     ELSE
                        bbb=tmid
                     END IF
                  END DO
!
                  dursec2(neclipse2)=tmid
!
               END IF
            END IF
         END IF
      END IF
   END DO
!
   RETURN
!
END SUBROUTINE findprimaryeclipse
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE findradius(overq,omega,psi0,x0,bdist,reff,tidephi,  &
   itide,ecc,thetamis,phimis)
!
!   This will find the effective radius.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                   :: overq
   REAL(KIND=dp), INTENT(IN)                   :: omega
   REAL(KIND=dp), INTENT(IN OUT)               :: psi0
   REAL(KIND=dp), INTENT(IN)                   :: x0
   REAL(KIND=dp), INTENT(IN)                   :: bdist
   REAL(KIND=dp), INTENT(OUT)                  :: reff
   REAL(KIND=dp), INTENT(IN)                   :: tidephi
   INTEGER, INTENT(IN)                         :: itide
   REAL(KIND=dp), INTENT(IN)                   :: ecc
   REAL(KIND=dp), INTENT(IN)                   :: thetamis
   REAL(KIND=dp), INTENT(IN)                   :: phimis
!
   REAL(KIND=dp)  :: vol,r,x,y,z,theta,snth,snth3,cnth,phi,cox,coy,coz
   REAL(KIND=dp)  :: tempcox,tempcoy,tempcoz,dtheta,dphi
!
   INTEGER :: na,nb,ibet,ialf
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   na=120
   nb=40
   dtheta=pie/REAL(na,KIND=dp)
   vol=0.0_dp
!
   IF(itide < 2)THEN
      DO  ialf=1,na/2
!
!   UPDATE MARCH 17, 2004
!
!   make the initial value of r smaller here.
!
         r=1.0E-15_dp
         x=x0
         y=0.0_dp
         z=0.0_dp
         tempcox=0.0_dp
         tempcoy=0.0_dp
         tempcoz=1.0_dp
         CALL rad(overq,omega,tempcox,tempcoy,tempcoz,psi0,r,x,y,z,1,  &
            bdist,tidephi,itide,ecc,thetamis,phimis)
         theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
         dphi=twopie/REAL(4*nb,KIND=dp)
         snth=SIN(theta)
         snth3=snth*(1.0_dp/3.0_dp)
         cnth=COS(theta)
         DO  ibet=1,nb*2
            phi=-0.5_dp*dphi+dphi*REAL(ibet,KIND=dp)
            cox=COS(phi)*snth
            coy=SIN(phi)*snth
            coz=cnth
            CALL rad(overq,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,  &
               tidephi,itide,ecc,thetamis,phimis)
            vol=vol+4.0_dp*r*r*r*dphi*dtheta*snth3
!
!   ibet loop
!
         END DO
!
!   ialf loop
!
      END DO
!
!   end if itide < 2
!
   END IF
!
   IF(itide >= 2)THEN
      DO  ialf=1,na
!
!   UPDATE MARCH 17, 2004
!
!   make the initial value of r smaller here.
!
         r=1.0E-15_dp
         x=x0
         y=0.0_dp
         z=0.0_dp
         tempcox=0.0_dp
         tempcoy=0.0_dp
         tempcoz=1.0_dp
         CALL rad(overq,omega,tempcox,tempcoy,tempcoz,psi0,r,x,y,z,1,  &
            bdist,tidephi,itide,ecc,thetamis,phimis)
         theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
         dphi=twopie/REAL(4*nb,KIND=dp)
         snth=SIN(theta)
         snth3=snth*(1.0_dp/3.0_dp)
         cnth=COS(theta)
         DO  ibet=1,nb*4
            phi=-0.5_dp*dphi+dphi*REAL(ibet,KIND=dp)
            cox=COS(phi)*snth
            coy=SIN(phi)*snth
            coz=cnth
            CALL rad(overq,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,  &
               tidephi,itide,ecc,thetamis,phimis)
            vol=vol+1.0_dp*r*r*r*dphi*dtheta*snth3
!
!   ibet loop
!
         END DO
!
!   ialf loop
!
      END DO
!
!   end if itide >= 2
!
   END IF
!
   reff=(0.75_dp*vol/pie)**(1.0_dp/3.0_dp)
!
   RETURN
!
END SUBROUTINE findradius
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE finishlc(nmaxphase,icount,dphase,nphase,xxx,yyy,  &
   iwrite,ioutflag)
!
!   December 3, 1999
!
!   This routine will use the symmetry of the light curve and fill out
!   the phases 180 to 360-dphase.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN)                      :: icount
   REAL(KIND=dp), INTENT(IN)                :: dphase
   INTEGER, INTENT(OUT)                     :: nphase
   REAL(KIND=dp), INTENT(IN OUT)            :: xxx(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: yyy(nmaxphase)
   INTEGER, INTENT(IN)                      :: iwrite
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp)  :: phase
!
   INTEGER :: nloop,iloop,i
!
   nloop=0
   iloop=0
   i=icount-1
   nphase=icount
   nloop=INT(((360.0_dp-dphase)-(180.0_dp+dphase))/dphase)
   phase=180.0_dp
!
   DO  iloop=1,nloop+1
      phase=phase+dphase
      IF(ioutflag == 1)THEN
         IF(iwrite == 1)WRITE(64,20)phase
      END IF
      nphase=nphase+1
      xxx(nphase)=phase/360.0_dp
      yyy(nphase)=yyy(i)
      i=i-1
   END DO
!
20 FORMAT(f6.2)
   RETURN
!
END SUBROUTINE finishlc
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE finishrv(istar,nmaxphase,icount,dphase,nphase,xxx,  &
   yyy,gamma,drv)
!
!   December 3, 1999
!
!   This routine will use the symmetry of the velocity curve and fill out
!   the phases 180 to 360-dphase.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN)                      :: icount
   REAL(KIND=dp), INTENT(IN)                :: dphase
   INTEGER, INTENT(OUT)                     :: nphase
   REAL(KIND=dp), INTENT(IN OUT)            :: xxx(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: yyy(nmaxphase)
   REAL(KIND=dp), INTENT(IN)                :: gamma
   REAL(KIND=dp), INTENT(IN OUT)            :: drv(nmaxphase)
!
   REAL(KIND=dp)  ::  phase
!
   INTEGER :: i,nloop,iloop
!
   i=icount-1
   nphase=icount
   nloop=0
   iloop=0
   i=icount-1
   nphase=icount
   nloop=INT(((360.0_dp-dphase)-(180.0_dp+dphase))/dphase)
   phase=180.0_dp
!
   DO  iloop=1,nloop+1
      phase=phase+dphase
      nphase=nphase+1
      xxx(nphase)=phase/360.0_dp
      IF(istar == 1)THEN
         drv(nphase)=-drv(i)
      ELSE
         drv(nphase)=-drv(i)
      END IF
      yyy(nphase)=-(yyy(i)-gamma)+gamma
!
      i=i-1
   END DO
!
   RETURN
!
END SUBROUTINE finishrv
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE fixedanalyticg(isw12,ilaw,dwavex,dwavey,delta,  &
   rfront,rback,refflux1,gimvel,omega,period,bigi,bigbeta,delx,  &
   dely,corr1,mandel,iusedark)
!
!   April 24, 2006
!
!   Will compute analytic transits according to Gimenez.  The number isw12 is
!   the number of terms in the summation.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: isw12
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(IN)                :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN)                :: dwavey(8,10)
   REAL(KIND=dp), INTENT(IN)                :: delta
   REAL(KIND=dp), INTENT(IN)                :: rfront
   REAL(KIND=dp), INTENT(IN)                :: rback
   REAL(KIND=dp), INTENT(IN)                :: refflux1(8)
   REAL(KIND=dp), INTENT(OUT)               :: gimvel(8)
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: bigi
   REAL(KIND=dp), INTENT(IN)                :: bigbeta
   REAL(KIND=dp), INTENT(IN)                :: delx
   REAL(KIND=dp), INTENT(IN)                :: dely
   REAL(KIND=dp), INTENT(OUT)               :: corr1(8)
   INTEGER, INTENT(IN)                      :: mandel
   INTEGER, INTENT(IN)                      :: iusedark
!
   REAL(KIND=dp)  :: alpha,alfone,si,cb,vrot,sb,c
   REAL(KIND=dp)  :: vstar,rplanet,rstar,bee,cee,rnu,cue,pee,alf,beta,xx
   REAL(KIND=dp)  :: beta1,t1,gamma_log,v1,summ,summv,dj,t3,t2,v3,v4,v5
   REAL(KIND=dp)  :: atot,vtot,delvel,rnp,rnp1,djp1,djpbeta,djpbeta1
   REAL(KIND=dp)  :: b1p1,flimbx,flimby,savefx,savefy,you2,agol1,agol2
   REAL(KIND=dp)  :: bp1,you1,rnp2,v6,ppee
!
   REAL(KIND=dp),ALLOCATABLE :: cx1(:),cx2(:),cv1(:),cv2(:)
!
   INTEGER :: i,n,j
!
   INTEGER, PARAMETER :: isize=3201
!
!   DIMENSION cx1(isize),cx2(isize),cv1(isize),cv2(isize)
!
   DIMENSION c(10),alpha(10),alfone(10)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   IF((ilaw == 2).OR.(ilaw == 3).OR.(ilaw == 6).OR.(ilaw == 7))THEN
      WRITE(*,*)'Error:  Limb darkening law not supported with', ' mandel=0'
      STOP
   END IF
!
   IF((ilaw == 12).OR.(ilaw == 13).OR.(ilaw == 16).OR.(ilaw == 17))THEN
      WRITE(*,*)'Error:  Limb darkening law not supported with', ' mandel=0'
      STOP
   END IF
!
   IF(isw12 > isize)THEN
      WRITE(*,*) 'Error:  The maximum size of Nterms is ',isize
      STOP
   END IF
!
!   add rotational velocity corrections
!
   si=SIN(bigi*degtorad)
   sb=SIN(bigbeta*degtorad)
   cb=COS(bigbeta*degtorad)
   vrot=twopie*omega/period
   vstar=vrot*si*(cb*delx+sb*dely)
!
!   Do the case for linear first (ilaw=1)
!
   alpha(1)=0.0_dp
   alpha(2)=0.0_dp
   alpha(3)=0.0_dp
   rstar=rback
   rplanet=rfront
   bee=rplanet/(rstar+rplanet)
   cee=delta/(rplanet+rstar)
!
   IF(delta > (rstar+rplanet))THEN
      DO  i=1,8
         corr1(i)=0.0_dp
         gimvel(i)=0.0_dp
      END DO
      RETURN
   END IF
!
   IF((rfront > rback).AND.(delta < (rfront-rback)))THEN
      DO  i=1,8
         corr1(i)=-refflux1(i)
         gimvel(i)=0.0_dp
      END DO
      RETURN
   END IF
!
!  UPDATE September 4, 2012
!
!  If ilaw=11, this is linear with the coefficients for star 2
!  forced to be equal for those of star 1
!
   ALLOCATE(cx1(isize),cx2(isize),cv1(isize),cv2(isize))
!
   IF((ilaw == 1).OR.(ilaw == 11))THEN
!
      DO  n=0,1
         rnu=REAL(n+2,KIND=dp)*0.5_dp
         pee=rnu+2.0_dp
         cue=rnu+1.0_dp
         alf=pee-cue
         beta=cue-1.0_dp
         xx=1.0_dp-(2.0_dp*(1.0_dp-bee))
!
         CALL jacobi_poly(isw12,beta,alf,xx,cx1)
         cue=1.0_dp
         alf=pee-cue
         beta=cue-1.0_dp
         xx=1.0_dp-2.0_dp*cee*cee
!
         CALL jacobi_poly(isw12,beta,alf,xx,cx2)
!
         pee=rnu+3.0_dp
         cue=2.0_dp
         alf=pee-cue
         beta1=cue-1.0_dp
         xx=1.0_dp-(2.0_dp*(cee*cee))
         CALL jacobi_poly(isw12,beta1,alf,xx,cv2)
!
         pee=rnu+3.0_dp
         cue=rnu+2.0_dp
         alf=pee-cue
         beta=cue-1.0_dp
         xx=1.0_dp-(2.0_dp*(1.0_dp-bee))
         CALL jacobi_poly(isw12,beta,alf,xx,cv1)
!
         t1=bee*bee*((1.0_dp-cee*cee)**(rnu+1.0_dp))/(rnu*  &
            EXP(gamma_log(rnu+1.0_dp)))
!
         v1=EXP(gamma_log(rnu)-2.0_dp*gamma_log(rnu+2.0_dp))
         v1=v1*cee*bee*bee*(1.0_dp-bee)*(1.0_dp-cee*cee)**(rnu+1.0_dp)
!
         summ=0.0_dp
         summv=0.0_dp
         DO  j=0,isw12
            dj=REAL(j,KIND=dp)
            t3=(gamma_log(dj+1.0_dp)+gamma_log(rnu+1.0_dp)- &
               gamma_log(dj+rnu+1.0_dp))
            t3=EXP(t3)
!
            t2=EXP(gamma_log(rnu+REAL(j+1,KIND=dp))-gamma_log(REAL(j+2,KIND=dp)))
            summ=summ+(-1.0_dp)**REAL(j,KIND=dp)*(2.0_dp*REAL(j,KIND=dp)+rnu+2.0_dp)*t2*  &
               cx1(j+1)**2*cx2(j+1)*t3*t3
!
            v3=EXP(gamma_log(rnu+dj+3.0_dp)-gamma_log(dj+1.0_dp))
            v4=EXP(gamma_log(dj+1.0_dp)+gamma_log(beta+1.0_dp)-  &
               gamma_log(dj+1.0_dp+beta))
            v5=EXP(gamma_log(dj+1.0_dp)+gamma_log(beta1+1.0_dp)-  &
               gamma_log(dj+1.0_dp+beta1))
!
            v4=v4*v4*v5
!
            summv=summv+v3*v4*cv1(j+1)*cv1(j+1)*cv2(j+1)*(-1.0_dp)**  &
               j*(2.0_dp*dj+rnu+3.0_dp)
!
         END DO
         alpha(n+1)=t1*summ
         alfone(n+1)=v1*summv
      END DO
!
      DO  i=1,8
         you1=dwavex(i,iusedark)
         c(1)=(1.0_dp-you1)/(1.0_dp-you1/3.0_dp)
         c(2)=you1/(1.0_dp-you1/3.0_dp)
         atot=alpha(1)*c(1)+alpha(2)*c(2)
         corr1(i)=-refflux1(i)*(atot)
!
         IF(mandel == 0)THEN
            vtot=alfone(1)*c(1)+alfone(2)*c(2)
         ELSE
            vtot=0.0_dp
         END IF
         IF(ABS(delta) > EPSILON(delta))THEN
            IF(ABS(atot-1.0_dp) > EPSILON(atot))THEN
               delvel=vstar/delta*(vtot/(1.0_dp-atot))
            ELSE
               delvel=0.0_dp
            END IF
         ELSE
            delvel=0.0_dp
         END IF
         IF(ABS(atot) > EPSILON(atot))THEN
            gimvel(i)=delvel
         ELSE
            gimvel(i)=0.0_dp
         END IF
      END DO
!
!   end if ilaw = 1
!
   END IF
!
!  UPDATE September 4, 2012
!
!  If ilaw=14, quad law with coefficients of star 2 forced to be
!  equal to the coefficients of star 1.
!
   IF((ilaw == 4).OR.(ilaw == 14).OR.(ilaw == 5).OR.(ilaw == 15)) THEN
!
!   quad law
!
      IF(mandel == 0)THEN
         DO  n=0,2
            rnu=REAL(n+2,KIND=dp)*0.5_dp
            rnp=gamma_log(rnu)
            rnp1=gamma_log(rnu+1.0_dp)
            rnp2=gamma_log(rnu+2.0_dp)
            pee=rnu+2.0_dp
            cue=rnu+1.0_dp
            alf=pee-cue
            beta=cue-1.0_dp
            xx=1.0_dp-(2.0_dp*(1.0_dp-bee))
            CALL jacobi_poly(isw12,beta,alf,xx,cx1)
            cue=1.0_dp
            alf=pee-cue
            beta=cue-1.0_dp
            xx=1.0_dp-2.0_dp*cee*cee
            CALL jacobi_poly(isw12,beta,alf,xx,cx2)
            t1=bee*bee*((1.0_dp-cee*cee)**(rnu+1.0_dp))/(rnu*EXP(rnp1))
            pee=rnu+3.0_dp
            cue=2.0_dp
            alf=pee-cue
            beta1=cue-1.0_dp
            xx=1.0_dp-(2.0_dp*(cee*cee))
            CALL jacobi_poly(isw12,beta1,alf,xx,cv2)
!
            pee=rnu+3.0_dp
            cue=rnu+2.0_dp
            alf=pee-cue
            beta=cue-1.0_dp
            xx=1.0_dp-(2.0_dp*(1.0_dp-bee))
            CALL jacobi_poly(isw12,beta,alf,xx,cv1)
            v1=EXP(rnp-2.0_dp*rnp2)
            v1=v1*cee*bee**2*(1.0_dp-bee)*(1.0_dp-cee*cee)**(rnu+1.0_dp)
!
            summ=0.0_dp
            summv=0.0_dp
            summ=0.0_dp
            DO  j=0,isw12
               dj=REAL(j,KIND=dp)
               djp1=gamma_log(dj+1.0_dp)
               djpbeta=gamma_log(dj+1.0_dp+beta)
               djpbeta1=gamma_log(dj+1.0_dp+beta1)
               bp1=gamma_log(beta+1.0_dp)
               b1p1=gamma_log(beta1+1.0_dp)
               t3=(djp1+rnp1-gamma_log(dj+rnu+1.0_dp))
               t3=EXP(t3)
               t2=EXP(gamma_log(rnu+REAL(j+1,KIND=dp))-gamma_log(REAL(j+2,KIND=dp)))
               summ=summ+(-1)**REAL(j,KIND=dp)*(2.0_dp*REAL(j,KIND=dp)+rnu+2.0_dp)*t2*  &
                  cx1(j+1)**2*cx2(j+1)*t3*t3
               v3=(dj+rnu+2.0_dp)/(dj+1.0_dp)*(-1.0_dp)**REAL(j,KIND=dp)*(2.0_dp*dj+rnu+3.0_dp)
               v4=gamma_log(rnu+dj+2.0_dp)
               v5=v3*EXP(djp1+rnp2+rnp2-v4)
               v6=cv1(j+1)*cv1(j+1)*cv2(j+1)
               summv=summv+v6*v5
!
            END DO
            alpha(n+1)=t1*summ
            alfone(n+1)=v1*summv
         END DO
      END IF
!
      DO  i=1,8
         flimbx=dwavex(i,iusedark)
         flimby=dwavey(i,iusedark)
!
!   December 15, 2013:  add triangular sampling
!
         IF((ilaw == 5).OR.(ilaw == 15))THEN
            savefx=flimbx
            savefy=flimby
            flimbx=2.0_dp*SQRT(savefx)*savefy
            flimby=SQRT(savefx)*(1.0_dp-2.0_dp*savefy)
         END IF
!
         you1=flimbx+2.0_dp*flimby
         you2=-1.0_dp*flimby
         IF(mandel > 0)THEN
            you1=dwavex(i,iusedark)
            you2=dwavey(i,iusedark)
            IF((ilaw == 5).OR.(ilaw == 15))THEN
               savefx=you1
               savefy=you2
               you1=2.0_dp*SQRT(savefx)*savefy
               you2=SQRT(savefx)*(1.0_dp-2.0_dp*savefy)
            END IF
            ppee=rfront/rback
            CALL occultquad(delta/rback,you1,you2,ppee,agol1,agol2,1)
            atot=1.0_dp-agol1
            IF(atot < 0.0_dp)atot=0.0_dp
         ELSE
            c(1)=(1.0_dp-you1-you2)/(1.0_dp-you1/3.0_dp-you2/2.0_dp)
            c(2)=you1/(1.0_dp-you1/3.0_dp-you2/2.0_dp)
            c(3)=you2/(1.0_dp-you1/3.0_dp-you2/2.0_dp)
            atot=alpha(1)*c(1)+alpha(2)*c(2)+alpha(3)*c(3)
            IF(atot < 0.0_dp)atot=0.0_dp
            IF(atot >= 1.0_dp)atot=1.0_dp
         END IF
!
         corr1(i)=-refflux1(i)*(atot)
!
         IF(mandel == 0)THEN
            vtot=alfone(1)*c(1)+alfone(2)*c(2)+alfone(3)*c(3)
         ELSE
            vtot=0.0_dp
         END IF
         IF(ABS(delta) > EPSILON(delta))THEN
            IF(ABS(atot-1.0_dp) > EPSILON(atot))THEN
               delvel=vstar/delta*(vtot/(1.0_dp-atot))
            ELSE
               delvel=0.0_dp
            END IF
         ELSE
            delvel=0.0_dp
         END IF
         gimvel(i)=delvel
         IF(ABS(atot) <= EPSILON(atot))THEN
            gimvel(i)=0.0_dp
         END IF
      END DO
!
!   end if ilaw = 4
!
   END IF
!
   DEALLOCATE(cx1,cx2,cv1,cv2)
!
   RETURN
!
END SUBROUTINE fixedanalyticg
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION gamma_log(x)
!
!  April 24, 2006
!
!  Routine to compute the natural log of the gamma function.  Received
!  by way of A. Gimenez.
!
!******************************************************************
!
!  GAMMA_LOG calculates the natural logarithm of GAMMA ( X ) for
!  positive X.
!
!  Discussion:
!
!    Computation is based on an algorithm outlined in references 1
!    and 2. The program uses rational functions that theoretically
!    approximate log ( GAMMA(X) ) to at least 18 significant decimal
!    digits.  The approximation for 12 < X is from reference 3, while
!    approximations for X < 12.0 are similar to those in reference 1,
!    but are unpublished. The accuracy achieved depends on the
!    arithmetic system, the compiler, intrinsic functions, and
!    proper selection of the machine-dependent constants.
!
!  Modified:
!
!    16 June 1999
!
!  Authors:
!
!    W. J. Cody and L. Stoltz
!    Argonne National Laboratory
!
!  Reference:
!
!    @ 1)
!    W. J. Cody and K. E. Hillstrom,
!    Chebyshev Approximations for the Natural Logarithm of the Gamma
!    Function, Mathematics of Computation,
!    Volume 21, 1967, pages 198-203.
!
!    @ 2)
!    K. E. Hillstrom,
!    ANL/AMD Program ANLC366S, DGAMMA/DLGAMA,
!    May 1969.
!
!    @ 3)
!    Hart, Cheney, Lawson, Maehly, Mesztenyi, Rice, Thacher, Witzgall,
!    Computer Approximations,
!    Wiley, 1968.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the argument of the Gamma function.
!    X must be positive.
!
!    Output, real ( kind = 8 ) GAMMA_LOG, the logarithm of the Gamma
!    function of X.  If X <= 0.0, or if overflow would occur, the
!    program returns the value HUGE().
!
!  Machine-dependent constants:
!
!       - radix for the floating-point representation.
!
!    MAXEXP - the smallest positive power of BETA that overflows.
!
!    XBIG   - largest argument for which LN(GAMMA(X)) is representable
!             in the machine, i.e., the solution to the equation
!             LN(GAMMA(XBIG)) = BETA**MAXEXP.
!
!    XINF   - largest machine representable floating-point number;
!             approximately BETA**MAXEXP.
!
!    FRTBIG - Rough estimate of the fourth root of XBIG
!
!
!    Approximate values for some important machines are:
!
!                              BETA      MAXEXP         XBIG
!
!    CRAY-1        (S.P.)        2        8191       9.62D+2461
!    Cyber 180/855
!      under NOS   (S.P.)        2        1070       1.72D+319
!    IEEE (IBM/XT,
!      SUN, etc.)  (S.P.)        2         128       4.08D+36
!    IEEE (IBM/XT,
!    SUN, etc.)  (D.P.)        2        1024       2.55D+305
!    IBM 3033      (D.P.)       16          63       4.29D+73
!    VAX D-Format  (D.P.)        2         127       2.05D+36
!    VAX G-Format  (D.P.)        2        1023       1.28D+305
!
!
!                            FRTBIG
!
!    CRAY-1        (S.P.)   3.13D+615
!    Cyber 180/855
!      under NOS   (S.P.)   6.44D+79
!    IEEE (IBM/XT,
!      SUN, etc.)  (S.P.)   1.42D+9
!    IEEE (IBM/XT,
!      SUN, etc.)  (D.P.)   2.25D+76
!    IBM 3033      (D.P.)   2.56D+18
!    VAX D-Format  (D.P.)   1.20D+9
!    VAX G-Format  (D.P.)   1.89D+76
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)       ::  x
!
   REAL(KIND=dp)                   ::  corr,eps,xm4,xnum,xsq,gamma_log
   REAL(KIND=dp)                   ::  res,xden,xm1,xm2
   REAL(KIND=dp), DIMENSION(7)     ::  c
   REAL(KIND=dp), DIMENSION(8)     ::  p1,p2,p4,q1,q2,q4
!
   INTEGER                  ::  i
!
! DIMENSION c(7),p1(8),p2(8),p4(8),q1(8),q2(8),q4(8)
!
   REAL(KIND=dp), PARAMETER :: d1=-5.772156649015328605195174E-01_dp
   REAL(KIND=dp), PARAMETER :: d2=4.227843350984671393993777E-01_dp
   REAL(KIND=dp), PARAMETER :: pnt68=0.6796875E+00_dp
   REAL(KIND=dp), PARAMETER :: d4=1.791759469228055000094023E+00_dp
   REAL(KIND=dp), PARAMETER :: frtbig=1.42E+09_dp
   REAL(KIND=dp), PARAMETER :: sqrtpi=0.9189385332046727417803297E+00_dp
   REAL(KIND=dp), PARAMETER :: xbig=4.08E+36_dp
!
   DATA c/-1.910444077728E-03_dp,8.4171387781295E-04_dp,  &
      -5.952379913043012E-04_dp,7.93650793500350248E-04_dp,  &
      -2.777777777777681622553E-03_dp,8.333333333333333331554247E-02_dp,  &
      5.7083835261E-03_dp/
!
   DATA p1/4.945235359296727046734888E+00_dp,  &
      2.018112620856775083915565E+02_dp,2.290838373831346393026739E+03_dp,  &
      1.131967205903380828685045E+04_dp,2.855724635671635335736389E+04_dp,  &
      3.848496228443793359990269E+04_dp,  &
      2.637748787624195437963534E+04_dp,7.225813979700288197698961E+03_dp/
!
   DATA p2/4.974607845568932035012064E+00_dp,  &
      5.424138599891070494101986E+02_dp,1.550693864978364947665077E+04_dp,  &
      1.847932904445632425417223E+05_dp,1.088204769468828767498470E+06_dp,  &
      3.338152967987029735917223E+06_dp,  &
      5.106661678927352456275255E+06_dp,3.074109054850539556250927E+06_dp/
!
   DATA p4/1.474502166059939948905062E+04_dp,  &
      2.426813369486704502836312E+06_dp,1.214755574045093227939592E+08_dp,  &
      2.663432449630976949898078E+09_dp,2.940378956634553899906876E+10_dp,  &
      1.702665737765398868392998E+11_dp,  &
      4.926125793377430887588120E+11_dp,5.606251856223951465078242E+11_dp/
!
   DATA q1/6.748212550303777196073036E+01_dp,  &
      1.113332393857199323513008E+03_dp,7.738757056935398733233834E+03_dp,  &
      2.763987074403340708898585E+04_dp,5.499310206226157329794414E+04_dp,  &
      6.161122180066002127833352E+04_dp,  &
      3.635127591501940507276287E+04_dp,8.785536302431013170870835E+03_dp/
!
   DATA q2/1.830328399370592604055942E+02_dp,  &
      7.765049321445005871323047E+03_dp,1.331903827966074194402448E+05_dp,  &
      1.136705821321969608938755E+06_dp,5.267964117437946917577538E+06_dp,  &
      1.346701454311101692290052E+07_dp,  &
      1.782736530353274213975932E+07_dp,9.533095591844353613395747E+06_dp/
!
   DATA q4/2.690530175870899333379843E+03_dp,  &
      6.393885654300092398984238E+05_dp,4.135599930241388052042842E+07_dp,  &
      1.120872109616147941376570E+09_dp,1.488613728678813811542398E+10_dp,  &
      1.016803586272438228077304E+11_dp,  &
      3.417476345507377132798597E+11_dp,4.463158187419713286462081E+11_dp/
!
!  Return immediately if the argument is out of range.
!
   IF((x <= 0.0_dp).OR.(xbig < x))THEN
      gamma_log=2.55E+305_dp
      RETURN
   END IF
   eps=1.0E-36_dp
   IF(x <= eps)THEN
      res=-LOG(x)
   ELSE IF(x <= 1.5_dp)THEN
      IF(x < pnt68)THEN
         corr=-LOG(x)
         xm1=x
      ELSE
         corr=0.0_dp
         xm1=(x-0.5_dp)-0.5_dp
      END IF
      IF((x <= 0.5_dp).OR.(pnt68 <= x))THEN
         xden=1.0_dp
         xnum=0.0_dp
         DO i=1,8
            xnum=xnum*xm1+p1(i)
            xden=xden*xm1+q1(i)
         END DO
         res=corr+(xm1*(d1+xm1*(xnum/xden)))
      ELSE
         xm2=(x-0.5_dp)-0.5_dp
         xden=1.0_dp
         xnum=0.0_dp
         DO i=1,8
            xnum=xnum*xm2+p2(i)
            xden=xden*xm2+q2(i)
         END DO
         res=corr+xm2*(d2+xm2*(xnum/xden))
      END IF
   ELSE IF(x <= 4.0_dp)THEN
      xm2=x-2.0_dp
      xden=1.0_dp
      xnum=0.0_dp
      DO i=1,8
         xnum=xnum*xm2+p2(i)
         xden=xden*xm2+q2(i)
      END DO
      res=xm2*(d2+xm2*(xnum/xden))
   ELSE IF(x <= 12.0_dp)THEN
      xm4=x-4.0_dp
      xden=-1.0_dp
      xnum=0.0_dp
      DO i=1,8
         xnum=xnum*xm4+p4(i)
         xden=xden*xm4+q4(i)
      END DO
      res=d4+xm4*(xnum/xden)
   ELSE
      res=0.0_dp
      IF(x <= frtbig)THEN
         res=c(7)
         xsq=x*x
         DO i=1,6
            res=res/xsq+c(i)
         END DO
      END IF
      res=res/x
      corr=LOG(x)
      res=res+sqrtpi-0.5_dp*corr
      res=res+x*(corr-1.0_dp)
   END IF
   gamma_log=res
!
   RETURN
!
END FUNCTION gamma_log
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gauspd(ns,c,b,bp,nsd,a,ap)
!
!    from Ernst Hairer
!
   USE accur

!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ns
   REAL(KIND=dp), INTENT(OUT)               :: c(ns)
   REAL(KIND=dp), INTENT(OUT)               :: b(ns)
   REAL(KIND=dp), INTENT(OUT)               :: bp(ns)
   INTEGER, INTENT(IN)                      :: nsd
   REAL(KIND=dp), INTENT(OUT)               :: a(nsd,ns)
   REAL(KIND=dp), INTENT(OUT)               :: ap(nsd,ns)
!
   REAL(KIND=dp)  :: qc,qb,qa
!
   INTEGER :: i,j
!
!      IMPLICIT REAL*16 (Q)
!
   INTEGER, PARAMETER :: nsdim=10
!
   DIMENSION qc(nsdim),qb(nsdim),qa(nsdim,nsdim)
!
   c=0.00_dp
   b=0.0_dp
   bp=0.0_dp
   a=0.0_dp
   ap=0.0_dp
!
   IF(ns == 2)THEN
      b(1)=0.5_dp
      a(1,1)=0.25_dp
      a(1,2)=-5.0_dp/128.0_dp
      a(2,1)=69.0_dp/128.0_dp
      a(2,2)=0.25_dp
   END IF
   IF(ns == 3)THEN
      b(1)=36.0_dp/128.0_dp
      b(2)=1.0_dp-2*b(1)
      a(1,1)=18.0_dp/128.0_dp
      a(1,2)=-5.0_dp/128.0_dp
      a(1,3)=1.0_dp/128.0_dp
      a(2,1)=38.0_dp/128.0_dp
      a(2,2)=28.0_dp/128.0_dp
      a(2,3)=-3.0_dp/128.0_dp
      a(3,1)=34.0_dp/128.0_dp
      a(3,2)=61.0_dp/128.0_dp
      a(3,3)=18.0_dp/128.0_dp
   END IF
   IF(ns == 4)THEN
      b(1)=178.0_dp/1024.0_dp
      b(2)=334.0_dp/1024.0_dp
      a(1,1)=89.0_dp/1024.0_dp
      a(1,2)=-27.0_dp/1024.0_dp
      a(1,3)=13.0_dp/1024.0_dp
      a(1,4)=-4.0_dp/1024.0_dp
      a(2,1)=193.0_dp/1024.0_dp
      a(2,2)=167.0_dp/1024.0_dp
      a(2,3)=-29.0_dp/1024.0_dp
      a(2,4)=7.0_dp/1024.0_dp
      a(3,1)=171.0_dp/1024.0_dp
      a(3,2)=362.0_dp/1024.0_dp
      a(3,3)=167.0_dp/1024.0_dp
      a(3,4)=-15.0_dp/1024.0_dp
      a(4,1)=182.0_dp/1024.0_dp
      a(4,2)=321.0_dp/1024.0_dp
      a(4,3)=361.0_dp/1024.0_dp
      a(4,4)=89.0_dp/1024.0_dp
   END IF
   IF(ns == 6)THEN
      b(1)=88.0_dp/1024.0_dp
      b(2)=185.0_dp/1024.0_dp
      b(3)=239.0_dp/1024.0_dp
      a(1,1)=44.0_dp/1024.0_dp
      a(1,2)=-15.0_dp/1024.0_dp
      a(1,3)=10.0_dp/1024.0_dp
      a(1,4)=-6.0_dp/1024.0_dp
      a(1,5)=3.0_dp/1024.0_dp
      a(1,6)=-1.0_dp/1024.0_dp
      a(2,1)=95.0_dp/1024.0_dp
      a(2,2)=92.0_dp/1024.0_dp
      a(2,3)=-21.0_dp/1024.0_dp
      a(2,4)=11.0_dp/1024.0_dp
      a(2,5)=-5.0_dp/1024.0_dp
      a(2,6)=1.0_dp/1024.0_dp
      a(3,1)=84.0_dp/1024.0_dp
      a(3,2)=201.0_dp/1024.0_dp
      a(3,3)=120.0_dp/1024.0_dp
      a(3,4)=-21.0_dp/1024.0_dp
      a(3,5)=8.0_dp/1024.0_dp
      a(3,6)=-2.0_dp/1024.0_dp
      a(4,1)=90.0_dp/1024.0_dp
      a(4,2)=177.0_dp/1024.0_dp
      a(4,3)=261.0_dp/1024.0_dp
      a(4,4)=120.0_dp/1024.0_dp
      a(4,5)=-16.0_dp/1024.0_dp
      a(4,6)=3.0_dp/1024.0_dp
      a(5,1)=86.0_dp/1024.0_dp
      a(5,2)=190.0_dp/1024.0_dp
      a(5,3)=229.0_dp/1024.0_dp
      a(5,4)=260.0_dp/1024.0_dp
      a(5,5)=92.0_dp/1024.0_dp
      a(5,6)=-7.0_dp/1024.0_dp
      a(6,1)=89.0_dp/1024.0_dp
      a(6,2)=182.0_dp/1024.0_dp
      a(6,3)=245.0_dp/1024.0_dp
      a(6,4)=230.0_dp/1024.0_dp
      a(6,5)=200.0_dp/1024.0_dp
      a(6,6)=44.0_dp/1024.0_dp
   END IF
   CALL gaussq(ns,qc,qb,nsdim,qa)
   DO i=1,ns
      c(i)=qc(i)
      bp(i)=qb(i)-b(i)
      DO j=1,ns
         ap(i,j)=qa(i,j)-a(i,j)
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE gauspd
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gausscoeff(norder,xx,ww)
!
!   Given the order Norder, this routine will return
!   the abscissa and weights for Gaussian Quadrature.
!   The order should be between 2 and 64
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN OUT)                     :: norder
   REAL(KIND=dp), INTENT(OUT)                  :: xx(64)
   REAL(KIND=dp), INTENT(OUT)                  :: ww(64)
!
   IF(norder < 2)norder=2
   IF(norder > 64)norder=64
!
   IF(norder == 2)THEN
      ww(1)= 1.00000000000000000000000000000000E+00_dp
      xx(1)=-5.77350269189625764509148780501957E-01_dp
      ww(2)= 1.00000000000000000000000000000000E+00_dp
      xx(2)= 5.77350269189625764509148780501957E-01_dp
      RETURN
   END IF
!
   IF(norder == 3)THEN
      ww(1)= 8.88888888888888888888888888888889E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 5.55555555555555555555555555555556E-01_dp
      xx(2)=-7.74596669241483377035853079956480E-01_dp
      ww(3)= 5.55555555555555555555555555555556E-01_dp
      xx(3)= 7.74596669241483377035853079956480E-01_dp
      RETURN
   END IF
!
   IF(norder == 4)THEN
      ww(1)= 6.52145154862546142626936050778001E-01_dp
      xx(1)=-3.39981043584856264802665759103245E-01_dp
      ww(2)= 6.52145154862546142626936050778001E-01_dp
      xx(2)= 3.39981043584856264802665759103245E-01_dp
      ww(3)= 3.47854845137453857373063949221999E-01_dp
      xx(3)=-8.61136311594052575223946488892809E-01_dp
      ww(4)= 3.47854845137453857373063949221999E-01_dp
      xx(4)= 8.61136311594052575223946488892809E-01_dp
      RETURN
   END IF
!
   IF(norder == 5)THEN
      ww(1)= 5.68888888888888888888888888888889E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 4.78628670499366468041291514835638E-01_dp
      xx(2)=-5.38469310105683091036314420700209E-01_dp
      ww(3)= 4.78628670499366468041291514835638E-01_dp
      xx(3)= 5.38469310105683091036314420700209E-01_dp
      ww(4)= 2.36926885056189087514264040719917E-01_dp
      xx(4)=-9.06179845938663992797626878299393E-01_dp
      ww(5)= 2.36926885056189087514264040719917E-01_dp
      xx(5)= 9.06179845938663992797626878299393E-01_dp
      RETURN
   END IF
!
   IF(norder == 6)THEN
      ww(1)= 3.60761573048138607569833513837716E-01_dp
      xx(1)= 6.61209386466264513661399595019905E-01_dp
      ww(2)= 3.60761573048138607569833513837716E-01_dp
      xx(2)=-6.61209386466264513661399595019905E-01_dp
      ww(3)= 4.67913934572691047389870343989551E-01_dp
      xx(3)=-2.38619186083196908630501721680712E-01_dp
      ww(4)= 4.67913934572691047389870343989551E-01_dp
      xx(4)= 2.38619186083196908630501721680712E-01_dp
      ww(5)= 1.71324492379170345040296142172733E-01_dp
      xx(5)=-9.32469514203152027812301554493995E-01_dp
      ww(6)= 1.71324492379170345040296142172733E-01_dp
      xx(6)= 9.32469514203152027812301554493995E-01_dp
      RETURN
   END IF
!
   IF(norder == 7)THEN
      ww(1)= 4.17959183673469387755102040816327E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 3.81830050505118944950369775488975E-01_dp
      xx(2)= 4.05845151377397166906606412076961E-01_dp
      ww(3)= 3.81830050505118944950369775488975E-01_dp
      xx(3)=-4.05845151377397166906606412076961E-01_dp
      ww(4)= 2.79705391489276667901467771423780E-01_dp
      xx(4)=-7.41531185599394439863864773280788E-01_dp
      ww(5)= 2.79705391489276667901467771423780E-01_dp
      xx(5)= 7.41531185599394439863864773280788E-01_dp
      ww(6)= 1.29484966168869693270611432679082E-01_dp
      xx(6)=-9.49107912342758524526189684047851E-01_dp
      ww(7)= 1.29484966168869693270611432679082E-01_dp
      xx(7)= 9.49107912342758524526189684047851E-01_dp
      RETURN
   END IF
!
   IF(norder == 8)THEN
      ww(1)= 3.62683783378361982965150449277196E-01_dp
      xx(1)=-1.83434642495649804939476142360184E-01_dp
      ww(2)= 3.62683783378361982965150449277196E-01_dp
      xx(2)= 1.83434642495649804939476142360184E-01_dp
      ww(3)= 3.13706645877887287337962201986601E-01_dp
      xx(3)=-5.25532409916328985817739049189246E-01_dp
      ww(4)= 3.13706645877887287337962201986601E-01_dp
      xx(4)= 5.25532409916328985817739049189246E-01_dp
      ww(5)= 2.22381034453374470544355994426241E-01_dp
      xx(5)=-7.96666477413626739591553936475830E-01_dp
      ww(6)= 2.22381034453374470544355994426241E-01_dp
      xx(6)= 7.96666477413626739591553936475830E-01_dp
      ww(7)= 1.01228536290376259152531354309962E-01_dp
      xx(7)=-9.60289856497536231683560868569473E-01_dp
      ww(8)= 1.01228536290376259152531354309962E-01_dp
      xx(8)= 9.60289856497536231683560868569473E-01_dp
      RETURN
   END IF
!
   IF(norder == 9)THEN
      ww(1)= 3.30239355001259763164525069286974E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 1.80648160694857404058472031242913E-01_dp
      xx(2)=-8.36031107326635794299429788069735E-01_dp
      ww(3)= 1.80648160694857404058472031242913E-01_dp
      xx(3)= 8.36031107326635794299429788069735E-01_dp
      ww(4)= 8.12743883615744119718921581105236E-02_dp
      xx(4)=-9.68160239507626089835576202903673E-01_dp
      ww(5)= 8.12743883615744119718921581105236E-02_dp
      xx(5)= 9.68160239507626089835576202903673E-01_dp
      ww(6)= 3.12347077040002840068630406584444E-01_dp
      xx(6)=-3.24253423403808929038538014643337E-01_dp
      ww(7)= 3.12347077040002840068630406584444E-01_dp
      xx(7)= 3.24253423403808929038538014643337E-01_dp
      ww(8)= 2.60610696402935462318742869418633E-01_dp
      xx(8)=-6.13371432700590397308702039341474E-01_dp
      ww(9)= 2.60610696402935462318742869418633E-01_dp
      xx(9)= 6.13371432700590397308702039341474E-01_dp
      RETURN
   END IF
!
   IF(norder == 10)THEN
      ww(1)= 2.95524224714752870173892994651338E-01_dp
      xx(1)=-1.48874338981631210884826001129720E-01_dp
      ww(2)= 2.95524224714752870173892994651338E-01_dp
      xx(2)= 1.48874338981631210884826001129720E-01_dp
      ww(3)= 2.69266719309996355091226921569469E-01_dp
      xx(3)=-4.33395394129247190799265943165784E-01_dp
      ww(4)= 2.69266719309996355091226921569469E-01_dp
      xx(4)= 4.33395394129247190799265943165784E-01_dp
      ww(5)= 2.19086362515982043995534934228163E-01_dp
      xx(5)=-6.79409568299024406234327365114874E-01_dp
      ww(6)= 2.19086362515982043995534934228163E-01_dp
      xx(6)= 6.79409568299024406234327365114874E-01_dp
      ww(7)= 1.49451349150580593145776339657697E-01_dp
      xx(7)=-8.65063366688984510732096688423493E-01_dp
      ww(8)= 1.49451349150580593145776339657697E-01_dp
      xx(8)= 8.65063366688984510732096688423493E-01_dp
      ww(9)= 6.66713443086881375935688098933318E-02_dp
      xx(9)=-9.73906528517171720077964012084452E-01_dp
      ww(10)= 6.66713443086881375935688098933318E-02_dp
      xx(10)= 9.73906528517171720077964012084452E-01_dp
      RETURN
   END IF
!
   IF(norder == 11)THEN
      ww(1)= 2.72925086777900630714483528336342E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 2.62804544510246662180688869890509E-01_dp
      xx(2)=-2.69543155952344972331531985400862E-01_dp
      ww(3)= 2.62804544510246662180688869890509E-01_dp
      xx(3)= 2.69543155952344972331531985400862E-01_dp
      ww(4)= 2.33193764591990479918523704843175E-01_dp
      xx(4)=-5.19096129206811815925725669458610E-01_dp
      ww(5)= 2.33193764591990479918523704843175E-01_dp
      xx(5)= 5.19096129206811815925725669458610E-01_dp
      ww(6)= 1.86290210927734251426097641431656E-01_dp
      xx(6)=-7.30152005574049324093416252031153E-01_dp
      ww(7)= 1.86290210927734251426097641431656E-01_dp
      xx(7)= 7.30152005574049324093416252031153E-01_dp
      ww(8)= 1.25580369464904624634694299223940E-01_dp
      xx(8)=-8.87062599768095299075157769303927E-01_dp
      ww(9)= 1.25580369464904624634694299223940E-01_dp
      xx(9)= 8.87062599768095299075157769303927E-01_dp
      ww(10)= 5.56685671161736664827537204425486E-02_dp
      xx(10)=-9.78228658146056992803938001122857E-01_dp
      ww(11)= 5.56685671161736664827537204425486E-02_dp
      xx(11)= 9.78228658146056992803938001122857E-01_dp
      RETURN
   END IF
!
   IF(norder == 12)THEN
      ww(1)= 2.49147045813402785000562436042951E-01_dp
      xx(1)=-1.25233408511468915472441369463853E-01_dp
      ww(2)= 2.49147045813402785000562436042951E-01_dp
      xx(2)= 1.25233408511468915472441369463853E-01_dp
      ww(3)= 2.33492536538354808760849898924878E-01_dp
      xx(3)=-3.67831498998180193752691536643718E-01_dp
      ww(4)= 2.33492536538354808760849898924878E-01_dp
      xx(4)= 3.67831498998180193752691536643718E-01_dp
      ww(5)= 2.03167426723065921749064455809798E-01_dp
      xx(5)=-5.87317954286617447296702418940534E-01_dp
      ww(6)= 2.03167426723065921749064455809798E-01_dp
      xx(6)= 5.87317954286617447296702418940534E-01_dp
      ww(7)= 1.60078328543346226334652529543359E-01_dp
      xx(7)=-7.69902674194304687036893833212818E-01_dp
      ww(8)= 1.60078328543346226334652529543359E-01_dp
      xx(8)= 7.69902674194304687036893833212818E-01_dp
      ww(9)= 1.06939325995318430960254718193996E-01_dp
      xx(9)=-9.04117256370474856678465866119096E-01_dp
      ww(10)= 1.06939325995318430960254718193996E-01_dp
      xx(10)= 9.04117256370474856678465866119096E-01_dp
      ww(11)= 4.71753363865118271946159614850171E-02_dp
      xx(11)=-9.81560634246719250690549090149281E-01_dp
      ww(12)= 4.71753363865118271946159614850171E-02_dp
      xx(12)= 9.81560634246719250690549090149281E-01_dp
      RETURN
   END IF
!
   IF(norder == 13)THEN
      ww(1)= 2.32551553230873910194589515268836E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 2.26283180262897238412090186039777E-01_dp
      xx(2)=-2.30458315955134794065528121097989E-01_dp
      ww(3)= 2.26283180262897238412090186039777E-01_dp
      xx(3)= 2.30458315955134794065528121097989E-01_dp
      ww(4)= 2.07816047536888502312523219306053E-01_dp
      xx(4)=-4.48492751036446852877912852127640E-01_dp
      ww(5)= 2.07816047536888502312523219306053E-01_dp
      xx(5)= 4.48492751036446852877912852127640E-01_dp
      ww(6)= 1.78145980761945738280046691996098E-01_dp
      xx(6)=-6.42349339440340220643984606995516E-01_dp
      ww(7)= 1.78145980761945738280046691996098E-01_dp
      xx(7)= 6.42349339440340220643984606995516E-01_dp
      ww(8)= 1.38873510219787238463601776868871E-01_dp
      xx(8)=-8.01578090733309912794206489582860E-01_dp
      ww(9)= 1.38873510219787238463601776868871E-01_dp
      xx(9)= 8.01578090733309912794206489582860E-01_dp
      ww(10)= 9.21214998377284479144217759537971E-02_dp
      xx(10)=-9.17598399222977965206547836500719E-01_dp
      ww(11)= 9.21214998377284479144217759537971E-02_dp
      xx(11)= 9.17598399222977965206547836500719E-01_dp
      ww(12)= 4.04840047653158795200215922009861E-02_dp
      xx(12)=-9.84183054718588149472829448807110E-01_dp
      ww(13)= 4.04840047653158795200215922009861E-02_dp
      xx(13)= 9.84183054718588149472829448807110E-01_dp
      RETURN
   END IF
!
   IF(norder == 14)THEN
      ww(1)= 2.15263853463157790195876443316260E-01_dp
      xx(1)=-1.08054948707343662066244650219835E-01_dp
      ww(2)= 2.15263853463157790195876443316260E-01_dp
      xx(2)= 1.08054948707343662066244650219835E-01_dp
      ww(3)= 2.05198463721295603965924065661218E-01_dp
      xx(3)=-3.19112368927889760435671824168475E-01_dp
      ww(4)= 2.05198463721295603965924065661218E-01_dp
      xx(4)= 3.19112368927889760435671824168475E-01_dp
      ww(5)= 1.85538397477937813741716590125157E-01_dp
      xx(5)=-5.15248636358154091965290718551189E-01_dp
      ww(6)= 1.85538397477937813741716590125157E-01_dp
      xx(6)= 5.15248636358154091965290718551189E-01_dp
      ww(7)= 1.57203167158193534569601938623842E-01_dp
      xx(7)=-6.87292904811685470148019803019334E-01_dp
      ww(8)= 1.57203167158193534569601938623842E-01_dp
      xx(8)= 6.87292904811685470148019803019334E-01_dp
      ww(9)= 1.21518570687903184689414809072477E-01_dp
      xx(9)=-8.27201315069764993189794742650395E-01_dp
      ww(10)= 1.21518570687903184689414809072477E-01_dp
      xx(10)= 8.27201315069764993189794742650395E-01_dp
      ww(11)= 8.01580871597602098056332770628543E-02_dp
      xx(11)=-9.28434883663573517336391139377874E-01_dp
      ww(12)= 8.01580871597602098056332770628543E-02_dp
      xx(12)= 9.28434883663573517336391139377874E-01_dp
      ww(13)= 3.51194603317518630318328761381918E-02_dp
      xx(13)=-9.86283808696812338841597266704053E-01_dp
      ww(14)= 3.51194603317518630318328761381918E-02_dp
      xx(14)= 9.86283808696812338841597266704053E-01_dp
      RETURN
   END IF
!
   IF(norder == 15)THEN
      ww(1)= 2.02578241925561272880620199967519E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 1.98431485327111576456118326443839E-01_dp
      xx(2)=-2.01194093997434522300628303394596E-01_dp
      ww(3)= 1.98431485327111576456118326443839E-01_dp
      xx(3)= 2.01194093997434522300628303394596E-01_dp
      ww(4)= 1.86161000015562211026800561866423E-01_dp
      xx(4)=-3.94151347077563369897207370981045E-01_dp
      ww(5)= 1.86161000015562211026800561866423E-01_dp
      xx(5)= 3.94151347077563369897207370981045E-01_dp
      ww(6)= 1.66269205816993933553200860481209E-01_dp
      xx(6)=-5.70972172608538847537226737253911E-01_dp
      ww(7)= 1.66269205816993933553200860481209E-01_dp
      xx(7)= 5.70972172608538847537226737253911E-01_dp
      ww(8)= 1.39570677926154314447804794511028E-01_dp
      xx(8)=-7.24417731360170047416186054613938E-01_dp
      ww(9)= 1.39570677926154314447804794511028E-01_dp
      xx(9)= 7.24417731360170047416186054613938E-01_dp
      ww(10)= 1.07159220467171935011869546685869E-01_dp
      xx(10)=-8.48206583410427216200648320774217E-01_dp
      ww(11)= 1.07159220467171935011869546685869E-01_dp
      xx(11)= 8.48206583410427216200648320774217E-01_dp
      ww(12)= 7.03660474881081247092674164506673E-02_dp
      xx(12)=-9.37273392400705904307758947710209E-01_dp
      ww(13)= 7.03660474881081247092674164506673E-02_dp
      xx(13)= 9.37273392400705904307758947710209E-01_dp
      ww(14)= 3.07532419961172683546283935772044E-02_dp
      xx(14)=-9.87992518020485428489565718586613E-01_dp
      ww(15)= 3.07532419961172683546283935772044E-02_dp
      xx(15)= 9.87992518020485428489565718586613E-01_dp
      RETURN
   END IF
!
   IF(norder == 16)THEN
      ww(1)= 1.89450610455068496285396723208283E-01_dp
      xx(1)=-9.50125098376374401853193354249581E-02_dp
      ww(2)= 1.89450610455068496285396723208283E-01_dp
      xx(2)= 9.50125098376374401853193354249581E-02_dp
      ww(3)= 1.82603415044923588866763667969220E-01_dp
      xx(3)=-2.81603550779258913230460501460496E-01_dp
      ww(4)= 1.82603415044923588866763667969220E-01_dp
      xx(4)= 2.81603550779258913230460501460496E-01_dp
      ww(5)= 1.69156519395002538189312079030360E-01_dp
      xx(5)=-4.58016777657227386342419442983578E-01_dp
      ww(6)= 1.69156519395002538189312079030360E-01_dp
      xx(6)= 4.58016777657227386342419442983578E-01_dp
      ww(7)= 1.49595988816576732081501730547479E-01_dp
      xx(7)=-6.17876244402643748446671764048791E-01_dp
      ww(8)= 1.49595988816576732081501730547479E-01_dp
      xx(8)= 6.17876244402643748446671764048791E-01_dp
      ww(9)= 1.24628971255533872052476282192016E-01_dp
      xx(9)=-7.55404408355003033895101194847442E-01_dp
      ww(10)= 1.24628971255533872052476282192016E-01_dp
      xx(10)= 7.55404408355003033895101194847442E-01_dp
      ww(11)= 9.51585116824927848099251076022462E-02_dp
      xx(11)=-8.65631202387831743880467897712393E-01_dp
      ww(12)= 9.51585116824927848099251076022462E-02_dp
      xx(12)= 8.65631202387831743880467897712393E-01_dp
      ww(13)= 6.22535239386478928628438369943777E-02_dp
      xx(13)=-9.44575023073232576077988415534608E-01_dp
      ww(14)= 6.22535239386478928628438369943777E-02_dp
      xx(14)= 9.44575023073232576077988415534608E-01_dp
      ww(15)= 2.71524594117540948517805724560181E-02_dp
      xx(15)=-9.89400934991649932596154173450333E-01_dp
      ww(16)= 2.71524594117540948517805724560181E-02_dp
      xx(16)= 9.89400934991649932596154173450333E-01_dp
      RETURN
   END IF
!
   IF(norder == 17)THEN
      ww(1)= 1.79446470356206525458265644261886E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 1.76562705366992646325270990113197E-01_dp
      xx(2)=-1.78484181495847855850677493654066E-01_dp
      ww(3)= 1.76562705366992646325270990113197E-01_dp
      xx(3)= 1.78484181495847855850677493654066E-01_dp
      ww(4)= 1.68004102156450044509970663788323E-01_dp
      xx(4)=-3.51231763453876315297185517095346E-01_dp
      ww(5)= 1.68004102156450044509970663788323E-01_dp
      xx(5)= 3.51231763453876315297185517095346E-01_dp
      ww(6)= 1.54045761076810288081431594801959E-01_dp
      xx(6)=-5.12690537086476967886246568629552E-01_dp
      ww(7)= 1.54045761076810288081431594801959E-01_dp
      xx(7)= 5.12690537086476967886246568629552E-01_dp
      ww(8)= 1.35136368468525473286319981702350E-01_dp
      xx(8)=-6.57671159216690765850302216643002E-01_dp
      ww(9)= 1.35136368468525473286319981702350E-01_dp
      xx(9)= 6.57671159216690765850302216643002E-01_dp
      ww(10)= 1.11883847193403971094788385626356E-01_dp
      xx(10)=-7.81514003896801406925230055520476E-01_dp
      ww(11)= 1.11883847193403971094788385626356E-01_dp
      xx(11)= 7.81514003896801406925230055520476E-01_dp
      ww(12)= 8.50361483171791808835353701910621E-02_dp
      xx(12)=-8.80239153726985902122955694488156E-01_dp
      ww(13)= 8.50361483171791808835353701910621E-02_dp
      xx(13)= 8.80239153726985902122955694488156E-01_dp
      ww(14)= 5.54595293739872011294401653582447E-02_dp
      xx(14)=-9.50675521768767761222716957895803E-01_dp
      ww(15)= 5.54595293739872011294401653582447E-02_dp
      xx(15)= 9.50675521768767761222716957895803E-01_dp
      ww(16)= 2.41483028685479319601100262875653E-02_dp
      xx(16)=-9.90575475314417335675434019940665E-01_dp
      ww(17)= 2.41483028685479319601100262875653E-02_dp
      xx(17)= 9.90575475314417335675434019940665E-01_dp
      RETURN
   END IF
!
   IF(norder == 18)THEN
      ww(1)= 1.69142382963143591840656470134987E-01_dp
      xx(1)=-8.47750130417353012422618529357838E-02_dp
      ww(2)= 1.69142382963143591840656470134987E-01_dp
      xx(2)= 8.47750130417353012422618529357838E-02_dp
      ww(3)= 1.64276483745832722986053776465928E-01_dp
      xx(3)=-2.51886225691505509588972854877911E-01_dp
      ww(4)= 1.64276483745832722986053776465928E-01_dp
      xx(4)= 2.51886225691505509588972854877911E-01_dp
      ww(5)= 1.54684675126265244925418003836375E-01_dp
      xx(5)=-4.11751161462842646035931793833052E-01_dp
      ww(6)= 1.54684675126265244925418003836375E-01_dp
      xx(6)= 4.11751161462842646035931793833052E-01_dp
      ww(7)= 1.40642914670650651204731303751947E-01_dp
      xx(7)=-5.59770831073947534607871548525329E-01_dp
      ww(8)= 1.40642914670650651204731303751947E-01_dp
      xx(8)= 5.59770831073947534607871548525329E-01_dp
      ww(9)= 1.22555206711478460184519126800202E-01_dp
      xx(9)=-6.91687043060353207874891081288848E-01_dp
      ww(10)= 1.22555206711478460184519126800202E-01_dp
      xx(10)= 6.91687043060353207874891081288848E-01_dp
      ww(11)= 1.00942044106287165562813984924835E-01_dp
      xx(11)=-8.03704958972523115682417455014591E-01_dp
      ww(12)= 1.00942044106287165562813984924835E-01_dp
      xx(12)= 8.03704958972523115682417455014591E-01_dp
      ww(13)= 7.64257302548890565291296776166365E-02_dp
      xx(13)=-8.92602466497555739206060591127146E-01_dp
      ww(14)= 7.64257302548890565291296776166365E-02_dp
      xx(14)= 8.92602466497555739206060591127146E-01_dp
      ww(15)= 4.97145488949697964533349462026386E-02_dp
      xx(15)=-9.55823949571397755181195892929776E-01_dp
      ww(16)= 4.97145488949697964533349462026386E-02_dp
      xx(16)= 9.55823949571397755181195892929776E-01_dp
      ww(17)= 2.16160135264833103133427102664525E-02_dp
      xx(17)=-9.91565168420930946730016004706151E-01_dp
      ww(18)= 2.16160135264833103133427102664525E-02_dp
      xx(18)= 9.91565168420930946730016004706151E-01_dp
      RETURN
   END IF
!
   IF(norder == 19)THEN
      ww(1)= 1.61054449848783695979163625320917E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 1.58968843393954347649956439465047E-01_dp
      xx(2)=-1.60358645640225375868096115740744E-01_dp
      ww(3)= 1.58968843393954347649956439465047E-01_dp
      xx(3)= 1.60358645640225375868096115740744E-01_dp
      ww(4)= 1.52766042065859666778855400897663E-01_dp
      xx(4)=-3.16564099963629831990117328849845E-01_dp
      ww(5)= 1.52766042065859666778855400897663E-01_dp
      xx(5)= 3.16564099963629831990117328849845E-01_dp
      ww(6)= 1.42606702173606611775746109441903E-01_dp
      xx(6)=-4.64570741375960945717267148104102E-01_dp
      ww(7)= 1.42606702173606611775746109441903E-01_dp
      xx(7)= 4.64570741375960945717267148104102E-01_dp
      ww(8)= 1.28753962539336227675515784856877E-01_dp
      xx(8)=-6.00545304661681023469638164946239E-01_dp
      ww(9)= 1.28753962539336227675515784856877E-01_dp
      xx(9)= 6.00545304661681023469638164946239E-01_dp
      ww(10)= 1.11566645547333994716023901681766E-01_dp
      xx(10)=-7.20966177335229378617095860823782E-01_dp
      ww(11)= 1.11566645547333994716023901681766E-01_dp
      xx(11)= 7.20966177335229378617095860823782E-01_dp
      ww(12)= 9.14900216224499994644620941238397E-02_dp
      xx(12)=-8.22714656537142824978922486712714E-01_dp
      ww(13)= 9.14900216224499994644620941238397E-02_dp
      xx(13)= 8.22714656537142824978922486712714E-01_dp
      ww(14)= 6.90445427376412265807082580060130E-02_dp
      xx(14)=-9.03155903614817901642660928532312E-01_dp
      ww(15)= 6.90445427376412265807082580060130E-02_dp
      xx(15)= 9.03155903614817901642660928532312E-01_dp
      ww(16)= 4.48142267656996003328381574019942E-02_dp
      xx(16)=-9.60208152134830030852778840687652E-01_dp
      ww(17)= 4.48142267656996003328381574019942E-02_dp
      xx(17)= 9.60208152134830030852778840687652E-01_dp
      ww(18)= 1.94617882297264770363120414644384E-02_dp
      xx(18)=-9.92406843843584403189017670253260E-01_dp
      ww(19)= 1.94617882297264770363120414644384E-02_dp
      xx(19)= 9.92406843843584403189017670253260E-01_dp
      RETURN
   END IF
!
   IF(norder == 20)THEN
      ww(1)= 1.52753387130725850698084331955098E-01_dp
      xx(1)=-7.65265211334973337546404093988382E-02_dp
      ww(2)= 1.52753387130725850698084331955098E-01_dp
      xx(2)= 7.65265211334973337546404093988382E-02_dp
      ww(3)= 1.49172986472603746787828737001969E-01_dp
      xx(3)=-2.27785851141645078080496195368575E-01_dp
      ww(4)= 1.49172986472603746787828737001969E-01_dp
      xx(4)= 2.27785851141645078080496195368575E-01_dp
      ww(5)= 1.42096109318382051329298325067165E-01_dp
      xx(5)=-3.73706088715419560672548177024927E-01_dp
      ww(6)= 1.42096109318382051329298325067165E-01_dp
      xx(6)= 3.73706088715419560672548177024927E-01_dp
      ww(7)= 1.31688638449176626898494499748163E-01_dp
      xx(7)=-5.10867001950827098004364050955251E-01_dp
      ww(8)= 1.31688638449176626898494499748163E-01_dp
      xx(8)= 5.10867001950827098004364050955251E-01_dp
      ww(9)= 1.18194531961518417312377377711382E-01_dp
      xx(9)=-6.36053680726515025452836696226286E-01_dp
      ww(10)= 1.18194531961518417312377377711382E-01_dp
      xx(10)= 6.36053680726515025452836696226286E-01_dp
      ww(11)= 1.01930119817240435036750135480350E-01_dp
      xx(11)=-7.46331906460150792614305070355642E-01_dp
      ww(12)= 1.01930119817240435036750135480350E-01_dp
      xx(12)= 7.46331906460150792614305070355642E-01_dp
      ww(13)= 8.32767415767047487247581432220462E-02_dp
      xx(13)=-8.39116971822218823394529061701521E-01_dp
      ww(14)= 8.32767415767047487247581432220462E-02_dp
      xx(14)= 8.39116971822218823394529061701521E-01_dp
      ww(15)= 6.26720483341090635695065351870416E-02_dp
      xx(15)=-9.12234428251325905867752441203298E-01_dp
      ww(16)= 6.26720483341090635695065351870416E-02_dp
      xx(16)= 9.12234428251325905867752441203298E-01_dp
      ww(17)= 4.06014298003869413310399522749321E-02_dp
      xx(17)=-9.63971927277913791267666131197277E-01_dp
      ww(18)= 4.06014298003869413310399522749321E-02_dp
      xx(18)= 9.63971927277913791267666131197277E-01_dp
      ww(19)= 1.76140071391521183118619623518528E-02_dp
      xx(19)=-9.93128599185094924786122388471320E-01_dp
      ww(20)= 1.76140071391521183118619623518528E-02_dp
      xx(20)= 9.93128599185094924786122388471320E-01_dp
      RETURN
   END IF
!
   IF(norder == 21)THEN
      ww(1)= 1.46081133649690427191985147683371E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 1.44524403989970059063827166553753E-01_dp
      xx(2)=-1.45561854160895090937030982338686E-01_dp
      ww(3)= 1.44524403989970059063827166553753E-01_dp
      xx(3)= 1.45561854160895090937030982338686E-01_dp
      ww(4)= 1.39887394791073154722133423867583E-01_dp
      xx(4)=-2.88021316802401096600792516064600E-01_dp
      ww(5)= 1.39887394791073154722133423867583E-01_dp
      xx(5)= 2.88021316802401096600792516064600E-01_dp
      ww(6)= 1.32268938633337461781052574496776E-01_dp
      xx(6)=-4.24342120207438783573668888543788E-01_dp
      ww(7)= 1.32268938633337461781052574496776E-01_dp
      xx(7)= 4.24342120207438783573668888543788E-01_dp
      ww(8)= 1.21831416053728534195367177125734E-01_dp
      xx(8)=-5.51618835887219807059018796724313E-01_dp
      ww(9)= 1.21831416053728534195367177125734E-01_dp
      xx(9)= 5.51618835887219807059018796724313E-01_dp
      ww(10)= 1.08797299167148377663474578070106E-01_dp
      xx(10)=-6.67138804197412319305966669990339E-01_dp
      ww(11)= 1.08797299167148377663474578070106E-01_dp
      xx(11)= 6.67138804197412319305966669990339E-01_dp
      ww(12)= 9.34444234560338615532897411139321E-02_dp
      xx(12)=-7.68439963475677908615877851306228E-01_dp
      ww(13)= 9.34444234560338615532897411139321E-02_dp
      xx(13)= 7.68439963475677908615877851306228E-01_dp
      ww(14)= 7.61001136283793020170516533001832E-02_dp
      xx(14)=-8.53363364583317283647250638587568E-01_dp
      ww(15)= 7.61001136283793020170516533001832E-02_dp
      xx(15)= 8.53363364583317283647250638587568E-01_dp
      ww(16)= 5.71344254268572082836358264724480E-02_dp
      xx(16)=-9.20099334150400828790187133714969E-01_dp
      ww(17)= 5.71344254268572082836358264724480E-02_dp
      xx(17)= 9.20099334150400828790187133714969E-01_dp
      ww(18)= 3.69537897708524937999506682993297E-02_dp
      xx(18)=-9.67226838566306294316622214907695E-01_dp
      ww(19)= 3.69537897708524937999506682993297E-02_dp
      xx(19)= 9.67226838566306294316622214907695E-01_dp
      ww(20)= 1.60172282577743333242246168584710E-02_dp
      xx(20)=-9.93752170620389500260242035937941E-01_dp
      ww(21)= 1.60172282577743333242246168584710E-02_dp
      xx(21)= 9.93752170620389500260242035937941E-01_dp
      RETURN
   END IF
!
   IF(norder == 22)THEN
      ww(1)= 1.39251872855631993375410248341810E-01_dp
      xx(1)=-6.97392733197222212138417961186281E-02_dp
      ww(2)= 1.39251872855631993375410248341810E-01_dp
      xx(2)= 6.97392733197222212138417961186281E-02_dp
      ww(3)= 1.36541498346015171352573831231517E-01_dp
      xx(3)=-2.07860426688221285478846533919546E-01_dp
      ww(4)= 1.36541498346015171352573831231517E-01_dp
      xx(4)= 2.07860426688221285478846533919546E-01_dp
      ww(5)= 1.31173504787062370732964992530307E-01_dp
      xx(5)=-3.41935820892084225158147420427380E-01_dp
      ww(6)= 1.31173504787062370732964992530307E-01_dp
      xx(6)= 3.41935820892084225158147420427380E-01_dp
      ww(7)= 1.23252376810512424285560986154814E-01_dp
      xx(7)=-4.69355837986757026406330710966406E-01_dp
      ww(8)= 1.23252376810512424285560986154814E-01_dp
      xx(8)= 4.69355837986757026406330710966406E-01_dp
      ww(9)= 1.12932296080539218393400607421784E-01_dp
      xx(9)=-5.87640403506911592958876927638647E-01_dp
      ww(10)= 1.12932296080539218393400607421784E-01_dp
      xx(10)= 5.87640403506911592958876927638647E-01_dp
      ww(11)= 1.00414144442880964932078837830536E-01_dp
      xx(11)=-6.94487263186682780050689835762257E-01_dp
      ww(12)= 1.00414144442880964932078837830536E-01_dp
      xx(12)= 6.94487263186682780050689835762257E-01_dp
      ww(13)= 8.59416062170677274144436813727029E-02_dp
      xx(13)=-7.87816805979208162004277955408352E-01_dp
      ww(14)= 8.59416062170677274144436813727029E-02_dp
      xx(14)= 7.87816805979208162004277955408352E-01_dp
      ww(15)= 6.97964684245204880949614189302177E-02_dp
      xx(15)=-8.65812577720300136536425637019379E-01_dp
      ww(16)= 6.97964684245204880949614189302177E-02_dp
      xx(16)= 8.65812577720300136536425637019379E-01_dp
      ww(17)= 5.22933351526832859403120512732113E-02_dp
      xx(17)=-9.26956772187174000520692939259053E-01_dp
      ww(18)= 5.22933351526832859403120512732113E-02_dp
      xx(18)= 9.26956772187174000520692939259053E-01_dp
      ww(19)= 3.37749015848141547933022468659129E-02_dp
      xx(19)=-9.70060497835428727123950986765269E-01_dp
      ww(20)= 3.37749015848141547933022468659129E-02_dp
      xx(20)= 9.70060497835428727123950986765269E-01_dp
      ww(21)= 1.46279952982722006849910980471854E-02_dp
      xx(21)=-9.94294585482399292073031421161299E-01_dp
      ww(22)= 1.46279952982722006849910980471854E-02_dp
      xx(22)= 9.94294585482399292073031421161299E-01_dp
      RETURN
   END IF
!
   IF(norder == 23)THEN
      ww(1)= 1.33654572186106175351457110545844E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 1.32462039404696617371642464703317E-01_dp
      xx(2)=-1.33256824298466110931742682241766E-01_dp
      ww(3)= 1.32462039404696617371642464703317E-01_dp
      xx(3)= 1.33256824298466110931742682241766E-01_dp
      ww(4)= 1.28905722188082149978595339399794E-01_dp
      xx(4)=-2.64135680970344930533869538283310E-01_dp
      ww(5)= 1.28905722188082149978595339399794E-01_dp
      xx(5)= 2.64135680970344930533869538283310E-01_dp
      ww(6)= 1.23049084306729530467578400672010E-01_dp
      xx(6)=-3.90301038030290831421488872880605E-01_dp
      ww(7)= 1.23049084306729530467578400672010E-01_dp
      xx(7)= 3.90301038030290831421488872880605E-01_dp
      ww(8)= 1.14996640222411364941643512933961E-01_dp
      xx(8)=-5.09501477846007549689793047866846E-01_dp
      ww(9)= 1.14996640222411364941643512933961E-01_dp
      xx(9)= 5.09501477846007549689793047866846E-01_dp
      ww(10)= 1.04892091464541410074086185014744E-01_dp
      xx(10)=-6.19609875763646156385097311649596E-01_dp
      ww(11)= 1.04892091464541410074086185014744E-01_dp
      xx(11)= 6.19609875763646156385097311649596E-01_dp
      ww(12)= 9.29157660600351474770186173697646E-02_dp
      xx(12)=-7.18661363131950194461624483748619E-01_dp
      ww(13)= 9.29157660600351474770186173697646E-02_dp
      xx(13)= 7.18661363131950194461624483748619E-01_dp
      ww(14)= 7.92814117767189549228925247420432E-02_dp
      xx(14)=-8.04888401618839892151118406996779E-01_dp
      ww(15)= 7.92814117767189549228925247420432E-02_dp
      xx(15)= 8.04888401618839892151118406996779E-01_dp
      ww(16)= 6.42324214085258521271696151589110E-02_dp
      xx(16)=-8.76752358270441667378156885934146E-01_dp
      ww(17)= 6.42324214085258521271696151589110E-02_dp
      xx(17)= 8.76752358270441667378156885934146E-01_dp
      ww(18)= 4.80376717310846685716410716320340E-02_dp
      xx(18)=-9.32971086826016102349196989038423E-01_dp
      ww(19)= 4.80376717310846685716410716320340E-02_dp
      xx(19)= 9.32971086826016102349196989038423E-01_dp
      ww(20)= 3.09880058569794443106942196418845E-02_dp
      xx(20)=-9.72542471218115231956024076820777E-01_dp
      ww(21)= 3.09880058569794443106942196418845E-02_dp
      xx(21)= 9.72542471218115231956024076820777E-01_dp
      ww(22)= 1.34118594871417720813094934586151E-02_dp
      xx(22)=-9.94769334997552123523925715445574E-01_dp
      ww(23)= 1.34118594871417720813094934586151E-02_dp
      xx(23)= 9.94769334997552123523925715445574E-01_dp
      RETURN
   END IF
!
   IF(norder == 24)THEN
      ww(1)= 1.27938195346752156974056165224695E-01_dp
      xx(1)=-6.40568928626056260850430826247450E-02_dp
      ww(2)= 1.27938195346752156974056165224695E-01_dp
      xx(2)= 6.40568928626056260850430826247450E-02_dp
      ww(3)= 1.25837456346828296121375382511184E-01_dp
      xx(3)=-1.91118867473616309158639820757070E-01_dp
      ww(4)= 1.25837456346828296121375382511184E-01_dp
      xx(4)= 1.91118867473616309158639820757070E-01_dp
      ww(5)= 1.21670472927803391204463153476262E-01_dp
      xx(5)=-3.15042679696163374386793291319810E-01_dp
      ww(6)= 1.21670472927803391204463153476262E-01_dp
      xx(6)= 3.15042679696163374386793291319810E-01_dp
      ww(7)= 1.15505668053725601353344483906784E-01_dp
      xx(7)=-4.33793507626045138487084231913350E-01_dp
      ww(8)= 1.15505668053725601353344483906784E-01_dp
      xx(8)= 4.33793507626045138487084231913350E-01_dp
      ww(9)= 1.07444270115965634782577342446606E-01_dp
      xx(9)=-5.45421471388839535658375617218372E-01_dp
      ww(10)= 1.07444270115965634782577342446606E-01_dp
      xx(10)= 5.45421471388839535658375617218372E-01_dp
      ww(11)= 9.76186521041138882698806644642472E-02_dp
      xx(11)=-6.48093651936975569252495786910748E-01_dp
      ww(12)= 9.76186521041138882698806644642472E-02_dp
      xx(12)= 6.48093651936975569252495786910748E-01_dp
      ww(13)= 8.61901615319532759171852029837427E-02_dp
      xx(13)=-7.40124191578554364243828103099978E-01_dp
      ww(14)= 8.61901615319532759171852029837427E-02_dp
      xx(14)= 7.40124191578554364243828103099978E-01_dp
      ww(15)= 7.33464814110803057340336152531165E-02_dp
      xx(15)=-8.20001985973902921953949872669745E-01_dp
      ww(16)= 7.33464814110803057340336152531165E-02_dp
      xx(16)= 8.20001985973902921953949872669745E-01_dp
      ww(17)= 5.92985849154367807463677585001086E-02_dp
      xx(17)=-8.86415527004401034213154341982197E-01_dp
      ww(18)= 5.92985849154367807463677585001086E-02_dp
      xx(18)= 8.86415527004401034213154341982197E-01_dp
      ww(19)= 4.42774388174198061686027482113382E-02_dp
      xx(19)=-9.38274552002732758523649001708721E-01_dp
      ww(20)= 4.42774388174198061686027482113382E-02_dp
      xx(20)= 9.38274552002732758523649001708721E-01_dp
      ww(21)= 2.85313886289336631813078159518783E-02_dp
      xx(21)=-9.74728555971309498198391993008169E-01_dp
      ww(22)= 2.85313886289336631813078159518783E-02_dp
      xx(22)= 9.74728555971309498198391993008169E-01_dp
      ww(23)= 1.23412297999871995468056670700373E-02_dp
      xx(23)=-9.95187219997021360179997409700737E-01_dp
      ww(24)= 1.23412297999871995468056670700373E-02_dp
      xx(24)= 9.95187219997021360179997409700737E-01_dp
      RETURN
   END IF
!
   IF(norder == 25)THEN
      ww(1)= 1.23176053726715451203902873079050E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 1.22242442990310041688959518945852E-01_dp
      xx(2)=-1.22864692610710396387359818808037E-01_dp
      ww(3)= 1.22242442990310041688959518945852E-01_dp
      xx(3)= 1.22864692610710396387359818808037E-01_dp
      ww(4)= 1.19455763535784772228178126512901E-01_dp
      xx(4)=-2.43866883720988432045190362797452E-01_dp
      ww(5)= 1.19455763535784772228178126512901E-01_dp
      xx(5)= 2.43866883720988432045190362797452E-01_dp
      ww(6)= 1.14858259145711648339325545869556E-01_dp
      xx(6)=-3.61172305809387837735821730127641E-01_dp
      ww(7)= 1.14858259145711648339325545869556E-01_dp
      xx(7)= 3.61172305809387837735821730127641E-01_dp
      ww(8)= 1.08519624474263653116093957050117E-01_dp
      xx(8)=-4.73002731445714960522182115009192E-01_dp
      ww(9)= 1.08519624474263653116093957050117E-01_dp
      xx(9)= 4.73002731445714960522182115009192E-01_dp
      ww(10)= 1.00535949067050644202206890392686E-01_dp
      xx(10)=-5.77662930241222967723689841612654E-01_dp
      ww(11)= 1.00535949067050644202206890392686E-01_dp
      xx(11)= 5.77662930241222967723689841612654E-01_dp
      ww(12)= 9.10282619829636498114972207028916E-02_dp
      xx(12)=-6.73566368473468364485120633247622E-01_dp
      ww(13)= 9.10282619829636498114972207028916E-02_dp
      xx(13)= 6.73566368473468364485120633247622E-01_dp
      ww(14)= 8.01407003350010180132349596691113E-02_dp
      xx(14)=-7.59259263037357630577282865204361E-01_dp
      ww(15)= 8.01407003350010180132349596691113E-02_dp
      xx(15)= 7.59259263037357630577282865204361E-01_dp
      ww(16)= 6.80383338123569172071871856567080E-02_dp
      xx(16)=-8.33442628760834001421021108693570E-01_dp
      ww(17)= 6.80383338123569172071871856567080E-02_dp
      xx(17)= 8.33442628760834001421021108693570E-01_dp
      ww(18)= 5.49046959758351919259368915404733E-02_dp
      xx(18)=-8.94991997878275368851042006782805E-01_dp
      ww(19)= 5.49046959758351919259368915404733E-02_dp
      xx(19)= 8.94991997878275368851042006782805E-01_dp
      ww(20)= 4.09391567013063126556234877116460E-02_dp
      xx(20)=-9.42974571228974339414011169658471E-01_dp
      ww(21)= 4.09391567013063126556234877116460E-02_dp
      xx(21)= 9.42974571228974339414011169658471E-01_dp
      ww(22)= 2.63549866150321372619018152952991E-02_dp
      xx(22)=-9.76663921459517511498315386479594E-01_dp
      ww(23)= 2.63549866150321372619018152952991E-02_dp
      xx(23)= 9.76663921459517511498315386479594E-01_dp
      ww(24)= 1.13937985010262879479029641132348E-02_dp
      xx(24)=-9.95556969790498097908784946893902E-01_dp
      ww(25)= 1.13937985010262879479029641132348E-02_dp
      xx(25)= 9.95556969790498097908784946893902E-01_dp
      RETURN
   END IF
!
   IF(norder == 26)THEN
      ww(1)= 1.18321415279262276516371085700469E-01_dp
      xx(1)=-5.92300934293132070937185751984034E-02_dp
      ww(2)= 1.18321415279262276516371085700469E-01_dp
      xx(2)= 5.92300934293132070937185751984034E-02_dp
      ww(3)= 1.16660443485296582044662507540362E-01_dp
      xx(3)=-1.76858820356890183969057748418345E-01_dp
      ww(4)= 1.16660443485296582044662507540362E-01_dp
      xx(4)= 1.76858820356890183969057748418345E-01_dp
      ww(5)= 1.13361816546319666549440718442598E-01_dp
      xx(5)=-2.92004839485956895142835382077830E-01_dp
      ww(6)= 1.13361816546319666549440718442598E-01_dp
      xx(6)= 2.92004839485956895142835382077830E-01_dp
      ww(7)= 1.08471840528576590656579426727998E-01_dp
      xx(7)=-4.03051755123486306481077377098883E-01_dp
      ww(8)= 1.08471840528576590656579426727998E-01_dp
      xx(8)= 4.03051755123486306481077377098883E-01_dp
      ww(9)= 1.02059161094425423238414070253431E-01_dp
      xx(9)=-5.08440714824505717695703064725569E-01_dp
      ww(10)= 1.02059161094425423238414070253431E-01_dp
      xx(10)= 5.08440714824505717695703064725569E-01_dp
      ww(11)= 9.42138003559141484636648830673032E-02_dp
      xx(11)=-6.06692293017618063231978746916887E-01_dp
      ww(12)= 9.42138003559141484636648830673032E-02_dp
      xx(12)= 6.06692293017618063231978746916887E-01_dp
      ww(13)= 8.50458943134852392104477650799817E-02_dp
      xx(13)=-6.96427260419957264863813913729425E-01_dp
      ww(14)= 8.50458943134852392104477650799817E-02_dp
      xx(14)= 6.96427260419957264863813913729425E-01_dp
      ww(15)= 7.46841497656597458870757961028483E-02_dp
      xx(15)=-7.76385948820678856192967247242284E-01_dp
      ww(16)= 7.46841497656597458870757961028483E-02_dp
      xx(16)= 7.76385948820678856192967247242284E-01_dp
      ww(17)= 6.32740463295748355394536899070451E-02_dp
      xx(17)=-8.45445942788498018797507061467838E-01_dp
      ww(18)= 6.32740463295748355394536899070451E-02_dp
      xx(18)= 8.45445942788498018797507061467838E-01_dp
      ww(19)= 5.09758252971478119983199007240734E-02_dp
      xx(19)=-9.02637861984307074217665599231210E-01_dp
      ww(20)= 5.09758252971478119983199007240734E-02_dp
      xx(20)= 9.02637861984307074217665599231210E-01_dp
      ww(21)= 3.79623832943627639503031412488505E-02_dp
      xx(21)=-9.47159066661714250135915283518037E-01_dp
      ww(22)= 3.79623832943627639503031412488505E-02_dp
      xx(22)= 9.47159066661714250135915283518037E-01_dp
      ww(23)= 2.44178510926319087896158275197884E-02_dp
      xx(23)=-9.78385445956470991100580354311926E-01_dp
      ww(24)= 2.44178510926319087896158275197884E-02_dp
      xx(24)= 9.78385445956470991100580354311926E-01_dp
      ww(25)= 1.05513726173430071556511876852520E-02_dp
      xx(25)=-9.95885701145616929003216959322906E-01_dp
      ww(26)= 1.05513726173430071556511876852520E-02_dp
      xx(26)= 9.95885701145616929003216959322906E-01_dp
      RETURN
   END IF
!
   IF(norder == 27)THEN
      ww(1)= 1.14220867378956989045045736901835E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 1.13476346108965148620369948092099E-01_dp
      xx(2)=-1.13972585609529966932894983869977E-01_dp
      ww(3)= 1.13476346108965148620369948092099E-01_dp
      xx(3)= 1.13972585609529966932894983869977E-01_dp
      ww(4)= 1.11252488356845192672163096042849E-01_dp
      xx(4)=-2.26459365439536858857239107360230E-01_dp
      ww(5)= 1.11252488356845192672163096042849E-01_dp
      xx(5)= 2.26459365439536858857239107360230E-01_dp
      ww(6)= 1.07578285788533187212162984426657E-01_dp
      xx(6)=-3.35993903638508899730319034207285E-01_dp
      ww(7)= 1.07578285788533187212162984426657E-01_dp
      xx(7)= 3.35993903638508899730319034207285E-01_dp
      ww(8)= 1.02501637817745798671247711532664E-01_dp
      xx(8)=-4.41148251750026880585974155689281E-01_dp
      ww(9)= 1.02501637817745798671247711532664E-01_dp
      xx(9)= 4.41148251750026880585974155689281E-01_dp
      ww(10)= 9.60887273700285075656526465581059E-02_dp
      xx(10)=-5.40551564579456894900300941559983E-01_dp
      ww(11)= 9.60887273700285075656526465581059E-02_dp
      xx(11)= 5.40551564579456894900300941559983E-01_dp
      ww(12)= 8.84231585437569501943228028537491E-02_dp
      xx(12)=-6.32907971946495140927734637634489E-01_dp
      ww(13)= 8.84231585437569501943228028537491E-02_dp
      xx(13)= 6.32907971946495140927734637634489E-01_dp
      ww(14)= 7.96048677730577712630749590098424E-02_dp
      xx(14)=-7.17013473739423699294816211642340E-01_dp
      ww(15)= 7.96048677730577712630749590098424E-02_dp
      xx(15)= 7.17013473739423699294816211642340E-01_dp
      ww(16)= 6.97488237662455929843228883566673E-02_dp
      xx(16)=-7.91771639070508227144397344107271E-01_dp
      ww(17)= 6.97488237662455929843228883566673E-02_dp
      xx(17)= 7.91771639070508227144397344107271E-01_dp
      ww(18)= 5.89835368598335991103008337195316E-02_dp
      xx(18)=-8.56207908018294490302737222706843E-01_dp
      ww(19)= 5.89835368598335991103008337195316E-02_dp
      xx(19)= 8.56207908018294490302737222706843E-01_dp
      ww(20)= 4.74494125206150627040967101141847E-02_dp
      xx(20)=-9.09482320677491104300645018209689E-01_dp
      ww(21)= 4.74494125206150627040967101141847E-02_dp
      xx(21)= 9.09482320677491104300645018209689E-01_dp
      ww(22)= 3.52970537574197110225782893047116E-02_dp
      xx(22)=-9.50900557814705006851908030643883E-01_dp
      ww(23)= 3.52970537574197110225782893047116E-02_dp
      xx(23)= 9.50900557814705006851908030643883E-01_dp
      ww(24)= 2.26862315961806231960342064467615E-02_dp
      xx(24)=-9.79923475961501222855873355661047E-01_dp
      ww(25)= 2.26862315961806231960342064467615E-02_dp
      xx(25)= 9.79923475961501222855873355661047E-01_dp
      ww(26)= 9.79899605129436026115005509125910E-03_dp
      xx(26)=-9.96179262888988566938887208381230E-01_dp
      ww(27)= 9.79899605129436026115005509125910E-03_dp
      xx(27)= 9.96179262888988566938887208381230E-01_dp
      RETURN
   END IF
!
   IF(norder == 28)THEN
      ww(1)= 1.10047013016475196282376265601818E-01_dp
      xx(1)=-5.50792898840342704265165273418800E-02_dp
      ww(2)= 1.10047013016475196282376265601818E-01_dp
      xx(2)= 5.50792898840342704265165273418800E-02_dp
      ww(3)= 1.08711192258294135253571519303673E-01_dp
      xx(3)=-1.64569282133380771281471777891165E-01_dp
      ww(4)= 1.08711192258294135253571519303673E-01_dp
      xx(4)= 1.64569282133380771281471777891165E-01_dp
      ww(5)= 1.06055765922846417910416436996811E-01_dp
      xx(5)=-2.72061627635178077676826356125770E-01_dp
      ww(6)= 1.06055765922846417910416436996811E-01_dp
      xx(6)= 2.72061627635178077676826356125770E-01_dp
      ww(7)= 1.02112967578060769814216638505712E-01_dp
      xx(7)=-3.76251516089078710221357209556087E-01_dp
      ww(8)= 1.02112967578060769814216638505712E-01_dp
      xx(8)= 3.76251516089078710221357209556087E-01_dp
      ww(9)= 9.69306579979299158504890060954406E-02_dp
      xx(9)=-4.75874224955118261034411847667434E-01_dp
      ww(10)= 9.69306579979299158504890060954406E-02_dp
      xx(10)= 4.75874224955118261034411847667434E-01_dp
      ww(11)= 9.05717443930328409421860313367841E-02_dp
      xx(11)=-5.69720471811401719308003283356431E-01_dp
      ww(12)= 9.05717443930328409421860313367841E-02_dp
      xx(12)= 5.69720471811401719308003283356431E-01_dp
      ww(13)= 8.31134172289012183903964982443325E-02_dp
      xx(13)=-6.56651094038864961219898176506743E-01_dp
      ww(14)= 8.31134172289012183903964982443325E-02_dp
      xx(14)= 6.56651094038864961219898176506743E-01_dp
      ww(15)= 7.46462142345687790239318871730220E-02_dp
      xx(15)=-7.35610878013631772028144510292534E-01_dp
      ww(16)= 7.46462142345687790239318871730220E-02_dp
      xx(16)= 7.35610878013631772028144510292534E-01_dp
      ww(17)= 6.52729239669995957933975667755046E-02_dp
      xx(17)=-8.05641370917179171447885955425278E-01_dp
      ww(18)= 6.52729239669995957933975667755046E-02_dp
      xx(18)= 8.05641370917179171447885955425278E-01_dp
      ww(19)= 5.51073456757167454314829182269456E-02_dp
      xx(19)=-8.65892522574395048942254567379687E-01_dp
      ww(20)= 5.51073456757167454314829182269456E-02_dp
      xx(20)= 8.65892522574395048942254567379687E-01_dp
      ww(21)= 4.42729347590042278395878776532074E-02_dp
      xx(21)=-9.15633026392132073869689423329927E-01_dp
      ww(22)= 4.42729347590042278395878776532074E-02_dp
      xx(22)= 9.15633026392132073869689423329927E-01_dp
      ww(23)= 3.29014277823043799776308191705320E-02_dp
      xx(23)=-9.54259280628938197254101839705216E-01_dp
      ww(24)= 3.29014277823043799776308191705320E-02_dp
      xx(24)= 9.54259280628938197254101839705216E-01_dp
      ww(25)= 2.11321125927712597515003809932654E-02_dp
      xx(25)=-9.81303165370872753694559945807830E-01_dp
      ww(26)= 2.11321125927712597515003809932654E-02_dp
      xx(26)= 9.81303165370872753694559945807830E-01_dp
      ww(27)= 9.12428259309451773881615392295171E-03_dp
      xx(27)=-9.96442497573954449950436390483311E-01_dp
      ww(28)= 9.12428259309451773881615392295171E-03_dp
      xx(28)= 9.96442497573954449950436390483311E-01_dp
      RETURN
   END IF
!
   IF(norder == 29)THEN
      ww(1)= 1.06479381718314244246511126909678E-01_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 1.05876155097320941406591327852188E-01_dp
      xx(2)=-1.06278230132679230170982392430377E-01_dp
      ww(3)= 1.05876155097320941406591327852188E-01_dp
      xx(3)= 1.06278230132679230170982392430377E-01_dp
      ww(4)= 1.04073310077729373913328471285120E-01_dp
      xx(4)=-2.11352286166001074506375728902938E-01_dp
      ww(5)= 1.04073310077729373913328471285120E-01_dp
      xx(5)= 2.11352286166001074506375728902938E-01_dp
      ww(6)= 1.01091273759914966121820546907497E-01_dp
      xx(6)=-3.14031637867639934948195923191047E-01_dp
      ww(7)= 1.01091273759914966121820546907497E-01_dp
      xx(7)= 3.14031637867639934948195923191047E-01_dp
      ww(8)= 9.69638340944086063019000748826888E-02_dp
      xx(8)=-4.13152888174008663890706586031617E-01_dp
      ww(9)= 9.69638340944086063019000748826888E-02_dp
      xx(9)= 4.13152888174008663890706586031617E-01_dp
      ww(10)= 9.17377571392587633479664110771108E-02_dp
      xx(10)=-5.07592955124227642102627919627520E-01_dp
      ww(11)= 9.17377571392587633479664110771108E-02_dp
      xx(11)= 5.07592955124227642102627919627520E-01_dp
      ww(12)= 8.54722573661725275453448492972081E-02_dp
      xx(12)=-5.96281797138227820379586211188990E-01_dp
      ww(13)= 8.54722573661725275453448492972081E-02_dp
      xx(13)= 5.96281797138227820379586211188990E-01_dp
      ww(14)= 7.82383271357637838281448886596803E-02_dp
      xx(14)=-6.78214537602686515156185005391986E-01_dp
      ww(15)= 7.82383271357637838281448886596803E-02_dp
      xx(15)= 6.78214537602686515156185005391986E-01_dp
      ww(16)= 7.01179332550512785695814869488792E-02_dp
      xx(16)=-7.52462851734477133912610077212138E-01_dp
      ww(17)= 7.01179332550512785695814869488792E-02_dp
      xx(17)= 7.52462851734477133912610077212138E-01_dp
      ww(18)= 6.12030906570791385421098480239070E-02_dp
      xx(18)=-8.18185487615252444989572214578785E-01_dp
      ww(19)= 6.12030906570791385421098480239070E-02_dp
      xx(19)= 8.18185487615252444989572214578785E-01_dp
      ww(20)= 5.15948269024979239125943811795426E-02_dp
      xx(20)=-8.74637804920102790417793421256579E-01_dp
      ww(21)= 5.15948269024979239125943811795426E-02_dp
      xx(21)= 8.74637804920102790417793421256579E-01_dp
      ww(22)= 4.14020625186828361048300101140769E-02_dp
      xx(22)=-9.21180232953058785093753436083106E-01_dp
      ww(23)= 4.14020625186828361048300101140769E-02_dp
      xx(23)= 9.21180232953058785093753436083106E-01_dp
      ww(24)= 3.07404922020936226444085253746168E-02_dp
      xx(24)=-9.57285595778087725798208036980824E-01_dp
      ww(25)= 3.07404922020936226444085253746168E-02_dp
      xx(25)= 9.57285595778087725798208036980824E-01_dp
      ww(26)= 1.97320850561227059838598016403956E-02_dp
      xx(26)=-9.82545505261413174870926015786377E-01_dp
      ww(27)= 1.97320850561227059838598016403956E-02_dp
      xx(27)= 9.82545505261413174870926015786377E-01_dp
      ww(28)= 8.51690387874640965426381330224980E-03_dp
      xx(28)=-9.96679442260596586163191532549354E-01_dp
      ww(29)= 8.51690387874640965426381330224980E-03_dp
      xx(29)= 9.96679442260596586163191532549354E-01_dp
      RETURN
   END IF
!
   IF(norder == 30)THEN
      ww(1)= 1.02852652893558840341285636705415E-01_dp
      xx(1)=-5.14718425553176958330252131667226E-02_dp
      ww(2)= 1.02852652893558840341285636705415E-01_dp
      xx(2)= 5.14718425553176958330252131667226E-02_dp
      ww(3)= 1.01762389748405504596428952168554E-01_dp
      xx(3)=-1.53869913608583546963794672743256E-01_dp
      ww(4)= 1.01762389748405504596428952168554E-01_dp
      xx(4)= 1.53869913608583546963794672743256E-01_dp
      ww(5)= 9.95934205867952670627802821035695E-02_dp
      xx(5)=-2.54636926167889846439805129817805E-01_dp
      ww(6)= 9.95934205867952670627802821035695E-02_dp
      xx(6)= 2.54636926167889846439805129817805E-01_dp
      ww(7)= 9.63687371746442596394686263518099E-02_dp
      xx(7)=-3.52704725530878113471037207089374E-01_dp
      ww(8)= 9.63687371746442596394686263518099E-02_dp
      xx(8)= 3.52704725530878113471037207089374E-01_dp
      ww(9)= 9.21225222377861287176327070876188E-02_dp
      xx(9)=-4.47033769538089176780609900322854E-01_dp
      ww(10)= 9.21225222377861287176327070876188E-02_dp
      xx(10)= 4.47033769538089176780609900322854E-01_dp
      ww(11)= 8.68997872010829798023875307151257E-02_dp
      xx(11)=-5.36624148142019899264169793311073E-01_dp
      ww(12)= 8.68997872010829798023875307151257E-02_dp
      xx(12)= 5.36624148142019899264169793311073E-01_dp
      ww(13)= 8.07558952294202153546949384605297E-02_dp
      xx(13)=-6.20526182989242861140477556431189E-01_dp
      ww(14)= 8.07558952294202153546949384605297E-02_dp
      xx(14)= 6.20526182989242861140477556431189E-01_dp
      ww(15)= 7.37559747377052062682438500221907E-02_dp
      xx(15)=-6.97850494793315796932292388026640E-01_dp
      ww(16)= 7.37559747377052062682438500221907E-02_dp
      xx(16)= 6.97850494793315796932292388026640E-01_dp
      ww(17)= 6.59742298821804951281285151159624E-02_dp
      xx(17)=-7.67777432104826194917977340974503E-01_dp
      ww(18)= 6.59742298821804951281285151159624E-02_dp
      xx(18)= 7.67777432104826194917977340974503E-01_dp
      ww(19)= 5.74931562176190664817216894020561E-02_dp
      xx(19)=-8.29565762382768397442898119732502E-01_dp
      ww(20)= 5.74931562176190664817216894020561E-02_dp
      xx(20)= 8.29565762382768397442898119732502E-01_dp
      ww(21)= 4.84026728305940529029381404228075E-02_dp
      xx(21)=-8.82560535792052681543116462530226E-01_dp
      ww(22)= 4.84026728305940529029381404228075E-02_dp
      xx(22)= 8.82560535792052681543116462530226E-01_dp
      ww(23)= 3.87991925696270495968019364463477E-02_dp
      xx(23)=-9.26200047429274325879324277080474E-01_dp
      ww(24)= 3.87991925696270495968019364463477E-02_dp
      xx(24)= 9.26200047429274325879324277080474E-01_dp
      ww(25)= 2.87847078833233693497191796112920E-02_dp
      xx(25)=-9.60021864968307512216871025581798E-01_dp
      ww(26)= 2.87847078833233693497191796112920E-02_dp
      xx(26)= 9.60021864968307512216871025581798E-01_dp
      ww(27)= 1.84664683110909591423021319120473E-02_dp
      xx(27)=-9.83668123279747209970032581605663E-01_dp
      ww(28)= 1.84664683110909591423021319120473E-02_dp
      xx(28)= 9.83668123279747209970032581605663E-01_dp
      ww(29)= 7.96819249616660561546588347467362E-03_dp
      xx(29)=-9.96893484074649540271630050918695E-01_dp
      ww(30)= 7.96819249616660561546588347467362E-03_dp
      xx(30)= 9.96893484074649540271630050918695E-01_dp
      RETURN
   END IF
!
   IF(norder == 31)THEN
      ww(1)= 9.97205447934264514275338337343494E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 9.92250112266723078748755144286150E-02_dp
      xx(2)=-9.95553121523415203251747901189407E-02_dp
      ww(3)= 9.92250112266723078748755144286150E-02_dp
      xx(3)= 9.95553121523415203251747901189407E-02_dp
      ww(4)= 9.77433353863287250934740109789967E-02_dp
      xx(4)=-1.98121199335570628772412996032834E-01_dp
      ww(5)= 9.77433353863287250934740109789967E-02_dp
      xx(5)= 1.98121199335570628772412996032834E-01_dp
      ww(6)= 9.52902429123195128072041974875967E-02_dp
      xx(6)=-2.94718069981701616617903897671704E-01_dp
      ww(7)= 9.52902429123195128072041974875967E-02_dp
      xx(7)= 2.94718069981701616617903897671704E-01_dp
      ww(8)= 9.18901138936414782153628716071501E-02_dp
      xx(8)=-3.88385901608232943061351461287520E-01_dp
      ww(9)= 9.18901138936414782153628716071501E-02_dp
      xx(9)= 3.88385901608232943061351461287520E-01_dp
      ww(10)= 8.75767406084778761261980696953331E-02_dp
      xx(10)=-4.78193782044902480440594039356486E-01_dp
      ww(11)= 8.75767406084778761261980696953331E-02_dp
      xx(11)= 4.78193782044902480440594039356486E-01_dp
      ww(12)= 8.23929917615892639038233674319618E-02_dp
      xx(12)=-5.63249161407149262720944923595161E-01_dp
      ww(13)= 8.23929917615892639038233674319618E-02_dp
      xx(13)= 5.63249161407149262720944923595161E-01_dp
      ww(14)= 7.63903865987766164263576749013306E-02_dp
      xx(14)=-6.42706722924260346184418203232501E-01_dp
      ww(15)= 7.63903865987766164263576749013306E-02_dp
      xx(15)= 6.42706722924260346184418203232501E-01_dp
      ww(16)= 6.96285832354103661677561262551257E-02_dp
      xx(16)=-7.15776784586853283905970865366486E-01_dp
      ww(17)= 6.96285832354103661677561262551257E-02_dp
      xx(17)= 7.15776784586853283905970865366486E-01_dp
      ww(18)= 6.21747865610284269103435436866967E-02_dp
      xx(18)=-7.81733148416624940406360020194684E-01_dp
      ww(19)= 6.21747865610284269103435436866967E-02_dp
      xx(19)= 7.81733148416624940406360020194684E-01_dp
      ww(20)= 5.41030824249168537116662590866200E-02_dp
      xx(20)=-8.39920320146267340086904535940178E-01_dp
      ww(21)= 5.41030824249168537116662590866200E-02_dp
      xx(21)= 8.39920320146267340086904535940178E-01_dp
      ww(22)= 4.54937075272011029023158578946297E-02_dp
      xx(22)=-8.89760029948271043374192008982159E-01_dp
      ww(23)= 4.54937075272011029023158578946297E-02_dp
      xx(23)= 8.89760029948271043374192008982159E-01_dp
      ww(24)= 3.64322739123854640243920104678034E-02_dp
      xx(24)=-9.30756997896648164956945759729264E-01_dp
      ww(25)= 3.64322739123854640243920104678034E-02_dp
      xx(25)= 9.30756997896648164956945759729264E-01_dp
      ww(26)= 2.70090191849794218006087080919322E-02_dp
      xx(26)=-9.62503925092949661789052404105858E-01_dp
      ww(27)= 2.70090191849794218006087080919322E-02_dp
      xx(27)= 9.62503925092949661789052404105858E-01_dp
      ww(28)= 1.73186207903105824631579960868211E-02_dp
      xx(28)=-9.84685909665152484002465166734685E-01_dp
      ww(29)= 1.73186207903105824631579960868211E-02_dp
      xx(29)= 9.84685909665152484002465166734685E-01_dp
      ww(30)= 7.47083157924877585869687503221241E-03_dp
      xx(30)=-9.97087481819477074055626554223102E-01_dp
      ww(31)= 7.47083157924877585869687503221241E-03_dp
      xx(31)= 9.97087481819477074055626554223102E-01_dp
      RETURN
   END IF
!
   IF(norder == 32)THEN
      ww(1)= 9.65400885147278005667648300635758E-02_dp
      xx(1)=-4.83076656877383162348125704405022E-02_dp
      ww(2)= 9.65400885147278005667648300635758E-02_dp
      xx(2)= 4.83076656877383162348125704405022E-02_dp
      ww(3)= 9.56387200792748594190820022041311E-02_dp
      xx(3)=-1.44471961582796493485186373598811E-01_dp
      ww(4)= 9.56387200792748594190820022041311E-02_dp
      xx(4)= 1.44471961582796493485186373598811E-01_dp
      ww(5)= 9.38443990808045656391802376681173E-02_dp
      xx(5)=-2.39287362252137074544603209165502E-01_dp
      ww(6)= 9.38443990808045656391802376681173E-02_dp
      xx(6)= 2.39287362252137074544603209165502E-01_dp
      ww(7)= 9.11738786957638847128685771116371E-02_dp
      xx(7)=-3.31868602282127649779916805730188E-01_dp
      ww(8)= 9.11738786957638847128685771116371E-02_dp
      xx(8)= 3.31868602282127649779916805730188E-01_dp
      ww(9)= 8.76520930044038111427714627518023E-02_dp
      xx(9)=-4.21351276130635345364119436172426E-01_dp
      ww(10)= 8.76520930044038111427714627518023E-02_dp
      xx(10)= 4.21351276130635345364119436172426E-01_dp
      ww(11)= 8.33119242269467552221990746043486E-02_dp
      xx(11)=-5.06899908932229390023747474377821E-01_dp
      ww(12)= 8.33119242269467552221990746043486E-02_dp
      xx(12)= 5.06899908932229390023747474377821E-01_dp
      ww(13)= 7.81938957870703064717409188283067E-02_dp
      xx(13)=-5.87715757240762329040745476401827E-01_dp
      ww(14)= 7.81938957870703064717409188283067E-02_dp
      xx(14)= 5.87715757240762329040745476401827E-01_dp
      ww(15)= 7.23457941088485062253993564784878E-02_dp
      xx(15)=-6.63044266930215200975115168663238E-01_dp
      ww(16)= 7.23457941088485062253993564784878E-02_dp
      xx(16)= 6.63044266930215200975115168663238E-01_dp
      ww(17)= 6.58222227763618468376500637069388E-02_dp
      xx(17)=-7.32182118740289680387426665091267E-01_dp
      ww(18)= 6.58222227763618468376500637069388E-02_dp
      xx(18)= 7.32182118740289680387426665091267E-01_dp
      ww(19)= 5.86840934785355471452836373001709E-02_dp
      xx(19)=-7.94483795967942406963097298970429E-01_dp
      ww(20)= 5.86840934785355471452836373001709E-02_dp
      xx(20)= 7.94483795967942406963097298970429E-01_dp
      ww(21)= 5.09980592623761761961632446895217E-02_dp
      xx(21)=-8.49367613732569970133693004967743E-01_dp
      ww(22)= 5.09980592623761761961632446895217E-02_dp
      xx(22)= 8.49367613732569970133693004967743E-01_dp
      ww(23)= 4.28358980222266806568786466061255E-02_dp
      xx(23)=-8.96321155766052123965307243719212E-01_dp
      ww(24)= 4.28358980222266806568786466061255E-02_dp
      xx(24)= 8.96321155766052123965307243719212E-01_dp
      ww(25)= 3.42738629130214331026877322523727E-02_dp
      xx(25)=-9.34906075937739689170919134835409E-01_dp
      ww(26)= 3.42738629130214331026877322523727E-02_dp
      xx(26)= 9.34906075937739689170919134835409E-01_dp
      ww(27)= 2.53920653092620594557525897892240E-02_dp
      xx(27)=-9.64762255587506430773811928118275E-01_dp
      ww(28)= 2.53920653092620594557525897892240E-02_dp
      xx(28)= 9.64762255587506430773811928118275E-01_dp
      ww(29)= 1.62743947309056706051705622063866E-02_dp
      xx(29)=-9.85611511545268335400175044630902E-01_dp
      ww(30)= 1.62743947309056706051705622063866E-02_dp
      xx(30)= 9.85611511545268335400175044630902E-01_dp
      ww(31)= 7.01861000947009660040706373885318E-03_dp
      xx(31)=-9.97263861849481563544981128665041E-01_dp
      ww(32)= 7.01861000947009660040706373885318E-03_dp
      xx(32)= 9.97263861849481563544981128665041E-01_dp
      RETURN
   END IF
!
   IF(norder == 33)THEN
      ww(1)= 9.37684461602099965673045415463488E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 9.33564260655961161609991262742755E-02_dp
      xx(2)=-9.36310658547333856707429241225377E-02_dp
      ww(3)= 9.33564260655961161609991262742755E-02_dp
      xx(3)= 9.36310658547333856707429241225377E-02_dp
      ww(4)= 9.21239866433168462132409777173631E-02_dp
      xx(4)=-1.86439298827991572335798759218824E-01_dp
      ww(5)= 9.21239866433168462132409777173631E-02_dp
      xx(5)= 1.86439298827991572335798759218824E-01_dp
      ww(6)= 9.00819586606385772397437055002236E-02_dp
      xx(6)=-2.77609097152497029403248067298321E-01_dp
      ww(7)= 9.00819586606385772397437055002236E-02_dp
      xx(7)= 2.77609097152497029403248067298321E-01_dp
      ww(8)= 8.72482876188443376072816709454465E-02_dp
      xx(8)=-3.66339257748073341070220623253871E-01_dp
      ww(9)= 8.72482876188443376072816709454465E-02_dp
      xx(9)= 3.66339257748073341070220623253871E-01_dp
      ww(10)= 8.36478760670387076139280145176606E-02_dp
      xx(10)=-4.51850017272450695725993277240767E-01_dp
      ww(11)= 8.36478760670387076139280145176606E-02_dp
      xx(11)= 4.51850017272450695725993277240767E-01_dp
      ww(12)= 7.93123647948867383639083849419976E-02_dp
      xx(12)=-5.33389904786347643548894264995492E-01_dp
      ww(13)= 7.93123647948867383639083849419976E-02_dp
      xx(13)= 5.33389904786347643548894264995492E-01_dp
      ww(14)= 7.42798548439541493424721759184720E-02_dp
      xx(14)=-6.10242345836379027307287513538097E-01_dp
      ww(15)= 7.42798548439541493424721759184720E-02_dp
      xx(15)= 6.10242345836379027307287513538097E-01_dp
      ww(16)= 6.85945728186567128059550730149587E-02_dp
      xx(16)=-6.81731959969742786268215946919328E-01_dp
      ww(17)= 6.85945728186567128059550730149587E-02_dp
      xx(17)= 6.81731959969742786268215946919328E-01_dp
      ww(18)= 6.23064825303174800316277257708976E-02_dp
      xx(18)=-7.47230496449562157859055124897948E-01_dp
      ww(19)= 6.23064825303174800316277257708976E-02_dp
      xx(19)= 7.47230496449562157859055124897948E-01_dp
      ww(20)= 5.54708466316635612849444954392591E-02_dp
      xx(20)=-8.06162356274166589796200870782777E-01_dp
      ww(21)= 5.54708466316635612849444954392591E-02_dp
      xx(21)= 8.06162356274166589796200870782777E-01_dp
      ww(22)= 4.81477428187116956701468801381197E-02_dp
      xx(22)=-8.58009652676504064643061480146068E-01_dp
      ww(23)= 4.81477428187116956701468801381197E-02_dp
      xx(23)= 8.58009652676504064643061480146068E-01_dp
      ww(24)= 4.04015413316695915634097905273985E-02_dp
      xx(24)=-9.02316767743433583040531331518762E-01_dp
      ww(25)= 4.04015413316695915634097905273985E-02_dp
      xx(25)= 9.02316767743433583040531331518762E-01_dp
      ww(26)= 3.23003586323289532815614472494313E-02_dp
      xx(26)=-9.38694372611168350355835124363554E-01_dp
      ww(27)= 3.23003586323289532815614472494313E-02_dp
      xx(27)= 9.38694372611168350355835124363554E-01_dp
      ww(28)= 2.39155481017494803505332575291862E-02_dp
      xx(28)=-9.66822909689992768928377706678592E-01_dp
      ww(29)= 2.39155481017494803505332575291862E-02_dp
      xx(29)= 9.66822909689992768928377706678592E-01_dp
      ww(30)= 1.53217015129346761279457685336619E-02_dp
      xx(30)=-9.86455726230642488110375698264626E-01_dp
      ww(31)= 1.53217015129346761279457685336619E-02_dp
      xx(31)= 9.86455726230642488110375698264626E-01_dp
      ww(32)= 6.60622784758737805864923520847385E-03_dp
      xx(32)=-9.97424694246455217266168017580404E-01_dp
      ww(33)= 6.60622784758737805864923520847385E-03_dp
      xx(33)= 9.97424694246455217266168017580404E-01_dp
      RETURN
   END IF
!
   IF(norder == 34)THEN
      ww(1)= 9.09567403302598736153376039485780E-02_dp
      xx(1)=-4.55098219531025427490756708519302E-02_dp
      ww(2)= 9.09567403302598736153376039485780E-02_dp
      xx(2)= 4.55098219531025427490756708519302E-02_dp
      ww(3)= 9.02030443706407295739422420174939E-02_dp
      xx(3)=-1.36152357259182975894428824331118E-01_dp
      ww(4)= 9.02030443706407295739422420174939E-02_dp
      xx(4)= 1.36152357259182975894428824331118E-01_dp
      ww(5)= 8.87018978356938692870764573648807E-02_dp
      xx(5)=-2.25666691616449483868641180934347E-01_dp
      ww(6)= 8.87018978356938692870764573648807E-02_dp
      xx(6)= 2.25666691616449483868641180934347E-01_dp
      ww(7)= 8.64657397470357497842468562807476E-02_dp
      xx(7)=-3.13311081339463247458316765650978E-01_dp
      ww(8)= 8.64657397470357497842468562807476E-02_dp
      xx(8)= 3.13311081339463247458316765650978E-01_dp
      ww(9)= 8.35130996998456551870202280461494E-02_dp
      xx(9)=-3.98359277758645940631494752932352E-01_dp
      ww(10)= 8.35130996998456551870202280461494E-02_dp
      xx(10)= 3.98359277758645940631494752932352E-01_dp
      ww(11)= 7.98684443397718447388188328064380E-02_dp
      xx(11)=-4.80106545190327034194102680507397E-01_dp
      ww(12)= 7.98684443397718447388188328064380E-02_dp
      xx(12)= 4.80106545190327034194102680507397E-01_dp
      ww(13)= 7.55619746600319312708339742284357E-02_dp
      xx(13)=-5.57875500669746642736459886216275E-01_dp
      ww(14)= 7.55619746600319312708339742284357E-02_dp
      xx(14)= 5.57875500669746642736459886216275E-01_dp
      ww(15)= 7.06293758142557249990387965676854E-02_dp
      xx(15)=-6.31021727080528545317775755519008E-01_dp
      ww(16)= 7.06293758142557249990387965676854E-02_dp
      xx(16)= 6.31021727080528545317775755519008E-01_dp
      ww(17)= 6.51115215540764113785444300648938E-02_dp
      xx(17)=-6.98939113216262907933000106575777E-01_dp
      ww(18)= 6.51115215540764113785444300648938E-02_dp
      xx(18)= 6.98939113216262907933000106575777E-01_dp
      ww(19)= 5.90541358275244931939609723505262E-02_dp
      xx(19)=-7.61064876629873014187408968978737E-01_dp
      ww(20)= 5.90541358275244931939609723505262E-02_dp
      xx(20)= 7.61064876629873014187408968978737E-01_dp
      ww(21)= 5.25074145726781061682459748424676E-02_dp
      xx(21)=-8.16884227900933664591578906586973E-01_dp
      ww(22)= 5.25074145726781061682459748424676E-02_dp
      xx(22)= 8.16884227900933664591578906586973E-01_dp
      ww(23)= 4.55256115233532724538225633952706E-02_dp
      xx(23)=-8.65934638334564469263572090671300E-01_dp
      ww(24)= 4.55256115233532724538225633952706E-02_dp
      xx(24)= 8.65934638334564469263572090671300E-01_dp
      ww(25)= 3.81665937963875163217659202899766E-02_dp
      xx(25)=-9.07809677718324468800899889019288E-01_dp
      ww(26)= 3.81665937963875163217659202899766E-02_dp
      xx(26)= 9.07809677718324468800899889019288E-01_dp
      ww(27)= 3.04913806384461318094423876813176E-02_dp
      xx(27)=-9.42162397405107091631676025460573E-01_dp
      ww(28)= 3.04913806384461318094423876813176E-02_dp
      xx(28)= 9.42162397405107091631676025460573E-01_dp
      ww(29)= 2.25637219854949700840940887149543E-02_dp
      xx(29)=-9.68708262533344281764646573055994E-01_dp
      ww(30)= 2.25637219854949700840940887149543E-02_dp
      xx(30)= 9.68708262533344281764646573055994E-01_dp
      ww(31)= 1.44501627485950354152022103287470E-02_dp
      xx(31)=-9.87227816406309485049750431099685E-01_dp
      ww(32)= 1.44501627485950354152022103287470E-02_dp
      xx(32)= 9.87227816406309485049750431099685E-01_dp
      ww(33)= 6.22914055590868471860646107143779E-03_dp
      xx(33)=-9.97571753790841919243372437454629E-01_dp
      ww(34)= 6.22914055590868471860646107143779E-03_dp
      xx(34)= 9.97571753790841919243372437454629E-01_dp
      RETURN
   END IF
!
   IF(norder == 35)THEN
      ww(1)= 8.84867949071042906382073877776157E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 8.81405304302754629707388075930966E-02_dp
      xx(2)=-8.83713432756592636009294334975488E-02_dp
      ww(3)= 8.81405304302754629707388075930966E-02_dp
      xx(3)= 8.83713432756592636009294334975488E-02_dp
      ww(4)= 8.71044469971835342433220316055409E-02_dp
      xx(4)=-1.76051061165989569974303656445060E-01_dp
      ww(5)= 8.71044469971835342433220316055409E-02_dp
      xx(5)= 1.76051061165989569974303656445060E-01_dp
      ww(6)= 8.53866533920991252259439873911176E-02_dp
      xx(6)=-2.62352941209296057970895200455581E-01_dp
      ww(7)= 8.53866533920991252259439873911176E-02_dp
      xx(7)= 2.62352941209296057970895200455581E-01_dp
      ww(8)= 8.30005937288565883799265282161770E-02_dp
      xx(8)=-3.46601554430813945876979834930238E-01_dp
      ww(9)= 8.30005937288565883799265282161770E-02_dp
      xx(9)= 3.46601554430813945876979834930238E-01_dp
      ww(10)= 7.99649422423242629326620809850458E-02_dp
      xx(10)=-4.28137541517814254187620613001480E-01_dp
      ww(11)= 7.99649422423242629326620809850458E-02_dp
      xx(11)= 4.28137541517814254187620613001480E-01_dp
      ww(12)= 7.63034571554420535386585378842262E-02_dp
      xx(12)=-5.06322773241488615024297555837327E-01_dp
      ww(13)= 7.63034571554420535386585378842262E-02_dp
      xx(13)= 5.06322773241488615024297555837327E-01_dp
      ww(14)= 7.20447947725600646654619097852778E-02_dp
      xx(14)=-5.80545344749764509934502008189690E-01_dp
      ww(15)= 7.20447947725600646654619097852778E-02_dp
      xx(15)= 5.80545344749764509934502008189690E-01_dp
      ww(16)= 6.72222852690869039643055087481486E-02_dp
      xx(16)=-6.50224364665890388675792808984559E-01_dp
      ww(17)= 6.72222852690869039643055087481486E-02_dp
      xx(17)= 6.50224364665890388675792808984559E-01_dp
      ww(18)= 6.18736719660801888870141387886887E-02_dp
      xx(18)=-7.14814501556628783264408631224447E-01_dp
      ww(19)= 6.18736719660801888870141387886887E-02_dp
      xx(19)= 7.14814501556628783264408631224447E-01_dp
      ww(20)= 5.60408162123701285783277471651010E-02_dp
      xx(20)=-7.73810252286912555267423009209887E-01_dp
      ww(21)= 5.60408162123701285783277471651010E-02_dp
      xx(21)= 7.73810252286912555267423009209887E-01_dp
      ww(22)= 4.97693704013535298051996760849950E-02_dp
      xx(22)=-8.26749899092225406834050612748558E-01_dp
      ww(23)= 4.97693704013535298051996760849950E-02_dp
      xx(23)= 8.26749899092225406834050612748558E-01_dp
      ww(24)= 4.31084223261702187823064593749082E-02_dp
      xx(24)=-8.73219125025222331523282349141385E-01_dp
      ww(25)= 4.31084223261702187823064593749082E-02_dp
      xx(25)= 8.73219125025222331523282349141385E-01_dp
      ww(26)= 3.61101158634633805327169696475499E-02_dp
      xx(26)=-9.12854261359317614464937063555764E-01_dp
      ww(27)= 3.61101158634633805327169696475499E-02_dp
      xx(27)= 9.12854261359317614464937063555764E-01_dp
      ww(28)= 2.88292601088942540487160397144849E-02_dp
      xx(28)=-9.45345148207827329538725985529975E-01_dp
      ww(29)= 2.88292601088942540487160397144849E-02_dp
      xx(29)= 9.45345148207827329538725985529975E-01_dp
      ww(30)= 2.13229799114835808834379839662051E-02_dp
      xx(30)=-9.70437616039229833215070482584770E-01_dp
      ww(31)= 2.13229799114835808834379839662051E-02_dp
      xx(31)= 9.70437616039229833215070482584770E-01_dp
      ww(32)= 1.36508283483614922664040029205164E-02_dp
      xx(32)=-9.87935764443851498035117089185486E-01_dp
      ww(33)= 1.36508283483614922664040029205164E-02_dp
      xx(33)= 9.87935764443851498035117089185486E-01_dp
      ww(34)= 5.88343342044308497575389624011262E-03_dp
      xx(34)=-9.97706569099600297260163139312095E-01_dp
      ww(35)= 5.88343342044308497575389624011262E-03_dp
      xx(35)= 9.97706569099600297260163139312095E-01_dp
      RETURN
   END IF
!
   IF(norder == 36)THEN
      ww(1)= 8.59832756703947474900851747905266E-02_dp
      xx(1)=-4.30181984737086072269689782283634E-02_dp
      ww(2)= 8.59832756703947474900851747905266E-02_dp
      xx(2)= 4.30181984737086072269689782283634E-02_dp
      ww(3)= 8.53466857393386274918505430764898E-02_dp
      xx(3)=-1.28736103809384788651993388005152E-01_dp
      ww(4)= 8.53466857393386274918505430764898E-02_dp
      xx(4)= 1.28736103809384788651993388005152E-01_dp
      ww(5)= 8.40782189796619349334576242915958E-02_dp
      xx(5)=-2.13500892316865578943226228902714E-01_dp
      ww(6)= 8.40782189796619349334576242915958E-02_dp
      xx(6)= 2.13500892316865578943226228902714E-01_dp
      ww(7)= 8.21872667043397095172234735449423E-02_dp
      xx(7)=-2.96684995344028270503239047745170E-01_dp
      ww(8)= 8.21872667043397095172234735449423E-02_dp
      xx(8)= 2.96684995344028270503239047745170E-01_dp
      ww(9)= 7.96878289120716019087246655018639E-02_dp
      xx(9)=-3.77672547119689216322736389669908E-01_dp
      ww(10)= 7.96878289120716019087246655018639E-02_dp
      xx(10)= 3.77672547119689216322736389669908E-01_dp
      ww(11)= 7.65984106458706745287577337215016E-02_dp
      xx(11)=-4.55863944433420267207217669327441E-01_dp
      ww(12)= 7.65984106458706745287577337215016E-02_dp
      xx(12)= 4.55863944433420267207217669327441E-01_dp
      ww(13)= 7.29418850056530613538733769412742E-02_dp
      xx(13)=-5.30680285926245161640709080121570E-01_dp
      ww(14)= 7.29418850056530613538733769412742E-02_dp
      xx(14)= 5.30680285926245161640709080121570E-01_dp
      ww(15)= 6.87453238357364426136896393636132E-02_dp
      xx(15)=-6.01567658135980535079944975073595E-01_dp
      ww(16)= 6.87453238357364426136896393636132E-02_dp
      xx(16)= 6.01567658135980535079944975073595E-01_dp
      ww(17)= 6.40397973550154895563847986258563E-02_dp
      xx(17)=-6.68001236585521062097191344340918E-01_dp
      ww(18)= 6.40397973550154895563847986258563E-02_dp
      xx(18)= 6.68001236585521062097191344340918E-01_dp
      ww(19)= 5.88601442453248173096753998189200E-02_dp
      xx(19)=-7.29489171593556582090260479006109E-01_dp
      ww(20)= 5.88601442453248173096753998189200E-02_dp
      xx(20)= 7.29489171593556582090260479006109E-01_dp
      ww(21)= 5.32447139777599190920256282862196E-02_dp
      xx(21)=-7.85576230132206512827768965080293E-01_dp
      ww(22)= 5.32447139777599190920256282862196E-02_dp
      xx(22)= 7.85576230132206512827768965080293E-01_dp
      ww(23)= 4.72350834902659784166168296166748E-02_dp
      xx(23)=-8.35847166992475306418820872498601E-01_dp
      ww(24)= 4.72350834902659784166168296166748E-02_dp
      xx(24)= 8.35847166992475306418820872498601E-01_dp
      ww(25)= 4.08757509236448954741145451432632E-02_dp
      xx(25)=-8.79929800890397131982427337465836E-01_dp
      ww(26)= 4.08757509236448954741145451432632E-02_dp
      xx(26)= 8.79929800890397131982427337465836E-01_dp
      ww(27)= 3.42138107703072299212450615627146E-02_dp
      xx(27)=-9.17497774515659066075867223026156E-01_dp
      ww(28)= 3.42138107703072299212450615627146E-02_dp
      xx(28)= 9.17497774515659066075867223026156E-01_dp
      ww(29)= 2.72986214985687790944171808679834E-02_dp
      xx(29)=-9.48272984399507545202474114945228E-01_dp
      ww(30)= 2.72986214985687790944171808679834E-02_dp
      xx(30)= 9.48272984399507545202474114945228E-01_dp
      ww(31)= 2.01815152977354715320989289582211E-02_dp
      xx(31)=-9.72027691049697949335605048431108E-01_dp
      ww(32)= 2.01815152977354715320989289582211E-02_dp
      xx(32)= 9.72027691049697949335605048431108E-01_dp
      ww(33)= 1.29159472840655744045034114977916E-02_dp
      xx(33)=-9.88586478902212238073395107877107E-01_dp
      ww(34)= 1.29159472840655744045034114977916E-02_dp
      xx(34)= 9.88586478902212238073395107877107E-01_dp
      ww(35)= 5.56571966424504536125598439054784E-03_dp
      xx(35)=-9.97830462484085836198828345580750E-01_dp
      ww(36)= 5.56571966424504536125598439054784E-03_dp
      xx(36)= 9.97830462484085836198828345580750E-01_dp
      RETURN
   END IF
!
   IF(norder == 37)THEN
      ww(1)= 8.37683609931389047970173663694594E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 8.34745736258627872522530094845187E-02_dp
      xx(2)=-8.36704089547699019430483317363992E-02_dp
      ww(3)= 8.34745736258627872522530094845187E-02_dp
      xx(3)= 8.36704089547699019430483317363992E-02_dp
      ww(4)= 8.25952722364372508912303011528385E-02_dp
      xx(4)=-1.66753930239851976968671730411824E-01_dp
      ww(5)= 8.25952722364372508912303011528385E-02_dp
      xx(5)= 1.66753930239851976968671730411824E-01_dp
      ww(6)= 8.11366245084650305098776017997923E-02_dp
      xx(6)=-2.48667792791365758805567751487716E-01_dp
      ww(7)= 8.11366245084650305098776017997923E-02_dp
      xx(7)= 2.48667792791365758805567751487716E-01_dp
      ww(8)= 7.91088618375293807672121873966452E-02_dp
      xx(8)=-3.28837429883706999498471801339940E-01_dp
      ww(9)= 7.91088618375293807672121873966452E-02_dp
      xx(9)= 3.28837429883706999498471801339940E-01_dp
      ww(10)= 7.65262075705292378858879912066225E-02_dp
      xx(10)=-4.06700509318326110100931591613967E-01_dp
      ww(11)= 7.65262075705292378858879912066225E-02_dp
      xx(11)= 4.06700509318326110100931591613967E-01_dp
      ww(12)= 7.34067772484881727246266315197955E-02_dp
      xx(12)=-4.81710877803205554147192868882639E-01_dp
      ww(13)= 7.34067772484881727246266315197955E-02_dp
      xx(13)= 4.81710877803205554147192868882639E-01_dp
      ww(14)= 6.97724515557003448850813567930193E-02_dp
      xx(14)=-5.53342391861581781235098358229264E-01_dp
      ww(15)= 6.97724515557003448850813567930193E-02_dp
      xx(15)= 5.53342391861581781235098358229264E-01_dp
      ww(16)= 6.56487228727512494840237662979712E-02_dp
      xx(16)=-6.21092608408924483148152591595057E-01_dp
      ww(17)= 6.56487228727512494840237662979712E-02_dp
      xx(17)= 6.21092608408924483148152591595057E-01_dp
      ww(18)= 6.10645165232259861309881045004966E-02_dp
      xx(18)=-6.84486309130959357445523212431154E-01_dp
      ww(19)= 6.10645165232259861309881045004966E-02_dp
      xx(19)= 6.84486309130959357445523212431154E-01_dp
      ww(20)= 5.60519879982749178085392396642527E-02_dp
      xx(20)=-7.43078833981965262547047417473813E-01_dp
      ww(21)= 5.60519879982749178085392396642527E-02_dp
      xx(21)= 7.43078833981965262547047417473813E-01_dp
      ww(22)= 5.06462976548246016038758630867163E-02_dp
      xx(22)=-7.96459200509902293393046335500325E-01_dp
      ww(23)= 5.06462976548246016038758630867163E-02_dp
      xx(23)= 7.96459200509902293393046335500325E-01_dp
      ww(24)= 4.48853646624371666574103041101964E-02_dp
      xx(24)=-8.44252987340555967987456276174860E-01_dp
      ww(25)= 4.48853646624371666574103041101964E-02_dp
      xx(25)= 8.44252987340555967987456276174860E-01_dp
      ww(26)= 3.88096025019345444889623703284760E-02_dp
      xx(26)=-8.86124962155486078946149509016886E-01_dp
      ww(27)= 3.88096025019345444889623703284760E-02_dp
      xx(27)= 8.86124962155486078946149509016886E-01_dp
      ww(28)= 3.24616398475214810672342535014587E-02_dp
      xx(28)=-9.21781437412463742668143686700714E-01_dp
      ww(29)= 3.24616398475214810672342535014587E-02_dp
      xx(29)= 9.21781437412463742668143686700714E-01_dp
      ww(30)= 2.58860369905589335227594813624873E-02_dp
      xx(30)=-9.50972343262094821328576096816326E-01_dp
      ww(31)= 2.58860369905589335227594813624873E-02_dp
      xx(31)= 9.50972343262094821328576096816326E-01_dp
      ww(32)= 1.91290444890839660435019479401062E-02_dp
      xx(32)=-9.73493030056485744328890475665759E-01_dp
      ww(33)= 1.91290444890839660435019479401062E-02_dp
      xx(33)= 9.73493030056485744328890475665759E-01_dp
      ww(34)= 1.22387801003075565263048524363466E-02_dp
      xx(34)=-9.89185963214319186684099060584272E-01_dp
      ww(35)= 1.22387801003075565263048524363466E-02_dp
      xx(35)= 9.89185963214319186684099060584272E-01_dp
      ww(36)= 5.27305727949793935172205423353039E-03_dp
      xx(36)=-9.97944582477913648940803074317363E-01_dp
      ww(37)= 5.27305727949793935172205423353039E-03_dp
      xx(37)= 9.97944582477913648940803074317363E-01_dp
      RETURN
   END IF
!
   IF(norder == 38)THEN
      ww(1)= 8.15250292803857866992187698858301E-02_dp
      xx(1)=-4.07851479045782399133164323297849E-02_dp
      ww(2)= 8.15250292803857866992187698858301E-02_dp
      xx(2)= 4.07851479045782399133164323297849E-02_dp
      ww(3)= 8.09824937705971006232694699490581E-02_dp
      xx(3)=-1.22084025337867419869612381329407E-01_dp
      ww(4)= 8.09824937705971006232694699490581E-02_dp
      xx(4)= 1.22084025337867419869612381329407E-01_dp
      ww(5)= 7.99010332435278215860276839251857E-02_dp
      xx(5)=-2.02570453892116703203977781514607E-01_dp
      ww(6)= 7.99010332435278215860276839251857E-02_dp
      xx(6)= 2.02570453892116703203977781514607E-01_dp
      ww(7)= 7.82878446582109480753754033357363E-02_dp
      xx(7)=-2.81708809790165261360114071418700E-01_dp
      ww(8)= 7.82878446582109480753754033357363E-02_dp
      xx(8)= 2.81708809790165261360114071418700E-01_dp
      ww(9)= 7.61536635484463960659935411044725E-02_dp
      xx(9)=-3.58972440479435013256717621456534E-01_dp
      ww(10)= 7.61536635484463960659935411044725E-02_dp
      xx(10)= 3.58972440479435013256717621456534E-01_dp
      ww(11)= 7.35126925847434571452064448483365E-02_dp
      xx(11)=-4.33847169432376484373256162517842E-01_dp
      ww(12)= 7.35126925847434571452064448483365E-02_dp
      xx(12)= 4.33847169432376484373256162517842E-01_dp
      ww(13)= 7.03825070668989547392829675936588E-02_dp
      xx(13)=-5.05834717927931103240533716467652E-01_dp
      ww(14)= 7.03825070668989547392829675936588E-02_dp
      xx(14)= 5.05834717927931103240533716467652E-01_dp
      ww(15)= 6.67839379791404119350461515290193E-02_dp
      xx(15)=-5.74456021047807081132927500924472E-01_dp
      ww(16)= 6.67839379791404119350461515290193E-02_dp
      xx(16)= 5.74456021047807081132927500924472E-01_dp
      ww(17)= 6.27409333921330540529696715251371E-02_dp
      xx(17)=-6.39254415829681707180344869500260E-01_dp
      ww(18)= 6.27409333921330540529696715251371E-02_dp
      xx(18)= 6.39254415829681707180344869500260E-01_dp
      ww(19)= 5.82803991469972060223058682581401E-02_dp
      xx(19)=-6.99798680379184355912825840627416E-01_dp
      ww(20)= 5.82803991469972060223058682581401E-02_dp
      xx(20)= 6.99798680379184355912825840627416E-01_dp
      ww(21)= 5.34320199103323199737569906312488E-02_dp
      xx(21)=-7.55685903753970680737738096779387E-01_dp
      ww(22)= 5.34320199103323199737569906312488E-02_dp
      xx(22)= 7.55685903753970680737738096779387E-01_dp
      ww(23)= 4.82280618607586833743521799114202E-02_dp
      xx(23)=-8.06544167605316815551565375979698E-01_dp
      ww(24)= 4.82280618607586833743521799114202E-02_dp
      xx(24)= 8.06544167605316815551565375979698E-01_dp
      ww(25)= 4.27031585046744342358784343588077E-02_dp
      xx(25)=-8.52035021932362188859649711247276E-01_dp
      ww(26)= 4.27031585046744342358784343588077E-02_dp
      xx(26)= 8.52035021932362188859649711247276E-01_dp
      ww(27)= 3.68940815940247381649401623368150E-02_dp
      xx(27)=-8.91855739004632216794937031973918E-01_dp
      ww(28)= 3.68940815940247381649401623368150E-02_dp
      xx(28)= 8.91855739004632216794937031973918E-01_dp
      ww(29)= 3.08395005451750546587310863133087E-02_dp
      xx(29)=-9.25741332048584396825109562213051E-01_dp
      ww(30)= 3.08395005451750546587310863133087E-02_dp
      xx(30)= 9.25741332048584396825109562213051E-01_dp
      ww(31)= 2.45797397382323758952012054467063E-02_dp
      xx(31)=-9.53466330933529595670542153117441E-01_dp
      ww(32)= 2.45797397382323758952012054467063E-02_dp
      xx(32)= 9.53466330933529595670542153117441E-01_dp
      ww(33)= 1.81565777096132368988761257547822E-02_dp
      xx(33)=-9.74846328590153507640885540946389E-01_dp
      ww(34)= 1.81565777096132368988761257547822E-02_dp
      xx(34)= 9.74846328590153507640885540946389E-01_dp
      ww(35)= 1.16134447164686741776683012004374E-02_dp
      xx(35)=-9.89739454266385571944425891105679E-01_dp
      ww(36)= 1.16134447164686741776683012004374E-02_dp
      xx(36)= 9.89739454266385571944425891105679E-01_dp
      ww(37)= 5.00288074963934567589954209189937E-03_dp
      xx(37)=-9.98049930535687619812847076551581E-01_dp
      ww(38)= 5.00288074963934567589954209189937E-03_dp
      xx(38)= 9.98049930535687619812847076551581E-01_dp
      RETURN
   END IF
!
   IF(norder == 39)THEN
      ww(1)= 7.95276221394428524174181966058510E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 7.92762225683684710101557717545079E-02_dp
      xx(2)=-7.94438046087554775819170831926407E-02_dp
      ww(3)= 7.92762225683684710101557717545079E-02_dp
      xx(3)= 7.94438046087554775819170831926407E-02_dp
      ww(4)= 7.85236132873711767250633009855235E-02_dp
      xx(4)=-1.58385339997837799922701061361399E-01_dp
      ww(5)= 7.85236132873711767250633009855235E-02_dp
      xx(5)= 1.58385339997837799922701061361399E-01_dp
      ww(6)= 7.72745525446820167285116367331173E-02_dp
      xx(6)=-2.36325512461835767336006327332650E-01_dp
      ww(7)= 7.72745525446820167285116367331173E-02_dp
      xx(7)= 2.36325512461835767336006327332650E-01_dp
      ww(8)= 7.55369373228360577047844469908094E-02_dp
      xx(8)=-3.12771559248185922535996911785629E-01_dp
      ww(9)= 7.55369373228360577047844469908094E-02_dp
      xx(9)= 3.12771559248185922535996911785629E-01_dp
      ww(10)= 7.33217534142686173811539328650483E-02_dp
      xx(10)=-3.87240163971561455853881965636963E-01_dp
      ww(11)= 7.33217534142686173811539328650483E-02_dp
      xx(11)= 3.87240163971561455853881965636963E-01_dp
      ww(12)= 7.06430059706087607701149315281311E-02_dp
      xx(12)=-4.59260512309136048663246633109572E-01_dp
      ww(13)= 7.06430059706087607701149315281311E-02_dp
      xx(13)= 4.59260512309136048663246633109572E-01_dp
      ww(14)= 6.75176309662312653630213280464486E-02_dp
      xx(14)=-5.28377268660437473896343635808223E-01_dp
      ww(15)= 6.75176309662312653630213280464486E-02_dp
      xx(15)= 5.28377268660437473896343635808223E-01_dp
      ww(16)= 6.39653881386823889867064044100636E-02_dp
      xx(16)=-5.94153454957277988692890074619106E-01_dp
      ww(17)= 6.39653881386823889867064044100636E-02_dp
      xx(17)= 5.94153454957277988692890074619106E-01_dp
      ww(18)= 6.00087360885961495749417735488195E-02_dp
      xx(18)=-6.56173213432010910734425934976256E-01_dp
      ww(19)= 6.00087360885961495749417735488195E-02_dp
      xx(19)= 6.56173213432010910734425934976256E-01_dp
      ww(20)= 5.56726903409162999073911397896815E-02_dp
      xx(20)=-7.14044435894534679133867036151831E-01_dp
      ww(21)= 5.56726903409162999073911397896815E-02_dp
      xx(21)= 7.14044435894534679133867036151831E-01_dp
      ww(22)= 5.09846652921294052140210336765813E-02_dp
      xx(22)=-7.67401242931063499832272404228343E-01_dp
      ww(23)= 5.09846652921294052140210336765813E-02_dp
      xx(23)= 7.67401242931063499832272404228343E-01_dp
      ww(24)= 4.59743011089166318841766393992328E-02_dp
      xx(24)=-8.15906297430143104353232678409630E-01_dp
      ww(25)= 4.59743011089166318841766393992328E-02_dp
      xx(25)= 8.15906297430143104353232678409630E-01_dp
      ww(26)= 4.06732768479338439390565560822614E-02_dp
      xx(26)=-8.59252937999906153913797439126042E-01_dp
      ww(27)= 4.06732768479338439390565560822614E-02_dp
      xx(27)= 8.59252937999906153913797439126042E-01_dp
      ww(28)= 3.51151114981313307610651852972328E-02_dp
      xx(28)=-8.97167119292992887848291090860814E-01_dp
      ww(29)= 3.51151114981313307610651852972328E-02_dp
      xx(29)= 8.97167119292992887848291090860814E-01_dp
      ww(30)= 2.93349559839033785921559863562514E-02_dp
      xx(30)=-9.29409148486738229697816964357735E-01_dp
      ww(31)= 2.93349559839033785921559863562514E-02_dp
      xx(31)= 9.29409148486738229697816964357735E-01_dp
      ww(32)= 2.33693848321781645947123444429247E-02_dp
      xx(32)=-9.55775212324652277110891897191082E-01_dp
      ww(33)= 2.33693848321781645947123444429247E-02_dp
      xx(33)= 9.55775212324652277110891897191082E-01_dp
      ww(34)= 1.72562290937249190408054711833550E-02_dp
      xx(34)=-9.76098709333471053844850319889518E-01_dp
      ww(35)= 1.72562290937249190408054711833550E-02_dp
      xx(35)= 9.76098709333471053844850319889518E-01_dp
      ww(36)= 1.10347889391645942426768054521773E-02_dp
      xx(36)=-9.90251536854685983639775117247078E-01_dp
      ww(37)= 1.10347889391645942426768054521773E-02_dp
      xx(37)= 9.90251536854685983639775117247078E-01_dp
      ww(38)= 4.75294469163510137077621315490694E-03_dp
      xx(38)=-9.98147383066432906005472302851820E-01_dp
      ww(39)= 4.75294469163510137077621315490694E-03_dp
      xx(39)= 9.98147383066432906005472302851820E-01_dp
      RETURN
   END IF
!
   IF(norder == 40)THEN
      ww(1)= 7.75059479784248112637239629583263E-02_dp
      xx(1)=-3.87724175060508219331934440246233E-02_dp
      ww(2)= 7.75059479784248112637239629583263E-02_dp
      xx(2)= 3.87724175060508219331934440246233E-02_dp
      ww(3)= 7.70398181642479655883075342838103E-02_dp
      xx(3)=-1.16084070675255208483451284408024E-01_dp
      ww(4)= 7.70398181642479655883075342838103E-02_dp
      xx(4)= 1.16084070675255208483451284408024E-01_dp
      ww(5)= 7.61103619006262423715580759224948E-02_dp
      xx(5)=-1.92697580701371099715516852065150E-01_dp
      ww(6)= 7.61103619006262423715580759224948E-02_dp
      xx(6)= 1.92697580701371099715516852065150E-01_dp
      ww(7)= 7.47231690579682642001893362613247E-02_dp
      xx(7)=-2.68152185007253681141184344808596E-01_dp
      ww(8)= 7.47231690579682642001893362613247E-02_dp
      xx(8)= 2.68152185007253681141184344808596E-01_dp
      ww(9)= 7.28865823958040590605106834425178E-02_dp
      xx(9)=-3.41994090825758473007492481179194E-01_dp
      ww(10)= 7.28865823958040590605106834425178E-02_dp
      xx(10)= 3.41994090825758473007492481179194E-01_dp
      ww(11)= 7.06116473912867796954836308552868E-02_dp
      xx(11)=-4.13779204371605001524879745803714E-01_dp
      ww(12)= 7.06116473912867796954836308552868E-02_dp
      xx(12)= 4.13779204371605001524879745803714E-01_dp
      ww(13)= 6.79120458152339038256901082319240E-02_dp
      xx(13)=-4.83075801686178712908566574244823E-01_dp
      ww(14)= 6.79120458152339038256901082319240E-02_dp
      xx(14)= 4.83075801686178712908566574244823E-01_dp
      ww(15)= 6.48040134566010380745545295667527E-02_dp
      xx(15)=-5.49467125095128202075931305529518E-01_dp
      ww(16)= 6.48040134566010380745545295667527E-02_dp
      xx(16)= 5.49467125095128202075931305529518E-01_dp
      ww(17)= 6.13062424929289391665379964083986E-02_dp
      xx(17)=-6.12553889667980237952612450230695E-01_dp
      ww(18)= 6.13062424929289391665379964083986E-02_dp
      xx(18)= 6.12553889667980237952612450230695E-01_dp
      ww(19)= 5.74397690993915513666177309104260E-02_dp
      xx(19)=-6.71956684614179548379354514961494E-01_dp
      ww(20)= 5.74397690993915513666177309104260E-02_dp
      xx(20)= 6.71956684614179548379354514961494E-01_dp
      ww(21)= 5.32278469839368243549964797722605E-02_dp
      xx(21)=-7.27318255189927103280996451754931E-01_dp
      ww(22)= 5.32278469839368243549964797722605E-02_dp
      xx(22)= 7.27318255189927103280996451754931E-01_dp
      ww(23)= 4.86958076350722320614341604481464E-02_dp
      xx(23)=-7.78305651426519387694971545506495E-01_dp
      ww(24)= 4.86958076350722320614341604481464E-02_dp
      xx(24)= 7.78305651426519387694971545506495E-01_dp
      ww(25)= 4.38709081856732719916746860417155E-02_dp
      xx(25)=-8.24612230833311663196320230666099E-01_dp
      ww(26)= 4.38709081856732719916746860417155E-02_dp
      xx(26)= 8.24612230833311663196320230666099E-01_dp
      ww(27)= 3.87821679744720176399720312904462E-02_dp
      xx(27)=-8.65959503212259503820781808354620E-01_dp
      ww(28)= 3.87821679744720176399720312904462E-02_dp
      xx(28)= 8.65959503212259503820781808354620E-01_dp
      ww(29)= 3.34601952825478473926781830864109E-02_dp
      xx(29)=-9.02098806968874296728253330868493E-01_dp
      ww(30)= 3.34601952825478473926781830864109E-02_dp
      xx(30)= 9.02098806968874296728253330868493E-01_dp
      ww(31)= 2.79370069800234010984891575077211E-02_dp
      xx(31)=-9.32812808278676533360852166845206E-01_dp
      ww(32)= 2.79370069800234010984891575077211E-02_dp
      xx(32)= 9.32812808278676533360852166845206E-01_dp
      ww(33)= 2.22458491941669572615043241842086E-02_dp
      xx(33)=-9.57916819213791655804540999452759E-01_dp
      ww(34)= 2.22458491941669572615043241842086E-02_dp
      xx(34)= 9.57916819213791655804540999452759E-01_dp
      ww(35)= 1.64210583819078887128634848823639E-02_dp
      xx(35)=-9.77259949983774262663370283712904E-01_dp
      ww(36)= 1.64210583819078887128634848823639E-02_dp
      xx(36)= 9.77259949983774262663370283712904E-01_dp
      ww(37)= 1.04982845311528136147421710672797E-02_dp
      xx(37)=-9.90726238699457006453054352221372E-01_dp
      ww(38)= 1.04982845311528136147421710672797E-02_dp
      xx(38)= 9.90726238699457006453054352221372E-01_dp
      ww(39)= 4.52127709853319125847173287818533E-03_dp
      xx(39)=-9.98237709710559200349622702420586E-01_dp
      ww(40)= 4.52127709853319125847173287818533E-03_dp
      xx(40)= 9.98237709710559200349622702420586E-01_dp
      RETURN
   END IF
!
   IF(norder == 41)THEN
      ww(1)= 7.56955356472983723187799610763603E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 7.54787470927158240272470626746167E-02_dp
      xx(2)=-7.56232589891629969237661936512003E-02_dp
      ww(3)= 7.54787470927158240272470626746167E-02_dp
      xx(3)= 7.56232589891629969237661936512003E-02_dp
      ww(4)= 7.48296231762215518913050726335053E-02_dp
      xx(4)=-1.50813354863992163574377967884582E-01_dp
      ww(5)= 7.48296231762215518913050726335053E-02_dp
      xx(5)= 1.50813354863992163574377967884582E-01_dp
      ww(6)= 7.37518820272234699392808183248487E-02_dp
      xx(6)=-2.25139605633422775605786256655472E-01_dp
      ww(7)= 7.37518820272234699392808183248487E-02_dp
      xx(7)= 2.25139605633422775605786256655472E-01_dp
      ww(8)= 7.22516968610230733963463983487874E-02_dp
      xx(8)=-2.98176277341824865922982880478924E-01_dp
      ww(9)= 7.22516968610230733963463983487874E-02_dp
      xx(9)= 2.98176277341824865922982880478924E-01_dp
      ww(10)= 7.03376606208174974816589899698815E-02_dp
      xx(10)=-3.69505022640481441428366913299935E-01_dp
      ww(11)= 7.03376606208174974816589899698815E-02_dp
      xx(11)= 3.69505022640481441428366913299935E-01_dp
      ww(12)= 6.80207367608767667355332397262489E-02_dp
      xx(12)=-4.38717277051407088517119856728039E-01_dp
      ww(13)= 6.80207367608767667355332397262489E-02_dp
      xx(13)= 4.38717277051407088517119856728039E-01_dp
      ww(14)= 6.53141964535274104361637126537963E-02_dp
      xx(14)=-5.05416599199406032708336070202695E-01_dp
      ww(15)= 6.53141964535274104361637126537963E-02_dp
      xx(15)= 5.05416599199406032708336070202695E-01_dp
      ww(16)= 6.22335425809663164715734170833465E-02_dp
      xx(16)=-5.69220941610215869654747215282980E-01_dp
      ww(17)= 6.22335425809663164715734170833465E-02_dp
      xx(17)= 5.69220941610215869654747215282980E-01_dp
      ww(18)= 5.87964209498719449911858533807343E-02_dp
      xx(18)=-6.29764839072196320488649091695104E-01_dp
      ww(19)= 5.87964209498719449911858533807343E-02_dp
      xx(19)= 6.29764839072196320488649091695104E-01_dp
      ww(20)= 5.50225192425787418801468101714223E-02_dp
      xx(20)=-6.86701502034951289584603856529135E-01_dp
      ww(21)= 5.50225192425787418801468101714223E-02_dp
      xx(21)= 6.86701502034951289584603856529135E-01_dp
      ww(22)= 5.09334542946174947811703571156886E-02_dp
      xx(22)=-7.39704803069926181060168744468559E-01_dp
      ww(23)= 5.09334542946174947811703571156886E-02_dp
      xx(23)= 7.39704803069926181060168744468559E-01_dp
      ww(24)= 4.65526483690143420607565868646114E-02_dp
      xx(24)=-7.88471145047409372736221781466770E-01_dp
      ww(25)= 4.65526483690143420607565868646114E-02_dp
      xx(25)= 7.88471145047409372736221781466770E-01_dp
      ww(26)= 4.19051951959096894293402743110488E-02_dp
      xx(26)=-8.32721200401361331244272779048544E-01_dp
      ww(27)= 4.19051951959096894293402743110488E-02_dp
      xx(27)= 8.32721200401361331244272779048544E-01_dp
      ww(28)= 3.70177167035079884352612515801607E-02_dp
      xx(28)=-8.72201511692441408833670574234329E-01_dp
      ww(29)= 3.70177167035079884352612515801607E-02_dp
      xx(29)= 8.72201511692441408833670574234329E-01_dp
      ww(30)= 3.19182117316992817870669468571455E-02_dp
      xx(30)=-9.06685944758101172958340413230723E-01_dp
      ww(31)= 3.19182117316992817870669468571455E-02_dp
      xx(31)= 9.06685944758101172958340413230723E-01_dp
      ww(32)= 2.66358992071104454675485752587133E-02_dp
      xx(32)=-9.35976987497853825682318275284766E-01_dp
      ww(33)= 2.66358992071104454675485752587133E-02_dp
      xx(33)= 9.35976987497853825682318275284766E-01_dp
      ww(34)= 2.12010633687795530756970334933766E-02_dp
      xx(34)=-9.59906891730346226099441696068687E-01_dp
      ww(35)= 2.12010633687795530756970334933766E-02_dp
      xx(35)= 9.59906891730346226099441696068687E-01_dp
      ww(36)= 1.56449384078185885308268444795337E-02_dp
      xx(36)=-9.78338673561083384469170706673967E-01_dp
      ww(37)= 1.56449384078185885308268444795337E-02_dp
      xx(37)= 9.78338673561083384469170706673967E-01_dp
      ww(38)= 9.99993877390594533849629662969884E-03_dp
      xx(38)=-9.91167109699016308250158894573170E-01_dp
      ww(39)= 9.99993877390594533849629662969884E-03_dp
      xx(39)= 9.91167109699016308250158894573170E-01_dp
      ww(40)= 4.30614035816488768400447790465449E-03_dp
      xx(40)=-9.98321588574771441519188508088378E-01_dp
      ww(41)= 4.30614035816488768400447790465449E-03_dp
      xx(41)= 9.98321588574771441519188508088378E-01_dp
      RETURN
   END IF
!
   IF(norder == 42)THEN
      ww(1)= 7.38642342321728799963855611497914E-02_dp
      xx(1)=-3.69489431653517758130959800375594E-02_dp
      ww(2)= 7.38642342321728799963855611497914E-02_dp
      xx(2)= 3.69489431653517758130959800375594E-02_dp
      ww(3)= 7.34608134534675282640282570543039E-02_dp
      xx(3)=-1.10645027208519868349122545002641E-01_dp
      ww(4)= 7.34608134534675282640282570543039E-02_dp
      xx(4)= 1.10645027208519868349122545002641E-01_dp
      ww(5)= 7.26561752438041048879057614925330E-02_dp
      xx(5)=-1.83736806564854550852755639380743E-01_dp
      ww(6)= 7.26561752438041048879057614925330E-02_dp
      xx(6)= 1.83736806564854550852755639380743E-01_dp
      ww(7)= 7.14547142651709829218104441174622E-02_dp
      xx(7)=-2.55825079342879083966414791018708E-01_dp
      ww(8)= 7.14547142651709829218104441174622E-02_dp
      xx(8)= 2.55825079342879083966414791018708E-01_dp
      ww(9)= 6.98629924925941597661547863814822E-02_dp
      xx(9)=-3.26516124465411512197156589375466E-01_dp
      ww(10)= 6.98629924925941597661547863814822E-02_dp
      xx(10)= 3.26516124465411512197156589375466E-01_dp
      ww(11)= 6.78897033765219448553634022137663E-02_dp
      xx(11)=-3.95423852042975057677093954594372E-01_dp
      ww(12)= 6.78897033765219448553634022137663E-02_dp
      xx(12)= 3.95423852042975057677093954594372E-01_dp
      ww(13)= 6.55456243649089789270051078517944E-02_dp
      xx(13)=-4.62171912070421929759075029930636E-01_dp
      ww(14)= 6.55456243649089789270051078517944E-02_dp
      xx(14)= 4.62171912070421929759075029930636E-01_dp
      ww(15)= 6.28435580450025764093182513237799E-02_dp
      xx(15)=-5.26395749931192287592867558791901E-01_dp
      ww(16)= 6.28435580450025764093182513237799E-02_dp
      xx(16)= 5.26395749931192287592867558791901E-01_dp
      ww(17)= 5.97982622275866543128315457535348E-02_dp
      xx(17)=-5.87744597485109322840711345473996E-01_dp
      ww(18)= 5.97982622275866543128315457535348E-02_dp
      xx(18)= 5.87744597485109322840711345473996E-01_dp
      ww(19)= 5.64263693580183816464268551396957E-02_dp
      xx(19)=-6.45883388869247833957496303718412E-01_dp
      ww(20)= 5.64263693580183816464268551396957E-02_dp
      xx(20)= 6.45883388869247833957496303718412E-01_dp
      ww(21)= 5.27462956991740703439425390440975E-02_dp
      xx(21)=-7.00494590556171213741569929055466E-01_dp
      ww(22)= 5.27462956991740703439425390440975E-02_dp
      xx(22)= 7.00494590556171213741569929055466E-01_dp
      ww(23)= 4.87781407928032450274493631284027E-02_dp
      xx(23)=-7.51279935689480489568472175914659E-01_dp
      ww(24)= 4.87781407928032450274493631284027E-02_dp
      xx(24)= 7.51279935689480489568472175914659E-01_dp
      ww(25)= 4.45435777719658778743163659852342E-02_dp
      xx(25)=-7.97962053255487413232705952546377E-01_dp
      ww(26)= 4.45435777719658778743163659852342E-02_dp
      xx(26)= 7.97962053255487413232705952546377E-01_dp
      ww(27)= 4.00657351806922617605961248300369E-02_dp
      xx(27)=-8.40285983261816900925439995086100E-01_dp
      ww(28)= 4.00657351806922617605961248300369E-02_dp
      xx(28)= 8.40285983261816900925439995086100E-01_dp
      ww(29)= 3.53690710975921108326621811265075E-02_dp
      xx(29)=-8.78020569812172742711985103478624E-01_dp
      ww(30)= 3.53690710975921108326621811265075E-02_dp
      xx(30)= 8.78020569812172742711985103478624E-01_dp
      ww(31)= 3.04792406996034683629047335233924E-02_dp
      xx(31)=-9.10959724904127452583847879208507E-01_dp
      ww(32)= 3.04792406996034683629047335233924E-02_dp
      xx(32)= 9.10959724904127452583847879208507E-01_dp
      ww(33)= 2.54229595261130478867424429094309E-02_dp
      xx(33)=-9.38923557354988178533173433625592E-01_dp
      ww(34)= 2.54229595261130478867424429094309E-02_dp
      xx(34)= 9.38923557354988178533173433625592E-01_dp
      ww(35)= 2.02278695690526447570557190793542E-02_dp
      xx(35)=-9.61759365338204488746927157853323E-01_dp
      ww(36)= 2.02278695690526447570557190793542E-02_dp
      xx(36)= 9.61759365338204488746927157853323E-01_dp
      ww(37)= 1.49224436973574941446776781058658E-02_dp
      xx(37)=-9.79342508063748193708982566542856E-01_dp
      ww(38)= 1.49224436973574941446776781058658E-02_dp
      xx(38)= 9.79342508063748193708982566542856E-01_dp
      ww(39)= 9.53622030174850241182010029269800E-03_dp
      xx(39)=-9.91577288340860919792361253280869E-01_dp
      ww(40)= 9.53622030174850241182010029269800E-03_dp
      xx(40)= 9.91577288340860919792361253280869E-01_dp
      ww(41)= 4.10599860464908461060277949683596E-03_dp
      xx(41)=-9.98399618990062415022868126847050E-01_dp
      ww(42)= 4.10599860464908461060277949683596E-03_dp
      xx(42)= 9.98399618990062415022868126847050E-01_dp
      RETURN
   END IF
!
   IF(norder == 43)THEN
      ww(1)= 7.22157516937989879774623317137369E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 7.20275019714219743453075516708571E-02_dp
      xx(2)=-7.21529908745862354223272509555611E-02_dp
      ww(3)= 7.20275019714219743453075516708571E-02_dp
      xx(3)= 7.21529908745862354223272509555611E-02_dp
      ww(4)= 7.14637342525141412975811177029102E-02_dp
      xx(4)=-1.43929809510713310770299937610745E-01_dp
      ww(5)= 7.14637342525141412975811177029102E-02_dp
      xx(5)= 1.43929809510713310770299937610745E-01_dp
      ww(6)= 7.05273877650850281262863554779407E-02_dp
      xx(6)=-2.14956244860518209014878381473675E-01_dp
      ww(7)= 7.05273877650850281262863554779407E-02_dp
      xx(7)= 2.14956244860518209014878381473675E-01_dp
      ww(8)= 6.92233441936566842822994791226351E-02_dp
      xx(8)=-2.84861998032913627105722894838338E-01_dp
      ww(9)= 6.92233441936566842822994791226351E-02_dp
      xx(9)= 2.84861998032913627105722894838338E-01_dp
      ww(10)= 6.75584022293651691924079047562656E-02_dp
      xx(10)=-3.53282612864303806645476364143468E-01_dp
      ww(11)= 6.75584022293651691924079047562656E-02_dp
      xx(11)= 3.53282612864303806645476364143468E-01_dp
      ww(12)= 6.55412421263227974912337642492078E-02_dp
      xx(12)=-4.19861376029269252487279394560568E-01_dp
      ww(13)= 6.55412421263227974912337642492078E-02_dp
      xx(13)= 4.19861376029269252487279394560568E-01_dp
      ww(14)= 6.31823804493961123256298177734083E-02_dp
      xx(14)=-4.84251176785734724069633434748514E-01_dp
      ww(15)= 6.31823804493961123256298177734083E-02_dp
      xx(15)= 4.84251176785734724069633434748514E-01_dp
      ww(16)= 6.04941152499912945196787419913628E-02_dp
      xx(16)=-5.46116316660084719140405047179661E-01_dp
      ww(17)= 6.04941152499912945196787419913628E-02_dp
      xx(17)= 5.46116316660084719140405047179661E-01_dp
      ww(18)= 5.74904619569105194276089168444165E-02_dp
      xx(18)=-6.05134259639600935725083071123955E-01_dp
      ww(19)= 5.74904619569105194276089168444165E-02_dp
      xx(19)= 6.05134259639600935725083071123955E-01_dp
      ww(20)= 5.41870803188817868633731783262654E-02_dp
      xx(20)=-6.60997313751498133165134763741345E-01_dp
      ww(21)= 5.41870803188817868633731783262654E-02_dp
      xx(21)= 6.60997313751498133165134763741345E-01_dp
      ww(22)= 5.06011927843901565238503989530147E-02_dp
      xx(22)=-7.13414235268957054851920877990904E-01_dp
      ww(23)= 5.06011927843901565238503989530147E-02_dp
      xx(23)= 7.13414235268957054851920877990904E-01_dp
      ww(24)= 4.67514947543465800106467663371029E-02_dp
      xx(24)=-7.62111747194955121460328463029046E-01_dp
      ww(25)= 4.67514947543465800106467663371029E-02_dp
      xx(25)= 7.62111747194955121460328463029046E-01_dp
      ww(26)= 4.26580571979820837638072053385139E-02_dp
      xx(26)=-8.06835964136938635279074740877512E-01_dp
      ww(27)= 4.26580571979820837638072053385139E-02_dp
      xx(27)= 8.06835964136938635279074740877512E-01_dp
      ww(28)= 3.83422221941326575721284246628491E-02_dp
      xx(28)=-8.47353716209315048999086085821792E-01_dp
      ww(29)= 3.83422221941326575721284246628491E-02_dp
      xx(29)= 8.47353716209315048999086085821792E-01_dp
      ww(30)= 3.38264920868602923449684757538021E-02_dp
      xx(30)=-8.83453765218616863337678011642167E-01_dp
      ww(31)= 3.38264920868602923449684757538021E-02_dp
      xx(31)= 8.83453765218616863337678011642167E-01_dp
      ww(32)= 2.91344132614984949159404248257812E-02_dp
      xx(32)=-9.14947907206138729456102870799286E-01_dp
      ww(33)= 2.91344132614984949159404248257812E-02_dp
      xx(33)= 9.14947907206138729456102870799286E-01_dp
      ww(34)= 2.42904566138388159020183242542492E-02_dp
      xx(34)=-9.41671956847637861818477390397938E-01_dp
      ww(35)= 2.42904566138388159020183242542492E-02_dp
      xx(35)= 9.41671956847637861818477390397938E-01_dp
      ww(36)= 1.93199014236839003961246108920714E-02_dp
      xx(36)=-9.63486613014079993410194963574244E-01_dp
      ww(37)= 1.93199014236839003961246108920714E-02_dp
      xx(37)= 9.63486613014079993410194963574244E-01_dp
      ww(38)= 1.42487564315764861085416017220042E-02_dp
      xx(38)=-9.80278220980255331505529382181136E-01_dp
      ww(39)= 1.42487564315764861085416017220042E-02_dp
      xx(39)= 9.80278220980255331505529382181136E-01_dp
      ww(40)= 9.10399663740140331886860829589672E-03_dp
      xx(40)=-9.91959557593244146420718341329618E-01_dp
      ww(41)= 9.10399663740140331886860829589672E-03_dp
      xx(41)= 9.91959557593244146420718341329618E-01_dp
      ww(42)= 3.91949025384412728296716519257644E-03_dp
      xx(42)=-9.98472332242507713517636187318392E-01_dp
      ww(43)= 3.91949025384412728296716519257644E-03_dp
      xx(43)= 9.98472332242507713517636187318392E-01_dp
      RETURN
   END IF
!
   IF(norder == 44)THEN
      ww(1)= 7.05491577893540688113382874802999E-02_dp
      xx(1)=-3.52892369641353590581967046314164E-02_dp
      ww(2)= 7.05491577893540688113382874802999E-02_dp
      xx(2)= 3.52892369641353590581967046314164E-02_dp
      ww(3)= 7.01976854735582125871420419443994E-02_dp
      xx(3)=-1.05691901708653247117305848915122E-01_dp
      ww(4)= 7.01976854735582125871420419443994E-02_dp
      xx(4)= 1.05691901708653247117305848915122E-01_dp
      ww(5)= 6.94964918615725780370840909250113E-02_dp
      xx(5)=-1.75568014775516785746507749380977E-01_dp
      ww(6)= 6.94964918615725780370840909250113E-02_dp
      xx(6)= 1.75568014775516785746507749380977E-01_dp
      ww(7)= 6.84490702693666609854586607043499E-02_dp
      xx(7)=-2.44569456928201251507302434740519E-01_dp
      ww(8)= 6.84490702693666609854586607043499E-02_dp
      xx(8)= 2.44569456928201251507302434740519E-01_dp
      ww(9)= 6.70606389062936523957049193517194E-02_dp
      xx(9)=-3.12352466502785812236545163572979E-01_dp
      ww(10)= 6.70606389062936523957049193517194E-02_dp
      xx(10)= 3.12352466502785812236545163572979E-01_dp
      ww(11)= 6.53381148791814349842408948456222E-02_dp
      xx(11)=-3.78579352014707132511764672772198E-01_dp
      ww(12)= 6.53381148791814349842408948456222E-02_dp
      xx(12)= 3.78579352014707132511764672772198E-01_dp
      ww(13)= 6.32900797332038549501388710197149E-02_dp
      xx(13)=-4.42920174525411483834826593647314E-01_dp
      ww(14)= 6.32900797332038549501388710197149E-02_dp
      xx(14)= 4.42920174525411483834826593647314E-01_dp
      ww(15)= 6.09267367015619680385578368743741E-02_dp
      xx(15)=-5.05054391388202317982798352291177E-01_dp
      ww(16)= 6.09267367015619680385578368743741E-02_dp
      xx(16)= 5.05054391388202317982798352291177E-01_dp
      ww(17)= 5.82598598775954953342106898442772E-02_dp
      xx(17)=-5.64672453185470768424636819382075E-01_dp
      ww(18)= 5.82598598775954953342106898442772E-02_dp
      xx(18)= 5.64672453185470768424636819382075E-01_dp
      ww(19)= 5.53027355637280525487466326431530E-02_dp
      xx(19)=-6.21477345903575847802424699121767E-01_dp
      ww(20)= 5.53027355637280525487466326431530E-02_dp
      xx(20)= 6.21477345903575847802424699121767E-01_dp
      ww(21)= 5.20700960917044618812318029931988E-02_dp
      xx(21)=-6.75186070666122365333699038563900E-01_dp
      ww(22)= 5.20700960917044618812318029931988E-02_dp
      xx(22)= 6.75186070666122365333699038563900E-01_dp
      ww(23)= 4.85780464483520375276394366912927E-02_dp
      xx(23)=-7.25531053660717002606964936719954E-01_dp
      ww(24)= 4.85780464483520375276394366912927E-02_dp
      xx(24)= 7.25531053660717002606964936719954E-01_dp
      ww(25)= 4.48439840819700314462431864030511E-02_dp
      xx(25)=-7.72261479248755899017758549231988E-01_dp
      ww(26)= 4.48439840819700314462431864030511E-02_dp
      xx(26)= 7.72261479248755899017758549231988E-01_dp
      ww(27)= 4.08865123103462189084471692830685E-02_dp
      xx(27)=-8.15144539645135010487437635751941E-01_dp
      ww(28)= 4.08865123103462189084471692830685E-02_dp
      xx(28)= 8.15144539645135010487437635751941E-01_dp
      ww(29)= 3.67253478138088736429092923487018E-02_dp
      xx(29)=-8.53966595004710378728302241292684E-01_dp
      ww(30)= 3.67253478138088736429092923487018E-02_dp
      xx(30)= 8.53966595004710378728302241292684E-01_dp
      ww(31)= 3.23812228120698208808469395401116E-02_dp
      xx(31)=-8.88534238286043202338367910190322E-01_dp
      ww(32)= 3.23812228120698208808469395401116E-02_dp
      xx(32)= 8.88534238286043202338367910190322E-01_dp
      ww(33)= 2.78757828212810100811142917793871E-02_dp
      xx(33)=-9.18675259984175774323001086694252E-01_dp
      ww(34)= 2.78757828212810100811142917793871E-02_dp
      xx(34)= 9.18675259984175774323001086694252E-01_dp
      ww(35)= 2.32314819020192106289582629387314E-02_dp
      xx(35)=-9.44239509118194099203254653026989E-01_dp
      ww(36)= 2.32314819020192106289582629387314E-02_dp
      xx(36)= 9.44239509118194099203254653026989E-01_dp
      ww(37)= 1.84714817368147491720422237433998E-02_dp
      xx(37)=-9.65099650422493139394398050580235E-01_dp
      ww(38)= 1.84714817368147491720422237433998E-02_dp
      xx(38)= 9.65099650422493139394398050580235E-01_dp
      ww(39)= 1.36195867555799855202050663900614E-02_dp
      xx(39)=-9.81151833077913966662749005350488E-01_dp
      ww(40)= 1.36195867555799855202050663900614E-02_dp
      xx(40)= 9.81151833077913966662749005350488E-01_dp
      ww(41)= 8.70048136752484412256562342431314E-03_dp
      xx(41)=-9.92316392138515808483338003613539E-01_dp
      ww(42)= 8.70048136752484412256562342431314E-03_dp
      xx(42)= 9.92316392138515808483338003613539E-01_dp
      ww(43)= 3.74540480311277751517377883176154E-03_dp
      xx(43)=-9.98540200636774224936056720606650E-01_dp
      ww(44)= 3.74540480311277751517377883176154E-03_dp
      xx(44)= 9.98540200636774224936056720606650E-01_dp
      RETURN
   END IF
!
   IF(norder == 45)THEN
      ww(1)= 6.90418248292320201107985551594047E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 6.88773169776613228820028482980558E-02_dp
      xx(2)=-6.89869801631441724904146141038117E-02_dp
      ww(3)= 6.88773169776613228820028482980558E-02_dp
      xx(3)= 6.89869801631441724904146141038117E-02_dp
      ww(4)= 6.83845773786696745316920993343161E-02_dp
      xx(4)=-1.37645205983253028756590041423066E-01_dp
      ww(5)= 6.83845773786696745316920993343161E-02_dp
      xx(5)= 1.37645205983253028756590041423066E-01_dp
      ww(6)= 6.75659541636075362709102238736486E-02_dp
      xx(6)=-2.05647489783263745719787225471544E-01_dp
      ww(7)= 6.75659541636075362709102238736486E-02_dp
      xx(7)= 2.05647489783263745719787225471544E-01_dp
      ww(8)= 6.64253484498425280829147156391037E-02_dp
      xx(8)=-2.72669769752377560608765391615645E-01_dp
      ww(9)= 6.64253484498425280829147156391037E-02_dp
      xx(9)= 2.72669769752377560608765391615645E-01_dp
      ww(10)= 6.49681957507234308538265703590757E-02_dp
      xx(10)=-3.38392654250602161643404100031873E-01_dp
      ww(11)= 6.49681957507234308538265703590757E-02_dp
      xx(11)= 3.38392654250602161643404100031873E-01_dp
      ww(12)= 6.32014400738199377499637302906669E-02_dp
      xx(12)=-4.02502943858541914077974508548346E-01_dp
      ww(13)= 6.32014400738199377499637302906669E-02_dp
      xx(13)= 4.02502943858541914077974508548346E-01_dp
      ww(14)= 6.11335008310665225018863705363256E-02_dp
      xx(14)=-4.64695123919635098579601502309749E-01_dp
      ww(15)= 6.11335008310665225018863705363256E-02_dp
      xx(15)= 4.64695123919635098579601502309749E-01_dp
      ww(16)= 5.87742327188417385743615176318314E-02_dp
      xx(16)=-5.24672820462916067091134100460162E-01_dp
      ww(17)= 5.87742327188417385743615176318314E-02_dp
      xx(17)= 5.24672820462916067091134100460162E-01_dp
      ww(18)= 5.61348787597864766439239403748698E-02_dp
      xx(18)=-5.82150212569353186680967334444177E-01_dp
      ww(19)= 5.61348787597864766439239403748698E-02_dp
      xx(19)= 5.82150212569353186680967334444177E-01_dp
      ww(20)= 5.32280167312689519459040440193104E-02_dp
      xx(20)=-6.36853394453223359271223845903383E-01_dp
      ww(21)= 5.32280167312689519459040440193104E-02_dp
      xx(21)= 6.36853394453223359271223845903383E-01_dp
      ww(22)= 5.00674992379520297991321024748743E-02_dp
      xx(22)=-6.88521680771200525232019825880438E-01_dp
      ww(23)= 5.00674992379520297991321024748743E-02_dp
      xx(23)= 6.88521680771200525232019825880438E-01_dp
      ww(24)= 4.66683877183733652677684757416541E-02_dp
      xx(24)=-7.36908848945490352623738848594892E-01_dp
      ww(25)= 4.66683877183733652677684757416541E-02_dp
      xx(25)= 7.36908848945490352623738848594892E-01_dp
      ww(26)= 4.30468807091649711516911130811669E-02_dp
      xx(26)=-7.81784312593906291312363188098603E-01_dp
      ww(27)= 4.30468807091649711516911130811669E-02_dp
      xx(27)= 7.81784312593906291312363188098603E-01_dp
      ww(28)= 3.92202367293024475641871853439293E-02_dp
      xx(28)=-8.22934220502086337035775260026502E-01_dp
      ww(29)= 3.92202367293024475641871853439293E-02_dp
      xx(29)= 8.22934220502086337035775260026502E-01_dp
      ww(30)= 3.52066922016090162476997982615751E-02_dp
      xx(30)=-8.60162475960664225339078870567134E-01_dp
      ww(31)= 3.52066922016090162476997982615751E-02_dp
      xx(31)= 8.60162475960664225339078870567134E-01_dp
      ww(32)= 3.10253749345154671625079388937681E-02_dp
      xx(32)=-8.93291671753241738464649051493057E-01_dp
      ww(33)= 3.10253749345154671625079388937681E-02_dp
      xx(33)= 8.93291671753241738464649051493057E-01_dp
      ww(34)= 2.66962139675776648056747787931075E-02_dp
      xx(34)=-9.22163936719000388097467360960527E-01_dp
      ww(35)= 2.66962139675776648056747787931075E-02_dp
      xx(35)= 9.22163936719000388097467360960527E-01_dp
      ww(36)= 2.22398475505787323939507585521690E-02_dp
      xx(36)=-9.46641690995629061784720596953837E-01_dp
      ww(37)= 2.22398475505787323939507585521690E-02_dp
      xx(37)= 9.46641690995629061784720596953837E-01_dp
      ww(38)= 1.76775352579375906170925466695771E-02_dp
      xx(38)=-9.66608310396894604736425160892478E-01_dp
      ww(39)= 1.76775352579375906170925466695771E-02_dp
      xx(39)= 9.66608310396894604736425160892478E-01_dp
      ww(40)= 1.30311049915827843206310824696869E-02_dp
      xx(40)=-9.81968715034540568239318473634341E-01_dp
      ww(41)= 1.30311049915827843206310824696869E-02_dp
      xx(41)= 9.81968715034540568239318473634341E-01_dp
      ww(42)= 8.32318929621824164573585312223385E-03_dp
      xx(42)=-9.92649998447203741748617120597735E-01_dp
      ww(43)= 8.32318929621824164573585312223385E-03_dp
      xx(43)= 9.92649998447203741748617120597735E-01_dp
      ww(44)= 3.58266315528355893114302865935139E-03_dp
      xx(44)=-9.98603645181936638156547676900821E-01_dp
      ww(45)= 3.58266315528355893114302865935139E-03_dp
      xx(45)= 9.98603645181936638156547676900821E-01_dp
      RETURN
   END IF
!
   IF(norder == 46)THEN
      ww(1)= 6.75186858490364588202141891643011E-02_dp
      xx(1)=-3.37721900160520415195578318914398E-02_dp
      ww(2)= 6.75186858490364588202141891643011E-02_dp
      xx(2)= 3.37721900160520415195578318914398E-02_dp
      ww(3)= 6.72106136006781758623741548270976E-02_dp
      xx(3)=-1.01162475305584239515859657008649E-01_dp
      ww(4)= 6.72106136006781758623741548270976E-02_dp
      xx(4)= 1.01162475305584239515859657008649E-01_dp
      ww(5)= 6.65958747684548873757619664227337E-02_dp
      xx(5)=-1.68091179467103528606796737427702E-01_dp
      ww(6)= 6.65958747684548873757619664227337E-02_dp
      xx(6)= 1.68091179467103528606796737427702E-01_dp
      ww(7)= 6.56772742677812073787575656855558E-02_dp
      xx(7)=-2.34252922206269768626056115573792E-01_dp
      ww(8)= 6.56772742677812073787575656855558E-02_dp
      xx(8)= 2.34252922206269768626056115573792E-01_dp
      ww(9)= 6.44590034671390695882794391082551E-02_dp
      xx(9)=-2.99345822701870015483439256577904E-01_dp
      ww(10)= 6.44590034671390695882794391082551E-02_dp
      xx(10)= 2.99345822701870015483439256577904E-01_dp
      ww(11)= 6.29466210643945081789519522471109E-02_dp
      xx(11)=-3.63072877020995710123706978514652E-01_dp
      ww(12)= 6.29466210643945081789519522471109E-02_dp
      xx(12)= 3.63072877020995710123706978514652E-01_dp
      ww(13)= 6.11470277246504810153566079041910E-02_dp
      xx(13)=-4.25143313282828397322146863428567E-01_dp
      ww(14)= 6.11470277246504810153566079041910E-02_dp
      xx(14)= 4.25143313282828397322146863428567E-01_dp
      ww(15)= 5.90684345955463148075507226369077E-02_dp
      xx(15)=-4.85273918388164662772320193708455E-01_dp
      ww(16)= 5.90684345955463148075507226369077E-02_dp
      xx(16)= 4.85273918388164662772320193708455E-01_dp
      ww(17)= 5.67203258439912358168744036032867E-02_dp
      xx(17)=-5.43190330261802635270962691028877E-01_dp
      ww(18)= 5.67203258439912358168744036032867E-02_dp
      xx(18)= 5.43190330261802635270962691028877E-01_dp
      ww(19)= 5.41134153858567544916376432592231E-02_dp
      xx(19)=-5.98628289712715153177172533600167E-01_dp
      ww(20)= 5.41134153858567544916376432592231E-02_dp
      xx(20)= 5.98628289712715153177172533600167E-01_dp
      ww(21)= 5.12595980071430213353652993714480E-02_dp
      xx(21)=-6.51334846201997715106477155816859E-01_dp
      ww(22)= 5.12595980071430213353652993714480E-02_dp
      xx(22)= 6.51334846201997715106477155816859E-01_dp
      ww(23)= 4.81718951017122005304688632232209E-02_dp
      xx(23)=-7.01069512020405697512122089426500E-01_dp
      ww(24)= 4.81718951017122005304688632232209E-02_dp
      xx(24)= 7.01069512020405697512122089426500E-01_dp
      ww(25)= 4.48643952773181267670946135627749E-02_dp
      xx(25)=-7.47605359615666054000336505268003E-01_dp
      ww(26)= 4.48643952773181267670946135627749E-02_dp
      xx(26)= 7.47605359615666054000336505268003E-01_dp
      ww(27)= 4.13521901096787297042201758702315E-02_dp
      xx(27)=-7.90730057075274255189144147420302E-01_dp
      ww(28)= 4.13521901096787297042201758702315E-02_dp
      xx(28)= 7.90730057075274255189144147420302E-01_dp
      ww(29)= 3.76513053573860713276607992284591E-02_dp
      xx(29)=-8.30246837066066053032385304790806E-01_dp
      ww(30)= 3.76513053573860713276607992284591E-02_dp
      xx(30)= 8.30246837066066053032385304790806E-01_dp
      ww(31)= 3.37786279991068965206038938811453E-02_dp
      xx(31)=-8.65975394866858062915888776816598E-01_dp
      ww(32)= 3.37786279991068965206038938811453E-02_dp
      xx(32)= 8.65975394866858062915888776816598E-01_dp
      ww(33)= 2.97518295522027557990517292357229E-02_dp
      xx(33)=-8.97752711533941965701319951319781E-01_dp
      ww(34)= 2.97518295522027557990517292357229E-02_dp
      xx(34)= 8.97752711533941965701319951319781E-01_dp
      ww(35)= 2.55892863971300106346995122003440E-02_dp
      xx(35)=-9.25433798806753950977491357699124E-01_dp
      ww(36)= 2.55892863971300106346995122003440E-02_dp
      xx(36)= 9.25433798806753950977491357699124E-01_dp
      ww(37)= 2.13099987541365010544793610708784E-02_dp
      xx(37)=-9.48892363446089795622213539436914E-01_dp
      ww(38)= 2.13099987541365010544793610708784E-02_dp
      xx(38)= 9.48892363446089795622213539436914E-01_dp
      ww(39)= 1.69335140078362380462307136717604E-02_dp
      xx(39)=-9.68021391853991942737748066371815E-01_dp
      ww(40)= 1.69335140078362380462307136717604E-02_dp
      xx(40)= 9.68021391853991942737748066371815E-01_dp
      ww(41)= 1.24798837709886842067345717509834E-02_dp
      xx(41)=-9.82733669804166863477979579659189E-01_dp
      ww(42)= 1.24798837709886842067345717509834E-02_dp
      xx(42)= 9.82733669804166863477979579659189E-01_dp
      ww(43)= 7.96989822972462245161303892632497E-03_dp
      xx(43)=-9.92962348906174364073095444666193E-01_dp
      ww(44)= 7.96989822972462245161303892632497E-03_dp
      xx(44)= 9.92962348906174364073095444666193E-01_dp
      ww(45)= 3.43030086810704828601878314804340E-03_dp
      xx(45)=-9.98663042133817981128268417390889E-01_dp
      ww(46)= 3.43030086810704828601878314804340E-03_dp
      xx(46)= 9.98663042133817981128268417390889E-01_dp
      RETURN
   END IF
!
   IF(norder == 47)THEN
      ww(1)= 6.61351296236554796534403543310550E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 6.59905335888104745335706553304983E-02_dp
      xx(2)=-6.60869239163556751604737774741337E-02_dp
      ww(3)= 6.59905335888104745335706553304983E-02_dp
      xx(3)= 6.60869239163556751604737774741337E-02_dp
      ww(4)= 6.55573777665497402511430023260759E-02_dp
      xx(4)=-1.31884866554514897053823530724127E-01_dp
      ww(5)= 6.55573777665497402511430023260759E-02_dp
      xx(5)= 1.31884866554514897053823530724127E-01_dp
      ww(6)= 6.48375562389457267026039391108060E-02_dp
      xx(6)=-1.97106110279111807961491358370505E-01_dp
      ww(7)= 6.48375562389457267026039391108060E-02_dp
      xx(7)= 1.97106110279111807961491358370505E-01_dp
      ww(8)= 6.38342166057170306312937798558135E-02_dp
      xx(8)=-2.61465459214974570306982966205171E-01_dp
      ww(9)= 6.38342166057170306312937798558135E-02_dp
      xx(9)= 2.61465459214974570306982966205171E-01_dp
      ww(10)= 6.25517462209216626405643814499535E-02_dp
      xx(10)=-3.24681486337735902210761299179997E-01_dp
      ww(11)= 6.25517462209216626405643814499535E-02_dp
      xx(11)= 3.24681486337735902210761299179997E-01_dp
      ww(12)= 6.09957530087396453307105781334375E-02_dp
      xx(12)=-3.86477764084667139583302387606023E-01_dp
      ww(13)= 6.09957530087396453307105781334375E-02_dp
      xx(13)= 3.86477764084667139583302387606023E-01_dp
      ww(14)= 5.91730409423388759761545563857413E-02_dp
      xx(14)=-4.46584073104855702725182142349408E-01_dp
      ww(15)= 5.91730409423388759761545563857413E-02_dp
      xx(15)= 4.46584073104855702725182142349408E-01_dp
      ww(16)= 5.70915802932315402220166053083828E-02_dp
      xx(16)=-5.04737583863577919774289025351301E-01_dp
      ww(17)= 5.70915802932315402220166053083828E-02_dp
      xx(17)= 5.04737583863577919774289025351301E-01_dp
      ww(18)= 5.47604727815302259571251768885048E-02_dp
      xx(18)=-5.60684005934664194483058317418269E-01_dp
      ww(19)= 5.47604727815302259571251768885048E-02_dp
      xx(19)= 5.60684005934664194483058317418269E-01_dp
      ww(20)= 5.21899117800571448722119417096761E-02_dp
      xx(20)=-6.14178699956373608595462542604254E-01_dp
      ww(21)= 5.21899117800571448722119417096761E-02_dp
      xx(21)= 6.14178699956373608595462542604254E-01_dp
      ww(22)= 4.93911377473611696045704858620049E-02_dp
      xx(22)=-6.64987747390332729136702648572089E-01_dp
      ww(23)= 4.93911377473611696045704858620049E-02_dp
      xx(23)= 6.64987747390332729136702648572089E-01_dp
      ww(24)= 4.63763890865059112044018482427451E-02_dp
      xx(24)=-7.12888973409064301661879327771019E-01_dp
      ww(25)= 4.63763890865059112044018482427451E-02_dp
      xx(25)= 7.12888973409064301661879327771019E-01_dp
      ww(26)= 4.31588486484795382683017934465031E-02_dp
      xx(26)=-7.57672918445438633573996523569682E-01_dp
      ww(27)= 4.31588486484795382683017934465031E-02_dp
      xx(27)= 7.57672918445438633573996523569682E-01_dp
      ww(28)= 3.97525861225310037809013801419610E-02_dp
      xx(28)=-7.99143754167741942915562069203593E-01_dp
      ww(29)= 3.97525861225310037809013801419610E-02_dp
      xx(29)= 7.99143754167741942915562069203593E-01_dp
      ww(30)= 3.61724965841749516134599297663113E-02_dp
      xx(30)=-8.37120139899902121277598948566352E-01_dp
      ww(31)= 3.61724965841749516134599297663113E-02_dp
      xx(31)= 8.37120139899902121277598948566352E-01_dp
      ww(32)= 3.24342355151847567676174631741702E-02_dp
      xx(32)=-8.71436015796896316940985464555606E-01_dp
      ww(33)= 3.24342355151847567676174631741702E-02_dp
      xx(33)= 8.71436015796896316940985464555606E-01_dp
      ww(34)= 2.85541507006433865047399246258111E-02_dp
      xx(34)=-9.01941329438525356867171301977436E-01_dp
      ww(35)= 2.85541507006433865047399246258111E-02_dp
      xx(35)= 9.01941329438525356867171301977436E-01_dp
      ww(36)= 2.45492116596588185378341571525058E-02_dp
      xx(36)=-9.28502693012360648197184924611321E-01_dp
      ww(37)= 2.45492116596588185378341571525058E-02_dp
      xx(37)= 9.28502693012360648197184924611321E-01_dp
      ww(38)= 2.04369381476684276420347606862554E-02_dp
      xx(38)=-9.51003969257708442589802923851442E-01_dp
      ww(39)= 2.04369381476684276420347606862554E-02_dp
      xx(39)= 9.51003969257708442589802923851442E-01_dp
      ww(40)= 1.62353331464330596707256874078986E-02_dp
      xx(40)=-9.69346787326564497145744277560271E-01_dp
      ww(41)= 1.62353331464330596707256874078986E-02_dp
      xx(41)= 9.69346787326564497145744277560271E-01_dp
      ww(42)= 1.19628484643123209639434548499485E-02_dp
      xx(42)=-9.83451003071623708764901034036170E-01_dp
      ww(43)= 1.19628484643123209639434548499485E-02_dp
      xx(43)= 9.83451003071623708764901034036170E-01_dp
      ww(44)= 7.63861629584883361410435677113166E-03_dp
      xx(44)=-9.93255210987768634692189684632464E-01_dp
      ww(45)= 7.63861629584883361410435677113166E-03_dp
      xx(45)= 9.93255210987768634692189684632464E-01_dp
      ww(46)= 3.28745384252801488324996420833618E-03_dp
      xx(46)=-9.98718728584212109183947714787108E-01_dp
      ww(47)= 3.28745384252801488324996420833618E-03_dp
      xx(47)= 9.98718728584212109183947714787108E-01_dp
      RETURN
   END IF
!
   IF(norder == 48)THEN
      ww(1)= 6.47376968126839225030249387365916E-02_dp
      xx(1)=-3.23801709628693620333222431521344E-02_dp
      ww(2)= 6.47376968126839225030249387365916E-02_dp
      xx(2)= 3.23801709628693620333222431521344E-02_dp
      ww(3)= 6.44661644359500822065041936577051E-02_dp
      xx(3)=-9.70046992094626989300539558536245E-02_dp
      ww(4)= 6.44661644359500822065041936577051E-02_dp
      xx(4)= 9.70046992094626989300539558536245E-02_dp
      ww(5)= 6.39242385846481866239062018255154E-02_dp
      xx(5)=-1.61222356068891718056437390783498E-01_dp
      ww(6)= 6.39242385846481866239062018255154E-02_dp
      xx(6)= 1.61222356068891718056437390783498E-01_dp
      ww(7)= 6.31141922862540256571260227502333E-02_dp
      xx(7)=-2.24763790394689061224865440174692E-01_dp
      ww(8)= 6.31141922862540256571260227502333E-02_dp
      xx(8)= 2.24763790394689061224865440174692E-01_dp
      ww(9)= 6.20394231598926639041977841375985E-02_dp
      xx(9)=-2.87362487355455576735886461316798E-01_dp
      ww(10)= 6.20394231598926639041977841375985E-02_dp
      xx(10)= 2.87362487355455576735886461316798E-01_dp
      ww(11)= 6.07044391658938800529692320278205E-02_dp
      xx(11)=-3.48755886292160738159817937270408E-01_dp
      ww(12)= 6.07044391658938800529692320278205E-02_dp
      xx(12)= 3.48755886292160738159817937270408E-01_dp
      ww(13)= 5.91148396983956357464748174335199E-02_dp
      xx(13)=-4.08686481990716729916225495814633E-01_dp
      ww(14)= 5.91148396983956357464748174335199E-02_dp
      xx(14)= 4.08686481990716729916225495814633E-01_dp
      ww(15)= 5.72772921004032157051502346847006E-02_dp
      xx(15)=-4.66902904750958404544928861650798E-01_dp
      ww(16)= 5.72772921004032157051502346847006E-02_dp
      xx(16)= 4.66902904750958404544928861650798E-01_dp
      ww(17)= 5.51995036999841628682034951916354E-02_dp
      xx(17)=-5.23160974722233033678225869137509E-01_dp
      ww(18)= 5.51995036999841628682034951916354E-02_dp
      xx(18)= 5.23160974722233033678225869137509E-01_dp
      ww(19)= 5.28901894851936670955050562646989E-02_dp
      xx(19)=-5.77224726083972703817809238540479E-01_dp
      ww(20)= 5.28901894851936670955050562646989E-02_dp
      xx(20)= 5.77224726083972703817809238540479E-01_dp
      ww(21)= 5.03590355538544749578076190878656E-02_dp
      xx(21)=-6.28867396776513623995164933069995E-01_dp
      ww(22)= 5.03590355538544749578076190878656E-02_dp
      xx(22)= 6.28867396776513623995164933069995E-01_dp
      ww(23)= 4.76166584924904748259066234789298E-02_dp
      xx(23)=-6.77872379632663905211851280675909E-01_dp
      ww(24)= 4.76166584924904748259066234789298E-02_dp
      xx(24)= 6.77872379632663905211851280675909E-01_dp
      ww(25)= 4.46745608566942804194485871258504E-02_dp
      xx(25)=-7.24034130923814654674482233493665E-01_dp
      ww(26)= 4.46745608566942804194485871258504E-02_dp
      xx(26)= 7.24034130923814654674482233493665E-01_dp
      ww(27)= 4.15450829434647492140588223610648E-02_dp
      xx(27)=-7.67159032515740339253855437522969E-01_dp
      ww(28)= 4.15450829434647492140588223610648E-02_dp
      xx(28)= 7.67159032515740339253855437522969E-01_dp
      ww(29)= 3.82413510658307063172172565237156E-02_dp
      xx(29)=-8.07066204029442627082553043024538E-01_dp
      ww(30)= 3.82413510658307063172172565237156E-02_dp
      xx(30)= 8.07066204029442627082553043024538E-01_dp
      ww(31)= 3.47772225647704388925485859638024E-02_dp
      xx(31)=-8.43588261624393530711089844519656E-01_dp
      ww(32)= 3.47772225647704388925485859638024E-02_dp
      xx(32)= 8.43588261624393530711089844519656E-01_dp
      ww(33)= 3.11672278327980889020657568463544E-02_dp
      xx(33)=-8.76572020274247885905693554805097E-01_dp
      ww(34)= 3.11672278327980889020657568463544E-02_dp
      xx(34)= 8.76572020274247885905693554805097E-01_dp
      ww(35)= 2.74265097083569482000738362625058E-02_dp
      xx(35)=-9.05879136715569672822074835671012E-01_dp
      ww(36)= 2.74265097083569482000738362625058E-02_dp
      xx(36)= 9.05879136715569672822074835671012E-01_dp
      ww(37)= 2.35707608393243791405193013784492E-02_dp
      xx(37)=-9.31386690706554333114174380101601E-01_dp
      ww(38)= 2.35707608393243791405193013784492E-02_dp
      xx(38)= 9.31386690706554333114174380101601E-01_dp
      ww(39)= 1.96161604573555278144607196522127E-02_dp
      xx(39)=-9.52987703160430860722960666025718E-01_dp
      ww(40)= 1.96161604573555278144607196522127E-02_dp
      xx(40)= 9.52987703160430860722960666025718E-01_dp
      ww(41)= 1.55793157229438487281769558344603E-02_dp
      xx(41)=-9.70591592546247250461411983800660E-01_dp
      ww(42)= 1.55793157229438487281769558344603E-02_dp
      xx(42)= 9.70591592546247250461411983800660E-01_dp
      ww(43)= 1.14772345792345394895926676090916E-02_dp
      xx(43)=-9.84124583722826857744583600026599E-01_dp
      ww(44)= 1.14772345792345394895926676090916E-02_dp
      xx(44)= 9.84124583722826857744583600026599E-01_dp
      ww(45)= 7.32755390127626210238397962178655E-03_dp
      xx(45)=-9.93530172266350757547928750849074E-01_dp
      ww(46)= 7.32755390127626210238397962178655E-03_dp
      xx(46)= 9.93530172266350757547928750849074E-01_dp
      ww(47)= 3.15334605230583863267731154389149E-03_dp
      xx(47)=-9.98771007252426118600541491563114E-01_dp
      ww(48)= 3.15334605230583863267731154389149E-03_dp
      xx(48)= 9.98771007252426118600541491563114E-01_dp
      RETURN
   END IF
!
   IF(norder == 49)THEN
      ww(1)= 6.34632814047905977182534678795296E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 6.33355092964917485908369274000905E-02_dp
      xx(2)=-6.34206849826867860288348208784850E-02_dp
      ww(3)= 6.33355092964917485908369274000905E-02_dp
      xx(3)= 6.34206849826867860288348208784850E-02_dp
      ww(4)= 6.29527074651956994743995557828910E-02_dp
      xx(4)=-1.26585997269672051067985288575536E-01_dp
      ww(5)= 6.29527074651956994743995557828910E-02_dp
      xx(5)= 1.26585997269672051067985288575536E-01_dp
      ww(6)= 6.23164173200572674010768252159497E-02_dp
      xx(6)=-1.89241592461813586485310173859987E-01_dp
      ww(7)= 6.23164173200572674010768252159497E-02_dp
      xx(7)= 1.89241592461813586485310173859987E-01_dp
      ww(8)= 6.14292009791929362968266461403011E-02_dp
      xx(8)=-2.51135178612577273507155942824611E-01_dp
      ww(9)= 6.14292009791929362968266461403011E-02_dp
      xx(9)= 2.51135178612577273507155942824611E-01_dp
      ww(10)= 6.02946309531520173031061168755416E-02_dp
      xx(10)=-3.12017532119748762207860676506416E-01_dp
      ww(11)= 6.02946309531520173031061168755416E-02_dp
      xx(11)= 3.12017532119748762207860676506416E-01_dp
      ww(12)= 5.89172757600272660245276507424925E-02_dp
      xx(12)=-3.71643501262284888863734540946961E-01_dp
      ww(13)= 5.89172757600272660245276507424925E-02_dp
      xx(13)= 3.71643501262284888863734540946961E-01_dp
      ww(14)= 5.73026815301874754851645923508165E-02_dp
      xx(14)=-4.29772993341576524658584141807423E-01_dp
      ww(15)= 5.73026815301874754851645923508165E-02_dp
      xx(15)= 4.29772993341576524658584141807423E-01_dp
      ww(16)= 5.54573496748035886904315814826981E-02_dp
      xx(16)=-4.86171941452492042176976096058575E-01_dp
      ww(17)= 5.54573496748035886904315814826981E-02_dp
      xx(17)= 4.86171941452492042176976096058575E-01_dp
      ww(18)= 5.33887107082589685279429337301762E-02_dp
      xx(18)=-5.40613246991726066558225467229436E-01_dp
      ww(19)= 5.33887107082589685279429337301762E-02_dp
      xx(19)= 5.40613246991726066558225467229436E-01_dp
      ww(20)= 5.11050943301445906746228060493186E-02_dp
      xx(20)=-5.92877694108900712455864336792629E-01_dp
      ww(21)= 5.11050943301445906746228060493186E-02_dp
      xx(21)= 5.92877694108900712455864336792629E-01_dp
      ww(22)= 4.86156958878282402776511972878685E-02_dp
      xx(22)=-6.42754832419237664056856948583900E-01_dp
      ww(23)= 4.86156958878282402776511972878685E-02_dp
      xx(23)= 6.42754832419237664056856948583900E-01_dp
      ww(24)= 4.59305393555958535424996199721277E-02_dp
      xx(24)=-6.90043824425132113504751807274942E-01_dp
      ww(25)= 4.59305393555958535424996199721277E-02_dp
      xx(25)= 6.90043824425132113504751807274942E-01_dp
      ww(26)= 4.30604369812595979883454840010385E-02_dp
      xx(26)=-7.34554254237402696213674212858525E-01_dp
      ww(27)= 4.30604369812595979883454840010385E-02_dp
      xx(27)= 7.34554254237402696213674212858525E-01_dp
      ww(28)= 4.00169457663730213686050367431033E-02_dp
      xx(28)=-7.76106894345446635018142812248456E-01_dp
      ww(29)= 4.00169457663730213686050367431033E-02_dp
      xx(29)= 7.76106894345446635018142812248456E-01_dp
      ww(30)= 3.68123209630006898194672366988823E-02_dp
      xx(30)=-8.14534427359855431539500787764777E-01_dp
      ww(31)= 3.68123209630006898194672366988823E-02_dp
      xx(31)= 8.14534427359855431539500787764777E-01_dp
      ww(32)= 3.34594667916221743424871508916892E-02_dp
      xx(32)=-8.49682119844165701034881872242979E-01_dp
      ww(33)= 3.34594667916221743424871508916892E-02_dp
      xx(33)= 8.49682119844165701034881872242979E-01_dp
      ww(34)= 2.99718846205838253506905580741472E-02_dp
      xx(34)=-8.81408445573008910037031535817005E-01_dp
      ww(35)= 2.99718846205838253506905580741472E-02_dp
      xx(35)= 8.81408445573008910037031535817005E-01_dp
      ww(36)= 2.63636189270660169609457452397420E-02_dp
      xx(36)=-9.09585655828073285213019640355800E-01_dp
      ww(37)= 2.63636189270660169609457452397420E-02_dp
      xx(37)= 9.09585655828073285213019640355800E-01_dp
      ww(38)= 2.26492015874466764987709642160429E-02_dp
      xx(38)=-9.34100294755810149058982460636545E-01_dp
      ww(39)= 2.26492015874466764987709642160429E-02_dp
      xx(39)= 9.34100294755810149058982460636545E-01_dp
      ww(40)= 1.88435958530894584444506533911073E-02_dp
      xx(40)=-9.54853658674137233555243679668184E-01_dp
      ww(41)= 1.88435958530894584444506533911073E-02_dp
      xx(41)= 9.54853658674137233555243679668184E-01_dp
      ww(42)= 1.49621449356246510295843191202015E-02_dp
      xx(42)=-9.71762200901555380139972421504774E-01_dp
      ww(43)= 1.49621449356246510295843191202015E-02_dp
      xx(43)= 9.71762200901555380139972421504774E-01_dp
      ww(44)= 1.10205510315935804975082881668333E-02_dp
      xx(44)=-9.84757895914213004359298995368575E-01_dp
      ww(45)= 1.10205510315935804975082881668333E-02_dp
      xx(45)= 9.84757895914213004359298995368575E-01_dp
      ww(46)= 7.03509959008645147345067831134841E-03_dp
      xx(46)=-9.93788661944167790760113859257954E-01_dp
      ww(47)= 7.03509959008645147345067831134841E-03_dp
      xx(47)= 9.93788661944167790760113859257954E-01_dp
      ww(48)= 3.02727898892290507748069817582714E-03_dp
      xx(48)=-9.98820150606635379361831272704111E-01_dp
      ww(49)= 3.02727898892290507748069817582714E-03_dp
      xx(49)= 9.98820150606635379361831272704111E-01_dp
      RETURN
   END IF
!
   IF(norder == 50)THEN
      ww(1)= 6.21766166553472623210331073606134E-02_dp
      xx(1)=-3.10983383271888761123289896659492E-02_dp
      ww(2)= 6.21766166553472623210331073606134E-02_dp
      xx(2)= 3.10983383271888761123289896659492E-02_dp
      ww(3)= 6.19360674206832433840875097808307E-02_dp
      xx(3)=-9.31747015600861408544503776396003E-02_dp
      ww(4)= 6.19360674206832433840875097808307E-02_dp
      xx(4)= 9.31747015600861408544503776396003E-02_dp
      ww(5)= 6.14558995903166637564067860839154E-02_dp
      xx(5)=-1.54890589998145902071628620941110E-01_dp
      ww(6)= 6.14558995903166637564067860839154E-02_dp
      xx(6)= 1.54890589998145902071628620941110E-01_dp
      ww(7)= 6.07379708417702160317500153848110E-02_dp
      xx(7)=-2.16007236876041756847284532617101E-01_dp
      ww(8)= 6.07379708417702160317500153848110E-02_dp
      xx(8)= 2.16007236876041756847284532617101E-01_dp
      ww(9)= 5.97850587042654575095764053125852E-02_dp
      xx(9)=-2.76288193779531990327645278521130E-01_dp
      ww(10)= 5.97850587042654575095764053125852E-02_dp
      xx(10)= 2.76288193779531990327645278521130E-01_dp
      ww(11)= 5.86008498132224458351224366308485E-02_dp
      xx(11)=-3.35500245419437356836988257291072E-01_dp
      ww(12)= 5.86008498132224458351224366308485E-02_dp
      xx(12)= 3.35500245419437356836988257291072E-01_dp
      ww(13)= 5.71899256477283837230293150659932E-02_dp
      xx(13)=-3.93414311897565127394229253823817E-01_dp
      ww(14)= 5.71899256477283837230293150659932E-02_dp
      xx(14)= 3.93414311897565127394229253823817E-01_dp
      ww(15)= 5.55577448062125176235674256122695E-02_dp
      xx(15)=-4.49806334974038789147131467778376E-01_dp
      ww(16)= 5.55577448062125176235674256122695E-02_dp
      xx(16)= 4.49806334974038789147131467778376E-01_dp
      ww(17)= 5.37106218889962465234587972556646E-02_dp
      xx(17)=-5.04458144907464201651459131849141E-01_dp
      ww(18)= 5.37106218889962465234587972556646E-02_dp
      xx(18)= 5.04458144907464201651459131849141E-01_dp
      ww(19)= 5.16557030695811384899052958400953E-02_dp
      xx(19)=-5.57158304514650054315522909625802E-01_dp
      ww(20)= 5.16557030695811384899052958400953E-02_dp
      xx(20)= 5.57158304514650054315522909625802E-01_dp
      ww(21)= 4.94009384494663149212435807514327E-02_dp
      xx(21)=-6.07702927184950239180381796391833E-01_dp
      ww(22)= 4.94009384494663149212435807514327E-02_dp
      xx(22)= 6.07702927184950239180381796391833E-01_dp
      ww(23)= 4.69550513039484329656330136349877E-02_dp
      xx(23)=-6.55896465685439360781624864003680E-01_dp
      ww(24)= 4.69550513039484329656330136349877E-02_dp
      xx(24)= 6.55896465685439360781624864003680E-01_dp
      ww(25)= 4.43275043388032754920222868303942E-02_dp
      xx(25)=-7.01552468706822251089546257883656E-01_dp
      ww(26)= 4.43275043388032754920222868303942E-02_dp
      xx(26)= 7.01552468706822251089546257883656E-01_dp
      ww(27)= 4.15284630901476974224119789640670E-02_dp
      xx(27)=-7.44494302226068538260536252682194E-01_dp
      ww(28)= 4.15284630901476974224119789640670E-02_dp
      xx(28)= 7.44494302226068538260536252682194E-01_dp
      ww(29)= 3.85687566125876752447701502363859E-02_dp
      xx(29)=-7.84555832900399263905305196340991E-01_dp
      ww(30)= 3.85687566125876752447701502363859E-02_dp
      xx(30)= 7.84555832900399263905305196340991E-01_dp
      ww(31)= 3.54598356151461541607346110009758E-02_dp
      xx(31)=-8.21582070859335948356254110873940E-01_dp
      ww(32)= 3.54598356151461541607346110009758E-02_dp
      xx(32)= 8.21582070859335948356254110873940E-01_dp
      ww(33)= 3.22137282235780166481658273230040E-02_dp
      xx(33)=-8.55429769429946084611362643934757E-01_dp
      ww(34)= 3.22137282235780166481658273230040E-02_dp
      xx(34)= 8.55429769429946084611362643934757E-01_dp
      ww(35)= 2.88429935805351980299063731132324E-02_dp
      xx(35)=-8.85967979523613048637540982466754E-01_dp
      ww(36)= 2.88429935805351980299063731132324E-02_dp
      xx(36)= 8.85967979523613048637540982466754E-01_dp
      ww(37)= 2.53606735700123904401948783854427E-02_dp
      xx(37)=-9.13078556655791893089735642771657E-01_dp
      ww(38)= 2.53606735700123904401948783854427E-02_dp
      xx(38)= 9.13078556655791893089735642771657E-01_dp
      ww(39)= 2.17802431701247929815920690626903E-02_dp
      xx(39)=-9.36656618944877933780874947272497E-01_dp
      ww(40)= 2.17802431701247929815920690626903E-02_dp
      xx(40)= 9.36656618944877933780874947272497E-01_dp
      ww(41)= 1.81155607134893903512599434223546E-02_dp
      xx(41)=-9.56610955242807942997745644156622E-01_dp
      ww(42)= 1.81155607134893903512599434223546E-02_dp
      xx(42)= 9.56610955242807942997745644156622E-01_dp
      ww(43)= 1.43808227614855744193789089273243E-02_dp
      xx(43)=-9.72864385106692073713344104606252E-01_dp
      ww(44)= 1.43808227614855744193789089273243E-02_dp
      xx(44)= 9.72864385106692073713344104606252E-01_dp
      ww(45)= 1.05905483836509692635696814992410E-02_dp
      xx(45)=-9.85354084048005882309009625632489E-01_dp
      ww(46)= 1.05905483836509692635696814992410E-02_dp
      xx(46)= 9.85354084048005882309009625632489E-01_dp
      ww(47)= 6.75979919574540150277887817798503E-03_dp
      xx(47)=-9.94031969432090712585108200420695E-01_dp
      ww(48)= 6.75979919574540150277887817798503E-03_dp
      xx(48)= 9.94031969432090712585108200420695E-01_dp
      ww(49)= 2.90862255315514095840072434285548E-03_dp
      xx(49)=-9.98866404420071050185459444974219E-01_dp
      ww(50)= 2.90862255315514095840072434285548E-03_dp
      xx(50)= 9.98866404420071050185459444974219E-01_dp
      RETURN
   END IF
!
   IF(norder == 51)THEN
      ww(1)= 6.09989248412058801597976430983561E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 6.08854648448563438811986142226962E-02_dp
      xx(2)=-6.09611001505787247341947068432054E-02_dp
      ww(3)= 6.08854648448563438811986142226962E-02_dp
      xx(3)= 6.09611001505787247341947068432054E-02_dp
      ww(4)= 6.05455069347377951381252514677542E-02_dp
      xx(4)=-1.21695421018888766963820420963181E-01_dp
      ww(5)= 6.05455069347377951381252514677542E-02_dp
      xx(5)= 1.21695421018888766963820420963181E-01_dp
      ww(6)= 5.99803157775032520900639879965171E-02_dp
      xx(6)=-1.81977026957077545323998701169214E-01_dp
      ww(7)= 5.99803157775032520900639879965171E-02_dp
      xx(7)= 1.81977026957077545323998701169214E-01_dp
      ww(8)= 5.91919939229615437835390077491546E-02_dp
      xx(8)=-2.41581666447798703846733114869262E-01_dp
      ww(9)= 5.91919939229615437835390077491546E-02_dp
      xx(9)= 2.41581666447798703846733114869262E-01_dp
      ww(10)= 5.81834739825921405984378776617759E-02_dp
      xx(10)=-3.00287606335331939530245649644420E-01_dp
      ww(11)= 5.81834739825921405984378776617759E-02_dp
      xx(11)= 3.00287606335331939530245649644420E-01_dp
      ww(12)= 5.69585077202586621000777267342772E-02_dp
      xx(12)=-3.57876456688409509775201088519666E-01_dp
      ww(13)= 5.69585077202586621000777267342772E-02_dp
      xx(13)= 3.57876456688409509775201088519666E-01_dp
      ww(14)= 5.55216520957386930167370590936242E-02_dp
      xx(14)=-4.14133983226303877936871809744658E-01_dp
      ww(15)= 5.55216520957386930167370590936242E-02_dp
      xx(15)= 4.14133983226303877936871809744658E-01_dp
      ww(16)= 5.38782523130455614340993016969720E-02_dp
      xx(16)=-4.68850904286041063610457258811622E-01_dp
      ww(17)= 5.38782523130455614340993016969720E-02_dp
      xx(17)= 4.68850904286041063610457258811622E-01_dp
      ww(18)= 5.20344219366970875641364474686624E-02_dp
      xx(18)=-5.21823669366185842514087784826818E-01_dp
      ww(19)= 5.20344219366970875641364474686624E-02_dp
      xx(19)= 5.21823669366185842514087784826818E-01_dp
      ww(20)= 4.99970201500574097795488553620058E-02_dp
      xx(20)=-5.72855216351303836522394702590191E-01_dp
      ww(21)= 4.99970201500574097795488553620058E-02_dp
      xx(21)= 5.72855216351303836522394702590191E-01_dp
      ww(22)= 4.77736262406231019999953537073536E-02_dp
      xx(22)=-6.21755704600723273755042745403316E-01_dp
      ww(23)= 4.77736262406231019999953537073536E-02_dp
      xx(23)= 6.21755704600723273755042745403316E-01_dp
      ww(24)= 4.53725114076500687481668149884379E-02_dp
      xx(24)=-6.68343221175370086864460419403989E-01_dp
      ww(25)= 4.53725114076500687481668149884379E-02_dp
      xx(25)= 6.68343221175370086864460419403989E-01_dp
      ww(26)= 4.28026079978800866536095142442857E-02_dp
      xx(26)=-7.12444457577036644580524855400146E-01_dp
      ww(27)= 4.28026079978800866536095142442857E-02_dp
      xx(27)= 7.12444457577036644580524855400146E-01_dp
      ww(28)= 4.00734762854964531868091159213959E-02_dp
      xx(28)=-7.53895354485375525763960025452474E-01_dp
      ww(29)= 4.00734762854964531868091159213959E-02_dp
      xx(29)= 7.53895354485375525763960025452474E-01_dp
      ww(30)= 3.71952689232602928429082758118710E-02_dp
      xx(30)=-7.92541712099381205234410878375876E-01_dp
      ww(31)= 3.71952689232602928429082758118710E-02_dp
      xx(31)= 7.92541712099381205234410878375876E-01_dp
      ww(32)= 3.41786932041883362362093385947675E-02_dp
      xx(32)=-8.28239763823064832854818424016562E-01_dp
      ww(33)= 3.41786932041883362362093385947675E-02_dp
      xx(33)= 8.28239763823064832854818424016562E-01_dp
      ww(34)= 3.10349712901600084544255029565474E-02_dp
      xx(34)=-8.60856711182292371473495743716111E-01_dp
      ww(35)= 3.10349712901600084544255029565474E-02_dp
      xx(35)= 8.60856711182292371473495743716111E-01_dp
      ww(36)= 2.77757985941624771959956656322089E-02_dp
      xx(36)=-8.90271218029527303277795370736727E-01_dp
      ww(37)= 2.77757985941624771959956656322089E-02_dp
      xx(37)= 8.90271218029527303277795370736727E-01_dp
      ww(38)= 2.44133005737814342731415654168982E-02_dp
      xx(38)=-9.16373862309780230823571294251476E-01_dp
      ww(39)= 2.44133005737814342731415654168982E-02_dp
      xx(39)= 9.16373862309780230823571294251476E-01_dp
      ww(40)= 2.09599884017032105797926184015142E-02_dp
      xx(40)=-9.39067544002962383435367806390905E-01_dp
      ww(41)= 2.09599884017032105797926184015142E-02_dp
      xx(41)= 9.39067544002962383435367806390905E-01_dp
      ww(42)= 1.74287147234010522595036464332924E-02_dp
      xx(42)=-9.58267848613908194557707038316324E-01_dp
      ww(43)= 1.74287147234010522595036464332924E-02_dp
      xx(43)= 9.58267848613908194557707038316324E-01_dp
      ww(44)= 1.38326340064778222966884530218564E-02_dp
      xx(44)=-9.73903368019323867231755486394187E-01_dp
      ww(45)= 1.38326340064778222966884530218564E-02_dp
      xx(45)= 9.73903368019323867231755486394187E-01_dp
      ww(46)= 1.01851912978217299392375917866067E-02_dp
      xx(46)=-9.85915991735902996583885707558310E-01_dp
      ww(47)= 1.01851912978217299392375917866067E-02_dp
      xx(47)= 9.85915991735902996583885707558310E-01_dp
      ww(48)= 6.50033778325260029210937519853753E-03_dp
      xx(48)=-9.94261260436752574621084897949263E-01_dp
      ww(49)= 6.50033778325260029210937519853753E-03_dp
      xx(49)= 9.94261260436752574621084897949263E-01_dp
      ww(50)= 2.79680717108989557554421688180905E-03_dp
      xx(50)=-9.98909990848903495168995877273386E-01_dp
      ww(51)= 2.79680717108989557554421688180905E-03_dp
      xx(51)= 9.98909990848903495168995877273386E-01_dp
      RETURN
   END IF
!
   IF(norder == 52)THEN
      ww(1)= 5.98103657452918602477853788114775E-02_dp
      xx(1)=-2.99141097973387660436807760707999E-02_dp
      ww(2)= 5.98103657452918602477853788114775E-02_dp
      xx(2)= 2.99141097973387660436807760707999E-02_dp
      ww(3)= 5.95962601712481582583108787484150E-02_dp
      xx(3)=-8.96352446489005654888546911223993E-02_dp
      ww(4)= 5.95962601712481582583108787484150E-02_dp
      xx(4)= 8.96352446489005654888546911223993E-02_dp
      ww(5)= 5.91688154660429703693320023948710E-02_dp
      xx(5)=-1.49035508606949180488634040018114E-01_dp
      ww(6)= 5.91688154660429703693320023948710E-02_dp
      xx(6)= 1.49035508606949180488634040018114E-01_dp
      ww(7)= 5.85295617718138685502905989716237E-02_dp
      xx(7)=-2.07902264156366059686466128122346E-01_dp
      ww(8)= 5.85295617718138685502905989716237E-02_dp
      xx(8)= 2.07902264156366059686466128122346E-01_dp
      ww(9)= 5.76807874525268276539319976634035E-02_dp
      xx(9)=-2.66024783605001827472971730598840E-01_dp
      ww(10)= 5.76807874525268276539319976634035E-02_dp
      xx(10)= 2.66024783605001827472971730598840E-01_dp
      ww(11)= 5.66255309023685971908082404783702E-02_dp
      xx(11)=-3.23195003434807825501099066601447E-01_dp
      ww(12)= 5.66255309023685971908082404783702E-02_dp
      xx(12)= 3.23195003434807825501099066601447E-01_dp
      ww(13)= 5.53675696693026525490410934512186E-02_dp
      xx(13)=-3.79208269116093669246681766939449E-01_dp
      ww(14)= 5.53675696693026525490410934512186E-02_dp
      xx(14)= 3.79208269116093669246681766939449E-01_dp
      ww(15)= 5.39114069327572647508368248938000E-02_dp
      xx(15)=-4.33864067718761670309086568209780E-01_dp
      ww(16)= 5.39114069327572647508368248938000E-02_dp
      xx(16)= 4.33864067718761670309086568209780E-01_dp
      ww(17)= 5.22622553839069930343941444263921E-02_dp
      xx(17)=-4.86966745698096077782458241346466E-01_dp
      ww(18)= 5.22622553839069930343941444263921E-02_dp
      xx(18)= 4.86966745698096077782458241346466E-01_dp
      ww(19)= 5.04260185663423772182112540828588E-02_dp
      xx(19)=-5.38326209285827438375951167975357E-01_dp
      ww(20)= 5.04260185663423772182112540828588E-02_dp
      xx(20)= 5.38326209285827438375951167975357E-01_dp
      ww(21)= 4.84092697440748968539602492860463E-02_dp
      xx(21)=-5.87758604979579069902025781557204E-01_dp
      ww(22)= 4.84092697440748968539602492860463E-02_dp
      xx(22)= 5.87758604979579069902025781557204E-01_dp
      ww(23)= 4.62192283727847935076457053352846E-02_dp
      xx(23)=-6.35086977695245924298124579288810E-01_dp
      ww(24)= 4.62192283727847935076457053352846E-02_dp
      xx(24)= 6.35086977695245924298124579288810E-01_dp
      ww(25)= 4.38637342590004079951296655787644E-02_dp
      xx(25)=-6.80141904227167702092238779736641E-01_dp
      ww(26)= 4.38637342590004079951296655787644E-02_dp
      xx(26)= 6.80141904227167702092238779736641E-01_dp
      ww(27)= 4.13512195005602716790402864239552E-02_dp
      xx(27)=-7.22762099749983193676816676071936E-01_dp
      ww(28)= 4.13512195005602716790402864239552E-02_dp
      xx(28)= 7.22762099749983193676816676071936E-01_dp
      ww(29)= 3.86906783104239789851012067403526E-02_dp
      xx(29)=-7.62794995193744960279211163089051E-01_dp
      ww(30)= 3.86906783104239789851012067403526E-02_dp
      xx(30)= 7.62794995193744960279211163089051E-01_dp
      ww(31)= 3.58916348350972329419423932852807E-02_dp
      xx(31)=-8.00097283430468324334758754225808E-01_dp
      ww(32)= 3.58916348350972329419423932852807E-02_dp
      xx(32)= 8.00097283430468324334758754225808E-01_dp
      ww(33)= 3.29641090897187979150100447786952E-02_dp
      xx(33)=-8.34535432326734534961726389621239E-01_dp
      ww(34)= 3.29641090897187979150100447786952E-02_dp
      xx(34)= 8.34535432326734534961726389621239E-01_dp
      ww(35)= 2.99185811471439466412820687399709E-02_dp
      xx(35)=-8.65986162846067585244358517624207E-01_dp
      ww(36)= 2.99185811471439466412820687399709E-02_dp
      xx(36)= 8.65986162846067585244358517624207E-01_dp
      ww(37)= 2.67659537465040134494930802860184E-02_dp
      xx(37)=-8.94336890534495322520844088263528E-01_dp
      ww(38)= 2.67659537465040134494930802860184E-02_dp
      xx(38)= 8.94336890534495322520844088263528E-01_dp
      ww(39)= 2.35175135539844615903225199100546E-02_dp
      xx(39)=-9.19486128916424539893596376541882E-01_dp
      ww(40)= 2.35175135539844615903225199100546E-02_dp
      xx(40)= 9.19486128916424539893596376541882E-01_dp
      ww(41)= 2.01848915079807922029890342094782E-02_dp
      xx(41)=-9.41343853641359056843579183850567E-01_dp
      ww(42)= 2.01848915079807922029890342094782E-02_dp
      xx(42)= 9.41343853641359056843579183850567E-01_dp
      ww(43)= 1.67800233963007356779215368705202E-02_dp
      xx(43)=-9.59831826933086552532025153425065E-01_dp
      ww(44)= 1.67800233963007356779215368705202E-02_dp
      xx(44)= 9.59831826933086552532025153425065E-01_dp
      ww(45)= 1.33151149823409606566003444777991E-02_dp
      xx(45)=-9.74883884221744503140706470399646E-01_dp
      ww(46)= 1.33151149823409606566003444777991E-02_dp
      xx(46)= 9.74883884221744503140706470399646E-01_dp
      ww(47)= 9.80263457946275206195116811668950E-03_dp
      xx(47)=-9.86446195651549840645322859118397E-01_dp
      ww(48)= 9.80263457946275206195116811668950E-03_dp
      xx(48)= 9.86446195651549840645322859118397E-01_dp
      ww(49)= 6.25552396297327689971610216981455E-03_dp
      xx(49)=-9.94477590929216029245043271799572E-01_dp
      ww(50)= 6.25552396297327689971610216981455E-03_dp
      xx(50)= 9.94477590929216029245043271799572E-01_dp
      ww(51)= 2.69131695004711111895217986884522E-03_dp
      xx(51)=-9.98951111103950278090961440716593E-01_dp
      ww(52)= 2.69131695004711111895217986884522E-03_dp
      xx(52)= 9.98951111103950278090961440716593E-01_dp
      RETURN
   END IF
!
   IF(norder == 53)THEN
      ww(1)= 5.87187941511643645254869444421341E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 5.86175862327202633180719370499889E-02_dp
      xx(2)=-5.86850543002594650227119458332315E-02_dp
      ww(3)= 5.86175862327202633180719370499889E-02_dp
      xx(3)= 5.86850543002594650227119458332315E-02_dp
      ww(4)= 5.83143113622560075562757563376973E-02_dp
      xx(4)=-1.17167809071955150140256808779324E-01_dp
      ww(5)= 5.83143113622560075562757563376973E-02_dp
      xx(5)= 1.17167809071955150140256808779324E-01_dp
      ww(6)= 5.78100149917131963196830760972521E-02_dp
      xx(6)=-1.75246662155325750729791009132895E-01_dp
      ww(7)= 5.78100149917131963196830760972521E-02_dp
      xx(7)= 1.75246662155325750729791009132895E-01_dp
      ww(8)= 5.71064355362671917733833392984188E-02_dp
      xx(8)=-2.32721403724272593643363642199916E-01_dp
      ww(9)= 5.71064355362671917733833392984188E-02_dp
      xx(9)= 2.32721403724272593643363642199916E-01_dp
      ww(10)= 5.62059983817397098086550620914450E-02_dp
      xx(10)=-2.89393906451626206426547006594013E-01_dp
      ww(11)= 5.62059983817397098086550620914450E-02_dp
      xx(11)= 2.89393906451626206426547006594013E-01_dp
      ww(12)= 5.51118075239335990023497047658674E-02_dp
      xx(12)=-3.45068808495722356694310646069501E-01_dp
      ww(13)= 5.51118075239335990023497047658674E-02_dp
      xx(13)= 3.45068808495722356694310646069501E-01_dp
      ww(14)= 5.38276348687310290420814416354027E-02_dp
      xx(14)=-3.99554186953952977392563136238398E-01_dp
      ww(15)= 5.38276348687310290420814416354027E-02_dp
      xx(15)= 3.99554186953952977392563136238398E-01_dp
      ww(16)= 5.23579072298727181997015209893607E-02_dp
      xx(16)=-4.52662219461845791383144760753316E-01_dp
      ww(17)= 5.23579072298727181997015209893607E-02_dp
      xx(17)= 4.52662219461845791383144760753316E-01_dp
      ww(18)= 5.07076910692927152964854826345305E-02_dp
      xx(18)=-5.04209831657133437039116972887958E-01_dp
      ww(19)= 5.07076910692927152964854826345305E-02_dp
      xx(19)= 5.04209831657133437039116972887958E-01_dp
      ww(20)= 4.88826750326991404204484075835841E-02_dp
      xx(20)=-5.54019328277067881014734990810049E-01_dp
      ww(21)= 4.88826750326991404204484075835841E-02_dp
      xx(21)= 5.54019328277067881014734990810049E-01_dp
      ww(22)= 4.68891503407503140218726395651049E-02_dp
      xx(22)=-6.01919005713769327464294371964624E-01_dp
      ww(23)= 4.68891503407503140218726395651049E-02_dp
      xx(23)= 6.01919005713769327464294371964624E-01_dp
      ww(24)= 4.47339891036728102127656459185636E-02_dp
      xx(24)=-6.47743743916510068751106189938633E-01_dp
      ww(25)= 4.47339891036728102127656459185636E-02_dp
      xx(25)= 6.47743743916510068751106189938633E-01_dp
      ww(26)= 4.24246206345200135922816375684504E-02_dp
      xx(26)=-6.91335575601366723540748823138945E-01_dp
      ww(27)= 4.24246206345200135922816375684504E-02_dp
      xx(27)= 6.91335575601366723540748823138945E-01_dp
      ww(28)= 3.99690058435403821270935457878636E-02_dp
      xx(28)=-7.32544230807510253782135586721750E-01_dp
      ww(29)= 3.99690058435403821270935457878636E-02_dp
      xx(29)= 7.32544230807510253782135586721750E-01_dp
      ww(30)= 3.73756098034829156741719727853942E-02_dp
      xx(30)=-7.71227654925532307866035875626040E-01_dp
      ww(31)= 3.73756098034829156741719727853942E-02_dp
      xx(31)= 7.71227654925532307866035875626040E-01_dp
      ww(32)= 3.46533725835342379583877205130107E-02_dp
      xx(32)=-8.07252498416895478220485638025907E-01_dp
      ww(33)= 3.46533725835342379583877205130107E-02_dp
      xx(33)= 8.07252498416895478220485638025907E-01_dp
      ww(34)= 3.18116784590193230632358620310809E-02_dp
      xx(34)=-8.40494576545801375430127509829947E-01_dp
      ww(35)= 3.18116784590193230632358620310809E-02_dp
      xx(35)= 8.40494576545801375430127509829947E-01_dp
      ww(36)= 2.88603236178237362627995530435833E-02_dp
      xx(36)=-8.70839297558241351601700086888594E-01_dp
      ww(37)= 2.88603236178237362627995530435833E-02_dp
      xx(37)= 8.70839297558241351601700086888594E-01_dp
      ww(38)= 2.58094825107575177139618881666294E-02_dp
      xx(38)=-8.98182057875426625925520029973081E-01_dp
      ww(39)= 2.58094825107575177139618881666294E-02_dp
      xx(39)= 8.98182057875426625925520029973081E-01_dp
      ww(40)= 2.26696730570702083987892752398278E-02_dp
      xx(40)=-9.22428603042812128267819100082517E-01_dp
      ww(41)= 2.26696730570702083987892752398278E-02_dp
      xx(41)= 9.22428603042812128267819100082517E-01_dp
      ww(42)= 1.94517211076368953880469222274969E-02_dp
      xx(42)=-9.43495353464441879021070667696193E-01_dp
      ww(43)= 1.94517211076368953880469222274969E-02_dp
      xx(43)= 9.43495353464441879021070667696193E-01_dp
      ww(44)= 1.61667252566874639280608284040399E-02_dp
      xx(44)=-9.61309694623136332369858193682640E-01_dp
      ww(45)= 1.61667252566874639280608284040399E-02_dp
      xx(45)= 9.61309694623136332369858193682640E-01_dp
      ww(46)= 1.28260261442403791791501829692037E-02_dp
      xx(46)=-9.75810233714984581632983858106362E-01_dp
      ww(47)= 1.28260261442403791791501829692037E-02_dp
      xx(47)= 9.75810233714984581632983858106362E-01_dp
      ww(48)= 9.44120228494034438666217882032514E-03_dp
      xx(48)=-9.86947035023371521720373081310578E-01_dp
      ww(49)= 9.44120228494034438666217882032514E-03_dp
      xx(49)= 9.86947035023371521720373081310578E-01_dp
      ww(50)= 6.02427622694867328124170681629986E-03_dp
      xx(50)=-9.94681919308007078636035893483994E-01_dp
      ww(51)= 6.02427622694867328124170681629986E-03_dp
      xx(51)= 9.94681919308007078636035893483994E-01_dp
      ww(52)= 2.59168372056703181159923943851093E-03_dp
      xx(52)=-9.98989947776328227121054267032200E-01_dp
      ww(53)= 2.59168372056703181159923943851093E-03_dp
      xx(53)= 9.98989947776328227121054267032200E-01_dp
      RETURN
   END IF
!
   IF(norder == 54)THEN
      ww(1)= 5.76175367071470246723761288058715E-02_dp
      xx(1)=-2.88167481993417776562358475002271E-02_dp
      ww(2)= 5.76175367071470246723761288058715E-02_dp
      xx(2)= 2.88167481993417776562358475002271E-02_dp
      ww(3)= 5.74261370541121148592901317732068E-02_dp
      xx(3)=-8.63545182632482152854431777687496E-02_dp
      ww(4)= 5.74261370541121148592901317732068E-02_dp
      xx(4)= 8.63545182632482152854431777687496E-02_dp
      ww(5)= 5.70439735587945985678284342542272E-02_dp
      xx(5)=-1.43605427316256153947089762898789E-01_dp
      ww(6)= 5.70439735587945985678284342542272E-02_dp
      xx(6)= 1.43605427316256153947089762898789E-01_dp
      ww(7)= 5.64723157306259650310442646817612E-02_dp
      xx(7)=-2.00379293606213569778602462829298E-01_dp
      ww(8)= 5.64723157306259650310442646817612E-02_dp
      xx(8)= 2.00379293606213569778602462829298E-01_dp
      ww(9)= 5.57130625605899876833698174273711E-02_dp
      xx(9)=-2.56487520069997300077411214453008E-01_dp
      ww(10)= 5.57130625605899876833698174273711E-02_dp
      xx(10)= 2.56487520069997300077411214453008E-01_dp
      ww(11)= 5.47687362130579863062226347171090E-02_dp
      xx(11)=-3.11743720834468228882550390152124E-01_dp
      ww(12)= 5.47687362130579863062226347171090E-02_dp
      xx(12)= 3.11743720834468228882550390152124E-01_dp
      ww(13)= 5.36424736475536112721006277252466E-02_dp
      xx(13)=-3.65964340372191181984332108165487E-01_dp
      ww(14)= 5.36424736475536112721006277252466E-02_dp
      xx(14)= 3.65964340372191181984332108165487E-01_dp
      ww(15)= 5.23380161982987446655886947526850E-02_dp
      xx(15)=-4.18969263255204528036102697462510E-01_dp
      ww(16)= 5.23380161982987446655886947526850E-02_dp
      xx(16)= 4.18969263255204528036102697462510E-01_dp
      ww(17)= 5.08596971461881443197092069761187E-02_dp
      xx(17)=-4.70582412481382283683212136327743E-01_dp
      ww(18)= 5.08596971461881443197092069761187E-02_dp
      xx(18)= 4.70582412481382283683212136327743E-01_dp
      ww(19)= 4.92124273245288860687906303688116E-02_dp
      xx(19)=-5.20632334385933073327017138749764E-01_dp
      ww(20)= 4.92124273245288860687906303688116E-02_dp
      xx(20)= 5.20632334385933073327017138749764E-01_dp
      ww(21)= 4.74016788064449910585764101153236E-02_dp
      xx(21)=-5.68952768195209429731624834177154E-01_dp
      ww(22)= 4.74016788064449910585764101153236E-02_dp
      xx(22)= 5.68952768195209429731624834177154E-01_dp
      ww(23)= 4.54334667282767139748521807515446E-02_dp
      xx(23)=-6.15383198331127370729937820161728E-01_dp
      ww(24)= 4.54334667282767139748521807515446E-02_dp
      xx(24)= 6.15383198331127370729937820161728E-01_dp
      ww(25)= 4.33143293095970154419257603705081E-02_dp
      xx(25)=-6.59769387631983124692289822856220E-01_dp
      ww(26)= 4.33143293095970154419257603705081E-02_dp
      xx(26)= 6.59769387631983124692289822856220E-01_dp
      ww(27)= 4.10513061366449742217182108776043E-02_dp
      xx(27)=-7.01963889719172919385570976969671E-01_dp
      ww(28)= 4.10513061366449742217182108776043E-02_dp
      xx(28)= 7.01963889719172919385570976969671E-01_dp
      ww(29)= 3.86519147821025168368571390515799E-02_dp
      xx(29)=-7.41826538809184316285766268753578E-01_dp
      ww(30)= 3.86519147821025168368571390515799E-02_dp
      xx(30)= 7.41826538809184316285766268753578E-01_dp
      ww(31)= 3.61241258403835525828870742074248E-02_dp
      xx(31)=-7.79224915346254021535948614840533E-01_dp
      ww(32)= 3.61241258403835525828870742074248E-02_dp
      xx(32)= 7.79224915346254021535948614840533E-01_dp
      ww(33)= 3.34763364643726457160404448356108E-02_dp
      xx(33)=-8.14034785913567835469638304075199E-01_dp
      ww(34)= 3.34763364643726457160404448356108E-02_dp
      xx(34)= 8.14034785913567835469638304075199E-01_dp
      ww(35)= 3.07173424978706760540046099161549E-02_dp
      xx(35)=-8.46140515970772949425887510872843E-01_dp
      ww(36)= 3.07173424978706760540046099161549E-02_dp
      xx(36)= 8.46140515970772949425887510872843E-01_dp
      ww(37)= 2.78563093105958702870020347639152E-02_dp
      xx(37)=-8.75435454065568939417909335722611E-01_dp
      ww(38)= 2.78563093105958702870020347639152E-02_dp
      xx(38)= 8.75435454065568939417909335722611E-01_dp
      ww(39)= 2.49027414672087730500549712733890E-02_dp
      xx(39)=-9.01822286284701580757467231388428E-01_dp
      ww(40)= 2.49027414672087730500549712733890E-02_dp
      xx(40)= 9.01822286284701580757467231388428E-01_dp
      ww(41)= 2.18664514228530859455104265388793E-02_dp
      xx(41)=-9.25213359866651486256276060479791E-01_dp
      ww(42)= 2.18664514228530859455104265388793E-02_dp
      xx(42)= 9.25213359866651486256276060479791E-01_dp
      ww(43)= 1.87575276214693779120079842840712E-02_dp
      xx(43)=-9.45530975164995853763837022906180E-01_dp
      ww(44)= 1.87575276214693779120079842840712E-02_dp
      xx(44)= 9.45530975164995853763837022906180E-01_dp
      ww(45)= 1.55863030359241317029689097058368E-02_dp
      xx(45)=-9.62707645785923583256993926905390E-01_dp
      ww(46)= 1.55863030359241317029689097058368E-02_dp
      xx(46)= 9.62707645785923583256993926905390E-01_dp
      ww(47)= 1.23633281288476441664678242601881E-02_dp
      xx(47)=-9.76686328857903237200010071988307E-01_dp
      ww(48)= 1.23633281288476441664678242601881E-02_dp
      xx(48)= 9.76686328857903237200010071988307E-01_dp
      ww(49)= 9.09936945550939694803352106241926E-03_dp
      xx(49)=-9.87420637397343558552145720403546E-01_dp
      ww(50)= 9.09936945550939694803352106241926E-03_dp
      xx(50)= 9.87420637397343558552145720403546E-01_dp
      ww(51)= 5.80561101523998487882588774587527E-03_dp
      xx(51)=-9.94875117018338884918889995948703E-01_dp
      ww(52)= 5.80561101523998487882588774587527E-03_dp
      xx(52)= 9.94875117018338884918889995948703E-01_dp
      ww(53)= 2.49748183576158577594603875726603E-03_dp
      xx(53)=-9.99026666867340983851071106983959E-01_dp
      ww(54)= 2.49748183576158577594603875726603E-03_dp
      xx(54)= 9.99026666867340983851071106983959E-01_dp
      RETURN
   END IF
!
   IF(norder == 55)THEN
      ww(1)= 5.66029764445604254401057619812440E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 5.65123182497720014006583676351891E-02_dp
      xx(2)=-5.65727538183367763273376108931084E-02_dp
      ww(3)= 5.65123182497720014006583676351891E-02_dp
      xx(3)= 5.65727538183367763273376108931084E-02_dp
      ww(4)= 5.62406340710843680282790880901978E-02_dp
      xx(4)=-1.12964288059329266588437923888712E-01_dp
      ww(5)= 5.62406340710843680282790880901978E-02_dp
      xx(5)= 1.12964288059329266588437923888712E-01_dp
      ww(6)= 5.57887941952840871029360071099197E-02_dp
      xx(6)=-1.68993963646873208282842493511702E-01_dp
      ww(7)= 5.57887941952840871029360071099197E-02_dp
      xx(7)= 1.68993963646873208282842493511702E-01_dp
      ww(8)= 5.51582460025086875966511395606667E-02_dp
      xx(8)=-2.24482300647845483400189062402926E-01_dp
      ww(9)= 5.51582460025086875966511395606667E-02_dp
      xx(9)= 2.24482300647845483400189062402926E-01_dp
      ww(10)= 5.43510093299111020703221181537721E-02_dp
      xx(10)=-2.79251553200806538549862451175671E-01_dp
      ww(11)= 5.43510093299111020703221181537721E-02_dp
      xx(11)= 2.79251553200806538549862451175671E-01_dp
      ww(12)= 5.33696700016054727235705156360979E-02_dp
      xx(12)=-3.33126278890023885189471490232962E-01_dp
      ww(13)= 5.33696700016054727235705156360979E-02_dp
      xx(13)= 3.33126278890023885189471490232962E-01_dp
      ww(14)= 5.22173715456320845643935632812950E-02_dp
      xx(14)=-3.85933900740979429755848543912590E-01_dp
      ww(15)= 5.22173715456320845643935632812950E-02_dp
      xx(15)= 3.85933900740979429755848543912590E-01_dp
      ww(16)= 5.08978051244939792247752742880834E-02_dp
      xx(16)=-4.37505260037174591808481024297467E-01_dp
      ww(17)= 5.08978051244939792247752742880834E-02_dp
      xx(17)= 4.37505260037174591808481024297467E-01_dp
      ww(18)= 4.94151977115517394807585390160393E-02_dp
      xx(18)=-4.87675158187474097208263673539356E-01_dp
      ww(19)= 4.94151977115517394807585390160393E-02_dp
      xx(19)= 4.87675158187474097208263673539356E-01_dp
      ww(20)= 4.77742985512006955500367147160559E-02_dp
      xx(20)=-5.36282885908343296720599572843598E-01_dp
      ww(21)= 4.77742985512006955500367147160559E-02_dp
      xx(21)= 5.36282885908343296720599572843598E-01_dp
      ww(22)= 4.59803639462838381039048608720747E-02_dp
      xx(22)=-5.83172738026032102974304815587687E-01_dp
      ww(23)= 4.59803639462838381039048608720747E-02_dp
      xx(23)= 5.83172738026032102974304815587687E-01_dp
      ww(24)= 4.40391404216065898951680856532929E-02_dp
      xx(24)=-6.28194512249928140090636215032975E-01_dp
      ww(25)= 4.40391404216065898951680856532929E-02_dp
      xx(25)= 6.28194512249928140090636215032975E-01_dp
      ww(26)= 4.19568463177187623952073166921441E-02_dp
      xx(26)=-6.71203990319826395796326728006016E-01_dp
      ww(27)= 4.19568463177187623952073166921441E-02_dp
      xx(27)= 6.71203990319826395796326728006016E-01_dp
      ww(28)= 3.97401518743371796094638319033998E-02_dp
      xx(28)=-7.12063399986637838909350192121167E-01_dp
      ww(29)= 3.97401518743371796094638319033998E-02_dp
      xx(29)= 7.12063399986637838909350192121167E-01_dp
      ww(30)= 3.73961578679655452829155985824576E-02_dp
      xx(30)=-7.50641856348021908674987682707311E-01_dp
      ww(31)= 3.73961578679655452829155985824576E-02_dp
      xx(31)= 7.50641856348021908674987682707311E-01_dp
      ww(32)= 3.49323728735898874072682268027065E-02_dp
      xx(32)=-7.86815781127622365897636250938041E-01_dp
      ww(33)= 3.49323728735898874072682268027065E-02_dp
      xx(33)= 7.86815781127622365897636250938041E-01_dp
      ww(34)= 3.23566892261858316847055918757769E-02_dp
      xx(34)=-8.20469298559320912454241285034722E-01_dp
      ww(35)= 3.23566892261858316847055918757769E-02_dp
      xx(35)= 8.20469298559320912454241285034722E-01_dp
      ww(36)= 2.96773577651610412212965061868854E-02_dp
      xx(36)=-8.51494606617154471460245320967007E-01_dp
      ww(37)= 2.96773577651610412212965061868854E-02_dp
      xx(37)= 8.51494606617154471460245320967007E-01_dp
      ww(38)= 2.69029614563962706671200286537791E-02_dp
      xx(38)=-8.79792322419895506067590906824086E-01_dp
      ww(39)= 2.69029614563962706671200286537791E-02_dp
      xx(39)= 8.79792322419895506067590906824086E-01_dp
      ww(40)= 2.40423880097256220077915729286035E-02_dp
      xx(40)=-9.05271800744000025781911424629624E-01_dp
      ww(41)= 2.40423880097256220077915729286035E-02_dp
      xx(41)= 9.05271800744000025781911424629624E-01_dp
      ww(42)= 2.11048016680164541202093056236983E-02_dp
      xx(42)=-9.27851424720791696816271269232586E-01_dp
      ww(43)= 2.11048016680164541202093056236983E-02_dp
      xx(43)= 9.27851424720791696816271269232586E-01_dp
      ww(44)= 1.80996145207290624079682026434122E-02_dp
      xx(44)=-9.47458868041210741859979847645292E-01_dp
      ww(45)= 1.80996145207290624079682026434122E-02_dp
      xx(45)= 9.47458868041210741859979847645292E-01_dp
      ww(46)= 1.50364583335117882131508989019373E-02_dp
      xx(46)=-9.64031328593135198778536631377369E-01_dp
      ww(47)= 1.50364583335117882131508989019373E-02_dp
      xx(47)= 9.64031328593135198778536631377369E-01_dp
      ww(48)= 1.19251607198486121707525531575899E-02_dp
      xx(48)=-9.77515735503989208859216606340730E-01_dp
      ww(49)= 1.19251607198486121707525531575899E-02_dp
      xx(49)= 9.77515735503989208859216606340730E-01_dp
      ww(50)= 8.77574610705852817738960068331784E-03_dp
      xx(50)=-9.87868941198889198522385684473473E-01_dp
      ww(51)= 8.77574610705852817738960068331784E-03_dp
      xx(51)= 9.87868941198889198522385684473473E-01_dp
      ww(52)= 5.59863226656076735408341687185986E-03_dp
      xx(52)=-9.95057977847411875043189116506202E-01_dp
      ww(53)= 5.59863226656076735408341687185986E-03_dp
      xx(53)= 9.95057977847411875043189116506202E-01_dp
      ww(54)= 2.40832361997978881917019348912528E-03_dp
      xx(54)=-9.99061419564818541479431839519384E-01_dp
      ww(55)= 2.40832361997978881917019348912528E-03_dp
      xx(55)= 9.99061419564818541479431839519384E-01_dp
      RETURN
   END IF
!
   IF(norder == 56)THEN
      ww(1)= 5.55797463065143958462734268351612E-02_dp
      xx(1)=-2.77970352872754370940611967749205E-02_dp
      ww(2)= 5.55797463065143958462734268351612E-02_dp
      xx(2)= 2.77970352872754370940611967749205E-02_dp
      ww(3)= 5.54079525032451232177933918439100E-02_dp
      xx(3)=-8.33051868224353744402873554406624E-02_dp
      ww(4)= 5.54079525032451232177933918439100E-02_dp
      xx(4)= 8.33051868224353744402873554406624E-02_dp
      ww(5)= 5.50648959017624257963045975478503E-02_dp
      xx(5)=-1.38555846810376242012886580438491E-01_dp
      ww(6)= 5.50648959017624257963045975478503E-02_dp
      xx(6)= 1.38555846810376242012886580438491E-01_dp
      ww(7)= 5.45516368708894210617506548900902E-02_dp
      xx(7)=-1.93378238635275258240184723012684E-01_dp
      ww(8)= 5.45516368708894210617506548900902E-02_dp
      xx(8)= 1.93378238635275258240184723012684E-01_dp
      ww(9)= 5.38697618657144857089544104066980E-02_dp
      xx(9)=-2.47602909434337203972966554970527E-01_dp
      ww(10)= 5.38697618657144857089544104066980E-02_dp
      xx(10)= 2.47602909434337203972966554970527E-01_dp
      ww(11)= 5.30213785240107639679915586076915E-02_dp
      xx(11)=-3.01062253867220669053094233125234E-01_dp
      ww(12)= 5.30213785240107639679915586076915E-02_dp
      xx(12)= 3.01062253867220669053094233125234E-01_dp
      ww(13)= 5.20091091517413998430522648274847E-02_dp
      xx(13)=-3.53591032174954520969707327033232E-01_dp
      ww(14)= 5.20091091517413998430522648274847E-02_dp
      xx(14)= 3.53591032174954520969707327033232E-01_dp
      ww(15)= 5.08360826177984805601240184701987E-02_dp
      xx(15)=-4.05026880927091278118866962602923E-01_dp
      ww(16)= 5.08360826177984805601240184701987E-02_dp
      xx(16)= 4.05026880927091278118866962602923E-01_dp
      ww(17)= 4.95059246830475789199660464308456E-02_dp
      xx(17)=-4.55210814878459578948831581324610E-01_dp
      ww(18)= 4.95059246830475789199660464308456E-02_dp
      xx(18)= 4.55210814878459578948831581324610E-01_dp
      ww(19)= 4.80227467936002581207355056669997E-02_dp
      xx(19)=-5.03987718384381714195224401218638E-01_dp
      ww(20)= 4.80227467936002581207355056669997E-02_dp
      xx(20)= 5.03987718384381714195224401218638E-01_dp
      ww(21)= 4.63911333730018967621901910664960E-02_dp
      xx(21)=-5.51206824855534618754363514576317E-01_dp
      ww(22)= 4.63911333730018967621901910664960E-02_dp
      xx(22)= 5.51206824855534618754363514576317E-01_dp
      ww(23)= 4.46161276526922832134151929276237E-02_dp
      xx(23)=-5.96722182770663320104135217138408E-01_dp
      ww(24)= 4.46161276526922832134151929276237E-02_dp
      xx(24)= 5.96722182770663320104135217138408E-01_dp
      ww(25)= 4.27032160846670865110385723624771E-02_dp
      xx(25)=-6.40393106807006894267938596062813E-01_dp
      ww(26)= 4.27032160846670865110385723624771E-02_dp
      xx(26)= 6.40393106807006894267938596062813E-01_dp
      ww(27)= 4.06583113847445178801250227788528E-02_dp
      xx(27)=-6.82084612694470455501561477969836E-01_dp
      ww(28)= 4.06583113847445178801250227788528E-02_dp
      xx(28)= 6.82084612694470455501561477969836E-01_dp
      ww(29)= 3.84877342592476624868255916233813E-02_dp
      xx(29)=-7.21667834450188083522593787047553E-01_dp
      ww(30)= 3.84877342592476624868255916233813E-02_dp
      xx(30)= 7.21667834450188083522593787047553E-01_dp
      ww(31)= 3.61981938723151860358844682888862E-02_dp
      xx(31)=-7.59020422705128902202413294445894E-01_dp
      ww(32)= 3.61981938723151860358844682888862E-02_dp
      xx(32)= 7.59020422705128902202413294445894E-01_dp
      ww(33)= 3.37967671156117612954266312254470E-02_dp
      xx(33)=-7.94026922893866498030008308486000E-01_dp
      ww(34)= 3.37967671156117612954266312254470E-02_dp
      xx(34)= 7.94026922893866498030008308486000E-01_dp
      ww(35)= 3.12908767473104478678354777930253E-02_dp
      xx(35)=-8.26579132142881651672126974456850E-01_dp
      ww(36)= 3.12908767473104478678354777930253E-02_dp
      xx(36)= 8.26579132142881651672126974456850E-01_dp
      ww(37)= 2.86882684738227417298858844303943E-02_dp
      xx(37)=-8.56576433762748635402991386766871E-01_dp
      ww(38)= 2.86882684738227417298858844303943E-02_dp
      xx(38)= 8.56576433762748635402991386766871E-01_dp
      ww(39)= 2.59969870583919521918194322072723E-02_dp
      xx(39)=-8.83926108327827540789012285809287E-01_dp
      ww(40)= 2.59969870583919521918194322072723E-02_dp
      xx(40)= 8.83926108327827540789012285809287E-01_dp
      ww(41)= 2.32253515625653169372581575767885E-02_dp
      xx(41)=-9.08543620420655490846107289957242E-01_dp
      ww(42)= 2.32253515625653169372581575767885E-02_dp
      xx(42)= 9.08543620420655490846107289957242E-01_dp
      ww(43)= 2.03819298824025726348059836669333E-02_dp
      xx(43)=-9.30352880247496300547272723291601E-01_dp
      ww(44)= 2.03819298824025726348059836669333E-02_dp
      xx(44)= 9.30352880247496300547272723291601E-01_dp
      ww(45)= 1.74755129114009465049593689054572E-02_dp
      xx(45)=-9.49286479561962635646737602794928E-01_dp
      ww(46)= 1.74755129114009465049593689054572E-02_dp
      xx(46)= 9.49286479561962635646737602794928E-01_dp
      ww(47)= 1.45150892780214718077707405330130E-02_dp
      xx(47)=-9.65285901905490183626194976055096E-01_dp
      ww(48)= 1.45150892780214718077707405330130E-02_dp
      xx(48)= 9.65285901905490183626194976055096E-01_dp
      ww(49)= 1.15098243403833821737727593244971E-02_dp
      xx(49)=-9.78301709140256383376990551538188E-01_dp
      ww(50)= 1.15098243403833821737727593244971E-02_dp
      xx(50)= 9.78301709140256383376990551538188E-01_dp
      ww(51)= 8.46906316330788766162711237500816E-03_dp
      xx(51)=-9.88293715540161511089925163523486E-01_dp
      ww(52)= 8.46906316330788766162711237500816E-03_dp
      xx(52)= 9.88293715540161511089925163523486E-01_dp
      ww(53)= 5.40252224601533776131126094412087E-03_dp
      xx(53)=-9.95231226081069747216308760098941E-01_dp
      ww(54)= 5.40252224601533776131126094412087E-03_dp
      xx(54)= 9.95231226081069747216308760098941E-01_dp
      ww(55)= 2.32385537577321550110227644339586E-03_dp
      xx(55)=-9.99094343801465584353153825090904E-01_dp
      ww(56)= 2.32385537577321550110227644339586E-03_dp
      xx(56)= 9.99094343801465584353153825090904E-01_dp
      RETURN
   END IF
!
   IF(norder == 57)THEN
      ww(1)= 5.46343287565840240628413879880521E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 5.45528036047618864801389953641965E-02_dp
      xx(2)=-5.46071510016468242198305597373324E-02_dp
      ww(3)= 5.45528036047618864801389953641965E-02_dp
      xx(3)= 5.46071510016468242198305597373324E-02_dp
      ww(4)= 5.43084714524986431387467729547916E-02_dp
      xx(4)=-1.09051332808787800978526521310979E-01_dp
      ww(5)= 5.43084714524986431387467729547916E-02_dp
      xx(5)= 1.09051332808787800978526521310979E-01_dp
      ww(6)= 5.39020614832985746428094817306015E-02_dp
      xx(6)=-1.63170062591264251043280378321512E-01_dp
      ww(7)= 5.39020614832985746428094817306015E-02_dp
      xx(7)= 1.63170062591264251043280378321512E-01_dp
      ww(8)= 5.33347865848191584265769779914406E-02_dp
      xx(8)=-2.16801828796124036413613975979559E-01_dp
      ww(9)= 5.33347865848191584265769779914406E-02_dp
      xx(9)= 2.16801828796124036413613975979559E-01_dp
      ww(10)= 5.26083397291774324402313816408842E-02_dp
      xx(10)=-2.69786573161838765763345609799643E-01_dp
      ww(11)= 5.26083397291774324402313816408842E-02_dp
      xx(11)= 2.69786573161838765763345609799643E-01_dp
      ww(12)= 5.17248889205178247206239086651470E-02_dp
      xx(12)=-3.21966168395378640590207915805397E-01_dp
      ww(13)= 5.17248889205178247206239086651470E-02_dp
      xx(13)= 3.21966168395378640590207915805397E-01_dp
      ww(14)= 5.06870707249274086566404255636366E-02_dp
      xx(14)=-3.73184890086594458552134396144889E-01_dp
      ww(15)= 5.06870707249274086566404255636366E-02_dp
      xx(15)= 3.73184890086594458552134396144889E-01_dp
      ww(16)= 4.94979824020196789938379444993879E-02_dp
      xx(16)=-4.23289881451563950960024353471524E-01_dp
      ww(17)= 4.94979824020196789938379444993879E-02_dp
      xx(17)= 4.23289881451563950960024353471524E-01_dp
      ww(18)= 4.81611726616877512688510517568167E-02_dp
      xx(18)=-4.72131609517975709588060082049235E-01_dp
      ww(19)= 4.81611726616877512688510517568167E-02_dp
      xx(19)= 4.72131609517975709588060082049235E-01_dp
      ww(20)= 4.66806310736415037838408927788336E-02_dp
      xx(20)=-5.19564311391187606315153819806214E-01_dp
      ww(21)= 4.66806310736415037838408927788336E-02_dp
      xx(21)= 5.19564311391187606315153819806214E-01_dp
      ww(22)= 4.50607761613811577972135295258330E-02_dp
      xx(22)=-5.65446429269236759018985552805240E-01_dp
      ww(23)= 4.50607761613811577972135295258330E-02_dp
      xx(23)= 5.65446429269236759018985552805240E-01_dp
      ww(24)= 4.33064422162151965964321083284261E-02_dp
      xx(24)=-6.09641032908715365423848901924741E-01_dp
      ww(25)= 4.33064422162151965964321083284261E-02_dp
      xx(25)= 6.09641032908715365423848901924741E-01_dp
      ww(26)= 4.14228648708011103631969052736104E-02_dp
      xx(26)=-6.52016228280976891249361840795708E-01_dp
      ww(27)= 4.14228648708011103631969052736104E-02_dp
      xx(27)= 6.52016228280976891249361840795708E-01_dp
      ww(28)= 3.94156654754801140899527208010555E-02_dp
      xx(28)=-6.92445551199517739040483688444010E-01_dp
      ww(29)= 3.94156654754801140899527208010555E-02_dp
      xx(29)= 6.92445551199517739040483688444010E-01_dp
      ww(30)= 3.72908343244173173547352639956990E-02_dp
      xx(30)=-7.30808344744523322827344670736778E-01_dp
      ww(31)= 3.72908343244173173547352639956990E-02_dp
      xx(31)= 7.30808344744523322827344670736778E-01_dp
      ww(32)= 3.50547127823126175057509705965501E-02_dp
      xx(32)=-7.66990119359450195491716144018132E-01_dp
      ww(33)= 3.50547127823126175057509705965501E-02_dp
      xx(33)= 7.66990119359450195491716144018132E-01_dp
      ww(34)= 3.27139743663715685424901099103935E-02_dp
      xx(34)=-8.00882894547218242076008718794949E-01_dp
      ww(35)= 3.27139743663715685424901099103935E-02_dp
      xx(35)= 8.00882894547218242076008718794949E-01_dp
      ww(36)= 3.02756048426939994584905988331372E-02_dp
      xx(36)=-8.32385521150439120829010895865203E-01_dp
      ww(37)= 3.02756048426939994584905988331372E-02_dp
      xx(37)= 8.32385521150439120829010895865203E-01_dp
      ww(38)= 2.77468814021801923212579500383638E-02_dp
      xx(38)=-8.61403983262046944722241881805215E-01_dp
      ww(39)= 2.77468814021801923212579500383638E-02_dp
      xx(39)= 8.61403983262046944722241881805215E-01_dp
      ww(40)= 2.51353509909181226472737881409555E-02_dp
      xx(40)=-8.87851678882221329513000147641862E-01_dp
      ww(41)= 2.51353509909181226472737881409555E-02_dp
      xx(41)= 8.87851678882221329513000147641862E-01_dp
      ww(42)= 2.24488078907764380796892388450909E-02_dp
      xx(42)=-9.11649678521391212728430561619670E-01_dp
      ww(43)= 2.24488078907764380796892388450909E-02_dp
      xx(43)= 9.11649678521391212728430561619670E-01_dp
      ww(44)= 1.96952706994885203824224522735149E-02_dp
      xx(44)=-9.32726961067101696100754154297357E-01_dp
      ww(45)= 1.96952706994885203824224522735149E-02_dp
      xx(45)= 9.32726961067101696100754154297357E-01_dp
      ww(46)= 1.68829590234415490350008215668333E-02_dp
      xx(46)=-9.51020626447876741911904110605190E-01_dp
      ww(47)= 1.68829590234415490350008215668333E-02_dp
      xx(47)= 9.51020626447876741911904110605190E-01_dp
      ww(48)= 1.40202707907535561702471513381503E-02_dp
      xx(48)=-9.66476085171886679114858583942333E-01_dp
      ww(49)= 1.40202707907535561702471513381503E-02_dp
      xx(49)= 9.66476085171886679114858583942333E-01_dp
      ww(50)= 1.11157637323359901456754487681900E-02_dp
      xx(50)=-9.79047226709468713798820875366508E-01_dp
      ww(51)= 1.11157637323359901456754487681900E-02_dp
      xx(51)= 9.79047226709468713798820875366508E-01_dp
      ww(52)= 8.17816006782123262621099813037940E-03_dp
      xx(52)=-9.88696577650222048849758398383855E-01_dp
      ww(53)= 8.17816006782123262621099813037940E-03_dp
      xx(53)= 9.88696577650222048849758398383855E-01_dp
      ww(54)= 5.21653347471877939050662987142009E-03_dp
      xx(54)=-9.95395523678430311135125027362419E-01_dp
      ww(55)= 5.21653347471877939050662987142009E-03_dp
      xx(55)= 9.95395523678430311135125027362419E-01_dp
      ww(56)= 2.24375387225066290973478682263501E-03_dp
      xx(56)=-9.99125565625262850572009849554250E-01_dp
      ww(57)= 2.24375387225066290973478682263501E-03_dp
      xx(57)= 9.99125565625262850572009849554250E-01_dp
      RETURN
   END IF
!
   IF(norder == 58)THEN
      ww(1)= 5.36811198633348488639059553057246E-02_dp
      xx(1)=-2.68470123659423558033386895173800E-02_dp
      ww(2)= 5.36811198633348488639059553057246E-02_dp
      xx(2)= 2.68470123659423558033386895173800E-02_dp
      ww(3)= 5.35263433040582521006108138861702E-02_dp
      xx(3)=-8.04636302141427293098477923805032E-02_dp
      ww(4)= 5.35263433040582521006108138861702E-02_dp
      xx(4)= 8.04636302141427293098477923805032E-02_dp
      ww(5)= 5.32172364465790141034809843773848E-02_dp
      xx(5)=-1.33848250595466857022376847874541E-01_dp
      ww(6)= 5.32172364465790141034809843773848E-02_dp
      xx(6)= 1.33848250595466857022376847874541E-01_dp
      ww(7)= 5.27546905263708334296457672315232E-02_dp
      xx(7)=-1.86846951835761321374383881464022E-01_dp
      ww(8)= 5.27546905263708334296457672315232E-02_dp
      xx(8)= 1.86846951835761321374383881464022E-01_dp
      ww(9)= 5.21400391836698189712605560600718E-02_dp
      xx(9)=-2.39306924966153454428948509085335E-01_dp
      ww(10)= 5.21400391836698189712605560600718E-02_dp
      xx(10)= 2.39306924966153454428948509085335E-01_dp
      ww(11)= 5.13750546182857254745148206110654E-02_dp
      xx(11)=-2.91076914311109189533025268314303E-01_dp
      ww(12)= 5.13750546182857254745148206110654E-02_dp
      xx(12)= 2.91076914311109189533025268314303E-01_dp
      ww(13)= 5.04619424799531252976598215676318E-02_dp
      xx(13)=-3.42007653597995261248368267483997E-01_dp
      ww(14)= 5.04619424799531252976598215676318E-02_dp
      xx(14)= 3.42007653597995261248368267483997E-01_dp
      ww(15)= 4.94033355089623928665108657127013E-02_dp
      xx(15)=-3.91952296330753150371216941213011E-01_dp
      ww(16)= 4.94033355089623928665108657127013E-02_dp
      xx(16)= 3.91952296330753150371216941213011E-01_dp
      ww(17)= 4.82022859454177484065704061098669E-02_dp
      xx(17)=-4.40766839186839565193703062214304E-01_dp
      ww(18)= 4.82022859454177484065704061098669E-02_dp
      xx(18)= 4.40766839186839565193703062214304E-01_dp
      ww(19)= 4.68622567290263469184180780379200E-02_dp
      xx(19)=-4.88310537216718463615552572736785E-01_dp
      ww(20)= 4.68622567290263469184180780379200E-02_dp
      xx(20)= 4.88310537216718463615552572736785E-01_dp
      ww(21)= 4.53871115148198025039805360888660E-02_dp
      xx(21)=-5.34446309648847586399802417425204E-01_dp
      ww(22)= 4.53871115148198025039805360888660E-02_dp
      xx(22)= 5.34446309648847586399802417425204E-01_dp
      ww(23)= 4.37811035336402510390256923483361E-02_dp
      xx(23)=-5.79041135130225030489977117136083E-01_dp
      ww(24)= 4.37811035336402510390256923483361E-02_dp
      xx(24)= 5.79041135130225030489977117136083E-01_dp
      ww(25)= 4.20488633295821259945699819172542E-02_dp
      xx(25)=-6.21966435263079111033984058745491E-01_dp
      ww(26)= 4.20488633295821259945699819172542E-02_dp
      xx(26)= 6.21966435263079111033984058745491E-01_dp
      ww(27)= 4.01953854098677968880767508268823E-02_dp
      xx(27)=-6.63098445332125266433016299753566E-01_dp
      ww(28)= 4.01953854098677968880767508268823E-02_dp
      xx(28)= 6.63098445332125266433016299753566E-01_dp
      ww(29)= 3.82260138458584332294590344571485E-02_dp
      xx(29)=-7.02318571153908113479757301458201E-01_dp
      ww(30)= 3.82260138458584332294590344571485E-02_dp
      xx(30)= 7.02318571153908113479757301458201E-01_dp
      ww(31)= 3.61464268670872705407808569758552E-02_dp
      xx(31)=-7.39513731020042267846617234851033E-01_dp
      ww(32)= 3.61464268670872705407808569758552E-02_dp
      xx(32)= 7.39513731020042267846617234851033E-01_dp
      ww(33)= 3.39626204934160107977275551845848E-02_dp
      xx(33)=-7.74576681749652745266140046496827E-01_dp
      ww(34)= 3.39626204934160107977275551845848E-02_dp
      xx(34)= 7.74576681749652745266140046496827E-01_dp
      ww(35)= 3.16808912538093273202920396219503E-02_dp
      xx(35)=-8.07406327913088141048997152207395E-01_dp
      ww(36)= 3.16808912538093273202920396219503E-02_dp
      xx(36)= 8.07406327913088141048997152207395E-01_dp
      ww(37)= 2.93078180441604907183940268884438E-02_dp
      xx(37)=-8.37908013339373316352097920621624E-01_dp
      ww(38)= 2.93078180441604907183940268884438E-02_dp
      xx(38)= 8.37908013339373316352097920621624E-01_dp
      ww(39)= 2.68502431819818684759074786781450E-02_dp
      xx(39)=-8.65993794074807479275071232512088E-01_dp
      ww(40)= 2.68502431819818684759074786781450E-02_dp
      xx(40)= 8.65993794074807479275071232512088E-01_dp
      ww(41)= 2.43152527249639525402587606257985E-02_dp
      xx(41)=-8.91582692022030176399882820812798E-01_dp
      ww(42)= 2.43152527249639525402587606257985E-02_dp
      xx(42)= 8.91582692022030176399882820812798E-01_dp
      ww(43)= 2.17101561401462357669168094951183E-02_dp
      xx(43)=-9.14600928564352540686505649897522E-01_dp
      ww(44)= 2.17101561401462357669168094951183E-02_dp
      xx(44)= 9.14600928564352540686505649897522E-01_dp
      ww(45)= 1.90424654618934086557876594821076E-02_dp
      xx(45)=-9.34982137588259348480843234766248E-01_dp
      ww(46)= 1.90424654618934086557876594821076E-02_dp
      xx(46)= 9.34982137588259348480843234766248E-01_dp
      ww(47)= 1.63198742349709650521208304195709E-02_dp
      xx(47)=-9.52667557518869091442845510022930E-01_dp
      ww(48)= 1.63198742349709650521208304195709E-02_dp
      xx(48)= 9.52667557518869091442845510022930E-01_dp
      ww(49)= 1.35502371129888121451789664017619E-02_dp
      xx(49)=-9.67606202502924090153300784621206E-01_dp
      ww(50)= 1.35502371129888121451789664017619E-02_dp
      xx(50)= 9.67606202502924090153300784621206E-01_dp
      ww(51)= 1.07415535328787741168563619136619E-02_dp
      xx(51)=-9.79755014694350309107816334392598E-01_dp
      ww(52)= 1.07415535328787741168563619136619E-02_dp
      xx(52)= 9.79755014694350309107816334392598E-01_dp
      ww(53)= 7.90197384999867475401674567484776E-03_dp
      xx(53)=-9.89079008248442636499910255275442E-01_dp
      ww(54)= 7.90197384999867475401674567484776E-03_dp
      xx(54)= 9.89079008248442636499910255275442E-01_dp
      ww(55)= 5.03998161265024308501750117462242E-03_dp
      xx(55)=-9.95551476597290902602771526179946E-01_dp
      ww(56)= 5.03998161265024308501750117462242E-03_dp
      xx(56)= 9.95551476597290902602771526179946E-01_dp
      ww(57)= 2.16772324962744994305434292498451E-03_dp
      xx(57)=-9.99155200407386606442737044184606E-01_dp
      ww(58)= 2.16772324962744994305434292498451E-03_dp
      xx(58)= 9.99155200407386606442737044184606E-01_dp
      RETURN
   END IF
!
   IF(norder == 59)THEN
      ww(1)= 5.27980126219904214155123324308553E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 5.27244338591279319613042488706125E-02_dp
      xx(2)=-5.27734840883100039516803286033385E-02_dp
      ww(3)= 5.27244338591279319613042488706125E-02_dp
      xx(3)= 5.27734840883100039516803286033385E-02_dp
      ww(4)= 5.25039026478287390509413220142885E-02_dp
      xx(4)=-1.05399879016344143836914387761869E-01_dp
      ww(5)= 5.25039026478287390509413220142885E-02_dp
      xx(5)= 1.05399879016344143836914387761869E-01_dp
      ww(6)= 5.21370336483753913839872083078182E-02_dp
      xx(6)=-1.57732505587857968115217856271554E-01_dp
      ww(7)= 5.21370336483753913839872083078182E-02_dp
      xx(7)= 1.57732505587857968115217856271554E-01_dp
      ww(8)= 5.16248493908914821464399397734228E-02_dp
      xx(8)=-2.09625503392036544923366790631491E-01_dp
      ww(9)= 5.16248493908914821464399397734228E-02_dp
      xx(9)= 2.09625503392036544923366790631491E-01_dp
      ww(10)= 5.09687774253939168502479689936810E-02_dp
      xx(10)=-2.60934237342811711610616267414278E-01_dp
      ww(11)= 5.09687774253939168502479689936810E-02_dp
      xx(11)= 2.60934237342811711610616267414278E-01_dp
      ww(12)= 5.01706463429969028107204304421657E-02_dp
      xx(12)=-3.11515700803013700318360149105750E-01_dp
      ww(13)= 5.01706463429969028107204304421657E-02_dp
      xx(13)= 3.11515700803013700318360149105750E-01_dp
      ww(14)= 4.92326806793619857796936200150242E-02_dp
      xx(14)=-3.61228914169794809992312452334049E-01_dp
      ww(15)= 4.92326806793619857796936200150242E-02_dp
      xx(15)= 3.61228914169794809992312452334049E-01_dp
      ww(16)= 4.81574947146064403881468292859358E-02_dp
      xx(16)=-4.09935317810418966722823693755879E-01_dp
      ww(17)= 4.81574947146064403881468292859358E-02_dp
      xx(17)= 4.09935317810418966722823693755879E-01_dp
      ww(18)= 4.69480851869620191931597364829290E-02_dp
      xx(18)=-4.57499158253266690226215260434961E-01_dp
      ww(19)= 4.69480851869620191931597364829290E-02_dp
      xx(19)= 4.57499158253266690226215260434961E-01_dp
      ww(20)= 4.56078229405097698318682131583742E-02_dp
      xx(20)=-5.03787866557717978768087280457309E-01_dp
      ww(21)= 4.56078229405097698318682131583742E-02_dp
      xx(21)= 5.03787866557717978768087280457309E-01_dp
      ww(22)= 4.41404435302973806907980847330810E-02_dp
      xx(22)=-5.48672427808396384372256300387006E-01_dp
      ww(23)= 4.41404435302973806907980847330810E-02_dp
      xx(23)= 5.48672427808396384372256300387006E-01_dp
      ww(24)= 4.25500368110676386673082004847131E-02_dp
      xx(24)=-5.92027740704030144464176159756534E-01_dp
      ww(25)= 4.25500368110676386673082004847131E-02_dp
      xx(25)= 5.92027740704030144464176159756534E-01_dp
      ww(26)= 4.08410355386867076602021080894693E-02_dp
      xx(26)=-6.33732966238850097512580930175008E-01_dp
      ww(27)= 4.08410355386867076602021080894693E-02_dp
      xx(27)= 6.33732966238850097512580930175008E-01_dp
      ww(28)= 3.90182030161600095030307772112855E-02_dp
      xx(28)=-6.73671864504937227024027212755254E-01_dp
      ww(29)= 3.90182030161600095030307772112855E-02_dp
      xx(29)= 6.73671864504937227024027212755254E-01_dp
      ww(30)= 3.70866198188709226918379170352774E-02_dp
      xx(30)=-7.11733118677197731595915721965909E-01_dp
      ww(31)= 3.70866198188709226918379170352774E-02_dp
      xx(31)= 7.11733118677197731595915721965909E-01_dp
      ww(32)= 3.50516696364001087837183589610783E-02_dp
      xx(32)=-7.47810645278640231889257579013212E-01_dp
      ww(33)= 3.50516696364001087837183589610783E-02_dp
      xx(33)= 7.47810645278640231889257579013212E-01_dp
      ww(34)= 3.29190242710452777575112643535988E-02_dp
      xx(34)=-7.81803889862360905632678812767483E-01_dp
      ww(35)= 3.29190242710452777575112643535988E-02_dp
      xx(35)= 7.81803889862360905632678812767483E-01_dp
      ww(36)= 3.06946278361116832397503281924808E-02_dp
      xx(36)=-8.13618107288211571435089773821200E-01_dp
      ww(37)= 3.06946278361116832397503281924808E-02_dp
      xx(37)= 8.13618107288211571435089773821200E-01_dp
      ww(38)= 2.83846802005347979051528693353885E-02_dp
      xx(38)=-8.43164625816872201470350953972237E-01_dp
      ww(39)= 2.83846802005347979051528693353885E-02_dp
      xx(39)= 8.43164625816872201470350953972237E-01_dp
      ww(40)= 2.59956197312985001866505068017079E-02_dp
      xx(40)=-8.70361094292882260963426233104145E-01_dp
      ww(41)= 2.59956197312985001866505068017079E-02_dp
      xx(41)= 8.70361094292882260963426233104145E-01_dp
      ww(42)= 2.35341053937133634252753600783577E-02_dp
      xx(42)=-8.95131711743472085364296829462459E-01_dp
      ww(43)= 2.35341053937133634252753600783577E-02_dp
      xx(43)= 8.95131711743472085364296829462459E-01_dp
      ww(44)= 2.10069982884371873504614732186693E-02_dp
      xx(44)=-9.17407438788155281352541485215246E-01_dp
      ww(45)= 2.10069982884371873504614732186693E-02_dp
      xx(45)= 9.17407438788155281352541485215246E-01_dp
      ww(46)= 1.84213427536100293606157510564453E-02_dp
      xx(46)=-9.37126190353453859405138471043290E-01_dp
      ww(47)= 1.84213427536100293606157510564453E-02_dp
      xx(47)= 9.37126190353453859405138471043290E-01_dp
      ww(48)= 1.57843473130814661473204803972492E-02_dp
      xx(48)=-9.54233009376951055863233112185650E-01_dp
      ww(49)= 1.57843473130814661473204803972492E-02_dp
      xx(49)= 9.54233009376951055863233112185650E-01_dp
      ww(50)= 1.31033663063451910183195464842170E-02_dp
      xx(50)=-9.68680221681781531353633339672562E-01_dp
      ww(51)= 1.31033663063451910183195464842170E-02_dp
      xx(51)= 9.68680221681781531353633339672562E-01_dp
      ww(52)= 1.03858855009958621937978744109830E-02_dp
      xx(52)=-9.80427573956715688449607981403268E-01_dp
      ww(53)= 1.03858855009958621937978744109830E-02_dp
      xx(53)= 9.80427573956715688449607981403268E-01_dp
      ww(54)= 7.63952945348757514270068297475437E-03_dp
      xx(54)=-9.89442365133730931782183935022706E-01_dp
      ww(55)= 7.63952945348757514270068297475437E-03_dp
      xx(55)= 9.89442365133730931782183935022706E-01_dp
      ww(56)= 4.87223916826528476858200113292407E-03_dp
      xx(56)=-9.95699640383245964687201823433448E-01_dp
      ww(57)= 4.87223916826528476858200113292407E-03_dp
      xx(57)= 9.95699640383245964687201823433448E-01_dp
      ww(58)= 2.09549228454122340270073148864006E-03_dp
      xx(58)=-9.99183353909294683756424019504678E-01_dp
      ww(59)= 2.09549228454122340270073148864006E-03_dp
      xx(59)= 9.99183353909294683756424019504678E-01_dp
      RETURN
   END IF
!
   IF(norder == 60)THEN
      ww(1)= 5.19078776312206397328649383622697E-02_dp
      xx(1)=-2.59597723012477985891703854003448E-02_dp
      ww(2)= 5.19078776312206397328649383622697E-02_dp
      xx(2)= 2.59597723012477985891703854003448E-02_dp
      ww(3)= 5.17679431749101875438036430288237E-02_dp
      xx(3)=-7.78093339495365694192855070822253E-02_dp
      ww(4)= 5.17679431749101875438036430288237E-02_dp
      xx(4)= 7.78093339495365694192855070822253E-02_dp
      ww(5)= 5.14884515009809339950443971770543E-02_dp
      xx(5)=-1.29449135396945003146444164649576E-01_dp
      ww(6)= 5.14884515009809339950443971770543E-02_dp
      xx(6)= 1.29449135396945003146444164649576E-01_dp
      ww(7)= 5.10701560698556274045491207344910E-02_dp
      xx(7)=-1.80739964873425417240876941261853E-01_dp
      ww(8)= 5.10701560698556274045491207344910E-02_dp
      xx(8)= 1.80739964873425417240876941261853E-01_dp
      ww(9)= 5.05141845325093745982387357416536E-02_dp
      xx(9)=-2.31543551376029338010344631346755E-01_dp
      ww(10)= 5.05141845325093745982387357416536E-02_dp
      xx(10)= 2.31543551376029338010344631346755E-01_dp
      ww(11)= 4.98220356905501810111592308937033E-02_dp
      xx(11)=-2.81722937423261691690694860339442E-01_dp
      ww(12)= 4.98220356905501810111592308937033E-02_dp
      xx(12)= 2.81722937423261691690694860339442E-01_dp
      ww(13)= 4.89955754557568353894756868578943E-02_dp
      xx(13)=-3.31142848268448194252352965350553E-01_dp
      ww(14)= 4.89955754557568353894756868578943E-02_dp
      xx(14)= 3.31142848268448194252352965350553E-01_dp
      ww(15)= 4.80370318199711809636666527287337E-02_dp
      xx(15)=-3.79670056576797977154952670521888E-01_dp
      ww(16)= 4.80370318199711809636666527287337E-02_dp
      xx(16)= 3.79670056576797977154952670521888E-01_dp
      ww(17)= 4.69489888489122048470131563947016E-02_dp
      xx(17)=-4.27173741583078389307452853530312E-01_dp
      ww(18)= 4.69489888489122048470131563947016E-02_dp
      xx(18)= 4.27173741583078389307452853530312E-01_dp
      ww(19)= 4.57343797161144866471964552909093E-02_dp
      xx(19)=-4.73525841761707111108163053752795E-01_dp
      ww(20)= 4.57343797161144866471964552909093E-02_dp
      xx(20)= 4.73525841761707111108163053752795E-01_dp
      ww(21)= 4.43964787957871133277841640913774E-02_dp
      xx(21)=-5.18601400058569747417889348484721E-01_dp
      ww(22)= 4.43964787957871133277841640913774E-02_dp
      xx(22)= 5.18601400058569747417889348484721E-01_dp
      ww(23)= 4.29388928359356419542312206563828E-02_dp
      xx(23)=-5.62278900753944539178272587485999E-01_dp
      ww(24)= 4.29388928359356419542312206563828E-02_dp
      xx(24)= 5.62278900753944539178272587485999E-01_dp
      ww(25)= 4.13655512355847556131638368066589E-02_dp
      xx(25)=-6.04440597048510363444208776311202E-01_dp
      ww(26)= 4.13655512355847556131638368066589E-02_dp
      xx(26)= 6.04440597048510363444208776311202E-01_dp
      ww(27)= 3.96806954523807994701228348117100E-02_dp
      xx(27)=-6.44972828489477067813447896420445E-01_dp
      ww(28)= 3.96806954523807994701228348117100E-02_dp
      xx(28)= 6.44972828489477067813447896420445E-01_dp
      ww(29)= 3.78888675692434440309407942092760E-02_dp
      xx(29)=-6.83766327381355437222930239224297E-01_dp
      ww(30)= 3.78888675692434440309407942092760E-02_dp
      xx(30)= 6.83766327381355437222930239224297E-01_dp
      ww(31)= 3.59948980510845030665786462880623E-02_dp
      xx(31)=-7.20716513355730399436021061013521E-01_dp
      ww(32)= 3.59948980510845030665786462880623E-02_dp
      xx(32)= 7.20716513355730399436021061013521E-01_dp
      ww(33)= 3.40038927249464228349144015552587E-02_dp
      xx(33)=-7.55723775306585686868842066602373E-01_dp
      ww(34)= 3.40038927249464228349144015552587E-02_dp
      xx(34)= 7.55723775306585686868842066602373E-01_dp
      ww(35)= 3.19212190192963289494588995367605E-02_dp
      xx(35)=-7.88693739932264054569944799777216E-01_dp
      ww(36)= 3.19212190192963289494588995367605E-02_dp
      xx(36)= 7.88693739932264054569944799777216E-01_dp
      ww(37)= 2.97524915007889452408364846734877E-02_dp
      xx(37)=-8.19537526162145759368518108519724E-01_dp
      ww(38)= 2.97524915007889452408364846734877E-02_dp
      xx(38)= 8.19537526162145759368518108519724E-01_dp
      ww(39)= 2.75035567499247916352231976386222E-02_dp
      xx(39)=-8.48171984785929632490515494994376E-01_dp
      ww(40)= 2.75035567499247916352231976386222E-02_dp
      xx(40)= 8.48171984785929632490515494994376E-01_dp
      ww(41)= 2.51804776215212483795709659723613E-02_dp
      xx(41)=-8.74519922646898315129308099912436E-01_dp
      ww(42)= 2.51804776215212483795709659723613E-02_dp
      xx(42)= 8.74519922646898315129308099912436E-01_dp
      ww(43)= 2.27895169439978198637834581929002E-02_dp
      xx(43)=-8.98510310810045941937789329572628E-01_dp
      ww(44)= 2.27895169439978198637834581929002E-02_dp
      xx(44)= 8.98510310810045941937789329572628E-01_dp
      ww(45)= 2.03371207294572867750321474171063E-02_dp
      xx(45)=-9.20078476177627552856656862519897E-01_dp
      ww(46)= 2.03371207294572867750321474171063E-02_dp
      xx(46)= 9.20078476177627552856656862519897E-01_dp
      ww(47)= 1.78299010142077202603962612483486E-02_dp
      xx(47)=-9.39166276116423249495419011609705E-01_dp
      ww(48)= 1.78299010142077202603962612483486E-02_dp
      xx(48)= 9.39166276116423249495419011609705E-01_dp
      ww(49)= 1.52746185967847993067260380988253E-02_dp
      xx(49)=-9.55722255839996107397231845829700E-01_dp
      ww(50)= 1.52746185967847993067260380988253E-02_dp
      xx(50)= 9.55722255839996107397231845829700E-01_dp
      ww(51)= 1.26781664768159601314953792695142E-02_dp
      xx(51)=-9.69701788765052733721544098913794E-01_dp
      ww(52)= 1.26781664768159601314953792695142E-02_dp
      xx(52)= 9.69701788765052733721544098913794E-01_dp
      ww(53)= 1.00475571822879843578857643770573E-02_dp
      xx(53)=-9.81067201752598185618576799826770E-01_dp
      ww(54)= 1.00475571822879843578857643770573E-02_dp
      xx(54)= 9.81067201752598185618576799826770E-01_dp
      ww(55)= 7.38993116334545553151695602208606E-03_dp
      xx(55)=-9.89787895222221717367278987016096E-01_dp
      ww(56)= 7.38993116334545553151695602208606E-03_dp
      xx(56)= 9.89787895222221717367278987016096E-01_dp
      ww(57)= 4.71272992695356864089482171407724E-03_dp
      xx(57)=-9.95840525118838173876746713377441E-01_dp
      ww(58)= 4.71272992695356864089482171407724E-03_dp
      xx(58)= 9.95840525118838173876746713377441E-01_dp
      ww(59)= 2.02681196887375849643171020989232E-03_dp
      xx(59)=-9.99210123227436022034229585797649E-01_dp
      ww(60)= 2.02681196887375849643171020989232E-03_dp
      xx(60)= 9.99210123227436022034229585797649E-01_dp
      RETURN
   END IF
!
   IF(norder == 61)THEN
      ww(1)= 5.10811194407862179779210956063099E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 5.10144870386972635437350805738520E-02_dp
      xx(2)=-5.10589067079743493668875006189008E-02_dp
      ww(3)= 5.10144870386972635437350805738520E-02_dp
      xx(3)= 5.10589067079743493668875006189008E-02_dp
      ww(4)= 5.08147636688183432077005292234787E-02_dp
      xx(4)=-1.01984606562274068957208404764366E-01_dp
      ww(5)= 5.08147636688183432077005292234787E-02_dp
      xx(5)= 1.01984606562274068957208404764366E-01_dp
      ww(6)= 5.04824703867974046481444651881513E-02_dp
      xx(6)=-1.52644240230815300529506761773477E-01_dp
      ww(7)= 5.04824703867974046481444651881513E-02_dp
      xx(7)= 1.52644240230815300529506761773477E-01_dp
      ww(8)= 5.00184741081782534250516150063586E-02_dp
      xx(8)=-2.02905642518058499226947203343057E-01_dp
      ww(9)= 5.00184741081782534250516150063586E-02_dp
      xx(9)= 2.02905642518058499226947203343057E-01_dp
      ww(10)= 4.94239853467355899399687766511165E-02_dp
      xx(10)=-2.52637687169053495833690863334405E-01_dp
      ww(11)= 4.94239853467355899399687766511165E-02_dp
      xx(11)= 2.52637687169053495833690863334405E-01_dp
      ww(12)= 4.87005550564115260875300883147056E-02_dp
      xx(12)=-3.01710628963030712604486525456977E-01_dp
      ww(13)= 4.87005550564115260875300883147056E-02_dp
      xx(13)= 3.01710628963030712604486525456977E-01_dp
      ww(14)= 4.78500705850956071618334275186997E-02_dp
      xx(14)=-3.49996442204066834533434477062094E-01_dp
      ww(15)= 4.78500705850956071618334275186997E-02_dp
      xx(15)= 3.49996442204066834533434477062094E-01_dp
      ww(16)= 4.68747507508090659764294455885907E-02_dp
      xx(16)=-3.97369154725756609178291847368589E-01_dp
      ww(17)= 4.68747507508090659764294455885907E-02_dp
      xx(17)= 3.97369154725756609178291847368589E-01_dp
      ww(18)= 4.57771400531459593713398338468248E-02_dp
      xx(18)=-4.43705176538531601995589301065823E-01_dp
      ww(19)= 4.57771400531459593713398338468248E-02_dp
      xx(19)= 4.43705176538531601995589301065823E-01_dp
      ww(20)= 4.45601020350834882715414198310884E-02_dp
      xx(20)=-4.88883622262252118820698511425830E-01_dp
      ww(21)= 4.45601020350834882715414198310884E-02_dp
      xx(21)= 4.88883622262252118820698511425830E-01_dp
      ww(22)= 4.32268118124960979010436458226829E-02_dp
      xx(22)=-5.32786626502925265638481716373072E-01_dp
      ww(23)= 4.32268118124960979010436458226829E-02_dp
      xx(23)= 5.32786626502925265638481716373072E-01_dp
      ww(24)= 4.17807477908884920666755723510730E-02_dp
      xx(24)=-5.75299651350830618600369981944973E-01_dp
      ww(25)= 4.17807477908884920666755723510730E-02_dp
      xx(25)= 5.75299651350830618600369981944973E-01_dp
      ww(26)= 4.02256825909982473676399837575116E-02_dp
      xx(26)=-6.16311785197921724709616859328591E-01_dp
      ww(27)= 4.02256825909982473676399837575116E-02_dp
      xx(27)= 6.16311785197921724709616859328591E-01_dp
      ww(28)= 3.85656732070081727461520476296538E-02_dp
      xx(28)=-6.55716032095070871699185777836307E-01_dp
      ww(29)= 3.85656732070081727461520476296538E-02_dp
      xx(29)= 6.55716032095070871699185777836307E-01_dp
      ww(30)= 3.68050504231548173843210428640675E-02_dp
      xx(30)=-6.93409590894491155499184363960232E-01_dp
      ww(31)= 3.68050504231548173843210428640675E-02_dp
      xx(31)= 6.93409590894491155499184363960232E-01_dp
      ww(32)= 3.49484075165333510908519192092193E-02_dp
      xx(32)=-7.29294123449465109688956690135532E-01_dp
      ww(33)= 3.49484075165333510908519192092193E-02_dp
      xx(33)= 7.29294123449465109688956690135532E-01_dp
      ww(34)= 3.30005882759074106327236834410045E-02_dp
      xx(34)=-7.63276011172312197145914668494350E-01_dp
      ww(35)= 3.30005882759074106327236834410045E-02_dp
      xx(35)= 7.63276011172312197145914668494350E-01_dp
      ww(36)= 3.09666743683973948246979466124894E-02_dp
      xx(36)=-7.95266599282359649152048802752546E-01_dp
      ww(37)= 3.09666743683973948246979466124894E-02_dp
      xx(37)= 7.95266599282359649152048802752546E-01_dp
      ww(38)= 2.88519720881834015043417755455903E-02_dp
      xx(38)=-8.25182428108659950664281892450848E-01_dp
      ww(39)= 2.88519720881834015043417755455903E-02_dp
      xx(39)= 8.25182428108659950664281892450848E-01_dp
      ww(40)= 2.66619985241508896628107068449680E-02_dp
      xx(40)=-8.52945450847663445564846904674171E-01_dp
      ww(41)= 2.66619985241508896628107068449680E-02_dp
      xx(41)= 8.52945450847663445564846904674171E-01_dp
      ww(42)= 2.44024671875442029153406597324675E-02_dp
      xx(42)=-8.78483237214881032478947513893353E-01_dp
      ww(43)= 2.44024671875442029153406597324675E-02_dp
      xx(43)= 8.78483237214881032478947513893353E-01_dp
      ww(44)= 2.20792731483190440024757656281816E-02_dp
      xx(44)=-9.01729162474001170642040042683511E-01_dp
      ww(45)= 2.20792731483190440024757656281816E-02_dp
      xx(45)= 9.01729162474001170642040042683511E-01_dp
      ww(46)= 1.96984777461011813305178302126846E-02_dp
      xx(46)=-9.22622581382955261257551500555845E-01_dp
      ww(47)= 1.96984777461011813305178302126846E-02_dp
      xx(47)= 9.22622581382955261257551500555845E-01_dp
      ww(48)= 1.72662929876137435944332127724366E-02_dp
      xx(48)=-9.41108986681361147477543860977789E-01_dp
      ww(49)= 1.72662929876137435944332127724366E-02_dp
      xx(49)= 9.41108986681361147477543860977789E-01_dp
      ww(50)= 1.47890658849379145461785157814883E-02_dp
      xx(50)=-9.57140151912984091372080287421215E-01_dp
      ww(51)= 1.47890658849379145461785157814883E-02_dp
      xx(51)= 9.57140151912984091372080287421215E-01_dp
      ww(52)= 1.22732635078121046292778003595261E-02_dp
      xx(52)=-9.70674258833182908247408453547910E-01_dp
      ww(53)= 1.22732635078121046292778003595261E-02_dp
      xx(53)= 9.70674258833182908247408453547910E-01_dp
      ww(54)= 9.72546183035613373613667175557012E-03_dp
      xx(54)=-9.81676011284037079685172540751319E-01_dp
      ww(55)= 9.72546183035613373613667175557012E-03_dp
      xx(55)= 9.81676011284037079685172540751319E-01_dp
      ww(56)= 7.15235499174908958583399309169418E-03_dp
      xx(56)=-9.90116745232517050965531685699916E-01_dp
      ww(57)= 7.15235499174908958583399309169418E-03_dp
      xx(57)= 9.90116745232517050965531685699916E-01_dp
      ww(58)= 4.56092400601241718453893257974279E-03_dp
      xx(58)=-9.95974599815120234268012760712288E-01_dp
      ww(59)= 4.56092400601241718453893257974279E-03_dp
      xx(59)= 9.95974599815120234268012760712288E-01_dp
      ww(60)= 1.96145336167028267177306446192685E-03_dp
      xx(60)=-9.99235597631363471731862259569131E-01_dp
      ww(61)= 1.96145336167028267177306446192685E-03_dp
      xx(61)= 9.99235597631363471731862259569131E-01_dp
      RETURN
   END IF
!
   IF(norder == 62)THEN
      ww(1)= 5.02480003752562816884029489951357E-02_dp
      xx(1)=-2.51292914218206147270882759991470E-02_dp
      ww(2)= 5.02480003752562816884029489951357E-02_dp
      xx(2)= 2.51292914218206147270882759991470E-02_dp
      ww(3)= 5.01210695690432880748041001015310E-02_dp
      xx(3)=-7.53243954962343327638269391178709E-02_dp
      ww(4)= 5.01210695690432880748041001015310E-02_dp
      xx(4)= 7.53243954962343327638269391178709E-02_dp
      ww(5)= 4.98675285949523942447613106348428E-02_dp
      xx(5)=-1.25329223615896808619648999499726E-01_dp
      ww(6)= 4.98675285949523942447613106348428E-02_dp
      xx(6)= 1.25329223615896808619648999499726E-01_dp
      ww(7)= 4.94880179196992925278658109047740E-02_dp
      xx(7)=-1.75017459249015628555687423904236E-01_dp
      ww(8)= 4.94880179196992925278658109047740E-02_dp
      xx(8)= 1.75017459249015628555687423904236E-01_dp
      ww(9)= 4.89834962205178371048511270262174E-02_dp
      xx(9)=-2.24263585604165531668991393344883E-01_dp
      ww(10)= 4.89834962205178371048511270262174E-02_dp
      xx(10)= 2.24263585604165531668991393344883E-01_dp
      ww(11)= 4.83552379634776728348031814784590E-02_dp
      xx(11)=-2.72943202696726343188683627973481E-01_dp
      ww(12)= 4.83552379634776728348031814784590E-02_dp
      xx(12)= 2.72943202696726343188683627973481E-01_dp
      ww(13)= 4.76048301841012322704500882678664E-02_dp
      xx(13)=-3.20933341594194004074101601003456E-01_dp
      ww(14)= 4.76048301841012322704500882678664E-02_dp
      xx(14)= 3.20933341594194004074101601003456E-01_dp
      ww(15)= 4.67341684784155248022070550794848E-02_dp
      xx(15)=-3.68112775046564529663021830952508E-01_dp
      ww(16)= 4.67341684784155248022070550794848E-02_dp
      xx(16)= 3.68112775046564529663021830952508E-01_dp
      ww(17)= 4.57454522145701807772322722976962E-02_dp
      xx(17)=-4.14362323717126048129588750657611E-01_dp
      ww(18)= 4.57454522145701807772322722976962E-02_dp
      xx(18)= 4.14362323717126048129588750657611E-01_dp
      ww(19)= 4.46411789771244142936446918091378E-02_dp
      xx(19)=-4.59565157240113395207143978075753E-01_dp
      ww(20)= 4.46411789771244142936446918091378E-02_dp
      xx(20)= 4.59565157240113395207143978075753E-01_dp
      ww(21)= 4.34241382580474195800692304339443E-02_dp
      xx(21)=-5.03607089344755955917020805931616E-01_dp
      ww(22)= 4.34241382580474195800692304339443E-02_dp
      xx(22)= 5.03607089344755955917020805931616E-01_dp
      ww(23)= 4.20974044103850966430226269038388E-02_dp
      xx(23)=-5.46376866300251095816100384523634E-01_dp
      ww(24)= 4.20974044103850966430226269038388E-02_dp
      xx(24)= 5.46376866300251095816100384523634E-01_dp
      ww(25)= 4.06643288824174409682850175166634E-02_dp
      xx(25)=-5.87766447953087338002149550121988E-01_dp
      ww(26)= 4.06643288824174409682850175166634E-02_dp
      xx(26)= 5.87766447953087338002149550121988E-01_dp
      ww(27)= 3.91285317519630841233108018226089E-02_dp
      xx(27)=-6.27671280646885180726954764916163E-01_dp
      ww(28)= 3.91285317519630841233108018226089E-02_dp
      xx(28)= 6.27671280646885180726954764916163E-01_dp
      ww(29)= 3.74938925822800299856185635187930E-02_dp
      xx(29)=-6.65990561335479446997546034082388E-01_dp
      ww(30)= 3.74938925822800299856185635187930E-02_dp
      xx(30)= 6.65990561335479446997546034082388E-01_dp
      ww(31)= 3.57645406227681412855873783617220E-02_dp
      xx(31)=-7.02627492222297055120972765059987E-01_dp
      ww(32)= 3.57645406227681412855873783617220E-02_dp
      xx(32)= 7.02627492222297055120972765059987E-01_dp
      ww(33)= 3.39448443794105450911174772542361E-02_dp
      xx(33)=-7.37489525283156749860784276501440E-01_dp
      ww(34)= 3.39448443794105450911174772542361E-02_dp
      xx(34)= 7.37489525283156749860784276501440E-01_dp
      ww(35)= 3.20394005816246781063392372781564E-02_dp
      xx(35)=-7.70488596055419318990944694995048E-01_dp
      ww(36)= 3.20394005816246781063392372781564E-02_dp
      xx(36)= 7.70488596055419318990944694995048E-01_dp
      ww(37)= 3.00530225739898700770094692270624E-02_dp
      xx(37)=-8.01541346103976371538505514495386E-01_dp
      ww(38)= 3.00530225739898700770094692270624E-02_dp
      xx(38)= 8.01541346103976371538505514495386E-01_dp
      ww(39)= 2.79907281633146375412382927540413E-02_dp
      xx(39)=-8.30569333604004851345931109477208E-01_dp
      ww(40)= 2.79907281633146375412382927540413E-02_dp
      xx(40)= 8.30569333604004851345931109477208E-01_dp
      ww(41)= 2.58577269540246980270955665535105E-02_dp
      xx(41)=-8.57499231512070922818403320544675E-01_dp
      ww(42)= 2.58577269540246980270955665535105E-02_dp
      xx(42)= 8.57499231512070922818403320544675E-01_dp
      ww(43)= 2.36594072086827925745168006505346E-02_dp
      xx(43)=-8.82263012831897363072686624355830E-01_dp
      ww(44)= 2.36594072086827925745168006505346E-02_dp
      xx(44)= 8.82263012831897363072686624355830E-01_dp
      ww(45)= 2.14013222776699688411790899649053E-02_dp
      xx(45)=-9.04798122521093465758485602428376E-01_dp
      ww(46)= 2.14013222776699688411790899649053E-02_dp
      xx(46)= 9.04798122521093465758485602428376E-01_dp
      ww(47)= 1.90891766585731987325037124822838E-02_dp
      xx(47)=-9.25047635636203755227300130757049E-01_dp
      ww(48)= 1.90891766585731987325037124822838E-02_dp
      xx(48)= 9.25047635636203755227300130757049E-01_dp
      ww(49)= 1.67288117901773162885504717840925E-02_dp
      xx(49)=-9.42960401392328503826364811623352E-01_dp
      ww(50)= 1.67288117901773162885504717840925E-02_dp
      xx(50)= 9.42960401392328503826364811623352E-01_dp
      ww(51)= 1.43261918238065177674028823094146E-02_dp
      xx(51)=-9.58491172973927092029560475165971E-01_dp
      ww(52)= 1.43261918238065177674028823094146E-02_dp
      xx(52)= 9.58491172973927092029560475165971E-01_dp
      ww(53)= 1.18873901170105019448189389667979E-02_dp
      xx(53)=-9.71600723371651806447179482540306E-01_dp
      ww(54)= 1.18873901170105019448189389667979E-02_dp
      xx(54)= 9.71600723371651806447179482540306E-01_dp
      ww(55)= 9.41857942842038763793756340656643E-03_dp
      xx(55)=-9.82255949097236649491103128009793E-01_dp
      ww(56)= 9.41857942842038763793756340656643E-03_dp
      xx(56)= 9.82255949097236649491103128009793E-01_dp
      ww(57)= 6.92604190183096087170282409925707E-03_dp
      xx(57)=-9.90429971189290352428071061860681E-01_dp
      ww(58)= 6.92604190183096087170282409925707E-03_dp
      xx(58)= 9.90429971189290352428071061860681E-01_dp
      ww(59)= 4.41633345693090481327412425549064E-03_dp
      xx(59)=-9.96102296316267132885148430476171E-01_dp
      ww(60)= 4.41633345693090481327412425549064E-03_dp
      xx(60)= 9.96102296316267132885148430476171E-01_dp
      ww(61)= 1.89920567951369048039734386093514E-03_dp
      xx(61)=-9.99259859308777029698408465035799E-01_dp
      ww(62)= 1.89920567951369048039734386093514E-03_dp
      xx(62)= 9.99259859308777029698408465035799E-01_dp
      RETURN
   END IF
!
   IF(norder == 63)THEN
      ww(1)= 4.94723666239310208886693604209259E-02_dp
      xx(1)= 0.00000000000000000000000000000000E+00_dp
      ww(2)= 4.94118330399181789670396461167049E-02_dp
      xx(2)=-4.94521871161596272342338180518076E-02_dp
      ww(3)= 4.94118330399181789670396461167049E-02_dp
      xx(3)= 4.94521871161596272342338180518076E-02_dp
      ww(4)= 4.92303804237475607850431169881446E-02_dp
      xx(4)=-9.87833564469452795297036694539221E-02_dp
      ww(5)= 4.92303804237475607850431169881446E-02_dp
      xx(5)= 9.87833564469452795297036694539221E-02_dp
      ww(6)= 4.89284528205119899447093615492148E-02_dp
      xx(6)=-1.47872786357871968569839096552973E-01_dp
      ww(7)= 4.89284528205119899447093615492148E-02_dp
      xx(7)= 1.47872786357871968569839096552973E-01_dp
      ww(8)= 4.85067890978838478640900991458016E-02_dp
      xx(8)=-1.96600346791506684557627457065718E-01_dp
      ww(9)= 4.85067890978838478640900991458016E-02_dp
      xx(9)= 1.96600346791506684557627457065718E-01_dp
      ww(10)= 4.79664211379951314110527561951323E-02_dp
      xx(10)=-2.44846793245953362748404593924829E-01_dp
      ww(11)= 4.79664211379951314110527561951323E-02_dp
      xx(11)= 2.44846793245953362748404593924829E-01_dp
      ww(12)= 4.73086713122689190806049883388441E-02_dp
      xx(12)=-2.92494058586251440036157155550667E-01_dp
      ww(13)= 4.73086713122689190806049883388441E-02_dp
      xx(13)= 2.92494058586251440036157155550667E-01_dp
      ww(14)= 4.65351492453836965103954187469532E-02_dp
      xx(14)=-3.39425541974584402468834431594315E-01_dp
      ww(15)= 4.65351492453836965103954187469532E-02_dp
      xx(15)= 3.39425541974584402468834431594315E-01_dp
      ww(16)= 4.56477478762926086858859926085425E-02_dp
      xx(16)=-3.85526394212247892477615022274398E-01_dp
      ww(17)= 4.56477478762926086858859926085425E-02_dp
      xx(17)= 3.85526394212247892477615022274398E-01_dp
      ww(18)= 4.46486388259413953703326695168134E-02_dp
      xx(18)=-4.30683798795111600662088933918630E-01_dp
      ww(19)= 4.46486388259413953703326695168134E-02_dp
      xx(19)= 4.30683798795111600662088933918630E-01_dp
      ww(20)= 4.35402670830275907989643157044011E-02_dp
      xx(20)=-4.74787247994804399922212309851495E-01_dp
      ww(21)= 4.35402670830275907989643157044011E-02_dp
      xx(21)= 4.74787247994804399922212309851495E-01_dp
      ww(22)= 4.23253450208158229825054854030275E-02_dp
      xx(22)=-5.17728813290033248124477584526316E-01_dp
      ww(23)= 4.23253450208158229825054854030275E-02_dp
      xx(23)= 5.17728813290033248124477584526316E-01_dp
      ww(24)= 4.10068457596663986351100370090723E-02_dp
      xx(24)=-5.59403409486285013267697800070055E-01_dp
      ww(25)= 4.10068457596663986351100370090723E-02_dp
      xx(25)= 5.59403409486285013267697800070055E-01_dp
      ww(26)= 3.95879958915440939848079281492024E-02_dp
      xx(26)=-5.99709051877625235739008926868800E-01_dp
      ww(27)= 3.95879958915440939848079281492024E-02_dp
      xx(27)= 5.99709051877625235739008926868800E-01_dp
      ww(28)= 3.80722675843495567636383249278892E-02_dp
      xx(28)=-6.38547105821365385000306953873376E-01_dp
      ww(29)= 3.80722675843495567636383249278892E-02_dp
      xx(29)= 6.38547105821365385000306953873376E-01_dp
      ww(30)= 3.64633700854572896304524097875418E-02_dp
      xx(30)=-6.75822528114986090131103315969544E-01_dp
      ww(31)= 3.64633700854572896304524097875418E-02_dp
      xx(31)= 6.75822528114986090131103315969544E-01_dp
      ww(32)= 3.47652406453558776971805046427882E-02_dp
      xx(32)=-7.11444099584845807851431537704015E-01_dp
      ww(33)= 3.47652406453558776971805046427882E-02_dp
      xx(33)= 7.11444099584845807851431537704015E-01_dp
      ww(34)= 3.29820348837793417656831796724593E-02_dp
      xx(34)=-7.45324648317847417829321661037588E-01_dp
      ww(35)= 3.29820348837793417656831796724593E-02_dp
      xx(35)= 7.45324648317847417829321661037588E-01_dp
      ww(36)= 3.11181166222198175082159885571886E-02_dp
      xx(36)=-7.77381262990372335563330189911043E-01_dp
      ww(37)= 3.11181166222198175082159885571886E-02_dp
      xx(37)= 7.77381262990372335563330189911043E-01_dp
      ww(38)= 2.91780472082805269455515021540288E-02_dp
      xx(38)=-8.07535495773456760051465986363243E-01_dp
      ww(39)= 2.91780472082805269455515021540288E-02_dp
      xx(39)= 8.07535495773456760051465986363243E-01_dp
      ww(40)= 2.71665743590979332251898394394127E-02_dp
      xx(40)=-8.35713554319502843471807769615705E-01_dp
      ww(41)= 2.71665743590979332251898394394127E-02_dp
      xx(41)= 8.35713554319502843471807769615705E-01_dp
      ww(42)= 2.50886205533449866186301380684434E-02_dp
      xx(42)=-8.61846482364123719539611839431060E-01_dp
      ww(43)= 2.50886205533449866186301380684434E-02_dp
      xx(43)= 8.61846482364123719539611839431060E-01_dp
      ww(44)= 2.29492710048899331489423195617705E-02_dp
      xx(44)=-8.85870328507853426290298457313370E-01_dp
      ww(45)= 2.29492710048899331489423195617705E-02_dp
      xx(45)= 8.85870328507853426290298457313370E-01_dp
      ww(46)= 2.07537612580390907753419534214732E-02_dp
      xx(46)=-9.07726302778531558036953132915953E-01_dp
      ww(47)= 2.07537612580390907753419534214732E-02_dp
      xx(47)= 9.07726302778531558036953132915953E-01_dp
      ww(48)= 1.85074644601612704092605458051580E-02_dp
      xx(48)=-9.27360920621843205447031381325122E-01_dp
      ww(49)= 1.85074644601612704092605458051580E-02_dp
      xx(49)= 9.27360920621843205447031381325122E-01_dp
      ww(50)= 1.62158784103383388822836729751309E-02_dp
      xx(50)=-9.44726134041009802966375319627501E-01_dp
      ww(51)= 1.62158784103383388822836729751309E-02_dp
      xx(51)= 9.44726134041009802966375319627501E-01_dp
      ww(52)= 1.38846126161156108248660863676244E-02_dp
      xx(52)=-9.59779449758941927070354166258989E-01_dp
      ww(53)= 1.38846126161156108248660863676244E-02_dp
      xx(53)= 9.59779449758941927070354166258989E-01_dp
      ww(54)= 1.15193760768800417507506061486181E-02_dp
      xx(54)=-9.72484034697570022801960678576811E-01_dp
      ww(55)= 1.15193760768800417507506061486181E-02_dp
      xx(55)= 9.72484034697570022801960678576811E-01_dp
      ww(56)= 9.12596867632665635405864542175996E-03_dp
      xx(56)=-9.82808810593727234862511405691612E-01_dp
      ww(57)= 9.12596867632665635405864542175996E-03_dp
      xx(57)= 9.82808810593727234862511405691612E-01_dp
      ww(58)= 6.71029176596013625190693072972880E-03_dp
      xx(58)=-9.90728546892189466810894667204703E-01_dp
      ww(59)= 6.71029176596013625190693072972880E-03_dp
      xx(59)= 9.90728546892189466810894667204703E-01_dp
      ww(60)= 4.27850834686376186607841108262279E-03_dp
      xx(60)=-9.96224012777970108602193361146311E-01_dp
      ww(61)= 4.27850834686376186607841108262279E-03_dp
      xx(61)= 9.96224012777970108602193361146311E-01_dp
      ww(62)= 1.83987459557708411709244555404392E-03_dp
      xx(62)=-9.99282984029123780378936140928944E-01_dp
      ww(63)= 1.83987459557708411709244555404392E-03_dp
      xx(63)= 9.99282984029123780378936140928944E-01_dp
      RETURN
   END IF
!
   IF(norder == 64)THEN
      ww(1)= 4.86909570091397203833653907347499E-02_dp
      xx(1)=-2.43502926634244325089558428537157E-02_dp
      ww(2)= 4.86909570091397203833653907347499E-02_dp
      xx(2)= 2.43502926634244325089558428537157E-02_dp
      ww(3)= 4.85754674415034269347990667839781E-02_dp
      xx(3)=-7.29931217877990394495429419403375E-02_dp
      ww(4)= 4.85754674415034269347990667839781E-02_dp
      xx(4)= 7.29931217877990394495429419403375E-02_dp
      ww(5)= 4.83447622348029571697695271580178E-02_dp
      xx(5)=-1.21462819296120554470376463492248E-01_dp
      ww(6)= 4.83447622348029571697695271580178E-02_dp
      xx(6)= 1.21462819296120554470376463492248E-01_dp
      ww(7)= 4.79993885964583077281261798713461E-02_dp
      xx(7)=-1.69644420423992818037313629748270E-01_dp
      ww(8)= 4.79993885964583077281261798713461E-02_dp
      xx(8)= 1.69644420423992818037313629748270E-01_dp
      ww(9)= 4.75401657148303086622822069442232E-02_dp
      xx(9)=-2.17423643740007084149648748988823E-01_dp
      ww(10)= 4.75401657148303086622822069442232E-02_dp
      xx(10)= 2.17423643740007084149648748988823E-01_dp
      ww(11)= 4.69681828162100173253262857545811E-02_dp
      xx(11)=-2.64687162208767416373964172510020E-01_dp
      ww(12)= 4.69681828162100173253262857545811E-02_dp
      xx(12)= 2.64687162208767416373964172510020E-01_dp
      ww(13)= 4.62847965813144172959532492322612E-02_dp
      xx(13)=-3.11322871990210956157512698560157E-01_dp
      ww(14)= 4.62847965813144172959532492322612E-02_dp
      xx(14)= 3.11322871990210956157512698560157E-01_dp
      ww(15)= 4.54916279274181444797709969712691E-02_dp
      xx(15)=-3.57220158337668115950442615046203E-01_dp
      ww(16)= 4.54916279274181444797709969712691E-02_dp
      xx(16)= 3.57220158337668115950442615046203E-01_dp
      ww(17)= 4.45905581637565630601347100309448E-02_dp
      xx(17)=-4.02270157963991603695766771260159E-01_dp
      ww(18)= 4.45905581637565630601347100309448E-02_dp
      xx(18)= 4.02270157963991603695766771260159E-01_dp
      ww(19)= 4.35837245293234533768278609737375E-02_dp
      xx(19)=-4.46366017253464087984947714758915E-01_dp
      ww(20)= 4.35837245293234533768278609737375E-02_dp
      xx(20)= 4.46366017253464087984947714758915E-01_dp
      ww(21)= 4.24735151236535890073397679088174E-02_dp
      xx(21)=-4.89403145707052957478526307021921E-01_dp
      ww(22)= 4.24735151236535890073397679088174E-02_dp
      xx(22)= 4.89403145707052957478526307021921E-01_dp
      ww(23)= 4.12625632426235286101562974736380E-02_dp
      xx(23)=-5.31279464019894545658013903544455E-01_dp
      ww(24)= 4.12625632426235286101562974736380E-02_dp
      xx(24)= 5.31279464019894545658013903544455E-01_dp
      ww(25)= 3.99537411327203413866569261283361E-02_dp
      xx(25)=-5.71895646202634034283878116659189E-01_dp
      ww(26)= 3.99537411327203413866569261283361E-02_dp
      xx(26)= 5.71895646202634034283878116659189E-01_dp
      ww(27)= 3.85501531786156291289624969468090E-02_dp
      xx(27)=-6.11155355172393250248852971018549E-01_dp
      ww(28)= 3.85501531786156291289624969468090E-02_dp
      xx(28)= 6.11155355172393250248852971018549E-01_dp
      ww(29)= 3.70551285402400460404151018095834E-02_dp
      xx(29)=-6.48965471254657339857761231993405E-01_dp
      ww(30)= 3.70551285402400460404151018095834E-02_dp
      xx(30)= 6.48965471254657339857761231993405E-01_dp
      ww(31)= 3.54722132568823838106931467152460E-02_dp
      xx(31)=-6.85236313054233242563558371031376E-01_dp
      ww(32)= 3.54722132568823838106931467152460E-02_dp
      xx(32)= 6.85236313054233242563558371031376E-01_dp
      ww(33)= 3.38051618371416093915654821107254E-02_dp
      xx(33)=-7.19881850171610826848940217831947E-01_dp
      ww(34)= 3.38051618371416093915654821107254E-02_dp
      xx(34)= 7.19881850171610826848940217831947E-01_dp
      ww(35)= 3.20579283548515535854675043478987E-02_dp
      xx(35)=-7.52819907260531896611863774885694E-01_dp
      ww(36)= 3.20579283548515535854675043478987E-02_dp
      xx(36)= 7.52819907260531896611863774885694E-01_dp
      ww(37)= 3.02346570724024788679740598195487E-02_dp
      xx(37)=-7.83972358943341407610220525213768E-01_dp
      ww(38)= 3.02346570724024788679740598195487E-02_dp
      xx(38)= 7.83972358943341407610220525213768E-01_dp
      ww(39)= 2.83396726142594832275113052002374E-02_dp
      xx(39)=-8.13265315122797559741923338086303E-01_dp
      ww(40)= 2.83396726142594832275113052002374E-02_dp
      xx(40)= 8.13265315122797559741923338086303E-01_dp
      ww(41)= 2.63774697150546586716917926252252E-02_dp
      xx(41)=-8.40629296252580362751691544695873E-01_dp
      ww(42)= 2.63774697150546586716917926252252E-02_dp
      xx(42)= 8.40629296252580362751691544695873E-01_dp
      ww(43)= 2.43527025687108733381775504090690E-02_dp
      xx(43)=-8.65999398154092819760783385070158E-01_dp
      ww(44)= 2.43527025687108733381775504090690E-02_dp
      xx(44)= 8.65999398154092819760783385070158E-01_dp
      ww(45)= 2.22701738083832541592983303841550E-02_dp
      xx(45)=-8.89315445995114105853404038272852E-01_dp
      ww(46)= 2.22701738083832541592983303841550E-02_dp
      xx(46)= 8.89315445995114105853404038272852E-01_dp
      ww(47)= 2.01348231535302093723403167285439E-02_dp
      xx(47)=-9.10522137078502805756380668008330E-01_dp
      ww(48)= 2.01348231535302093723403167285439E-02_dp
      xx(48)= 9.10522137078502805756380668008330E-01_dp
      ww(49)= 1.79517157756973430850453020011194E-02_dp
      xx(49)=-9.29569172131939575821490154559226E-01_dp
      ww(50)= 1.79517157756973430850453020011194E-02_dp
      xx(50)= 9.29569172131939575821490154559226E-01_dp
      ww(51)= 1.57260304760247193219659952975398E-02_dp
      xx(51)=-9.46411374858402816062481491347265E-01_dp
      ww(52)= 1.57260304760247193219659952975398E-02_dp
      xx(52)= 9.46411374858402816062481491347265E-01_dp
      ww(53)= 1.34630478967186425980607666859557E-02_dp
      xx(53)=-9.61008799652053718918614121897157E-01_dp
      ww(54)= 1.34630478967186425980607666859557E-02_dp
      xx(54)= 9.61008799652053718918614121897157E-01_dp
      ww(55)= 1.11681394601311288185904930192081E-02_dp
      xx(55)=-9.73326827789910963741853507352273E-01_dp
      ww(56)= 1.11681394601311288185904930192081E-02_dp
      xx(56)= 9.73326827789910963741853507352273E-01_dp
      ww(57)= 8.84675982636394772303091465973065E-03_dp
      xx(57)=-9.83336253884625956931299302156831E-01_dp
      ww(58)= 8.84675982636394772303091465973065E-03_dp
      xx(58)= 9.83336253884625956931299302156831E-01_dp
      ww(59)= 6.50445796897836285611736039998127E-03_dp
      xx(59)=-9.91013371476744320739382383443303E-01_dp
      ww(60)= 6.50445796897836285611736039998127E-03_dp
      xx(60)= 9.91013371476744320739382383443303E-01_dp
      ww(61)= 4.14703326056246763528753572855142E-03_dp
      xx(61)=-9.96340116771955279346924500676399E-01_dp
      ww(62)= 4.14703326056246763528753572855142E-03_dp
      xx(62)= 9.96340116771955279346924500676399E-01_dp
      ww(63)= 1.78328072169643294729607914497193E-03_dp
      xx(63)=-9.99305041735772139456905624345636E-01_dp
      ww(64)= 1.78328072169643294729607914497193E-03_dp
      xx(64)= 9.99305041735772139456905624345636E-01_dp
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE gausscoeff
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gaussq(ns,c,b,nsd,a)
!
!   from Ernst Hairer
!
!      IMPLICIT REAL*16 (A-H,O-Z)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ns
   REAL(KIND=dp), INTENT(OUT)               :: c(ns)
   REAL(KIND=dp), INTENT(OUT)               :: b(ns)
   INTEGER, INTENT(IN)                      :: nsd
   REAL(KIND=dp), INTENT(OUT)               :: a(nsd,ns)
!
   c=0.0_dp
   b=0.0_dp
   a=0.0_dp
!
   IF(ns == 2)THEN
      c(1)=0.211324865405187117745425609749E+00_dp
      c(2)=0.788675134594812882254574390251E+00_dp
      b(1)=0.5E+00_dp
      a(1,1)=0.250000000000000000000000000000E+00_dp
      a(1,2)=-0.386751345948128822545743902510E-01_dp
      a(2,1)=0.538675134594812882254574390251E+00_dp
      a(2,2)=0.250000000000000000000000000000E+00_dp
   END IF
   IF(ns == 3)THEN
      c(1)=0.112701665379258311482073460022E+00_dp
      c(2)=0.500000000000000000000000000000E+00_dp
      c(3)=0.887298334620741688517926539978E+00_dp
      b(1)=0.277777777777777777777777777778E+00_dp
      b(2)=0.444444444444444444444444444444E+00_dp
      a(1,1)=0.138888888888888888888888888889E+00_dp
      a(1,2)=-0.359766675249389034563954710966E-01_dp
      a(1,3)=0.978944401530832604958004222948E-02_dp
      a(2,1)=0.300263194980864592438024947213E+00_dp
      a(2,2)=0.222222222222222222222222222222E+00_dp
      a(2,3)=-0.224854172030868146602471694354E-01_dp
      a(3,1)=0.267988333762469451728197735548E+00_dp
      a(3,2)=0.480421111969383347900839915541E+00_dp
      a(3,3)=0.138888888888888888888888888889E+00_dp
   END IF
   IF(ns == 4)THEN
      c(1)=0.694318442029737123880267555536E-01_dp
      c(2)=0.330009478207571867598667120448E+00_dp
      c(3)=0.669990521792428132401332879552E+00_dp
      c(4)=0.930568155797026287611973244446E+00_dp
      b(1)=0.173927422568726928686531974611E+00_dp
      b(2)=0.326072577431273071313468025389E+00_dp
      a(1,1)=0.869637112843634643432659873055E-01_dp
      a(1,2)=-0.266041800849987933133851304770E-01_dp
      a(1,3)=0.126274626894047245150568805746E-01_dp
      a(1,4)=-0.355514968579568315691098184957E-02_dp
      a(2,1)=0.188118117499868071650685545087E+00_dp
      a(2,2)=0.163036288715636535656734012694E+00_dp
      a(2,3)=-0.278804286024708952241511064190E-01_dp
      a(2,4)=0.673550059453815551539866908570E-02_dp
      a(3,1)=0.167191921974188773171133305525E+00_dp
      a(3,2)=0.353953006033743966537619131808E+00_dp
      a(3,3)=0.163036288715636535656734012694E+00_dp
      a(3,4)=-0.141906949311411429641535704762E-01_dp
      a(4,1)=0.177482572254522611843442956461E+00_dp
      a(4,2)=0.313445114741868346798411144814E+00_dp
      a(4,3)=0.352676757516271864626853155866E+00_dp
      a(4,4)=0.869637112843634643432659873055E-01_dp
   END IF
   IF(ns == 6)THEN
      c(1)=0.337652428984239860938492227530E-01_dp
      c(2)=0.169395306766867743169300202490E+00_dp
      c(3)=0.380690406958401545684749139160E+00_dp
      c(4)=0.619309593041598454315250860840E+00_dp
      c(5)=0.830604693233132256830699797510E+00_dp
      c(6)=0.966234757101576013906150777247E+00_dp
      b(1)=0.856622461895851725201480710863E-01_dp
      b(2)=0.180380786524069303784916756919E+00_dp
      b(3)=0.233956967286345523694935171995E+00_dp
      a(1,1)=0.428311230947925862600740355432E-01_dp
      a(1,2)=-0.147637259971974124753725910605E-01_dp
      a(1,3)=0.932505070647775119143888450801E-02_dp
      a(1,4)=-0.566885804948351190092125641622E-02_dp
      a(1,5)=0.285443331509933513092928583012E-02_dp
      a(1,6)=-0.812780171264762112299135651564E-03_dp
      a(2,1)=0.926734914303788631865122917633E-01_dp
      a(2,2)=0.901903932620346518924583784594E-01_dp
      a(2,3)=-0.203001022932395859524940805243E-01_dp
      a(2,4)=0.103631562402464237307199458066E-01_dp
      a(2,5)=-0.488719292803767146341420376580E-02_dp
      a(2,6)=0.135556105548506177551787075080E-02_dp
      a(3,1)=0.822479226128438738077716511411E-01_dp
      a(3,2)=0.196032162333245006055759781564E+00_dp
      a(3,3)=0.116978483643172761847467585997E+00_dp
      a(3,4)=-0.204825277456560976298590118654E-01_dp
      a(3,5)=0.798999189966233579720442148033E-02_dp
      a(3,6)=-0.207562578486633419359528915759E-02_dp
      a(4,1)=0.877378719744515067137433602439E-01_dp
      a(4,2)=0.172390794624406967987712335439E+00_dp
      a(4,3)=0.254439495032001621324794183860E+00_dp
      a(4,4)=0.116978483643172761847467585997E+00_dp
      a(4,5)=-0.156513758091757022708430246450E-01_dp
      a(4,6)=0.341432357674129871237641994524E-02_dp
      a(5,1)=0.843066851341001107446302003355E-01_dp
      a(5,2)=0.185267979452106975248330960685E+00_dp
      a(5,3)=0.223593811046099099964215226188E+00_dp
      a(5,4)=0.254257069579585109647429252519E+00_dp
      a(5,5)=0.901903932620346518924583784593E-01_dp
      a(5,6)=-0.701124524079369066636422067690E-02_dp
      a(6,1)=0.864750263608499346324472067378E-01_dp
      a(6,2)=0.177526353208969968653987471089E+00_dp
      a(6,3)=0.239625825335829035595856428410E+00_dp
      a(6,4)=0.224631916579867772503496287487E+00_dp
      a(6,5)=0.195144512521266716260289347979E+00_dp
      a(6,6)=0.428311230947925862600740355433E-01_dp
   END IF
!
   RETURN
!
END SUBROUTINE gaussq
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getalflim(istar,ialphmax,ibetmax,nalf,ibetlim,  &
   phase,finc,q,gradx,grady,gradz,xarray,yarray,zarray,nhoriz,  &
   xhoriz,yhoriz,bdist,mmdx,ialfmin,ialfmax,tertincl,tertbdist,  &
   tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
!  October 9, 1999
!
!  This routine will compute the 'projection' factor of each grid element on
!  the star (istar=1 to do star 1, istar=2 to do star2), check for eclipses
!  (the horizon of the other body is in xhoriz,yhoriz), and return the
!  sky coordinates of the visible points.  Set iecheck = -1 to skip the
!  check for
!  eclipses.
!
!  UPDATE JULY 4, 2004
!
!  Add jdum and MonteCarlo to the argument list.  If MonteCarlo > 10,
!  then use Monte Carlo integration to determine fractionally
!  eclipsed pixels.  If MonteCarlo < 10, then proceed as before
!  and use interpolation in getBBflux and getATMflux.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: gradx(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: grady(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gradz(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: xarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: yarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: zarray(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: nhoriz
   REAL(KIND=dp), INTENT(IN)                :: xhoriz(nhoriz)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz(nhoriz)
   REAL(KIND=dp), INTENT(IN)                :: bdist
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   INTEGER, INTENT(OUT)                     :: ialfmin
   INTEGER, INTENT(OUT)                     :: ialfmax
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp) :: tertxcen,tertycen,tomrad,phaser,fincr,ay,az,ax,xp
   REAL(KIND=dp) :: yp,ytran,xxoff,yyoff,xxoff1,yyoff1,proj,xx,yy,zz,xtran
!
   INTEGER :: iidx
   INTEGER :: ialf,ibet,iimax,iimin
   INTEGER :: iyes,icut
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!    November 18, 2012
!
!    If there is a third body, offset all x and y sky coordinates
!
   xxoff=0.0_dp
   yyoff=0.0_dp
   IF((isw30 >= 3).AND.(isw7 >= 2))THEN
      xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      tomrad=tertomega*degtorad
      xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
      yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
   END IF
!
!    Keep track of the smallest and largest values of ialf on star 1 that
!    are eclipsed.
!
   phaser=phase*degtorad
   fincr=finc*degtorad
   az=COS(fincr)
   IF(az < 0.0_dp)az=0.0_dp
   ax=-SIN(fincr)*COS(phaser)
   ay=SIN(fincr)*SIN(phaser)
!
!   Check to see of the star in question is in front.  If so, then simply
!   find the projection factors.
!
   iimax=-12345
   iimin=12345
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         proj=ax*gradx(iidx)+ay*grady(iidx)+az*gradz(iidx)
!
!   is the surface element visible?
!
         IF(proj < 0.0_dp)CYCLE
         xx=xarray(iidx)
         yy=yarray(iidx)
         zz=zarray(iidx)
         xp=xtran(xx,yy,phase,q,istar,bdist)
         yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
!
!   Check to see of the point in question is eclipsed by the other star, or
!   in the case of star 1, eclipsed by the disk, or
!   in the case of a point on the bottom half of star 2, eclipsed by the disk.
!   icut=2 for points outside and below the horizon.
!
         iyes=-100
         CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
         IF(iyes == 100)THEN
            IF(ialf < ialfmin)ialfmin=ialf
            IF(ialf < iimin)iimin=ialf
            IF(ialf > ialfmax)ialfmax=ialf
            IF(ialf > iimax)iimax=ialf
            CYCLE
         END IF
!
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE getalflim
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getanalfracs(nmaxphase,icount,fracs1,fracs2,  &
   fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,compfracs,nphase,  &
   xmod,eshift,pshift,sw26,fracstring)
!
!   October 10, 2007
!
!   This is a new routine that will return the luminosity ratios in
!   each bandpass.  compfracs(i,1) will have L_2/L_1, and
!   compfracs(i,2) will have L_disk/L_tot.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN OUT)                  :: icount
   REAL(KIND=dp), INTENT(OUT)               :: fracs1(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs2(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs3(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs4(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs5(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs6(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs7(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: fracs8(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: compfracs(8,3)
   INTEGER, INTENT(IN)                      :: nphase
   REAL(KIND=dp), INTENT(IN)                :: xmod(nmaxphase)
   REAL(KIND=dp), INTENT(IN)                :: eshift
   REAL(KIND=dp), INTENT(IN)                :: pshift
   REAL(KIND=dp), INTENT(IN)                :: sw26
   CHARACTER (LEN=350), INTENT(IN OUT)      :: fracstring
!
   REAL(KIND=dp), ALLOCATABLE   :: scratch1(:),scratch2(:),scratch3(:),xscratch(:)
   REAL(KIND=dp) :: aaa,bbb,ccc,ddd,eee,diffmin,q1,fred,q2
   REAL(KIND=dp) :: diff,rmedian1,rmedian2,rmedian3
!
   INTEGER ::  iii,i,nnn,jj
!
   ALLOCATE(xscratch(nmaxphase+10),scratch1(nmaxphase+10),  &
      scratch2(nmaxphase+10),scratch3(nmaxphase+10))
!
   aaa=1.0_dp
   bbb=1.0_dp
   ccc=1.0_dp
   eee=1.0_dp
!
   DO  i=1,8
      DO  iii=1,nphase
         nnn=iii
         IF(i == 1)THEN
            fracs1(nnn,1)=fracs1(iii,1)
            fracs1(nnn,2)=fracs1(iii,2)
            fracs1(nnn,3)=fracs1(iii,3)
            fracs1(nnn,4)=fracs1(iii,4)
         END IF
         IF(i == 2)THEN
            fracs2(nnn,1)=fracs2(iii,1)
            fracs2(nnn,2)=fracs2(iii,2)
            fracs2(nnn,3)=fracs2(iii,3)
            fracs2(nnn,4)=fracs2(iii,4)
         END IF
         IF(i == 3)THEN
            fracs3(nnn,1)=fracs3(iii,1)
            fracs3(nnn,2)=fracs3(iii,2)
            fracs3(nnn,3)=fracs3(iii,3)
            fracs3(nnn,4)=fracs3(iii,4)
         END IF
         IF(i == 4)THEN
            fracs4(nnn,1)=fracs4(iii,1)
            fracs4(nnn,2)=fracs4(iii,2)
            fracs4(nnn,3)=fracs4(iii,3)
            fracs4(nnn,4)=fracs4(iii,4)
         END IF
         IF(i == 5)THEN
            fracs5(nnn,1)=fracs5(iii,1)
            fracs5(nnn,2)=fracs5(iii,2)
            fracs5(nnn,3)=fracs5(iii,3)
            fracs5(nnn,4)=fracs5(iii,4)
         END IF
         IF(i == 6)THEN
            fracs6(nnn,1)=fracs6(iii,1)
            fracs6(nnn,2)=fracs6(iii,2)
            fracs6(nnn,3)=fracs6(iii,3)
            fracs6(nnn,4)=fracs6(iii,4)
         END IF
         IF(i == 7)THEN
            fracs7(nnn,1)=fracs7(iii,1)
            fracs7(nnn,2)=fracs7(iii,2)
            fracs7(nnn,3)=fracs7(iii,3)
            fracs7(nnn,4)=fracs7(iii,4)
         END IF
         IF(i == 8)THEN
            fracs8(nnn,1)=fracs8(iii,1)
            fracs8(nnn,2)=fracs8(iii,2)
            fracs8(nnn,3)=fracs8(iii,3)
            fracs8(nnn,4)=fracs8(iii,4)
         END IF
         xscratch(nnn)=xmod(iii)
         xscratch(iii)=xscratch(nnn)
      END DO
!
!  UPDATE October 27, 2008
!
!  If the variable sw26 is positive, then reference the disk fraction at
!  sw26.   Otherwise, take the median over the whole orbit.
!
      IF(sw26 <= 0.0_dp)THEN
         DO  jj=1,nnn
            IF(i == 1)THEN
               aaa=fracs1(jj,1)
               bbb=fracs1(jj,2)
               ccc=fracs1(jj,3)
               eee=fracs1(jj,4)
            END IF
            IF(i == 2)THEN
               aaa=fracs2(jj,1)
               bbb=fracs2(jj,2)
               ccc=fracs2(jj,3)
               eee=fracs2(jj,4)
            END IF
            IF(i == 3)THEN
               aaa=fracs3(jj,1)
               bbb=fracs3(jj,2)
               ccc=fracs3(jj,3)
               eee=fracs3(jj,4)
            END IF
            IF(i == 4)THEN
               aaa=fracs4(jj,1)
               bbb=fracs4(jj,2)
               ccc=fracs4(jj,3)
               eee=fracs4(jj,4)
            END IF
            IF(i == 5)THEN
               aaa=fracs5(jj,1)
               bbb=fracs5(jj,2)
               ccc=fracs5(jj,3)
               eee=fracs5(jj,4)
            END IF
            IF(i == 6)THEN
               aaa=fracs6(jj,1)
               bbb=fracs6(jj,2)
               ccc=fracs6(jj,3)
               eee=fracs6(jj,4)
            END IF
            IF(i == 7)THEN
               aaa=fracs7(jj,1)
               bbb=fracs7(jj,2)
               ccc=fracs7(jj,3)
               eee=fracs7(jj,4)
            END IF
            IF(i == 8)THEN
               aaa=fracs8(jj,1)
               bbb=fracs8(jj,2)
               ccc=fracs8(jj,3)
               eee=fracs8(jj,4)
            END IF
            ddd=aaa+bbb+ccc+eee
            IF(ABS(aaa) <= EPSILON(aaa))THEN
               scratch1(jj)=0.0_dp
               scratch3(jj)=0.0_dp
            ELSE
               scratch1(jj)=bbb/aaa
               scratch3(jj)=eee/aaa
            END IF
            IF(ABS(ddd) <= EPSILON(ddd))THEN
               scratch2(jj)=0.0_dp
            ELSE
               scratch2(jj)=ccc/ddd
            END IF
         END DO
!
         IF(icount <= 2)THEN
            compfracs(i,1)=0.0_dp
            compfracs(i,2)=0.0_dp
            compfracs(i,3)=0.0_dp
            CYCLE
         END IF
!
         IF(nnn > 1)CALL sort3(nnn,scratch1,scratch2,scratch3)
!
         q1=REAL(nnn/2,KIND=dp)
         q2=REAL(nnn,KIND=dp)/2.0_dp
         IF(ABS(q1-q2) <= EPSILON(q1))THEN
            rmedian1=(scratch1(nnn/2)+scratch1(nnn/2+1))/2.0_dp
         ELSE
            rmedian1=scratch1(nnn/2+1)
         END IF
!
         IF(nnn > 1)CALL sort3(nnn,scratch2,scratch1,scratch3)
!
         q1=REAL(nnn/2,KIND=dp)
         q2=REAL(nnn,KIND=dp)/2.0_dp
         IF(ABS(q1-q2) <= EPSILON(q1))THEN
            rmedian2=(scratch2(nnn/2)+scratch2(nnn/2+1))/2.0_dp
         ELSE
            rmedian2=scratch2(nnn/2+1)
         END IF
!
         IF(nnn > 1)CALL sort3(nnn,scratch3,scratch1,scratch2)
!
         q1=REAL(nnn/2,KIND=dp)
         q2=REAL(nnn,KIND=dp)/2.0_dp
         IF(ABS(q1-q2) <= EPSILON(q1))THEN
            rmedian3=(scratch3(nnn/2)+scratch3(nnn/2+1))/2.0_dp
         ELSE
            rmedian3=scratch3(nnn/2+1)
         END IF
!
         IF(rmedian1 < 0.0_dp)rmedian1=0.0_dp
         IF(rmedian2 < 0.0_dp)rmedian2=0.0_dp
         IF(rmedian3 < 0.0_dp)rmedian3=0.0_dp
!
         compfracs(i,1)=rmedian1
         compfracs(i,2)=rmedian2
         compfracs(i,3)=rmedian3
      ELSE
         diffmin=1.0E44_dp
         DO  jj=1,nnn
            fred=MOD(xscratch(jj)+eshift+pshift,1.0_dp)
            IF(fred < 0.0_dp)fred=fred+1.0_dp
            IF(fred > 1.0_dp)fred=fred-1.0_dp
            diff=ABS(fred-sw26)
            IF(diff <= diffmin)THEN
               diffmin=diff
               IF(i == 1)THEN
                  aaa=fracs1(jj,1)
                  bbb=fracs1(jj,2)
                  ccc=fracs1(jj,3)
                  eee=fracs1(jj,4)
               END IF
               IF(i == 2)THEN
                  aaa=fracs2(jj,1)
                  bbb=fracs2(jj,2)
                  ccc=fracs2(jj,3)
                  eee=fracs2(jj,4)
               END IF
               IF(i == 3)THEN
                  aaa=fracs3(jj,1)
                  bbb=fracs3(jj,2)
                  ccc=fracs3(jj,3)
                  eee=fracs3(jj,4)
               END IF
               IF(i == 4)THEN
                  aaa=fracs4(jj,1)
                  bbb=fracs4(jj,2)
                  ccc=fracs4(jj,3)
                  eee=fracs4(jj,4)
               END IF
               IF(i == 5)THEN
                  aaa=fracs5(jj,1)
                  bbb=fracs5(jj,2)
                  ccc=fracs5(jj,3)
                  eee=fracs5(jj,4)
               END IF
               IF(i == 6)THEN
                  aaa=fracs6(jj,1)
                  bbb=fracs6(jj,2)
                  ccc=fracs6(jj,3)
                  eee=fracs6(jj,4)
               END IF
               IF(i == 7)THEN
                  aaa=fracs7(jj,1)
                  bbb=fracs7(jj,2)
                  ccc=fracs7(jj,3)
                  eee=fracs7(jj,4)
               END IF
               IF(i == 8)THEN
                  aaa=fracs8(jj,1)
                  bbb=fracs8(jj,2)
                  ccc=fracs8(jj,3)
                  eee=fracs8(jj,4)
               END IF
!
               ddd=aaa+bbb+ccc+eee
               compfracs(i,1)=bbb/aaa
               IF(ABS(ddd) <= EPSILON(ddd))THEN
                  compfracs(i,2)=0.0_dp
               ELSE
                  compfracs(i,2)=ccc/ddd
               END IF
               IF(ABS(aaa) <= EPSILON(aaa))THEN
                  compfracs(i,3)=0.0_dp
               ELSE
                  compfracs(i,3)=eee/aaa
               END IF
            END IF
         END DO
      END IF
!
   END DO
!
   WRITE(fracstring,50)(compfracs(i,1),i=1,8),(compfracs(i,2),  &
      i=1,8),(compfracs(i,3),i=1,8)
!
50 FORMAT(24(1PE13.6,1X))
!
   DEALLOCATE(xscratch,scratch1,scratch2,scratch3)
!
   RETURN
!
END SUBROUTINE getanalfracs
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getanalyticint(maxlines,maxmu,nlines,atmt,atmg,  &
   atmmu,nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,  &
   atmint7,atmint8,gpole,darkint,tpole,dwavex,dwavey,ilaw,iatm,  &
   istar,wave,reff,separ)
!
!  December 9, 2009
!
!  This subroutine will evaluate the integral:
!
!  dint = int^1_0 (I(T,g,mu)*mu*du)
!
!  The dint values will go into the reference fluxes for the fast
!  analytic mode.
!
!  if iatm=0, then use black bodies
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: maxlines
   INTEGER, INTENT(IN)                      :: maxmu
   INTEGER, INTENT(IN)                      :: nlines
   REAL(KIND=dp), INTENT(IN)                :: atmt(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmg(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmmu(maxlines,maxmu)
   INTEGER, INTENT(IN)                      :: nmu(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmint1(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint2(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint3(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint4(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint5(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint6(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint7(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint8(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: gpole
   REAL(KIND=dp), INTENT(OUT)               :: darkint(8)
   REAL(KIND=dp), INTENT(IN)                :: tpole
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: iatm
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: wave(8)
   REAL(KIND=dp), INTENT(IN)                :: reff
   REAL(KIND=dp), INTENT(IN)                :: separ
!
   REAL(KIND=dp) :: tin,summ,hhh,rmuin,outinty,tkkelv,gin
   REAL(KIND=dp) :: flimbx,flimby,savefx,savefy,ddint,wavemu,c1,c2,c3
!
   INTEGER :: i,itguess
   INTEGER :: indext,k,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,jj
!
   DIMENSION outinty(8),summ(8)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   IF(iatm > 0)THEN
!
!   Find the rough place in the atmosphere table.
!
      tin=tpole
      gin=LOG10(gpole)
      CALL locate(atmt,nlines,tin,indext)
      itguess=indext
!
      DO  i=1,8
         summ(i)=0.0_dp
      END DO
!
      icnu=0
      icnb=0
      icnv=0
      icnr=0
      icni=0
      icnj=0
      icnh=0
      icnk=0
      hhh=0.01_dp
      DO  i=100,0,-1
         rmuin=REAL(i-1,KIND=dp)/500.0_dp+0.001_dp
         rmuin=REAL(i,KIND=dp)/100.0_dp
         IF(rmuin > 0.0_dp)THEN
            CALL computeinty(tin,gin,rmuin,maxlines,maxmu,nlines,  &
               atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
               atmint5,atmint6,atmint7,atmint8,outinty,icnu,icnb,icnv,  &
               icnr,icni,icnj,icnh,icnk,itguess,dwavex,dwavey,ilaw, &
               iatm,istar)
         ELSE
            outinty(1)=0.0_dp
            outinty(2)=0.0_dp
            outinty(3)=0.0_dp
            outinty(4)=0.0_dp
            outinty(5)=0.0_dp
            outinty(6)=0.0_dp
            outinty(7)=0.0_dp
            outinty(8)=0.0_dp
         END IF
!
         DO  k=1,8
            IF(i == 100)THEN
               summ(k)=summ(k)+1.0_dp*hhh*outinty(k)*rmuin
            ELSE
               summ(k)=summ(k)+2.0_dp*hhh*outinty(k)*rmuin
            END IF
            darkint(k)=summ(k)*reff*reff
            darkint(k)=darkint(k)*(separ*solarrad)**2
         END DO
      END DO
      RETURN
   END IF
!
   IF(iatm <= 0)THEN
      DO  jj=1,8
         flimbx=dwavex(jj,istar)
         flimby=dwavey(jj,istar)
!
!   December 15, 2013:  add triangular sampling
!
         IF((ilaw == 5).OR.(ilaw == 15))THEN
            savefx=flimbx
            savefy=flimby
            flimbx=2.0_dp*SQRT(savefx)*savefy
            flimby=SQRT(savefx)*(1.0_dp-2.0_dp*savefy)
         END IF
!
         IF((ilaw == 6).OR.(ilaw == 16))THEN
            savefx=flimbx
            savefy=flimby
            flimbx=1.0_dp-SQRT(savefx)*savefy
            flimby=1.0_dp-SQRT(savefx)
         END IF
!
         IF((ilaw == 7).OR.(ilaw == 17))THEN
            savefx=flimbx
            savefy=flimby
            flimbx=SQRT(savefx)*(1.0_dp-2.0_dp*savefy)
            flimby=2.0_dp*SQRT(savefx)*savefy
         END IF
!
         ddint=pie*(1.0_dp-flimbx/3.0_dp)
         IF(ilaw == 2)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp+2.0_dp*flimby/9.0_dp)
         END IF
         IF(ilaw == 6)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp+2.0_dp*flimby/9.0_dp)
         END IF
         IF(ilaw == 3)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp-flimby/5.0_dp)
         END IF
         IF(ilaw == 7)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp-flimby/5.0_dp)
         END IF
         IF(ilaw == 4)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp-flimby/6.0_dp)
         END IF
         IF(ilaw == 5)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp-flimby/6.0_dp)
         END IF
         IF(ilaw == 12)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp+2.0_dp*flimby/9.0_dp)
         END IF
         IF(ilaw == 16)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp+2.0_dp*flimby/9.0_dp)
         END IF
         IF(ilaw == 13)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp-flimby/5.0_dp)
         END IF
         IF(ilaw == 13)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp-flimby/5.0_dp)
         END IF
         IF(ilaw == 17)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp-flimby/6.0_dp)
         END IF
         IF(ilaw == 15)THEN
            ddint=pie*(1.0_dp-flimbx/3.0_dp-flimby/6.0_dp)
         END IF
!
         wavemu=wave(jj)/10000.0_dp
         c1=2.0_dp*pie*planck*speedlightm*speedlightm*1.0E+16_dp
         c2=speedlightm*planck/boltzmann*1.0E+3_dp
!
!         c1=3.74185_dp
!         c2=14.3883_dp
!
         tkkelv=tpole/1000.0_dp
         c3=c2/(wavemu*tkkelv)
         darkint(jj)=ddint*c1/(EXP(c3)-1.0_dp)/wavemu**5*reff*reff
         darkint(jj)=c1/(EXP(c3)-1.0_dp)/wavemu**5*reff*reff
         darkint(jj)=darkint(jj)*(separ*solarrad)**2
      END DO
   END IF
!
   RETURN
!
END SUBROUTINE getanalyticint
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getatmflux(ialphmax,ibetmax,nalf,ibetlim,visib,  &
   projarray,temp,surf,garray,rinty,flum,maxlines,maxmu,nlines,  &
   atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,atmint5,  &
   atmint6,atmint7,atmint8,gscale,fluxu,fluxb,fluxv,fluxr,fluxi,  &
   fluxj,fluxh,fluxk,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,  &
   irvfilt,delphi,delphiedge,iedgestar,iedgehor,separ,mmdx,  &
   montecarlo,dwavex,dwavey,ilaw,iatm,istar)
!
!  November 30, 1999
!
!  This routine will return fluxes computed from model atmospheres.
!  The flum  and rinty arrays will contain the intensities for the V band.
!  The rinty array contains the specific intensities, while the
!  flum array contains the intensities weighted by the area and the surf
!  vectors.
!
!  The projarray contains the cosine mu terms for each element.  The visib
!  array contains the cosine mu terms for each element, except if the point
!  is eclipsed in which case the visib=0.
!
!  The parameter gscale is used to convert the gravities in program units
!  into cgs units.  This number is G*M/(a*a).
!
!   UPDATE April 3, 2002
!
!   Add separ to the argument list of getBBflux, getATMflux,
!   getdiskBBflux, getdiskATMflux, and getBBsimp.  Then scale the fluxes
!   by (separ*solarrad)**2
!
!   UPDATE JULY 4, 2004
!
!   Add the variable MonteCarlo to the argument list.  If MonteCarlo < 10,
!   then proceed as before.  If Monte Carlo > 10, then the fractional
!   pixels were computed in getvisib via Monte Carlo integration.  In
!   that case, we can skip some steps below.
!
!   UPDATE SEPTEMBER 11, 2009
!
!   Add the ability to use a parameterized limb darkening law to this
!   routine.  computeinty is modified so that when iatm=2, the flux
!   at mu=1 is found, then I(mu)=I_0*ld_law
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: visib(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: projarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: temp(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: surf(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: garray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: rinty(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: flum(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: maxlines
   INTEGER, INTENT(IN)                      :: maxmu
   INTEGER, INTENT(IN)                      :: nlines
   REAL(KIND=dp), INTENT(IN)                :: atmt(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmg(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmmu(maxlines,maxmu)
   INTEGER, INTENT(IN)                      :: nmu(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmint1(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint2(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint3(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint4(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint5(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint6(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint7(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint8(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: gscale
   REAL(KIND=dp), INTENT(OUT)               :: fluxu
   REAL(KIND=dp), INTENT(OUT)               :: fluxb
   REAL(KIND=dp), INTENT(OUT)               :: fluxv
   REAL(KIND=dp), INTENT(OUT)               :: fluxr
   REAL(KIND=dp), INTENT(OUT)               :: fluxi
   REAL(KIND=dp), INTENT(OUT)               :: fluxj
   REAL(KIND=dp), INTENT(OUT)               :: fluxh
   REAL(KIND=dp), INTENT(OUT)               :: fluxk
   INTEGER, INTENT(IN)                      :: icnu
   INTEGER, INTENT(IN)                      :: icnb
   INTEGER, INTENT(IN)                      :: icnv
   INTEGER, INTENT(IN)                      :: icnr
   INTEGER, INTENT(IN)                      :: icni
   INTEGER, INTENT(IN)                      :: icnj
   INTEGER, INTENT(IN)                      :: icnh
   INTEGER, INTENT(IN)                      :: icnk
   INTEGER, INTENT(IN)                      :: irvfilt
   REAL(KIND=dp), INTENT(IN OUT)            :: delphi(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: delphiedge(ialphmax*ibetmax)
   INTEGER, INTENT(IN OUT)                  :: iedgestar(ialphmax*ibetmax)
   INTEGER, INTENT(IN OUT)                  :: iedgehor(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: separ
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   INTEGER, INTENT(IN)                      :: montecarlo
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: iatm
   INTEGER, INTENT(IN)                      :: istar
!
   REAL(KIND=dp)  :: frac,gin,rmuin,outinty,dphi,corr1,tin
!
   INTEGER :: iidx,ibet,ialf,izz,itguess,indext,jzz,k
!
!   Set these to the value of ialphmax,ibetmax
!
   INTEGER, PARAMETER :: tempalf=600
   INTEGER, PARAMETER :: tempbet=600
!
   REAL(KIND=dp), ALLOCATABLE    ::  sveflum(:,:)
!
   DIMENSION outinty(8),corr1(8)
!
   ALLOCATE(sveflum(ialphmax*ibetmax,8))
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   IF(tempalf < ialphmax)THEN
      WRITE(*,*)'dimension error in getATMflux'
      WRITE(*,*)'tempalf = ',tempalf,'  ialphmax = ',ialphmax
      STOP
   END IF
   IF(tempbet < ibetmax)THEN
      WRITE(*,*)'dimension error in getATMflux'
      WRITE(*,*)'tempbet = ',tempbet,'  ibetmax = ',ibetmax
      STOP
   END IF
!
   fluxu=0.0_dp
   fluxb=0.0_dp
   fluxv=0.0_dp
   fluxr=0.0_dp
   fluxi=0.0_dp
   fluxj=0.0_dp
   fluxh=0.0_dp
   fluxk=0.0_dp
   corr1(1)=0.0_dp
   corr1(2)=0.0_dp
   corr1(3)=0.0_dp
   corr1(4)=0.0_dp
   corr1(5)=0.0_dp
   corr1(6)=0.0_dp
   corr1(7)=0.0_dp
   corr1(8)=0.0_dp
!
!   Initialize the flum matrix.
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
         iidx=mmdx(ialf,ibet)
         flum(iidx)=0.0_dp
         rinty(iidx)=0.0_dp
         sveflum(iidx,1)=0.0_dp
         sveflum(iidx,2)=0.0_dp
         sveflum(iidx,3)=0.0_dp
         sveflum(iidx,4)=0.0_dp
         sveflum(iidx,5)=0.0_dp
         sveflum(iidx,6)=0.0_dp
         sveflum(iidx,7)=0.0_dp
         sveflum(iidx,8)=0.0_dp
      END DO
   END DO
!
!          Nalf2=Nalf/2
!
!   Find the rough place in the atmosphere table.
!
   tin=temp(1)
   CALL locate(atmt,nlines,tin,indext)
   itguess=indext
!
!   Loop for fractional pixels near the edge.
!
!   UPDATE JULY 4, 2004
!
!   if MonteCarlo > 10, we can skip this loop.
!
   IF(montecarlo < 10)THEN
      DO  ialf=1,nalf
         DO  ibet=1,ibetlim(ialf)
            iidx=mmdx(ialf,ibet)
            IF((iedgehor(iidx) == -10).OR.(iedgehor(iidx) > 5).OR.  &
               (iedgestar(iidx) == -10).OR.(iedgestar(iidx) > 5).OR.  &
               (delphi(iidx) > -10.0_dp))THEN
               tin=temp(iidx)
               gin=LOG10(gscale*garray(iidx))
               rmuin=ABS(projarray(iidx))
               CALL computeinty(tin,gin,rmuin,maxlines,maxmu,nlines,  &
                  atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
                  atmint5,atmint6,atmint7,atmint8,outinty,icnu,icnb,  &
                  icnv,icnr,icni,icnj,icnh,icnk,itguess,dwavex,dwavey, &
                  ilaw,iatm,istar)
               DO  k=1,8
                  sveflum(iidx,k)=outinty(k)*surf(iidx)*ABS(projarray(iidx))
               END DO
            END IF
         END DO
      END DO
   END IF
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
         iidx=mmdx(ialf,ibet)
         corr1(1)=0.0_dp
         corr1(2)=0.0_dp
         corr1(3)=0.0_dp
         corr1(4)=0.0_dp
         corr1(5)=0.0_dp
         corr1(6)=0.0_dp
         corr1(7)=0.0_dp
         corr1(8)=0.0_dp
         dphi=pie/REAL(ibetlim(ialf),KIND=dp)
         IF(projarray(iidx) <= 0.0_dp)CYCLE
         tin=temp(iidx)
         gin=LOG10(gscale*garray(iidx))
         rmuin=projarray(iidx)
         CALL computeinty(tin,gin,rmuin,maxlines,maxmu,nlines,  &
            atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
            atmint5,atmint6,atmint7,atmint8,outinty,icnu,icnb,icnv,  &
            icnr,icni,icnj,icnh,icnk,itguess,dwavex,dwavey,ilaw,iatm, istar)
!
!   save intensities for plotting
!
         rinty(iidx)=outinty(irvfilt)
!
         DO  k=1,8
            sveflum(iidx,k)=outinty(k)*surf(iidx)*projarray(iidx)
            outinty(k)=outinty(k)*surf(iidx)*visib(iidx)
         END DO
!
!   Check for fractional pixels near the horizon of the star in front,
!   in the beta direction (along constant latitude rows).
!
!   UPDATE JULY 4, 2004
!
!   If MonteCarlo > 10, we can skip this step since the fractional
!   pixel corrections were done in getvisib.
!
         IF(montecarlo > 10)THEN
            corr1(1)=0.0_dp
            corr1(2)=0.0_dp
            corr1(3)=0.0_dp
            corr1(4)=0.0_dp
            corr1(5)=0.0_dp
            corr1(6)=0.0_dp
            corr1(7)=0.0_dp
            corr1(8)=0.0_dp
            GO TO 70
         END IF
!
         IF(delphi(iidx) >= -10.0_dp)THEN
            frac=0.5_dp*(ABS(delphi(iidx))-dphi)/dphi
            IF(frac < 0.0_dp)THEN
               corr1(1)=frac*sveflum(iidx,1)
               corr1(2)=frac*sveflum(iidx,2)
               corr1(3)=frac*sveflum(iidx,3)
               corr1(4)=frac*sveflum(iidx,4)
               corr1(5)=frac*sveflum(iidx,5)
               corr1(6)=frac*sveflum(iidx,6)
               corr1(7)=frac*sveflum(iidx,7)
               corr1(8)=frac*sveflum(iidx,8)
            ELSE
               IF(iedgehor(iidx) == 10)THEN
                  IF(ibet < ibetlim(ialf))THEN
                     izz=ialf
                     jzz=ibet+1
                     iidx=mmdx(izz,jzz)
                     corr1(1)=frac*sveflum(iidx,1)
                     corr1(2)=frac*sveflum(iidx,2)
                     corr1(3)=frac*sveflum(iidx,3)
                     corr1(4)=frac*sveflum(iidx,4)
                     corr1(5)=frac*sveflum(iidx,5)
                     corr1(6)=frac*sveflum(iidx,6)
                     corr1(7)=frac*sveflum(iidx,7)
                     corr1(8)=frac*sveflum(iidx,8)
                  ELSE
                     izz=ialf
                     jzz=1
                     iidx=mmdx(izz,jzz)
                     corr1(1)=frac*sveflum(iidx,1)
                     corr1(2)=frac*sveflum(iidx,2)
                     corr1(3)=frac*sveflum(iidx,3)
                     corr1(4)=frac*sveflum(iidx,4)
                     corr1(5)=frac*sveflum(iidx,5)
                     corr1(6)=frac*sveflum(iidx,6)
                     corr1(7)=frac*sveflum(iidx,7)
                     corr1(8)=frac*sveflum(iidx,8)
                  END IF
               END IF
!
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
               IF(iedgehor(iidx) == 20)THEN
                  IF(ibet > 1)THEN
                     izz=ialf
                     jzz=ibet-1
                     iidx=mmdx(izz,jzz)
                     corr1(1)=frac*sveflum(iidx,1)
                     corr1(2)=frac*sveflum(iidx,2)
                     corr1(3)=frac*sveflum(iidx,3)
                     corr1(4)=frac*sveflum(iidx,4)
                     corr1(5)=frac*sveflum(iidx,5)
                     corr1(6)=frac*sveflum(iidx,6)
                     corr1(7)=frac*sveflum(iidx,7)
                     corr1(8)=frac*sveflum(iidx,8)
                  ELSE
                     izz=ialf
                     jzz=ibetlim(ialf)
                     iidx=mmdx(izz,jzz)
                     corr1(1)=frac*sveflum(iidx,1)
                     corr1(2)=frac*sveflum(iidx,2)
                     corr1(3)=frac*sveflum(iidx,3)
                     corr1(4)=frac*sveflum(iidx,4)
                     corr1(5)=frac*sveflum(iidx,5)
                     corr1(6)=frac*sveflum(iidx,6)
                     corr1(7)=frac*sveflum(iidx,7)
                     corr1(8)=frac*sveflum(iidx,8)
                  END IF
               END IF
            END IF
         END IF
!
         izz=ialf
         jzz=ibet
         iidx=mmdx(izz,jzz)
         IF(iedgestar(iidx) == 10)THEN
            frac=0.5_dp*(ABS(delphiedge(iidx))-dphi)/dphi
            IF(frac < 0.0_dp)THEN
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
            ELSE
               IF(ibet < ibetlim(ialf))THEN
                  izz=ialf
                  jzz=ibet+1
                  iidx=mmdx(izz,jzz)
               ELSE
                  izz=ialf
                  jzz=1
                  iidx=mmdx(izz,jzz)
               END IF
            END IF
         END IF
!
         izz=ialf
         jzz=ibet
         iidx=mmdx(izz,jzz)
         IF(iedgestar(iidx) == 20)THEN
            frac=0.5_dp*(ABS(delphiedge(iidx))-dphi)/dphi
            IF(frac < 0.0_dp)THEN
            ELSE
               IF(ibet > 1)THEN
                  izz=ialf
                  jzz=ibet-1
                  iidx=mmdx(izz,jzz)
               ELSE
                  izz=ialf
                  jzz=ibetlim(ialf)
                  iidx=mmdx(izz,jzz)
               END IF
            END IF
         END IF
!
70       fluxu=fluxu+outinty(1)+corr1(1)
         fluxb=fluxb+outinty(2)+corr1(2)
         fluxv=fluxv+outinty(3)+corr1(3)
         fluxr=fluxr+outinty(4)+corr1(4)
         fluxi=fluxi+outinty(5)+corr1(5)
         fluxj=fluxj+outinty(6)+corr1(6)
         fluxh=fluxh+outinty(7)+corr1(7)
         fluxk=fluxk+outinty(8)+corr1(8)
         izz=ialf
         jzz=ibet
         iidx=mmdx(izz,jzz)
         flum(iidx)=outinty(irvfilt)+corr1(irvfilt)
      END DO
   END DO
!
!  UPDATE April 3, 2002
!
!  Scale the fluxes.
!
   fluxu=fluxu*(separ*solarrad)**2
   fluxb=fluxb*(separ*solarrad)**2
   fluxv=fluxv*(separ*solarrad)**2
   fluxr=fluxr*(separ*solarrad)**2
   fluxi=fluxi*(separ*solarrad)**2
   fluxj=fluxj*(separ*solarrad)**2
   fluxh=fluxh*(separ*solarrad)**2
   fluxk=fluxk*(separ*solarrad)**2
!
   DEALLOCATE(sveflum)
!
   RETURN
!
END SUBROUTINE getatmflux
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getatmint(maxlines,maxmu,nlines,atmt,atmg,atmmu,  &
   nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,  &
   atmint8,gscale,darkint,tpole,gpole,dwavex,dwavey,ilaw,iatm,  &
   istar)
!
!  May 16, 2000
!
!  This subroutine will evaluate the integral:
!
!  dint = int^1_0 (I(T,g,mu)*mu*du)
!
!  The light curves are scaled by DINT for compatability with
!  Wilson and Devinney.
!
!  The parameter gscale is used to convert the gravities in program units
!  into cgs units.  This number is G*M/(a*a).
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: maxlines
   INTEGER, INTENT(IN)                      :: maxmu
   INTEGER, INTENT(IN)                      :: nlines
   REAL(KIND=dp), INTENT(IN)                :: atmt(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmg(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmmu(maxlines,maxmu)
   INTEGER, INTENT(IN)                      :: nmu(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmint1(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint2(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint3(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint4(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint5(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint6(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint7(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint8(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: gscale
   REAL(KIND=dp), INTENT(OUT)               :: darkint(8)
   REAL(KIND=dp), INTENT(IN)                :: tpole
   REAL(KIND=dp), INTENT(IN)                :: gpole
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: iatm
   INTEGER, INTENT(IN)                      :: istar
!
   REAL(KIND=dp) :: flimbx,flimby,savefx,savefy,rdint,tin,gin,summ,hhh,rmuin,outinty
!
   INTEGER :: i,itguess
   INTEGER :: indext,k,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk
!
   DIMENSION outinty(8),summ(8)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   IF(iatm < 1)THEN
      DO i=1,8
         flimbx=dwavex(i,istar)
         flimby=dwavey(i,istar)
!
!   December 15, 2013:  add triangular sampling
!
         IF((ilaw == 5).OR.(ilaw == 15))THEN
            savefx=flimbx
            savefy=flimby
            flimbx=2.0_dp*SQRT(savefx)*savefy
            flimby=SQRT(savefx)*(1.0_dp-2.0_dp*savefy)
         END IF
!
         IF((ilaw == 6).OR.(ilaw == 16))THEN
            savefx=flimbx
            savefy=flimby
            flimbx=1.0_dp-SQRT(savefx)*savefy
            flimby=1.0_dp-SQRT(savefx)
         END IF
!
         IF((ilaw == 7).OR.(ilaw == 17))THEN
            savefx=flimbx
            savefy=flimby
            flimbx=SQRT(savefx)*(1.0_dp-2.0_dp*savefy)
            flimby=2.0_dp*SQRT(savefx)*savefy
         END IF
!
         rdint=pie*(1.0_dp-flimbx/3.0_dp)
         IF((ilaw == 2).OR.(ilaw == 12))THEN
            rdint=pie*(1.0_dp-flimbx/3.0_dp+2.0_dp*flimby/9.0_dp)
         END IF
         IF((ilaw == 6).OR.(ilaw == 16))THEN
            rdint=pie*(1.0_dp-flimbx/3.0_dp+2.0_dp*flimby/9.0_dp)
         END IF
         IF((ilaw == 3).OR.(ilaw == 13))THEN
            rdint=pie*(1.0_dp-flimbx/3.0_dp-flimby/5.0_dp)
         END IF
         IF((ilaw == 7).OR.(ilaw == 17))THEN
            rdint=pie*(1.0_dp-flimbx/3.0_dp-flimby/5.0_dp)
         END IF
         IF((ilaw == 4).OR.(ilaw == 14))THEN
            rdint=pie*(1.0_dp-flimbx/3.0_dp-flimby/6.0_dp)
         END IF
         IF((ilaw == 5).OR.(ilaw == 15))THEN
            rdint=pie*(1.0_dp-flimbx/3.0_dp-flimby/6.0_dp)
         END IF
         darkint(i)=rdint
      END DO
      RETURN
   END IF
!
!   Find the rough place in the atmosphere table.
!
   tin=tpole
   gin=LOG10(gscale*gpole)
   indext=0
   CALL locate(atmt,nlines,tin,indext)
   itguess=indext
!
   DO i=1,8
      summ(i)=0.0_dp
   END DO
!
   icnu=0
   icnb=0
   icnv=0
   icnr=0
   icni=0
   icnj=0
   icnh=0
   icnk=0
   hhh=0.01_dp
   DO  i=100,0,-1
      rmuin=REAL(i,KIND=dp)/100.0_dp
      IF(rmuin > 0.0_dp)THEN
         CALL computeinty(tin,gin,rmuin,maxlines,maxmu,nlines,  &
            atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
            atmint5,atmint6,atmint7,atmint8,outinty,icnu,icnb,icnv,  &
            icnr,icni,icnj,icnh,icnk,itguess,dwavex,dwavey,ilaw,iatm,istar)
      ELSE
         outinty(1)=0.0_dp
         outinty(2)=0.0_dp
         outinty(3)=0.0_dp
         outinty(4)=0.0_dp
         outinty(5)=0.0_dp
         outinty(6)=0.0_dp
         outinty(7)=0.0_dp
         outinty(8)=0.0_dp
      END IF
!
      DO  k=1,8
         IF((i == 100).OR.(i == 0))THEN
            summ(k)=summ(k)+1.0_dp*hhh*outinty(k)*rmuin
         ELSE
            summ(k)=summ(k)+2.0_dp*hhh*outinty(k)*rmuin
         END IF
      END DO
   END DO
!
   DO  i=1,8
      rmuin=1.0_dp
      CALL computeinty(tin,gin,rmuin,maxlines,maxmu,nlines,atmt,  &
         atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,atmint5,  &
         atmint6,atmint7,atmint8,outinty,icnu,icnb,icnv,icnr,icni,  &
         icnj,icnh,icnk,itguess,dwavex,dwavey,ilaw,iatm,istar)
!
      darkint(i)=pie*summ(i)/outinty(i)
   END DO
!
   RETURN
!
END SUBROUTINE getatmint
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!

SUBROUTINE getbbflux(ialphmax,ibetmax,nalf,ibetlim,wave,  &
   visib,projarray,temp,surf,flimbx,flimby,ilaw,rinty,flum,flux,  &
   delphi,delphiedge,iedgestar,iedgehor,rldint,separ,mmdx,  &
   montecarlo,isw13,ialfmin,ialfmax,fluxlat,istar,phiarr,phihor)
!
!  October 11, 1999
!
!  This routine will compute the intensities of each element, given the
!  temperatures (temp(ialf,ibet)) and the input wavelength.  It will then
!  integrate the flux given the visibilities (visib) and surface elements
!  (surf).
!
!  The projarray contains the cosine mu terms for each element.  The visib
!  array contains the cosine mu terms for each element, except if the point
!  is eclipsed in which case the visib=0.
!
!   UPDATE April 3, 2002
!
!   Add separ to the argument list of getBBflux, getATMflux,
!   getdiskBBflux, getdiskATMflux, and getBBsimp.  Then scale the fluxes
!   by (separ*solarrad)**2
!
!   UPDATE JULY 4, 2004
!
!   Add the variable MonteCarlo to the argument list.  If MonteCarlo < 10,
!   then proceed as before.  If Monte Carlo > 10, then the fractional
!   pixels were computed in getvisib via Monte Carlo integration.  In
!   that case, we can skip some steps below.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: wave
   REAL(KIND=dp), INTENT(IN)                :: visib(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: projarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: temp(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: surf(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: flimbx
   REAL(KIND=dp), INTENT(IN OUT)            :: flimby
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: rinty(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: flum(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: flux
   REAL(KIND=dp), INTENT(IN OUT)            :: delphi(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: delphiedge(ialphmax*ibetmax)
   INTEGER, INTENT(IN OUT)                  :: iedgestar(ialphmax*ibetmax)
   INTEGER, INTENT(IN OUT)                  :: iedgehor(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: rldint
   REAL(KIND=dp), INTENT(IN OUT)            :: separ
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   INTEGER, INTENT(IN OUT)                  :: montecarlo
   INTEGER, INTENT(IN OUT)                  :: isw13
   INTEGER, INTENT(IN)                      :: ialfmin
   INTEGER, INTENT(IN)                      :: ialfmax
   REAL(KIND=dp), INTENT(IN)                :: fluxlat
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: phiarr(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: phihor(ialphmax,4)
!
   REAL(KIND=dp) ::  svflimbx,c1,c2,svflimby,rdint
   REAL(KIND=dp) ::  wavemu,tkkelv,c3,dark,dphi,corr1,corr2,fred1,fred2,frac
!
   REAL(KIND=dp), DIMENSION(2000)    :: xrow,yrow
   REAL(KIND=dp), ALLOCATABLE        :: svflum(:)
!
   INTEGER :: iidx,ialf,ibet,jjdx,irow
!
!   Set these to the value of ialphmax,ibetmax
!
   INTEGER, PARAMETER :: tempalf=600
   INTEGER, PARAMETER :: tempbet=600
!
   ALLOCATE(svflum(ialphmax*ibetmax))
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   IF(tempalf < ialphmax)THEN
      WRITE(*,*)'dimension error in getBBflux ',ialphmax,ibetmax
      STOP
   END IF
   IF(tempbet < ibetmax)THEN
      WRITE(*,*)'dimension error in getBBflux ',ialphmax,ibetmax
      STOP
   END IF
!
!   new triangular sampling for quad law
!
   IF((ilaw == 5).OR.(ilaw == 15))THEN
      svflimbx=flimbx
      svflimby=flimby
      flimbx=2.0_dp*SQRT(svflimbx)*svflimby
      flimby=SQRT(svflimbx)*(1.0_dp-2.0_dp*svflimby)
   END IF
!
   IF((ilaw == 6).OR.(ilaw == 16))THEN
      svflimbx=flimbx
      svflimby=flimby
      flimbx=1.0_dp-SQRT(svflimbx)*svflimby
      flimby=1.0_dp-SQRT(svflimbx)
   END IF
!
   IF((ilaw == 7).OR.(ilaw == 17))THEN
      svflimbx=flimbx
      svflimby=flimby
      flimbx=SQRT(svflimbx)*(1.0_dp-2.0_dp*svflimby)
      flimby=2.0_dp*SQRT(svflimbx)*svflimby
   END IF
!
   rdint=pie*(1.0_dp-flimbx/3.0_dp)
   IF((ilaw == 2).OR.(ilaw == 12))THEN
      rdint=pie*(1.0_dp-flimbx/3.0_dp+2.0_dp*flimby/9.0_dp)
   END IF
   IF((ilaw == 3).OR.(ilaw == 13))THEN
      rdint=pie*(1.0_dp-flimbx/3.0_dp-flimby/5.0_dp)
   END IF
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic law, ilaw=4
!
   IF((ilaw == 4).OR.(ilaw == 14))THEN
      rdint=pie*(1.0_dp-flimbx/3.0_dp-flimby/6.0_dp)
   END IF
!
   IF((ilaw == 5).OR.(ilaw == 15))THEN
      rdint=pie*(1.0_dp-flimbx/3.0_dp-flimby/6.0_dp)
   END IF
!
   flux=0.0_dp
!
!   Initialize the flum matrix.
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         flum(iidx)=0.0_dp
         rinty(iidx)=0.0_dp
         svflum(iidx)=0.0_dp
      END DO
   END DO
!
!   Compute the intensity values of pixels just behind the edge or the
!   eclipsing horizon for use in fractional eclipse corrections.
!
   wavemu=wave/10000.0_dp
   c1=2.0_dp*pie*planck*speedlightm*speedlightm*1.0E+16_dp
   c2=speedlightm*planck/boltzmann*1.0E+3_dp
!
!   c1=3.74185_dp
!   c2=14.3883_dp
!
!   UPDATE JULY 4, 2004
!
!   This loop is no longer needed when using the Monte Carlo
!   routine to compute fractionally eclipsed pixels.
!
   IF(montecarlo < 10)THEN
      DO  ialf=1,nalf
         IF((istar == 1).AND.(isw13 > 0))THEN
            IF((ialf < ialfmin).OR.(ialf > ialfmax))CYCLE
         END IF
         DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!                iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
            iidx=mmdx(ialf,ibet)
            IF((iedgehor(iidx) == -10).OR.(iedgehor(iidx) > 5).OR.  &
               (iedgestar(iidx) == -10).OR.(iedgestar(iidx) > 5).OR.  &
               (delphi(iidx) > -10.0_dp))THEN
               tkkelv=temp(iidx)/1000.0_dp
               c3=c2/(wavemu*tkkelv)
               svflum(iidx)=c1/(EXP(c3)-1.0_dp)/wavemu**5
               dark=(1.0_dp-flimbx+flimbx*ABS(projarray(iidx)))
               IF((ilaw == 2).OR.(ilaw == 12))dark=dark-flimby*  &
                  ABS(projarray(iidx))*LOG(ABS(projarray(iidx)))
               IF((ilaw == 6).OR.(ilaw == 16))dark=dark-flimby*  &
                  ABS(projarray(iidx))*LOG(ABS(projarray(iidx)))
               IF((ilaw == 3).OR.(ilaw == 13))dark=dark-flimby*(  &
                  1.0_dp-SQRT(ABS(projarray(iidx))))
               IF((ilaw == 7).OR.(ilaw == 17))dark=dark-flimby*(  &
                  1.0_dp-SQRT(ABS(projarray(iidx))))
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic law, ilaw=4
!
               IF((ilaw == 4).OR.(ilaw == 14))dark=dark-flimby*(  &
                  1.0_dp-ABS(projarray(iidx)))**2
               IF((ilaw == 5).OR.(ilaw == 15))dark=dark-flimby*(  &
                  1.0_dp-ABS(projarray(iidx)))**2
               svflum(iidx)=svflum(iidx)*dark
               svflum(iidx)=surf(iidx)*svflum(iidx)* ABS(projarray(iidx))
            END IF
         END DO
      END DO
   END IF
!c
   DO  ialf=1,nalf
      IF((istar == 1).AND.(isw13 > 0))THEN
         IF((ialf < ialfmin).OR.(ialf > ialfmax))CYCLE
      END IF
      dphi=pie/REAL(ibetlim(ialf),KIND=dp)
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         corr1=0.0_dp
         corr2=0.0_dp
         IF((projarray(iidx) <= 0.0_dp))THEN
            xrow(ibet)=phiarr(iidx)
            yrow(ibet)=0.0_dp
            CYCLE
         END IF
         tkkelv=temp(iidx)/1000.0_dp
         c3=c2/(wavemu*tkkelv)
         flum(iidx)=c1/(EXP(c3)-1.0_dp)/wavemu**5
         dark=(1.0_dp-flimbx+flimbx*projarray(iidx))
         IF((ilaw == 2).OR.(ilaw == 12))dark=dark-flimby*  &
            projarray(iidx)*LOG(projarray(iidx))
         IF((ilaw == 6).OR.(ilaw == 16))dark=dark-flimby*  &
            projarray(iidx)*LOG(projarray(iidx))
         IF((ilaw == 3).OR.(ilaw == 13))dark=dark-flimby*(1.0_dp-  &
            SQRT(projarray(iidx)))
         IF((ilaw == 7).OR.(ilaw == 17))dark=dark-flimby*(1.0_dp-  &
            SQRT(projarray(iidx)))
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic law, ilaw=4
!
         IF((ilaw == 4).OR.(ilaw == 14))dark=dark-flimby*(1.0_dp-  &
            ABS(projarray(iidx)))**2
         IF((ilaw == 5).OR.(ilaw == 15))dark=dark-flimby*(1.0_dp-  &
            ABS(projarray(iidx)))**2
!
         flum(iidx)=flum(iidx)*dark
!
!   save intensities for plotting
!
         rinty(iidx)=flum(iidx)
         svflum(iidx)=surf(iidx)*flum(iidx)*projarray(iidx)
         flum(iidx)=surf(iidx)*flum(iidx)*visib(iidx)
!
!   Correct for fractional pixels near the limb.
!
!   UPDATE JULY 4, 2004
!
!   These corrections are no longer needed when using the Monte
!   Carlo routine to compute fractionally eclipsed pixels.
!
         iidx=mmdx(ialf,ibet)
         IF(montecarlo > 10)THEN
            corr1=0.0_dp
            corr2=0.0_dp
            GO TO 50
         END IF
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
         IF(iedgestar(iidx) == 10)THEN
            frac=0.5_dp*(ABS(delphiedge(iidx))-dphi)/dphi
            IF(frac < 0.0_dp)THEN
               corr2=frac*svflum(iidx)
               svflum(iidx)=svflum(iidx)+corr2
            ELSE
               IF(ibet < ibetlim(ialf))THEN
!                    iidx=kount(ialphmax,ialf,ibetlim)+ibet+1
                  iidx=mmdx(ialf,ibet+1)
                  corr2=frac*svflum(iidx)
                  svflum(iidx)=svflum(iidx)+corr2
               ELSE
!                    iidx=kount(ialphmax,ialf,ibetlim)+1
                  iidx=mmdx(ialf,1)
                  corr2=frac*svflum(iidx)
                  svflum(iidx)=svflum(iidx)+corr2
               END IF
            END IF
         END IF
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
         iidx=mmdx(ialf,ibet)
         IF(iedgestar(iidx) == 20)THEN
            frac=0.5_dp*(ABS(delphiedge(iidx))-dphi)/dphi
            IF(frac < 0.0_dp)THEN
               corr2=frac*svflum(iidx)
               svflum(iidx)=svflum(iidx)+corr2
            ELSE
               IF(ibet > 1)THEN
!                    iidx=kount(ialphmax,ialf,ibetlim)+(ibet-1)
                  iidx=mmdx(ialf,ibet-1)
                  corr2=frac*svflum(iidx)
                  svflum(iidx)=svflum(iidx)+corr2
               ELSE
!                    iidx=kount(ialphmax,ialf,ibetlim)+ibetlim(ialf)
                  iidx=mmdx(ialf,ibetlim(ialf))
                  corr2=frac*svflum(iidx)
                  svflum(iidx)=svflum(iidx)+corr2
               END IF
            END IF
         END IF
!
!   Check for fractional pixels near the horizon of the star in front,
!   in the beta direction (along constant latitude rows).
!
         iidx=mmdx(ialf,ibet)
         IF(delphi(iidx) >= -10.0_dp)THEN
            frac=0.5_dp*(ABS(delphi(iidx))-dphi)/dphi
            IF(frac < 0.0_dp)THEN
               corr1=frac*svflum(iidx)
            ELSE
               IF(iedgehor(iidx) == 10)THEN
                  IF(ibet < ibetlim(ialf))THEN
!                      jjdx=kount(ialphmax,ialf,ibetlim)+ibet+1
                     jjdx=mmdx(ialf,ibet+1)
                     corr1=frac*svflum(jjdx)
                  ELSE
!                      jjdx=kount(ialphmax,ialf,ibetlim)+1
                     jjdx=mmdx(ialf,1)
                     corr1=frac*svflum(jjdx)
                  END IF
               END IF
!                  iidx=kount(ialphmax,ialf,ibetlim)+ibet
               iidx=mmdx(ialf,ibet)
               IF(iedgehor(iidx) == 20)THEN
                  IF(ibet > 1)THEN
!                      jjdx=kount(ialphmax,ialf,ibetlim)+(ibet-1)/dphi
                     jjdx=mmdx(ialf,ibet-1)
                     corr1=frac*svflum(jjdx)
                  ELSE
!                      jjdx=kount(ialphmax,ialf,ibetlim)+ibetlim(ialf)
                     jjdx=mmdx(ialf,ibetlim(ialf))
                     corr1=frac*svflum(jjdx)
                  END IF
               END IF
            END IF
         END IF
!
         iidx=mmdx(ialf,ibet)
50       flux=flux+flum(iidx)+corr1

         xrow(ibet)=phiarr(iidx)
         yrow(ibet)=flum(iidx)
         flum(iidx)=flum(iidx)+corr1
!
      END DO
      fred1=phihor(ialf,1)
      fred2=phihor(ialf,2)
      irow=ibetlim(ialf)
      CALL edgecor(irow,xrow,yrow,fred1,fred2,corr1)
      flux=flux+corr1
!
   END DO
!
!   Scale the light curve by the integral of the limb darkening law
!   for compatibility with Wilson-Devinney.
!
   IF((istar == 1).AND.(isw13 > 0))flux=flux+fluxlat
   flux=pie*flux/rdint
!
!   UPDATE April 3, 2002
!
!   Scale the fluxes.
!
   flux=flux*(separ*solarrad)**2
   rldint=rdint
!
   DEALLOCATE(svflum)
!
   RETURN
!
END SUBROUTINE getbbflux
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getbblumcor(ialphmax,ibetmax,nalf,ibetlim,wave,  &
   visib,projarray,temp,surf,flimbx,flimby,ilaw,rinty,flum,flux,  &
   mmdx,ialfmin,ialfmax)
!
!   May 3, 2006
!
!   This routine will return the integrate flux on star 1 outside the
!   ialpha range of ialfmin,ialfmax
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: wave
   REAL(KIND=dp), INTENT(IN)                :: visib(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: projarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: temp(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: surf(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: flimbx
   REAL(KIND=dp), INTENT(IN OUT)            :: flimby
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: rinty(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: flum(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: flux
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   INTEGER, INTENT(IN)                      :: ialfmin
   INTEGER, INTENT(IN)                      :: ialfmax
!
   REAL(KIND=dp)  :: c1,c2,savefx,savefy,wavemu,tkkelv,c3,dark
!
   INTEGER :: ialf,ibet,iidx
!
!   December 15, 2013:  add triangular sampling
!
   IF((ilaw == 5).OR.(ilaw == 15))THEN
      savefx=flimbx
      savefy=flimby
      flimbx=2.0_dp*SQRT(savefx)*savefy
      flimby=SQRT(savefx)*(1.0_dp-2.0_dp*savefy)
   END IF
!
   IF((ilaw == 6).OR.(ilaw == 16))THEN
      savefx=flimbx
      savefy=flimby
      flimbx=1.0_dp-SQRT(savefx)*savefy
      flimby=1.0_dp-SQRT(savefx)
   END IF
!
   IF((ilaw == 7).OR.(ilaw == 17))THEN
      savefx=flimbx
      savefy=flimby
      flimbx=SQRT(savefx)*(1.0_dp-2.0_dp*savefy)
      flimby=2.0_dp*SQRT(savefx)*savefy
   END IF
!
   wavemu=wave/10000.0_dp
!
!   Initialize the flum matrix.
!
!   c1=3.74185_dp
!   c2=14.3883_dp
!
   c1=pie*2.0_dp*planck*speedlightm*speedlightm*1.0E+16_dp
   c2=speedlightm*planck/boltzmann*1.0E+3_dp
!
   flux=0.0_dp
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         flum(iidx)=0.0_dp
         rinty(iidx)=0.0_dp
      END DO
   END DO
!
   DO  ialf=1,nalf
      IF((ialf >= ialfmin).AND.(ialf <= ialfmax))CYCLE
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         IF((projarray(iidx) <= 0.0_dp))CYCLE
         tkkelv=temp(iidx)/1000.0_dp
         c3=c2/(wavemu*tkkelv)
         flum(iidx)=c1/(EXP(c3)-1.0_dp)/wavemu**5
         dark=(1.0_dp-flimbx+flimbx*projarray(iidx))
         IF(ilaw == 2)dark=dark-flimby*projarray(iidx)*LOG(projarray(iidx))
         IF(ilaw == 6)dark=dark-flimby*projarray(iidx)*LOG(projarray(iidx))
         IF(ilaw == 3)dark=dark-flimby*(1.0_dp-SQRT(projarray(iidx)))
         IF(ilaw == 7)dark=dark-flimby*(1.0_dp-SQRT(projarray(iidx)))
         IF(ilaw == 12)dark=dark-flimby*projarray(iidx)*LOG(projarray(iidx))
         IF(ilaw == 16)dark=dark-flimby*projarray(iidx)*LOG(projarray(iidx))
         IF(ilaw == 13)dark=dark-flimby*(1.0_dp-SQRT(projarray(iidx)) )
         IF(ilaw == 17)dark=dark-flimby*(1.0_dp-SQRT(projarray(iidx)) )
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic limb darkening law, ilaw=4
!
         IF(ilaw == 4)dark=dark-flimby*(1.0_dp-(projarray(iidx)))**2
         IF(ilaw == 14)dark=dark-flimby*(1.0_dp-(projarray(iidx)))**2
         IF(ilaw == 5)dark=dark-flimby*(1.0_dp-(projarray(iidx)))**2
         IF(ilaw == 15)dark=dark-flimby*(1.0_dp-(projarray(iidx)))**2
!
         flum(iidx)=flum(iidx)*dark
!
!    save intensities for plotting
!
         rinty(iidx)=flum(iidx)
         flum(iidx)=surf(iidx)*flum(iidx)*visib(iidx)
         flux=flux+flum(iidx)
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE getbblumcor
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getbinbinibc(nbody,rmass,ribcinp,qq,pp,tstart,  &
   isw28)
!
!   will find x,y,z positions and velocities for the special
!   binary+binary configuration
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, PARAMETER :: ndim=30
!
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: ribcinp(10,6)
   REAL(KIND=dp), INTENT(OUT)               :: qq(ndim)
   REAL(KIND=dp), INTENT(OUT)               :: pp(ndim)
   REAL(KIND=dp), INTENT(IN)                :: tstart
   INTEGER, INTENT(IN)                      :: isw28
!
   REAL(KIND=dp)  :: rm1,rm2,vzcom
   REAL(KIND=dp)  :: period,ecos,esin,argper,ecc,tconj,rmean,trueatomeana
   REAL(KIND=dp)  :: t0b,rmeanbin,finc,omega,xcom,ycom,zcom,vxcom,vycom
   REAL(KIND=dp), DIMENSION(30)   :: qqbc1,ppbc1
   REAL(KIND=dp), DIMENSION(3)    :: qqm2,ppm2
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!   xyz of primary,secondary
!
   rm1=rmass(1)
   rm2=rmass(2)
   period=ribcinp(1,1)
   ecos=ribcinp(1,2)
   esin=ribcinp(1,3)
   argper=ATAN2(esin,ecos)
   ecc=SQRT(ecos*ecos+esin*esin)
   IF(ecc >= 1.0_dp)ecc=0.99_dp
   tconj=ribcinp(1,6)
   rmean=trueatomeana(halfpie-argper,ecc)
   IF(isw28 == 2)THEN
      rmean=trueatomeana(3.0_dp*pie/2.0_dp-argper,ecc)
   END IF
   t0b=tconj-period*rmean/(twopie)
   rmeanbin=twopie*(tstart-t0b)/period
   finc=ribcinp(1,4)
   omega=ribcinp(1,5)
!
   CALL m2tom1centric(rm1,rm2,period,ecc,rmeanbin,argper,finc,omega,qqm2,ppm2)
!
   qq(1)=0.0_dp
   qq(2)=0.0_dp
   qq(3)=0.0_dp
   qq(4)=qqm2(1)
   qq(5)=qqm2(2)
   qq(6)=qqm2(3)
   pp(1)=0.0_dp
   pp(2)=0.0_dp
   pp(3)=0.0_dp
   pp(4)=ppm2(1)
   pp(5)=ppm2(2)
   pp(6)=ppm2(3)
!
   xcom=(rm1*qq(1)+rm2*qq(4))/(rm1+rm2)
   ycom=(rm1*qq(2)+rm2*qq(5))/(rm1+rm2)
   zcom=(rm1*qq(3)+rm2*qq(6))/(rm1+rm2)
   vxcom=(rm1*pp(1)+rm2*pp(4))/(rm1+rm2)
   vycom=(rm1*pp(2)+rm2*pp(5))/(rm1+rm2)
   vzcom=(rm1*pp(3)+rm2*pp(6))/(rm1+rm2)
!
   qqbc1(1)=qq(1)-xcom
   qqbc1(2)=qq(2)-ycom
   qqbc1(3)=qq(3)-zcom
   qqbc1(4)=qq(4)-xcom
   qqbc1(5)=qq(5)-ycom
   qqbc1(6)=qq(6)-zcom
   ppbc1(1)=pp(1)-vxcom
   ppbc1(2)=pp(2)-vycom
   ppbc1(3)=pp(3)-vzcom
   ppbc1(4)=pp(4)-vxcom
   ppbc1(5)=pp(5)-vycom
   ppbc1(6)=pp(6)-vzcom
!
!   xyz of second binary (body3, body4)
!
   rm1=rmass(3)
   rm2=rmass(4)
   period=ribcinp(3,1)
   ecos=ribcinp(3,2)
   esin=ribcinp(3,3)
   argper=ATAN2(esin,ecos)
   ecc=SQRT(ecos*ecos+esin*esin)
   IF(ecc >= 1.0_dp)ecc=0.99_dp
   tconj=ribcinp(3,6)
   rmean=trueatomeana(halfpie-argper,ecc)
   IF(isw28 == 2)THEN
      rmean=trueatomeana(3.0_dp*pie/2.0_dp-argper,ecc)
   END IF
   t0b=tconj-period*rmean/(twopie)
   rmeanbin=twopie*(tstart-t0b)/period
   finc=ribcinp(3,4)
   omega=ribcinp(3,5)
!
   CALL m2tom1centric(rm1,rm2,period,ecc,rmeanbin,argper,finc,omega,qqm2,ppm2)
!
   qq(7)=0.0_dp
   qq(8)=0.0_dp
   qq(9)=0.0_dp
   qq(10)=qqm2(1)
   qq(11)=qqm2(2)
   qq(12)=qqm2(3)
   pp(7)=0.0_dp
   pp(8)=0.0_dp
   pp(9)=0.0_dp
   pp(10)=ppm2(1)
   pp(11)=ppm2(2)
   pp(12)=ppm2(3)
!
   xcom=(rm1*qq(7)+rm2*qq(10))/(rm1+rm2)
   ycom=(rm1*qq(8)+rm2*qq(11))/(rm1+rm2)
   zcom=(rm1*qq(9)+rm2*qq(12))/(rm1+rm2)
   vxcom=(rm1*pp(7)+rm2*pp(10))/(rm1+rm2)
   vycom=(rm1*pp(8)+rm2*pp(11))/(rm1+rm2)
   vzcom=(rm1*pp(9)+rm2*pp(12))/(rm1+rm2)
!
   qqbc1(7)=qq(7)-xcom
   qqbc1(8)=qq(8)-ycom
   qqbc1(9)=qq(9)-zcom
   qqbc1(10)=qq(10)-xcom
   qqbc1(11)=qq(11)-ycom
   qqbc1(12)=qq(12)-zcom
   ppbc1(7)=pp(7)-vxcom
   ppbc1(8)=pp(8)-vycom
   ppbc1(9)=pp(9)-vzcom
   ppbc1(10)=pp(10)-vxcom
   ppbc1(11)=pp(11)-vycom
   ppbc1(12)=pp(12)-vzcom
!
!   xyz of binary2 relative to binary 1
!
   rm1=rmass(1)+rmass(2)
   rm2=rmass(3)+rmass(4)
   period=ribcinp(2,1)
   ecos=ribcinp(2,2)
   esin=ribcinp(2,3)
   argper=ATAN2(esin,ecos)
   ecc=SQRT(ecos*ecos+esin*esin)
   IF(ecc >= 1.0_dp)ecc=0.99_dp
   tconj=ribcinp(2,6)
   rmean=trueatomeana(halfpie-argper,ecc)
   IF(isw28 == 2)THEN
      rmean=trueatomeana(3.0_dp*pie/2.0_dp-argper,ecc)
   END IF
   t0b=tconj-period*rmean/(twopie)
   rmeanbin=twopie*(tstart-t0b)/period
   finc=ribcinp(2,4)
   omega=ribcinp(2,5)
!
   CALL m2tom1centric(rm1,rm2,period,ecc,rmeanbin,argper,finc,omega,qqm2,ppm2)
!
!   add the x,y,z coordinates to those of bodies 3 and 4
!
   qqbc1(7)=qqbc1(7)+qqm2(1)
   qqbc1(8)=qqbc1(8)+qqm2(2)
   qqbc1(9)=qqbc1(9)+qqm2(3)
   qqbc1(10)=qqbc1(10)+qqm2(1)
   qqbc1(11)=qqbc1(11)+qqm2(2)
   qqbc1(12)=qqbc1(12)+qqm2(3)
!
   ppbc1(7)=ppbc1(7)+ppm2(1)
   ppbc1(8)=ppbc1(8)+ppm2(2)
   ppbc1(9)=ppbc1(9)+ppm2(3)
   ppbc1(10)=ppbc1(10)+ppm2(1)
   ppbc1(11)=ppbc1(11)+ppm2(2)
   ppbc1(12)=ppbc1(12)+ppm2(3)
!
   CALL movetobarycenter(nbody,rmass,qqbc1,ppbc1,qq,pp)
!
   RETURN
!
END SUBROUTINE getbinbinibc
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getbody3(nalph3,nbet3,tertperiod,tertt0,tertecos,  &
   tertesin,tertincl,tertomega,tertq,dwavex,dwavey,itconj,it1,  &
   it2,it3,it4,tertconj,tertratrad,hh,sw72,sw73,p2tconj,  &
   p2period,p2t0,p2ecos,p2esin,p2incl,p2omega,p2q,p2ratrad,  &
   p3tconj,p3period,p3t0,p3ecos,p3esin,p3incl,p3omega,p3q,  &
   p3ratrad,p4tconj,p4period,p4t0,p4ecos,p4esin,p4incl,p4omega,  &
   p4q,p4ratrad,p5tconj,p5period,p5t0,p5ecos,p5esin,p5incl,  &
   p5omega,p5q,p5ratrad,p6tconj,p6period,p6t0,p6ecos,p6esin,  &
   p6incl,p6omega,p6q,p6ratrad,p7tconj,p7period,p7t0,p7ecos,  &
   p7esin,p7incl,p7omega,p7q,p7ratrad,p8tconj,p8period,p8t0,  &
   p8ecos,p8esin,p8incl,p8omega,p8q,p8ratrad,nbody)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(OUT)                     :: nalph3
   INTEGER, INTENT(OUT)                     :: nbet3
   REAL(KIND=dp), INTENT(OUT)               :: tertperiod
   REAL(KIND=dp), INTENT(OUT)               :: tertt0
   REAL(KIND=dp), INTENT(OUT)               :: tertecos
   REAL(KIND=dp), INTENT(OUT)               :: tertesin
   REAL(KIND=dp), INTENT(OUT)               :: tertincl
   REAL(KIND=dp), INTENT(OUT)               :: tertomega
   REAL(KIND=dp), INTENT(OUT)               :: tertq
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   INTEGER, INTENT(OUT)                     :: itconj
   INTEGER, INTENT(OUT)                     :: it1
   INTEGER, INTENT(OUT)                     :: it2
   INTEGER, INTENT(OUT)                     :: it3
   INTEGER, INTENT(OUT)                     :: it4
   REAL(KIND=dp), INTENT(OUT)               :: tertconj
   REAL(KIND=dp), INTENT(OUT)               :: tertratrad
   REAL(KIND=dp), INTENT(OUT)               :: hh
   REAL(KIND=dp), INTENT(OUT)               :: sw72
   REAL(KIND=dp), INTENT(OUT)               :: sw73
   REAL(KIND=dp), INTENT(OUT)               :: p2tconj
   REAL(KIND=dp), INTENT(OUT)               :: p2period
   REAL(KIND=dp), INTENT(OUT)               :: p2t0
   REAL(KIND=dp), INTENT(OUT)               :: p2ecos
   REAL(KIND=dp), INTENT(OUT)               :: p2esin
   REAL(KIND=dp), INTENT(OUT)               :: p2incl
   REAL(KIND=dp), INTENT(OUT)               :: p2omega
   REAL(KIND=dp), INTENT(OUT)               :: p2q
   REAL(KIND=dp), INTENT(OUT)               :: p2ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p3tconj
   REAL(KIND=dp), INTENT(OUT)               :: p3period
   REAL(KIND=dp), INTENT(OUT)               :: p3t0
   REAL(KIND=dp), INTENT(OUT)               :: p3ecos
   REAL(KIND=dp), INTENT(OUT)               :: p3esin
   REAL(KIND=dp), INTENT(OUT)               :: p3incl
   REAL(KIND=dp), INTENT(OUT)               :: p3omega
   REAL(KIND=dp), INTENT(OUT)               :: p3q
   REAL(KIND=dp), INTENT(OUT)               :: p3ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p4tconj
   REAL(KIND=dp), INTENT(OUT)               :: p4period
   REAL(KIND=dp), INTENT(OUT)               :: p4t0
   REAL(KIND=dp), INTENT(OUT)               :: p4ecos
   REAL(KIND=dp), INTENT(OUT)               :: p4esin
   REAL(KIND=dp), INTENT(OUT)               :: p4incl
   REAL(KIND=dp), INTENT(OUT)               :: p4omega
   REAL(KIND=dp), INTENT(OUT)               :: p4q
   REAL(KIND=dp), INTENT(OUT)               :: p4ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p5tconj
   REAL(KIND=dp), INTENT(OUT)               :: p5period
   REAL(KIND=dp), INTENT(OUT)               :: p5t0
   REAL(KIND=dp), INTENT(OUT)               :: p5ecos
   REAL(KIND=dp), INTENT(OUT)               :: p5esin
   REAL(KIND=dp), INTENT(OUT)               :: p5incl
   REAL(KIND=dp), INTENT(OUT)               :: p5omega
   REAL(KIND=dp), INTENT(OUT)               :: p5q
   REAL(KIND=dp), INTENT(OUT)               :: p5ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p6tconj
   REAL(KIND=dp), INTENT(OUT)               :: p6period
   REAL(KIND=dp), INTENT(OUT)               :: p6t0
   REAL(KIND=dp), INTENT(OUT)               :: p6ecos
   REAL(KIND=dp), INTENT(OUT)               :: p6esin
   REAL(KIND=dp), INTENT(OUT)               :: p6incl
   REAL(KIND=dp), INTENT(OUT)               :: p6omega
   REAL(KIND=dp), INTENT(OUT)               :: p6q
   REAL(KIND=dp), INTENT(OUT)               :: p6ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p7tconj
   REAL(KIND=dp), INTENT(OUT)               :: p7period
   REAL(KIND=dp), INTENT(OUT)               :: p7t0
   REAL(KIND=dp), INTENT(OUT)               :: p7ecos
   REAL(KIND=dp), INTENT(OUT)               :: p7esin
   REAL(KIND=dp), INTENT(OUT)               :: p7incl
   REAL(KIND=dp), INTENT(OUT)               :: p7omega
   REAL(KIND=dp), INTENT(OUT)               :: p7q
   REAL(KIND=dp), INTENT(OUT)               :: p7ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p8tconj
   REAL(KIND=dp), INTENT(OUT)               :: p8period
   REAL(KIND=dp), INTENT(OUT)               :: p8t0
   REAL(KIND=dp), INTENT(OUT)               :: p8ecos
   REAL(KIND=dp), INTENT(OUT)               :: p8esin
   REAL(KIND=dp), INTENT(OUT)               :: p8incl
   REAL(KIND=dp), INTENT(OUT)               :: p8omega
   REAL(KIND=dp), INTENT(OUT)               :: p8q
   REAL(KIND=dp), INTENT(OUT)               :: p8ratrad
   INTEGER, INTENT(IN)                      :: nbody
!
   INTEGER :: ios,i
!
   ios=0
   OPEN(UNIT=1,FILE='ELCbody3.inp',STATUS='old',ERR=20,IOSTAT= ios)
!
   READ(1,*)nalph3
   READ(1,*)nbet3
   READ(1,*)itconj
   READ(1,*)it1
   READ(1,*)it2
   READ(1,*)it3
   READ(1,*)it4
   READ(1,*)tertconj
   READ(1,*)tertperiod
   READ(1,*)tertt0
   READ(1,*)tertecos
   READ(1,*)tertesin
   READ(1,*)tertincl
   READ(1,*)tertomega
   READ(1,*)tertq
!
!  Load the limb darkening parameters.
!
   DO  i=1,8
      READ(1,*)dwavex(i,3),dwavey(i,3)
   END DO
!
   READ(1,*)tertratrad
   READ(1,*)hh
   READ(1,*)sw72
   READ(1,*)sw73
!
!  body 4 parameters.  If Nbody is 3, then zero these out
!
   READ(1,*)p2tconj
   READ(1,*)p2period
   READ(1,*)p2t0
   READ(1,*)p2ecos
   READ(1,*)p2esin
   READ(1,*)p2incl
   READ(1,*)p2omega
   READ(1,*)p2q
   READ(1,*)p2ratrad
   IF(nbody < 4)THEN
      p2tconj=0.0_dp
      p2period=0.0_dp
      p2t0=0.0_dp
      p2ecos=0.0_dp
      p2esin=0.0_dp
      p2incl=0.0_dp
      p2omega=0.0_dp
      p2q=0.0_dp
      p2ratrad=0.0_dp
   END IF
!
   READ(1,*)p3tconj
   READ(1,*)p3period
   READ(1,*)p3t0
   READ(1,*)p3ecos
   READ(1,*)p3esin
   READ(1,*)p3incl
   READ(1,*)p3omega
   READ(1,*)p3q
   READ(1,*)p3ratrad
   IF(nbody < 5)THEN
      p3tconj=0.0_dp
      p3period=0.0_dp
      p3t0=0.0_dp
      p3ecos=0.0_dp
      p3esin=0.0_dp
      p3incl=0.0_dp
      p3omega=0.0_dp
      p3q=0.0_dp
      p3ratrad=0.0_dp
   END IF
!
   READ(1,*)p4tconj
   READ(1,*)p4period
   READ(1,*)p4t0
   READ(1,*)p4ecos
   READ(1,*)p4esin
   READ(1,*)p4incl
   READ(1,*)p4omega
   READ(1,*)p4q
   READ(1,*)p4ratrad
   IF(nbody < 6)THEN
      p4tconj=0.0_dp
      p4period=0.0_dp
      p4t0=0.0_dp
      p4ecos=0.0_dp
      p4esin=0.0_dp
      p4incl=0.0_dp
      p4omega=0.0_dp
      p4q=0.0_dp
      p4ratrad=0.0_dp
   END IF
!
   READ(1,*)p5tconj
   READ(1,*)p5period
   READ(1,*)p5t0
   READ(1,*)p5ecos
   READ(1,*)p5esin
   READ(1,*)p5incl
   READ(1,*)p5omega
   READ(1,*)p5q
   READ(1,*)p5ratrad
   IF(nbody < 7)THEN
      p5tconj=0.0_dp
      p5period=0.0_dp
      p5t0=0.0_dp
      p5ecos=0.0_dp
      p5esin=0.0_dp
      p5incl=0.0_dp
      p5omega=0.0_dp
      p5q=0.0_dp
      p5ratrad=0.0_dp
   END IF
!
   READ(1,*)p6tconj
   READ(1,*)p6period
   READ(1,*)p6t0
   READ(1,*)p6ecos
   READ(1,*)p6esin
   READ(1,*)p6incl
   READ(1,*)p6omega
   READ(1,*)p6q
   READ(1,*)p6ratrad
   IF(nbody < 8)THEN
      p6tconj=0.0_dp
      p6period=0.0_dp
      p6t0=0.0_dp
      p6ecos=0.0_dp
      p6esin=0.0_dp
      p6incl=0.0_dp
      p6omega=0.0_dp
      p6q=0.0_dp
      p6ratrad=0.0_dp
   END IF
!
   READ(1,*)p7tconj
   READ(1,*)p7period
   READ(1,*)p7t0
   READ(1,*)p7ecos
   READ(1,*)p7esin
   READ(1,*)p7incl
   READ(1,*)p7omega
   READ(1,*)p7q
   READ(1,*)p7ratrad
   IF(nbody < 9)THEN
      p7tconj=0.0_dp
      p7period=0.0_dp
      p7t0=0.0_dp
      p7ecos=0.0_dp
      p7esin=0.0_dp
      p7incl=0.0_dp
      p7omega=0.0_dp
      p7q=0.0_dp
      p7ratrad=0.0_dp
   END IF
!
   READ(1,*)p8tconj
   READ(1,*)p8period
   READ(1,*)p8t0
   READ(1,*)p8ecos
   READ(1,*)p8esin
   READ(1,*)p8incl
   READ(1,*)p8omega
   READ(1,*)p8q
   READ(1,*)p8ratrad
   IF(nbody < 10)THEN
      p8tconj=0.0_dp
      p8period=0.0_dp
      p8t0=0.0_dp
      p8ecos=0.0_dp
      p8esin=0.0_dp
      p8incl=0.0_dp
      p8omega=0.0_dp
      p8q=0.0_dp
      p8ratrad=0.0_dp
   END IF
!
!   limb darkening of body 4 and 5
!
   DO i=1,8
      READ(1,*)dwavex(i,4),dwavey(i,4)
   END DO
!
   DO i=1,8
      READ(1,*)dwavex(i,5),dwavey(i,5)
   END DO
!
!   Come here if the input file ELCbody3.inp does not exist. The
!   subroutine writeinput will make the correct file and set default
!   values.
!
20 IF(ios > 0)CALL writebody3input(nalph3,nbet3,tertperiod,  &
      tertt0,tertecos,tertesin,tertincl,tertomega,tertq,dwavex,  &
      dwavey,itconj,it1,it2,it3,it4,tertconj,tertratrad,hh,sw72,  &
      sw73,p2tconj,p2period,p2t0,p2ecos,p2esin,p2incl,p2omega,p2q,  &
      p2ratrad,p3tconj,p3period,p3t0,p3ecos,p3esin,p3incl,p3omega,  &
      p3q,p3ratrad,p4tconj,p4period,p4t0,p4ecos,p4esin,p4incl,  &
      p4omega,p4q,p4ratrad,p5tconj,p5period,p5t0,p5ecos,p5esin,  &
      p5incl,p5omega,p5q,p5ratrad,p6tconj,p6period,p6t0,p6ecos,  &
      p6esin,p6incl,p6omega,p6q,p6ratrad,p7tconj,p7period,p7t0,  &
      p7ecos,p7esin,p7incl,p7omega,p7q,p7ratrad,p8tconj,p8period,  &
      p8t0,p8ecos,p8esin,p8incl,p8omega,p8q,p8ratrad)
!
!   Put this if-then block for successful completion.
!
   IF(ios == 0)THEN
      CLOSE(1)
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE getbody3
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getcontimes(finc,period,ecc,argper,t0,tconj1,  &
   tconj2)
!
!   November 5, 2008
!
!   This routine will compute the conjunction times
!   given the input parameters.
!   It basically finds the value of the true anamoly that minimizes
!   the projected
!   separation of centers.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: finc
   REAL(KIND=dp), INTENT(IN)                       :: period
   REAL(KIND=dp), INTENT(IN)                       :: ecc
   REAL(KIND=dp), INTENT(IN)                       :: argper
   REAL(KIND=dp), INTENT(IN)                       :: t0
   REAL(KIND=dp), INTENT(OUT)                      :: tconj1
   REAL(KIND=dp), INTENT(OUT)                      :: tconj2
!
   REAL(KIND=dp)  :: fincr,omegar
   REAL(KIND=dp)  :: guess,diff,ft,htrc,ecan,xmc,deltat,deltapp,deltap
!
   INTEGER :: jj
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   threehalfpie=1.5_dp*pie
!
   fincr=finc*degtorad
   omegar=argper*degtorad
   ft=1.5_dp*pie-omegar
   CALL checkangle(ft)
   guess=ft
   DO  jj=1,20
      guess=guess-deltap(fincr,omegar,ecc,guess)/deltapp(fincr,omegar,ecc,guess)
      diff=ABS(guess-ft)
      IF(diff < 1.0E-09_dp)EXIT
      ft=guess
   END DO
!
   ft=guess
   htrc=0.5_dp*ft
   IF(ABS(halfpie-htrc) < 7.0E-06_dp)GO TO 30
   IF(ABS(threehalfpie-htrc) < 7.0E-06_dp)GO TO 30
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-ecc)/(1.0_dp+ecc))*TAN(htrc))
   GO TO 40
30 ecan=pie
40 xmc=ecan-ecc*SIN(ecan)
   deltat=(xmc*period)/(twopie)
   tconj1=t0+deltat
!
   ft=0.5_dp*pie-omegar
   CALL checkangle(ft)
   guess=ft
   DO  jj=1,20
      guess=guess-deltap(fincr,omegar,ecc,guess)/deltapp(fincr,omegar,ecc,guess)
      diff=ABS(guess-ft)
      IF(diff < 1.0E-09_dp)EXIT
      ft=guess
   END DO
!
   ft=guess
   htrc=0.5_dp*ft
   IF(ABS(halfpie-htrc) < 7.0E-06_dp)GO TO 70
   IF(ABS(threehalfpie-htrc) < 7.0E-06_dp)GO TO 70
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-ecc)/(1.0_dp+ecc))*TAN(htrc))
   GO TO 80
70 ecan=pie
80 xmc=ecan-ecc*SIN(ecan)
   deltat=(xmc*period)/(twopie)
   tconj2=t0+deltat
!
   RETURN
!
END SUBROUTINE getcontimes
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getcoords(istar,ialphmax,ibetmax,nalf,ibetlim,  &
   phase,finc,q,xarray,yarray,zarray,gradx,grady,gradz,temp,  &
   ncoords,xcoords,ycoords,xend,extension,separation,bdist,mmdx,  &
   tertincl,tertbdist,tertphase,tertq,axisscale,isw30,isw7,  &
   tertomega)
!
!  October 9, 1999
!
!  This subroutine will return the sky coordinates of the star in the array
!  xcoords(1:Ncoords),ycoords(1:Ncoords).  Only the points that are visible
!  to the observer are included, and eclipses are not accounted for.
!
!  Set istar=1 to do star 1, istar=2 to do star2
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: xarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: yarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: zarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gradx(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: grady(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gradz(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: temp(ialphmax*ibetmax)
   INTEGER, INTENT(OUT)                     :: ncoords
   REAL(KIND=dp), INTENT(OUT)               :: xcoords(ialphmax*ibetmax*4)
   REAL(KIND=dp), INTENT(OUT)               :: ycoords(ialphmax*ibetmax*4)
   REAL(KIND=dp), INTENT(IN)                :: xend(4)
   CHARACTER (LEN=9), INTENT(IN)            :: extension
   REAL(KIND=dp), INTENT(IN)                :: separation
   REAL(KIND=dp), INTENT(IN)                :: bdist
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp)  :: xxoff,yyoff,proj
   REAL(KIND=dp)  :: xxoff1,yyoff1,tertxcen,tertycen,tomrad,ax,ay,az,a2,a3
   REAL(KIND=dp)  :: phaser,fincr,xx,yy,zz,xtran,ytran,xx1,yy1,xx2,yy2,xx3
   REAL(KIND=dp)  :: xx4,yy4,xp,yp,yy3
!
   INTEGER :: i,iidx,ialf,ibet,izz,jzz
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   proj=0.0_dp
!
!    November 18, 2012
!
!    If there is a third body, offset all x and y sky coordinates
!
   xxoff=0.0_dp
   yyoff=0.0_dp
   IF((isw30 >= 3).AND.(isw7 >= 2))THEN
      xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      tomrad=tertomega*degtorad
      xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
      yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
   END IF
!
   IF(istar == 1)OPEN(UNIT=39,FILE='star1temp.'//extension,STATUS='unknown')
   IF(istar == 2)OPEN(UNIT=39,FILE='star2temp.'//extension,STATUS='unknown')
!
   phaser=phase*degtorad
   fincr=finc*degtorad
   az=COS(fincr)
   IF(az < 0.0_dp)az=0.0_dp
   ax=-SIN(fincr)*COS(phaser)
   ay=SIN(fincr)*SIN(phaser)
   a2=ACOS(ax)
   a3=SIN(a2)
   IF(a3 < 0.0_dp)a3=0.0_dp
!
   ncoords=0
!
   IF(istar == 1)THEN
      xx=0.0_dp
      yy=0.0_dp
      zz=0.0_dp
   END IF
   IF(istar == 2)THEN
      xx=1.0_dp
      yy=0.0_dp
      zz=0.0_dp
   END IF
   xp=xtran(xx,yy,phase,q,istar,bdist)
   yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
   xp=xp+xxoff
   yp=yp+yyoff
   ncoords=ncoords+1
   xcoords(ncoords)=xp*separation
   ycoords(ncoords)=yp*separation
!
!   Check the visibility of the nose and end
!
   DO  i=1,2
      IF(i == 1)proj=ax
      IF(i == 2)proj=-ax
      IF(proj > 0.0_dp)THEN
         xp=xtran(xend(i+2),0.0_dp,phase,q,istar,bdist)
         yp=ytran(xend(i+2),0.0_dp,0.0_dp,phase,fincr,q,istar,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
         ncoords=ncoords+1
         xcoords(ncoords)=xp*separation
         ycoords(ncoords)=yp*separation
      END IF
   END DO
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         proj=ax*gradx(iidx)+ay*grady(iidx)+az*gradz(iidx)
!
!  is the surface element visible?
!
         IF(proj < 0.0_dp)CYCLE
         xx=xarray(iidx)
         yy=yarray(iidx)
         zz=zarray(iidx)
         xp=xtran(xx,yy,phase,q,istar,bdist)
         yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
         ncoords=ncoords+1
         xcoords(ncoords)=xp*separation
         ycoords(ncoords)=yp*separation
!
!   Record the x,y,z coordinates of the nearby points.  These points
!   will be used for area filling.
!
         xx1=xp*separation
         yy1=yp*separation
         IF(ibet > 1)THEN
            iidx=mmdx(ialf,ibet-1)
            xx=xarray(iidx)
            yy=yarray(iidx)
            zz=zarray(iidx)
         ELSE
            iidx=mmdx(ialf,ibetlim(ialf))
            xx=xarray(iidx)
            yy=yarray(iidx)
            zz=zarray(iidx)
         END IF
         xx2=xtran(xx,yy,phase,q,istar,bdist)
         yy2=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx2=xx2+xxoff
         yy2=yy2+yyoff
         xx2=xx2*separation
         yy2=yy2*separation
         IF(ialf > 1)THEN
            IF(ibet > 1)THEN
               izz=ialf-1
               jzz=ibet-1
               iidx=mmdx(izz,jzz)
               xx=xarray(iidx)
               yy=yarray(iidx)
               zz=zarray(iidx)
            ELSE
               izz=ialf-1
               jzz=ibetlim(ialf)
               iidx=mmdx(izz,jzz)
               xx=xarray(iidx)
               yy=yarray(iidx)
               zz=zarray(iidx)
            END IF
         ELSE
            xx=xend(1)
            yy=0.0_dp
            zz=0.0_dp
         END IF
         xx3=xtran(xx,yy,phase,q,istar,bdist)
         yy3=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx3=xx3+xxoff
         yy3=yy3+yyoff
         xx3=xx3*separation
         yy3=yy3*separation
         IF(ialf > 1)THEN
            izz=ialf-1
            jzz=ibet
            iidx=mmdx(izz,jzz)
            xx=xarray(iidx)
            yy=yarray(iidx)
            zz=zarray(iidx)
         ELSE
            xx=xend(1)
            yy=0.0_dp
            zz=0.0_dp
         END IF
         xx4=xtran(xx,yy,phase,q,istar,bdist)
         yy4=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx4=xx4+xxoff
         yy4=yy4+yyoff
         xx4=xx4*separation
         yy4=yy4*separation
         izz=ialf
         jzz=ibet
         iidx=mmdx(izz,jzz)
         WRITE(39,40)temp(iidx),xx1,yy1,xx2,yy2,xx3,yy3,xx4,yy4
         IF(ialf == nalf)THEN
            IF(ibet > 1)THEN
               izz=ialf
               jzz=ibet-1
               iidx=mmdx(izz,jzz)
               xx=xarray(iidx)
               yy=yarray(iidx)
               zz=zarray(iidx)
            ELSE
               izz=ialf
               jzz=ibetlim(ialf)
               iidx=mmdx(izz,jzz)
               xx=xarray(iidx)
               yy=yarray(iidx)
               zz=zarray(iidx)
            END IF
            xx2=xtran(xx,yy,phase,q,istar,bdist)
            yy2=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
            xx2=xx2+xxoff
            yy2=yy2+yyoff
            xx2=xx2*separation
            yy2=yy2*separation
            xx=xend(2)
            yy=0.0_dp
            zz=0.0_dp
            xx3=xtran(xx,yy,phase,q,istar,bdist)
            yy3=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
            xx3=xx3+xxoff
            yy3=yy3+yyoff
            xx3=xx3*separation
            yy3=yy3*separation
            xx=xend(2)
            yy=0.0_dp
            zz=0.0_dp
            xx4=xtran(xx,yy,phase,q,istar,bdist)
            yy4=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
            xx4=xx4+xxoff
            yy4=yy4+yyoff
            xx4=xx4*separation
            yy4=yy4*separation
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(39,40)temp(iidx),xx1,yy1,xx2,yy2,xx3,yy3,xx4,yy4
         END IF
!
      END DO
!
!     continue the alpha loop
!
   END DO
!
40 FORMAT(f7.1,1X,8(f10.4,2X))
!
   CLOSE(39)
   CLOSE(40)
!
   RETURN
!
END SUBROUTINE getcoords
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getdepth(n,ymod,rdepth)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: ymod(n)
   REAL(KIND=dp), INTENT(OUT)               :: rdepth
!
   REAL(KIND=dp) :: rmax,rmin
!
   INTEGER :: i
!
   rmax=-1.0E99_dp
   rmin=1.0E99_dp
!
   DO  i=1,n
      IF(ymod(i) > rmax)rmax=ymod(i)
      IF(ymod(i) < rmin)rmin=ymod(i)
   END DO
   rdepth=(rmax-rmin)/rmax
   RETURN
!
END SUBROUTINE getdepth
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getdiskatmflux(nrmax,nthetamax,nradius,ntheta,  &
   diskproj,edgeproj,dvisib,evisib,dtemp,tedge,drad,dinty,einty,  &
   stepr,stepz,maxlines,maxmu,nlines,atmt,atmg,atmmu,nmu,  &
   atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,  &
   atmint8,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,dfluxu,  &
   dfluxb,dfluxv,dfluxr,dfluxi,dfluxj,dfluxh,dfluxk,irvfilt,  &
   separ,dwavex,dwavey,ilaw,iatm,tmin)
!
!  November 30, 1999
!
!  This routine will return fluxes computed from model atmospheres.
!  The flum  and rinty arrays will contain the intensities for the V band.
!  The rinty array contains the specific intensities, while the
!  flum array contains the intensities weighted by the area and the surf
!  vectors.
!
!  The projarray contains the cosine mu terms for each element.  The visib
!  array contains the cosine mu terms for each element, except if the point
!  is eclipsed in which case the visib=0.
!
!   UPDATE April 3, 2002
!
!   Add separ to the argument list of getBBflux, getATMflux,
!   getdiskBBflux, getdiskATMflux, and getBBsimp.  Then scale the fluxes
!   by (separ*solarrad)**2
!
!   UPDATE SEPTEMBER 11, 2009
!
!   If iatm=2, then use a parameterized limb darkening law to
!   compute the flux at angles less than mu=1.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nrmax
   INTEGER, INTENT(IN)                      :: nthetamax
   INTEGER, INTENT(IN)                      :: nradius
   INTEGER, INTENT(IN)                      :: ntheta
   REAL(KIND=dp), INTENT(IN)                :: diskproj(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: edgeproj(nthetamax*11)
   REAL(KIND=dp), INTENT(IN OUT)            :: dvisib(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: evisib(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: dtemp(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: tedge(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: drad(nrmax)
   REAL(KIND=dp), INTENT(OUT)               :: dinty(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: einty(nthetamax*11)
   REAL(KIND=dp), INTENT(IN OUT)            :: stepr
   REAL(KIND=dp), INTENT(IN)                :: stepz
   INTEGER, INTENT(IN)                      :: maxlines
   INTEGER, INTENT(IN)                      :: maxmu
   INTEGER, INTENT(IN)                      :: nlines
   REAL(KIND=dp), INTENT(IN)                :: atmt(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmg(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmmu(maxlines,maxmu)
   INTEGER, INTENT(IN)                      :: nmu(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmint1(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint2(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint3(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint4(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint5(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint6(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint7(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint8(maxlines,maxmu)
   INTEGER, INTENT(IN OUT)                  :: icnu
   INTEGER, INTENT(IN OUT)                  :: icnb
   INTEGER, INTENT(IN OUT)                  :: icnv
   INTEGER, INTENT(IN OUT)                  :: icnr
   INTEGER, INTENT(IN OUT)                  :: icni
   INTEGER, INTENT(IN OUT)                  :: icnj
   INTEGER, INTENT(IN OUT)                  :: icnh
   INTEGER, INTENT(IN OUT)                  :: icnk
   REAL(KIND=dp), INTENT(OUT)               :: dfluxu
   REAL(KIND=dp), INTENT(OUT)               :: dfluxb
   REAL(KIND=dp), INTENT(OUT)               :: dfluxv
   REAL(KIND=dp), INTENT(OUT)               :: dfluxr
   REAL(KIND=dp), INTENT(OUT)               :: dfluxi
   REAL(KIND=dp), INTENT(OUT)               :: dfluxj
   REAL(KIND=dp), INTENT(OUT)               :: dfluxh
   REAL(KIND=dp), INTENT(OUT)               :: dfluxk
   INTEGER, INTENT(IN)                      :: irvfilt
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN OUT)                  :: iatm
   REAL(KIND=dp), INTENT(IN)                :: tmin
!
   REAL(KIND=dp) :: scale,steptheta,tin,gin,rmuin,outinty
!
   INTEGER :: isaveatm,itguess,indext,iidx,ithet,ir,k,iz
!
   DIMENSION  outinty(8)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   isaveatm=iatm
   IF(iatm >= 2)iatm=1
   dfluxu=0.0_dp
   dfluxb=0.0_dp
   dfluxv=0.0_dp
   dfluxr=0.0_dp
   dfluxi=0.0_dp
   dfluxj=0.0_dp
   dfluxh=0.0_dp
   dfluxk=0.0_dp
!
   steptheta=360.0_dp/REAL(ntheta,KIND=dp)
!
!   Find the rough place in the table
!
   tin=dtemp(1)
   CALL locate(atmt,nlines,tin,indext)
   itguess=indext

   DO  ir=1,nradius
      DO  ithet=1,ntheta
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(ir-1)*ntheta+ithet
!
         IF(diskproj(iidx) <= 0.0_dp)CYCLE
         tin=dtemp(iidx)
         IF(tin < tmin)tin=tmin+1.0_dp
         IF((tin < 6800.0_dp))THEN
            gin=3.9_dp
         ELSE
            gin=3.9_dp
         END IF
         rmuin=diskproj(iidx)
!
         CALL computeinty(tin,gin,rmuin,maxlines,maxmu,nlines,  &
            atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
            atmint5,atmint6,atmint7,atmint8,outinty,icnu,icnb,icnv,  &
            icnr,icni,icnj,icnh,icnk,itguess,dwavex,dwavey,ilaw,iatm,1)
!
!    save intensities for plotting
!
         dinty(iidx)=outinty(irvfilt)
!
         IF(dtemp(iidx) < tmin)THEN
            scale=(dtemp(iidx)/tmin)**4
         ELSE
            scale=1.0_dp
         END IF
!
!   Convert the steptheta into radians!
!
         DO  k=1,8
            outinty(k)=outinty(k)*((1.0_dp/8.0_dp)*drad(ir)**3)*  &
               dvisib(iidx)*stepr*steptheta*scale*degtorad
         END DO
!
         dfluxu=dfluxu+outinty(1)
         dfluxb=dfluxb+outinty(2)
         dfluxv=dfluxv+outinty(3)
         dfluxr=dfluxr+outinty(4)
         dfluxi=dfluxi+outinty(5)
         dfluxj=dfluxj+outinty(6)
         dfluxh=dfluxh+outinty(7)
         dfluxk=dfluxk+outinty(8)
      END DO
   END DO
!
   DO  ithet=1,ntheta
      DO  iz=1,11
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(iz-1)*ntheta+ithet
!
         einty(iidx)=0.0_dp
         IF(edgeproj(iidx) < 0.0_dp)CYCLE
         tin=tedge(iidx)
         IF(tin < tmin)tin=tmin+1.0_dp
         IF((tin < 6800.0_dp))THEN
            gin=3.9_dp
         ELSE
            gin=3.9_dp
         END IF
         rmuin=edgeproj(iidx)
!
         CALL computeinty(tin,gin,rmuin,maxlines,maxmu,nlines,  &
            atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
            atmint5,atmint6,atmint7,atmint8,outinty,icnu,icnb,icnv,  &
            icnr,icni,icnj,icnh,icnk,itguess,dwavex,dwavey,ilaw,iatm,1)
!
!   save intensities for plotting
!
         einty(iidx)=outinty(irvfilt)
!
         IF(tedge(iidx) < tmin)THEN
            scale=(tedge(iidx)/tmin)**4
         ELSE
            scale=1.0_dp
         END IF
!
!   Convert the steptheta into radians!
!
         DO  k=1,8
            outinty(k)=outinty(k)*evisib(iidx)*stepz*steptheta*scale*degtorad
         END DO
!
!   The upper rim points are in the face integration.
!   If iz=11, then don't add to dflux.
!
         IF(iz < 11)THEN
            dfluxu=dfluxu+outinty(1)
            dfluxb=dfluxb+outinty(2)
            dfluxv=dfluxv+outinty(3)
            dfluxr=dfluxr+outinty(4)
            dfluxi=dfluxi+outinty(5)
            dfluxj=dfluxj+outinty(6)
            dfluxh=dfluxh+outinty(7)
            dfluxk=dfluxk+outinty(8)
         END IF
      END DO
   END DO
!
!   UPDATE April 3, 2002
!
!   Scale the fluxes.
!
   dfluxu=dfluxu*(separ*solarrad)**2
   dfluxb=dfluxb*(separ*solarrad)**2
   dfluxv=dfluxv*(separ*solarrad)**2
   dfluxr=dfluxr*(separ*solarrad)**2
   dfluxi=dfluxi*(separ*solarrad)**2
   dfluxj=dfluxj*(separ*solarrad)**2
   dfluxh=dfluxh*(separ*solarrad)**2
   dfluxk=dfluxk*(separ*solarrad)**2
!
   IF(isaveatm >= 2)iatm=isaveatm
   RETURN
!
END SUBROUTINE getdiskatmflux
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getdiskbbflux(nrmax,nthetamax,nradius,ntheta,  &
   diskproj,edgeproj,dvisib,evisib,dtemp,tedge,drad,dinty,einty,  &
   stepr,stepz,www,iwww,ilaw,dflux,separ)
!
!   November 8, 1999
!
!   This routine will integrate the flux from the visible parts of
!   the disk and return the result as dflux.
!
!   November 16, 1999
!
!   This routine uses passband specific limb darkening coefficients taken
!   from Van Hamme (1993, AJ, 106, 2096).  I assume log(g)=5.
!
!   November 29, 1999
!
!   Use as the radial coordinate zeta=2.0*dsqrt(r).  This will
!   put more grid points at smaller radii where the temperature
!   might be changing rapidly.  r*d(r) = (1/8)*zeta^3*d(zeta).
!   The variable 'stepr' is actually the stepsize in zeta, and the
!   array 'drad' actually contains zeta values.
!
!   UPDATE April 3, 2002
!
!   Add separ to the argument list of getBBflux, getATMflux,
!   getdiskBBflux, getdiskATMflux, and getBBsimp.  Then scale the fluxes
!   by (separ*solarrad)**2.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nrmax
   INTEGER, INTENT(IN)                      :: nthetamax
   INTEGER, INTENT(IN)                      :: nradius
   INTEGER, INTENT(IN)                      :: ntheta
   REAL(KIND=dp), INTENT(IN)                :: diskproj(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: edgeproj(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: dvisib(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: evisib(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: dtemp(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: tedge(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: drad(nrmax)
   REAL(KIND=dp), INTENT(OUT)               :: dinty(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: einty(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: stepr
   REAL(KIND=dp), INTENT(IN)                :: stepz
   REAL(KIND=dp), INTENT(IN)                :: www
   INTEGER, INTENT(IN)                      :: iwww
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: dflux
   REAL(KIND=dp), INTENT(IN)                :: separ
!
   REAL(KIND=dp)  :: c1,c2,saveflimbx,flum,c3
   REAL(KIND=dp)  :: saveflimby,flimbx,flimby,dark,steptheta,wavemu,ringflux
!
   INTEGER :: iidx,ir
   INTEGER :: iz,ithet
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
!   December 15, 2013:  new triangular sampling for quad law
!
!
   dark=1.0_dp
   dflux=0.0_dp
!
!  C2 =  hc/(k*1e-8)
!  C1 =  2hc^2/((1e-8)**5)
!
!   c2=1.4384E+08_dp
!   c1=1.191044E+35_dp
!
   c2=speedlightm*planck/boltzmann*1.0E+10_dp
   c1=2.0_dp*planck*speedlightm*speedlightm*1.0E+51_dp
!
   steptheta=360.0_dp/REAL(ntheta,KIND=dp)
!
   c1=3.74185_dp
   c2=14.3883_dp
   wavemu=www/10000.0_dp
   DO  ir=1,nradius
      iidx=(ir-1)*ntheta+1
      IF(iwww == 1)CALL flcu50(dtemp(iidx),ilaw,flimbx,flimby)
      IF(iwww == 2)CALL flcb50(dtemp(iidx),ilaw,flimbx,flimby)
      IF(iwww == 3)CALL flcv50(dtemp(iidx),ilaw,flimbx,flimby)
      IF(iwww == 4)CALL flcr50(dtemp(iidx),ilaw,flimbx,flimby)
      IF(iwww == 5)CALL flci50(dtemp(iidx),ilaw,flimbx,flimby)
      IF(iwww == 6)CALL flcj50(dtemp(iidx),ilaw,flimbx,flimby)
      IF(iwww == 7)CALL flch50(dtemp(iidx),ilaw,flimbx,flimby)
      IF(iwww == 8)CALL flck50(dtemp(iidx),ilaw,flimbx,flimby)
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         saveflimbx=flimbx
         saveflimby=flimby
         flimbx=2.0_dp*SQRT(saveflimbx)*saveflimby
         flimby=SQRT(saveflimbx)*(1.0_dp-2.0_dp*saveflimby)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         saveflimbx=flimbx
         saveflimby=flimby
         flimbx=1.0_dp-SQRT(saveflimbx)*saveflimby
         flimby=1.0_dp-SQRT(saveflimbx)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         saveflimbx=flimbx
         saveflimby=flimby
         flimbx=SQRT(saveflimbx)*(1.0_dp-2.0_dp*saveflimby)
         flimby=2.0_dp*SQRT(saveflimbx)*saveflimby
      END IF
!
      ringflux=0.0_dp
      DO  ithet=1,ntheta
         iidx=(ir-1)*ntheta+ithet
         dinty(iidx)=0.0_dp
         IF(diskproj(iidx) <= 0.0_dp)CYCLE
         c3=c2/(wavemu*dtemp(iidx)/1000.0_dp)
         flum=c1/(EXP(c3)-1.0_dp)/wavemu**5
         IF(ilaw <= 1)dark=(1.0_dp-flimbx+flimbx*diskproj(iidx))
         IF(ilaw == 2)THEN
            dark=1.0_dp-flimbx*(1.0_dp-diskproj(iidx))
            dark=dark-flimby*diskproj(iidx)*LOG(diskproj(iidx))
         END IF
         IF(ilaw == 6)THEN
            dark=1.0_dp-flimbx*(1.0_dp-diskproj(iidx))
            dark=dark-flimby*diskproj(iidx)*LOG(diskproj(iidx))
         END IF
         IF(ilaw == 3)THEN
            dark=1.0_dp-flimbx*(1.0_dp-diskproj(iidx))
            dark=dark-flimby*(1.0_dp-SQRT(diskproj(iidx)))
         END IF
         IF(ilaw == 7)THEN
            dark=1.0_dp-flimbx*(1.0_dp-diskproj(iidx))
            dark=dark-flimby*(1.0_dp-SQRT(diskproj(iidx)))
         END IF
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic limb darkening law, ilaw=4
!
         IF(ilaw == 4)THEN
            dark=1.0_dp-flimbx*(1.0_dp-diskproj(iidx))
            dark=dark-flimby*(1.0_dp-(diskproj(iidx)))**2
         END IF
         IF(ilaw == 5)THEN
            dark=1.0_dp-flimbx*(1.0_dp-diskproj(iidx))
            dark=dark-flimby*(1.0_dp-(diskproj(iidx)))**2
         END IF
!
         flum=flum*dark
!
!    save intensities for plotting
!
         dinty(iidx)=flum
!
!   Here is the old term when the steps were linear in r:
!
!              flum=drad(ir)*flum*dvisib(ir,ithet)*stepr*steptheta
!
!   Here is the expression for steps in the zeta coordinate:
!
!   April 19, 2001:
!
!   Convert the steptheta into radians!
!
         flum=((1.0_dp/8.0_dp)*drad(ir)**3)*flum*dvisib(iidx)*stepr*  &
            steptheta*degtorad
         ringflux=ringflux+flum
      END DO
      dflux=ringflux+dflux
   END DO
!
   DO  ithet=1,ntheta
      iidx=(1-1)*ntheta+ithet
      IF(iwww == 1)CALL flcu50(tedge(iidx),ilaw,flimbx,flimby)
      IF(iwww == 2)CALL flcb50(tedge(iidx),ilaw,flimbx,flimby)
      IF(iwww == 3)CALL flcv50(tedge(iidx),ilaw,flimbx,flimby)
      IF(iwww == 4)CALL flcr50(tedge(iidx),ilaw,flimbx,flimby)
      IF(iwww == 5)CALL flci50(tedge(iidx),ilaw,flimbx,flimby)
      IF(iwww == 6)CALL flcj50(tedge(iidx),ilaw,flimbx,flimby)
      IF(iwww == 7)CALL flch50(tedge(iidx),ilaw,flimbx,flimby)
      IF(iwww == 8)CALL flck50(tedge(iidx),ilaw,flimbx,flimby)
!
      ringflux=0.0_dp
!
      DO  iz=1,11
         iidx=(iz-1)*ntheta+ithet
         einty(iidx)=0.0_dp
         IF(edgeproj(iidx) < 0.0_dp)CYCLE
         c3=c2/(wavemu*tedge(iidx)/1000.0_dp)
         flum=c1/(EXP(c3)-1.0_dp)/wavemu**5
         IF(ilaw <= 1)dark=(1.0_dp-flimbx+flimbx*edgeproj(iidx))
         IF(ilaw == 2)THEN
            dark=1.0_dp-flimbx*(1.0_dp-edgeproj(iidx))
            dark=dark-flimby*edgeproj(iidx)*LOG(edgeproj(iidx))
         END IF
         IF(ilaw == 6)THEN
            dark=1.0_dp-flimbx*(1.0_dp-edgeproj(iidx))
            dark=dark-flimby*edgeproj(iidx)*LOG(edgeproj(iidx))
         END IF
         IF(ilaw == 3)THEN
            dark=1.0_dp-flimbx*(1.0_dp-edgeproj(iidx))
            dark=dark-flimby*(1.0_dp-SQRT(edgeproj(iidx)))
         END IF
         IF(ilaw == 7)THEN
            dark=1.0_dp-flimbx*(1.0_dp-edgeproj(iidx))
            dark=dark-flimby*(1.0_dp-SQRT(edgeproj(iidx)))
         END IF
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic limb darkening law, ilaw=4
!
         IF(ilaw == 4)THEN
            dark=1.0_dp-flimbx*(1.0_dp-edgeproj(iidx))
            dark=dark-flimby*(1.0_dp-(edgeproj(iidx)))**2
         END IF
         IF(ilaw == 5)THEN
            dark=1.0_dp-flimbx*(1.0_dp-edgeproj(iidx))
            dark=dark-flimby*(1.0_dp-(edgeproj(iidx)))**2
         END IF
!
         flum=flum*dark
!
!   save intensities for plotting
!
         einty(iidx)=flum
!
!   April 19, 2001:
!
!   Convert the steptheta into radians!
!
         flum=flum*evisib(iidx)*stepz*steptheta*degtorad
!
!   The upper rim points are in the face integration.  If iz=11, then don't
!   add to dflux.
!
         IF(iz < 11)ringflux=ringflux+flum
      END DO
!
      dflux=ringflux+dflux
!
   END DO
!
!   UPDATE April 3, 2002
!
!   Scale the flux
!
   dflux=dflux*(separ*solarrad)**2
!
   RETURN
!
END SUBROUTINE getdiskbbflux
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getdiskhoriz(nthetamax,ntheta,q,phase,finc,xedge,  &
   yedge,zedge,ndhoriz,dxhoriz,dyhoriz,ndtop,dtopx,dtopy,bdist,  &
   tertincl,tertbdist,tertphase,tertq,axisscale,isw30,isw7,  &
   tertomega)
!
!   November 3, 1999
!
!   This routine will find the horizon of the disk.  The horizon is simply
!   the lower rim for the front part (proj>0) and the upper rim for the
!   back part (proj<0).
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nthetamax
   INTEGER, INTENT(IN)                      :: ntheta
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: xedge(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: yedge(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: zedge(nthetamax*11)
   INTEGER, INTENT(OUT)                     :: ndhoriz
   REAL(KIND=dp), INTENT(OUT)               :: dxhoriz(2*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: dyhoriz(2*nthetamax)
   INTEGER, INTENT(OUT)                     :: ndtop
   REAL(KIND=dp), INTENT(OUT)               :: dtopx(2*nthetamax)
   REAL(KIND=dp), INTENT(OUT)               :: dtopy(2*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp) :: fincr,sifinc,xxoff,yyoff,xxoff1,yyoff1,tomrad
   REAL(KIND=dp) :: xp,yp,xx,yy,zz,tertxcen,tertycen,rsign,rlastproj
   REAL(KIND=dp) :: steptheta,theta,angdiff,proj,diskxtran,diskytran
!
   INTEGER :: iidx,kkk
   INTEGER :: ithet
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!    November 18, 2012
!
!    If there is a third body, offset all x and y sky coordinates
!
   xxoff=0.0_dp
   yyoff=0.0_dp
   IF((isw30 >= 3).AND.(isw7 >= 2))THEN
      xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      tomrad=tertomega*degtorad
      xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
      yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
   END IF
!
   fincr=finc*degtorad
   sifinc=SIN(fincr)
!
   ndhoriz=0
   ndtop=0
   kkk=0
   steptheta=360.0_dp/REAL(ntheta,KIND=dp)
!
!  theta goes from zero to 360-step
!
   DO  ithet=1,ntheta
      theta=REAL(ithet,KIND=dp)*steptheta-0.5_dp*steptheta
      angdiff=(theta-phase)*degtorad
      proj=sifinc*COS(angdiff)
      IF(proj > 0.0_dp)THEN
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(1-1)*ntheta+ithet
         xx=xedge(iidx)
         yy=yedge(iidx)
         zz=zedge(iidx)
         xp=diskxtran(xx,yy,phase,q,1,bdist)
         yp=diskytran(xx,yy,zz,phase,fincr,q,1,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
         ndhoriz=ndhoriz+1
         dxhoriz(ndhoriz)=xp
         dyhoriz(ndhoriz)=yp
      ELSE
         iidx=(11-1)*ntheta+ithet
         xx=xedge(iidx)
         yy=yedge(iidx)
         zz=zedge(iidx)
         xp=diskxtran(xx,yy,phase,q,1,bdist)
         yp=diskytran(xx,yy,zz,phase,fincr,q,1,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
         ndhoriz=ndhoriz+1
         dxhoriz(ndhoriz)=xp
         dyhoriz(ndhoriz)=yp
      END IF
      iidx=(11-1)*ntheta+ithet
      xx=xedge(iidx)
      yy=yedge(iidx)
      zz=zedge(iidx)
      xp=diskxtran(xx,yy,phase,q,1,bdist)
      yp=diskytran(xx,yy,zz,phase,fincr,q,1,bdist)
      xp=xp+xxoff
      yp=yp+yyoff
      ndtop=ndtop+1
      dtopx(ndtop)=xp
      dtopy(ndtop)=yp
!
      IF(ithet > 1)THEN
         rsign=proj*rlastproj
         IF(rsign < 0.0_dp)THEN
            kkk=kkk+1
         END IF
      END IF
      rlastproj=proj
   END DO
!
   CALL sortcircle(ndhoriz,dxhoriz,dyhoriz)
   CALL sortcircle(ndtop,dtopx,dtopy)
!
   RETURN
!
END SUBROUTINE getdiskhoriz
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gete(em,ecc,bige)
!
!    Solve for bigE in  em = bigE - ecc*sin(bigE)  (i.e. Kepler's Eq.)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: em
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(OUT)               :: bige
!
   REAL(KIND=dp)  :: eold,top,bottom,enew,diff
!
   INTEGER :: i
!
   eold=em
   DO  i=1,20
      top=eold-ecc*SIN(eold)-em
      bottom=1.0_dp-ecc*COS(eold)
      enew=eold-top/bottom
      diff=ABS(enew-eold)
      IF(diff < 10.0_dp*epsilon(diff))EXIT
!
!      IF(PRECISION(diff).ge.18)THEN
!        IF(diff < 1.0E-18_dp)EXIT
!      ELSE
!        IF(diff < 1.0E-15_dp)EXIT
!      END IF
!
      eold=enew
   END DO
!
   bige=eold
!
   RETURN
!
END SUBROUTINE gete
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getelcparmvals(nbody,ioptimizer)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                  :: nbody
   INTEGER, INTENT(IN)                  :: ioptimizer
!
   INTEGER :: icount,i
!
   CHARACTER (LEN=30) :: suffix(999)
!
   OPEN(UNIT=66,FILE='getELCparmvals.com',STATUS='unknown')
   IF(ioptimizer == 2)OPEN(UNIT=67,FILE=  &
      'getdemcmc_starparmvals.com',STATUS='unknown')
   IF(ioptimizer == 10)OPEN(UNIT=67,FILE=  &
      'gethammer_starparmvals.com',STATUS='unknown')
   icount=3
!
   suffix(3)='M1solar'
   suffix(4)='M2solar'
   suffix(5)='R1solar'
   suffix(6)='R2solar'
   suffix(7)='log_g1'
   suffix(8)='log_g2'
   suffix(9)='den1'
   suffix(10)='den2'
   suffix(11)='fill1'
   suffix(12)='fill2'
   suffix(13)='K1'
   suffix(14)='K2'
   suffix(15)='Vrot1'
   suffix(16)='Vrot2'
   suffix(17)='Vrot1_omega1'
   suffix(18)='Vrot2_omega2'
   suffix(19)='tspot_1_1'
   suffix(20)='tspot_2_1'
   suffix(21)='tspot_1_2'
   suffix(22)='tspot_2_2'
   suffix(23)='tspot_1_disk'
   suffix(24)='tspot_2_disk'
   suffix(25)='diskrad'
   suffix(26)='diskthick'
   suffix(27)='X_duras'
   suffix(28)='impact1'
   suffix(29)='tran_duras'
   suffix(30)='tran_depth'
   suffix(31)='tran_duras_alt'
   suffix(32)='M2earth'
   suffix(33)='R2earth'
   suffix(34)='period2days'
   suffix(35)='a2AU'
   suffix(36)='ecc2'
   suffix(37)='argper2deg'
   suffix(38)='incl2deg'
   suffix(39)='Omega2deg'
   suffix(40)='Tconj2'
   suffix(41)='Tperi2'
   suffix(42)='mutual2deg'
!
   DO i=3,42
!      k1=lnblnk(suffix(i))
      IF(icount < 10)THEN
         WRITE(66,10)icount,TRIM(suffix(i))
      END IF
      IF((icount < 100).AND.(icount > 9))THEN
         WRITE(66,20)icount,TRIM(suffix(i))
      END IF
      IF((icount < 1000).AND.(icount > 99))THEN
         WRITE(66,30)icount,TRIM(suffix(i))
      END IF
      IF(ioptimizer == 2)THEN
         IF(icount-2 < 10)THEN
            WRITE(67,40)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 100).AND.(icount-2 > 9))THEN
            WRITE(67,50)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 1000).AND.(icount-2 > 99))THEN
            WRITE(67,60)icount-2,TRIM(suffix(i))
         END IF
      END IF
      IF(ioptimizer == 10)THEN
         IF(icount-2 < 10)THEN
            WRITE(67,70)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 100).AND.(icount-2 > 9))THEN
            WRITE(67,80)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 1000).AND.(icount-2 > 99))THEN
            WRITE(67,90)icount-2,TRIM(suffix(i))
         END IF
      END IF
      icount=icount+1
   END DO
!
   IF(nbody <= 2)GO TO 100
   icount=icount+1
   icount=icount+1
!
   suffix(45)='M3solar'
   suffix(46)='R3solar'
   suffix(47)='M3earth'
   suffix(48)='R3earth'
   suffix(49)='log_g3'
   suffix(50)='den3'
   suffix(51)='period3days'
   suffix(52)='a3AU'
   suffix(53)='ecc3'
   suffix(54)='argper3deg'
   suffix(55)='incl3deg'
   suffix(56)='Omega3deg'
   suffix(57)='Tconj3'
   suffix(58)='Tperi3'
   suffix(59)='mutual3deg'
!
   DO i=45,59
!      k1=lnblnk(suffix(i))
      IF(icount < 10)THEN
         WRITE(66,10)icount,TRIM(suffix(i))
      END IF
      IF((icount < 100).AND.(icount > 9))THEN
         WRITE(66,20)icount,TRIM(suffix(i))
      END IF
      IF((icount < 1000).AND.(icount > 99))THEN
         WRITE(66,30)icount,TRIM(suffix(i))
      END IF
      IF(ioptimizer == 2)THEN
         IF(icount-2 < 10)THEN
            WRITE(67,40)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 100).AND.(icount > 9))THEN
            WRITE(67,50)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 1000).AND.(icount > 99))THEN
            WRITE(67,60)icount-2,TRIM(suffix(i))
         END IF
      END IF
      IF(ioptimizer == 10)THEN
         IF(icount < 10)THEN
            WRITE(67,70)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 100).AND.(icount > 9))THEN
            WRITE(67,80)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 1000).AND.(icount > 99))THEN
            WRITE(67,90)icount-2,TRIM(suffix(i))
         END IF
      END IF
      icount=icount+1
   END DO
!
   IF(nbody <= 3)GO TO 100
!
   suffix(60)='M4solar'
   suffix(61)='R4solar'
   suffix(62)='M4earth'
   suffix(63)='R4earth'
   suffix(64)='log_g4'
   suffix(65)='den4'
   suffix(66)='period4days'
   suffix(67)='a4AU'
   suffix(68)='ecc4'
   suffix(69)='argper4deg'
   suffix(70)='incl4deg'
   suffix(71)='Omega4deg'
   suffix(72)='Tconj4'
   suffix(73)='Tperi4'
   suffix(74)='mutual4deg'
!
   DO i=60,74
!      k1=lnblnk(TRIM(suffix(i))
      IF(icount < 10)THEN
         WRITE(66,10)icount,TRIM(suffix(i))
      END IF
      IF((icount < 100).AND.(icount > 9))THEN
         WRITE(66,20)icount,TRIM(suffix(i))
      END IF
      IF((icount < 1000).AND.(icount > 99))THEN
         WRITE(66,30)icount,TRIM(suffix(i))
      END IF
      IF(ioptimizer == 2)THEN
         IF(icount-2 < 10)THEN
            WRITE(67,40)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 100).AND.(icount > 9))THEN
            WRITE(67,50)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 1000).AND.(icount > 99))THEN
            WRITE(67,60)icount-2,TRIM(suffix(i))
         END IF
      END IF
      IF(ioptimizer == 10)THEN
         IF(icount < 10)THEN
            WRITE(67,70)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 100).AND.(icount > 9))THEN
            WRITE(67,80)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 1000).AND.(icount > 99))THEN
            WRITE(67,90)icount-2,TRIM(suffix(i))
         END IF
      END IF
      icount=icount+1
   END DO
!
   IF(nbody <= 4)GO TO 100
!
   suffix(75)='M5solar'
   suffix(76)='R5solar'
   suffix(77)='M5earth'
   suffix(78)='R5earth'
   suffix(79)='log_g5'
   suffix(80)='den5'
   suffix(81)='period5days'
   suffix(82)='a5AU'
   suffix(83)='ecc5'
   suffix(84)='argper5deg'
   suffix(85)='incl5deg'
   suffix(86)='Omega5deg'
   suffix(87)='Tconj5'
   suffix(88)='Tperi5'
   suffix(89)='mutual5deg'
!
   DO i=75,89
!      k1=lnblnk(suffix(i))
      IF(icount < 10)THEN
         WRITE(66,10)icount,TRIM(suffix(i))
      END IF
      IF((icount < 100).AND.(icount > 9))THEN
         WRITE(66,20)icount,TRIM(suffix(i))
      END IF
      IF((icount < 1000).AND.(icount > 99))THEN
         WRITE(66,30)icount,TRIM(suffix(i))
      END IF
      IF(ioptimizer == 2)THEN
         IF(icount-2 < 10)THEN
            WRITE(67,40)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 100).AND.(icount > 9))THEN
            WRITE(67,50)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 1000).AND.(icount > 99))THEN
            WRITE(67,60)icount-2,TRIM(suffix(i))
         END IF
      END IF
      IF(ioptimizer == 10)THEN
         IF(icount < 10)THEN
            WRITE(67,70)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 100).AND.(icount > 9))THEN
            WRITE(67,80)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 1000).AND.(icount > 99))THEN
            WRITE(67,90)icount-2,TRIM(suffix(i))
         END IF
      END IF
      icount=icount+1
   END DO
!
   IF(nbody <= 5)GO TO 100
!
   suffix(90)='M6solar'
   suffix(91)='R6solar'
   suffix(92)='M6earth'
   suffix(93)='R6earth'
   suffix(94)='log_g6'
   suffix(95)='den6'
   suffix(96)='period6days'
   suffix(97)='a6AU'
   suffix(98)='ecc6'
   suffix(99)='argper6deg'
   suffix(100)='incl6deg'
   suffix(101)='Omega6deg'
   suffix(102)='Tconj6'
   suffix(103)='Tperi6'
   suffix(104)='mutual6deg'
!
   DO i=90,104
!      k1=lnblnk(TRIM(suffix(i))
      IF(icount < 10)THEN
         WRITE(66,10)icount,TRIM(suffix(i))
      END IF
      IF((icount < 100).AND.(icount > 9))THEN
         WRITE(66,20)icount,TRIM(suffix(i))
      END IF
      IF((icount < 1000).AND.(icount > 99))THEN
         WRITE(66,30)icount,TRIM(suffix(i))
      END IF
      IF(ioptimizer == 2)THEN
         IF(icount-2 < 10)THEN
            WRITE(67,40)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 100).AND.(icount > 9))THEN
            WRITE(67,50)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 1000).AND.(icount > 99))THEN
            WRITE(67,60)icount-2,TRIM(suffix(i))
         END IF
      END IF
      IF(ioptimizer == 10)THEN
         IF(icount < 10)THEN
            WRITE(67,70)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 100).AND.(icount > 9))THEN
            WRITE(67,80)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 1000).AND.(icount > 99))THEN
            WRITE(67,90)icount-2,TRIM(suffix(i))
         END IF
      END IF
      icount=icount+1
   END DO
!
   IF(nbody <= 6)GO TO 100
!
   suffix(105)='M7solar'
   suffix(106)='R7solar'
   suffix(107)='M7earth'
   suffix(108)='R7earth'
   suffix(109)='log_g7'
   suffix(110)='den7'
   suffix(111)='period7days'
   suffix(112)='a7AU'
   suffix(113)='ecc7'
   suffix(114)='argper7deg'
   suffix(115)='incl7deg'
   suffix(116)='Omega7deg'
   suffix(117)='Tconj7'
   suffix(118)='Tperi7'
   suffix(119)='mutual7deg'
!
   DO i=105,119
!      k1=lnblnk(suffix(i))
      IF(icount < 10)THEN
         WRITE(66,10)icount,TRIM(suffix(i))
      END IF
      IF((icount < 100).AND.(icount > 9))THEN
         WRITE(66,20)icount,TRIM(suffix(i))
      END IF
      IF((icount < 1000).AND.(icount > 99))THEN
         WRITE(66,30)icount,TRIM(suffix(i))
      END IF
      IF(ioptimizer == 2)THEN
         IF(icount-2 < 10)THEN
            WRITE(67,40)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 100).AND.(icount > 9))THEN
            WRITE(67,50)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 1000).AND.(icount > 99))THEN
            WRITE(67,60)icount-2,TRIM(suffix(i))
         END IF
      END IF
      IF(ioptimizer == 10)THEN
         IF(icount < 10)THEN
            WRITE(67,70)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 100).AND.(icount > 9))THEN
            WRITE(67,80)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 1000).AND.(icount > 99))THEN
            WRITE(67,90)icount-2,TRIM(suffix(i))
         END IF
      END IF
      icount=icount+1
   END DO
!
   IF(nbody <= 7)GO TO 100
!
   suffix(120)='M8solar'
   suffix(121)='R8solar'
   suffix(122)='M8earth'
   suffix(123)='R8earth'
   suffix(124)='log_g8'
   suffix(125)='den8'
   suffix(126)='period8days'
   suffix(127)='a8AU'
   suffix(128)='ecc8'
   suffix(129)='argper8deg'
   suffix(130)='incl8deg'
   suffix(131)='Omega8deg'
   suffix(132)='Tconj8'
   suffix(133)='Tperi8'
   suffix(134)='mutual8deg'
!
   DO i=120,134
!      k1=lnblnk(suffix(i))
      IF(icount < 10)THEN
         WRITE(66,10)icount,TRIM(suffix(i))
      END IF
      IF((icount < 100).AND.(icount > 9))THEN
         WRITE(66,20)icount,TRIM(suffix(i))
      END IF
      IF((icount < 1000).AND.(icount > 99))THEN
         WRITE(66,30)icount,TRIM(suffix(i))
      END IF
      IF(ioptimizer == 2)THEN
         IF(icount-2 < 10)THEN
            WRITE(67,40)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 100).AND.(icount > 9))THEN
            WRITE(67,50)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 1000).AND.(icount > 99))THEN
            WRITE(67,60)icount-2,TRIM(suffix(i))
         END IF
      END IF
      IF(ioptimizer == 10)THEN
         IF(icount < 10)THEN
            WRITE(67,70)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 100).AND.(icount > 9))THEN
            WRITE(67,80)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 1000).AND.(icount > 99))THEN
            WRITE(67,90)icount-2,TRIM(suffix(i))
         END IF
      END IF
      icount=icount+1
   END DO
!
   IF(nbody <= 8)GO TO 100
!
   suffix(135)='M9solar'
   suffix(136)='R9solar'
   suffix(137)='M9earth'
   suffix(138)='R9earth'
   suffix(139)='log_g9'
   suffix(140)='den9'
   suffix(141)='period9days'
   suffix(142)='a9AU'
   suffix(143)='ecc9'
   suffix(144)='argper9deg'
   suffix(145)='incl9deg'
   suffix(146)='Omega9deg'
   suffix(147)='Tconj9'
   suffix(148)='Tperi9'
   suffix(149)='mutual9deg'
!
   DO i=135,149
!      k1=lnblnk(suffix(i))
      IF(icount < 10)THEN
         WRITE(66,10)icount,TRIM(suffix(i))
      END IF
      IF((icount < 100).AND.(icount > 9))THEN
         WRITE(66,20)icount,TRIM(suffix(i))
      END IF
      IF((icount < 1000).AND.(icount > 99))THEN
         WRITE(66,30)icount,TRIM(suffix(i))
      END IF
      IF(ioptimizer == 2)THEN
         IF(icount-2 < 10)THEN
            WRITE(67,40)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 100).AND.(icount > 9))THEN
            WRITE(67,50)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 1000).AND.(icount > 99))THEN
            WRITE(67,60)icount-2,TRIM(suffix(i))
         END IF
      END IF
      IF(ioptimizer == 10)THEN
         IF(icount < 10)THEN
            WRITE(67,70)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 100).AND.(icount > 9))THEN
            WRITE(67,80)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 1000).AND.(icount > 99))THEN
            WRITE(67,90)icount-2,TRIM(suffix(i))
         END IF
      END IF
      icount=icount+1
   END DO
!
   IF(nbody <= 9)GO TO 100
!
   suffix(150)='M10solar'
   suffix(151)='R10solar'
   suffix(152)='M10earth'
   suffix(153)='R10earth'
   suffix(154)='log_g10'
   suffix(155)='den10'
   suffix(156)='period10days'
   suffix(157)='a10AU'
   suffix(158)='ecc10'
   suffix(159)='argper10deg'
   suffix(160)='incl10deg'
   suffix(161)='Omega10deg'
   suffix(162)='Tconj10'
   suffix(163)='Tperi10'
   suffix(164)='mutual10deg'
!
   DO i=150,164
!      k1=lnblnk(suffix(i))
      IF(icount < 10)THEN
         WRITE(66,10)icount,TRIM(suffix(i))
      END IF
      IF((icount < 100).AND.(icount > 9))THEN
         WRITE(66,20)icount,TRIM(suffix(i))
      END IF
      IF((icount < 1000).AND.(icount > 99))THEN
         WRITE(66,30)icount,TRIM(suffix(i))
      END IF
      IF(ioptimizer == 2)THEN
         IF(icount-2 < 10)THEN
            WRITE(67,40)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 100).AND.(icount > 9))THEN
            WRITE(67,50)icount-2,TRIM(suffix(i))
         END IF
         IF((icount-2 < 1000).AND.(icount > 99))THEN
            WRITE(67,60)icount-2,TRIM(suffix(i))
         END IF
      END IF
      IF(ioptimizer == 10)THEN
         IF(icount < 10)THEN
            WRITE(67,70)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 100).AND.(icount > 9))THEN
            WRITE(67,80)icount-2,TRIM(suffix(i))
         END IF
         IF((icount < 1000).AND.(icount > 99))THEN
            WRITE(67,90)icount-2,TRIM(suffix(i))
         END IF
      END IF
      icount=icount+1
   END DO
!
   IF(nbody <= 9)GO TO 100
!
10 FORMAT('awk ''{print $',i1,',$2}'' ELCparm.*',1X,'> ttempELC.' ,a)
20 FORMAT('awk ''{print $',i2,',$2}'' ELCparm.*',1X,'> ttempELC.' ,a)
30 FORMAT('awk ''{print $',i3,',$2}'' ELCparm.*',1X,'> ttempELC.' ,a)
40 FORMAT('awk ''{print $',i1,'}'' demcmc_starparm.*',1X,'> temp'  &
      ,'ELC.',a)
50 FORMAT('awk ''{print $',i2,'}'' demcmc_starparm.*',1X,'> temp'  &
      ,'ELC.',a)
60 FORMAT('awk ''{print $',i3,'}'' demcmc_parm.*',1X,'> tempELC.' ,a)
70 FORMAT('awk ''{print $',i1,'}'' hammer_starparm.*',1X,'> temp'  &
      ,'ELC.',a)
80 FORMAT('awk ''{print $',i2,'}'' hammer_starparm.*',1X,'> temp'  &
      ,'ELC.',a)
90 FORMAT('awk ''{print $',i3,'}'' hammer_parm.*',1X,'> tempELC.' ,a)

100 CLOSE(66)
   IF(ioptimizer == 2)CLOSE(67)
   IF(ioptimizer == 10)CLOSE(67)
!
   RETURN
!
END SUBROUTINE getelcparmvals
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getextension(phase,extension,isw7,icounttime)
!
!   October 25, 1999
!
!   extension = '001.00'  for phase = 1.0
!   extension = '011.22'  for phase = 11.22
!   extension = '123.45'  for phase = 123.45  etc.
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: phase
   CHARACTER (LEN=9), INTENT(OUT)           :: extension
   INTEGER, INTENT(IN)                      :: isw7
   INTEGER, INTENT(IN)                      :: icounttime
!
   IF(isw7 > 1)THEN
      WRITE(extension,40)icounttime+100000000
      RETURN
   END IF
   IF((phase >= 0.0_dp).AND.(phase < 10.0_dp))WRITE(extension,10)phase
   IF((phase >= 10.0_dp).AND.(phase < 100.0_dp))WRITE(extension,20)phase
   IF((phase >= 100.0_dp).AND.(phase < 1000.0_dp))WRITE(extension,30)phase
!
   RETURN
!
10 FORMAT('00',f7.5)
20 FORMAT('0',f8.5)
30 FORMAT(f9.5)
40 FORMAT(i9)
!
END SUBROUTINE getextension
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getfracs(nmaxphase,icount,fracs1,fracs2,fracs3,  &
   fracs4,fracs5,fracs6,fracs7,fracs8,compfracs,dphase,eshift,  &
   pshift,ionephase,ism1,ecc,sw26,fracstring)
!
!   October 10, 2007
!
!   This is a new routine that will return the luminosity ratios in
!   each bandpass.  compfracs(i,1) will have L_2/L_1, and
!   compfracs(i,2) will have L_disk/L_tot.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN)                      :: icount
   REAL(KIND=dp), INTENT(IN OUT)            :: fracs1(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN OUT)            :: fracs2(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN OUT)            :: fracs3(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN OUT)            :: fracs4(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN OUT)            :: fracs5(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN OUT)            :: fracs6(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN OUT)            :: fracs7(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN OUT)            :: fracs8(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: compfracs(8,3)
   REAL(KIND=dp), INTENT(IN)                :: dphase
   REAL(KIND=dp), INTENT(IN)                :: eshift
   REAL(KIND=dp), INTENT(IN)                :: pshift
   INTEGER, INTENT(IN)                      :: ionephase
   INTEGER, INTENT(IN)                      :: ism1
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: sw26
   CHARACTER (LEN=350), INTENT(OUT)         :: fracstring
!
   REAL(KIND=dp), ALLOCATABLE   :: scratch1(:),scratch2(:),scratch3(:),xscratch(:)
   REAL(KIND=dp)  :: aaa,bbb,ccc,eee,phase
   REAL(KIND=dp)  :: diffmin,fred,diff,ddd,q1,q2,rmedian1,rmedian2,rmedian3
!
   INTEGER :: iii,nnn,nloop
   INTEGER :: iloop,i,jjcount,jj
!
   ALLOCATE(xscratch(nmaxphase+10),scratch1(nmaxphase+10),  &
      scratch2(nmaxphase+10),scratch3(nmaxphase+10))
!
   aaa=1.0_dp
   bbb=1.0_dp
   ccc=1.0_dp
   eee=1.0_dp
   compfracs=0.0_dp
!
!   update December 10, 2019
!
   iii=icount-1
   nnn=2*iii
   phase=0.0_dp-dphase
   nloop=INT(((360.0_dp-dphase)-(180.0_dp+dphase))/dphase)
   DO  iloop=1,nnn
      phase=phase+dphase
      xscratch(iloop)=phase/360.0_dp
   END DO
!
   DO  i=1,8
!
!   UPDATE October 27, 2008
!
!   First, 'finish' the fraction curves
!
      iii=icount-1
      nnn=icount
      IF((ionephase == 0).AND.(ism1 >= 1).AND.(ABS(ecc) <= &
          EPSILON(ecc)))THEN
!
         nloop=0
         iloop=1
         phase=180.0_dp
         nloop=INT(((360.0_dp-dphase)-(180.0_dp+dphase))/dphase)
!
!              do 1 phase=180.0d0+dphase,360.0d0-dphase,dphase
!
         DO  iloop=1,nloop+1
            phase=phase+dphase
            nnn=nnn+1
            IF(i == 1)THEN
               fracs1(nnn,1)=fracs1(iii,1)
               fracs1(nnn,2)=fracs1(iii,2)
               fracs1(nnn,3)=fracs1(iii,3)
               fracs1(nnn,4)=fracs1(iii,4)
            END IF
            IF(i == 2)THEN
               fracs2(nnn,1)=fracs2(iii,1)
               fracs2(nnn,2)=fracs2(iii,2)
               fracs2(nnn,3)=fracs2(iii,3)
               fracs2(nnn,4)=fracs2(iii,4)
            END IF
            IF(i == 3)THEN
               fracs3(nnn,1)=fracs3(iii,1)
               fracs3(nnn,2)=fracs3(iii,2)
               fracs3(nnn,3)=fracs3(iii,3)
               fracs3(nnn,4)=fracs3(iii,4)
            END IF
            IF(i == 4)THEN
               fracs4(nnn,1)=fracs4(iii,1)
               fracs4(nnn,2)=fracs4(iii,2)
               fracs4(nnn,3)=fracs4(iii,3)
               fracs4(nnn,4)=fracs4(iii,4)
            END IF
            IF(i == 5)THEN
               fracs5(nnn,1)=fracs5(iii,1)
               fracs5(nnn,2)=fracs5(iii,2)
               fracs5(nnn,3)=fracs5(iii,3)
               fracs5(nnn,4)=fracs5(iii,4)
            END IF
            IF(i == 6)THEN
               fracs6(nnn,1)=fracs6(iii,1)
               fracs6(nnn,2)=fracs6(iii,2)
               fracs6(nnn,3)=fracs6(iii,3)
               fracs6(nnn,4)=fracs6(iii,4)
            END IF
            IF(i == 7)THEN
               fracs7(nnn,1)=fracs7(iii,1)
               fracs7(nnn,2)=fracs7(iii,2)
               fracs7(nnn,3)=fracs7(iii,3)
               fracs7(nnn,4)=fracs7(iii,4)
            END IF
            IF(i == 8)THEN
               fracs8(nnn,1)=fracs8(iii,1)
               fracs8(nnn,2)=fracs8(iii,2)
               fracs8(nnn,3)=fracs8(iii,3)
               fracs8(nnn,4)=fracs8(iii,4)
            END IF
            iii=iii-1
         END DO
      END IF
!
!  UPDATE October 27, 2008
!
!  If the variable sw26 is positive, then reference the disk fraction at
!  sw26.   Otherwise, take the median over the whole orbit.
!
      jjcount=0
      IF(sw26 <= 0.0_dp)THEN
         DO  jj=1,nnn
            IF(i == 1)THEN
               IF(fracs1(jj,1) >= 0.0_dp)THEN
                  jjcount=jjcount+1
                  aaa=fracs1(jj,1)
                  bbb=fracs1(jj,2)
                  ccc=fracs1(jj,3)
                  eee=fracs1(jj,4)
               END IF
            END IF
            IF(i == 2)THEN
               IF(fracs2(jj,1) >= 0.0_dp)THEN
                  jjcount=jjcount+1
                  aaa=fracs2(jj,1)
                  bbb=fracs2(jj,2)
                  ccc=fracs2(jj,3)
                  eee=fracs2(jj,4)
               END IF
            END IF
            IF(i == 3)THEN
               IF(fracs3(jj,1) >= 0.0_dp)THEN
                  jjcount=jjcount+1
                  aaa=fracs3(jj,1)
                  bbb=fracs3(jj,2)
                  ccc=fracs3(jj,3)
                  eee=fracs3(jj,4)
               END IF
            END IF
            IF(i == 4)THEN
               IF(fracs4(jj,1) >= 0.0_dp)THEN
                  jjcount=jjcount+1
                  aaa=fracs4(jj,1)
                  bbb=fracs4(jj,2)
                  ccc=fracs4(jj,3)
                  eee=fracs4(jj,4)
               END IF
            END IF
            IF(i == 5)THEN
               IF(fracs5(jj,1) >= 0.0_dp)THEN
                  jjcount=jjcount+1
                  aaa=fracs5(jj,1)
                  bbb=fracs5(jj,2)
                  ccc=fracs5(jj,3)
                  eee=fracs5(jj,4)
               END IF
            END IF
            IF(i == 6)THEN
               IF(fracs6(jj,1) >= 0.0_dp)THEN
                  jjcount=jjcount+1
                  aaa=fracs6(jj,1)
                  bbb=fracs6(jj,2)
                  ccc=fracs6(jj,3)
                  eee=fracs6(jj,4)
               END IF
            END IF
            IF(i == 7)THEN
               IF(fracs7(jj,1) >= 0.0_dp)THEN
                  jjcount=jjcount+1
                  aaa=fracs7(jj,1)
                  bbb=fracs7(jj,2)
                  ccc=fracs7(jj,3)
                  eee=fracs7(jj,4)
               END IF
            END IF
            IF(i == 8)THEN
               IF(fracs8(jj,1) >= 0.0_dp)THEN
                  jjcount=jjcount+1
                  aaa=fracs8(jj,1)
                  bbb=fracs8(jj,2)
                  ccc=fracs8(jj,3)
                  eee=fracs8(jj,4)
               END IF
            END IF
            ddd=aaa+bbb+ccc+eee
            IF(ABS(aaa) <= EPSILON(aaa))THEN
               scratch1(jjcount)=0.0_dp
               scratch3(jjcount)=0.0_dp
            ELSE
               scratch1(jjcount)=bbb/aaa
               scratch3(jjcount)=eee/aaa
            END IF
            IF(ABS(ddd) <= EPSILON(ddd))THEN
               scratch2(jjcount)=0.0_dp
            ELSE
               scratch2(jjcount)=ccc/ddd
            END IF
         END DO
!
         IF(icount <= 2)THEN
            compfracs(i,1)=0.0_dp
            compfracs(i,2)=0.0_dp
            compfracs(i,3)=0.0_dp
            CYCLE
         END IF
!
         IF(jjcount > 1)CALL sort3(jjcount,scratch1,scratch2,scratch3)
!
         q1=REAL(jjcount/2,KIND=dp)
         q2=REAL(jjcount,KIND=dp)/2.0_dp
         IF(ABS(q1-q2) <= EPSILON(q1))THEN
            rmedian1=(scratch1(jjcount/2)+scratch1(jjcount/2+1))/2.0_dp
         ELSE
            rmedian1=scratch1(jjcount/2+1)
         END IF
!
         IF(jjcount > 1)CALL sort3(jjcount,scratch2,scratch1,scratch3)
!
         q1=REAL(jjcount/2,KIND=dp)
         q2=REAL(jjcount,KIND=dp)/2.0_dp
         IF(ABS(q1-q2) <= EPSILON(q1))THEN
            rmedian2=(scratch2(jjcount/2)+scratch2(jjcount/2+1))/2.0_dp
         ELSE
            rmedian2=scratch2(jjcount/2+1)
         END IF
!
         IF(jjcount > 1)CALL sort3(jjcount,scratch3,scratch1,scratch2)
!
         q1=REAL(jjcount/2,KIND=dp)
         q2=REAL(jjcount,KIND=dp)/2.0_dp
         IF(ABS(q1-q2) <= EPSILON(q1))THEN
            rmedian3=(scratch3(jjcount/2)+scratch3(jjcount/2+1))/2.0_dp
         ELSE
            rmedian3=scratch3(jjcount/2+1)
         END IF
!
         IF(rmedian1 < 0.0_dp)rmedian1=0.0_dp
         IF(rmedian2 < 0.0_dp)rmedian2=0.0_dp
         IF(rmedian3 < 0.0_dp)rmedian3=0.0_dp
!
         compfracs(i,1)=rmedian1
         compfracs(i,2)=rmedian2
         compfracs(i,3)=rmedian3
      ELSE
         diffmin=1.0E+44_dp
         jjcount=0
         DO  jj=1,nnn
            fred=MOD(xscratch(jj)+eshift+pshift,1.0_dp)
            IF(fred < 0.0_dp)fred=fred+1.0_dp
            IF(fred > 1.0_dp)fred=fred-1.0_dp
            diff=ABS(fred-sw26)
            IF(diff <= diffmin)THEN
               diffmin=diff
!
               IF(i == 1)THEN
                  IF(fracs1(jj,1) >= 0.0_dp)THEN
                     jjcount=jjcount+1
                     aaa=fracs1(jj,1)
                     bbb=fracs1(jj,2)
                     ccc=fracs1(jj,3)
                     eee=fracs1(jj,4)
                  END IF
               END IF
               IF(i == 2)THEN
                  IF(fracs2(jj,1) >= 0.0_dp)THEN
                     jjcount=jjcount+1
                     aaa=fracs2(jj,1)
                     bbb=fracs2(jj,2)
                     ccc=fracs2(jj,3)
                     eee=fracs2(jj,4)
                  END IF
               END IF
               IF(i == 3)THEN
                  IF(fracs3(jj,1) >= 0.0_dp)THEN
                     jjcount=jjcount+1
                     aaa=fracs3(jj,1)
                     bbb=fracs3(jj,2)
                     ccc=fracs3(jj,3)
                     eee=fracs3(jj,4)
                  END IF
               END IF
               IF(i == 4)THEN
                  IF(fracs4(jj,1) >= 0.0_dp)THEN
                     jjcount=jjcount+1
                     aaa=fracs4(jj,1)
                     bbb=fracs4(jj,2)
                     ccc=fracs4(jj,3)
                     eee=fracs4(jj,4)
                  END IF
               END IF
               IF(i == 5)THEN
                  IF(fracs5(jj,1) >= 0.0_dp)THEN
                     jjcount=jjcount+1
                     aaa=fracs5(jj,1)
                     bbb=fracs5(jj,2)
                     ccc=fracs5(jj,3)
                     eee=fracs5(jj,4)
                  END IF
               END IF
               IF(i == 6)THEN
                  IF(fracs6(jj,1) >= 0.0_dp)THEN
                     jjcount=jjcount+1
                     aaa=fracs6(jj,1)
                     bbb=fracs6(jj,2)
                     ccc=fracs6(jj,3)
                     eee=fracs6(jj,4)
                  END IF
               END IF
               IF(i == 7)THEN
                  IF(fracs7(jj,1) >= 0.0_dp)THEN
                     jjcount=jjcount+1
                     aaa=fracs7(jj,1)
                     bbb=fracs7(jj,2)
                     ccc=fracs7(jj,3)
                     eee=fracs7(jj,4)
                  END IF
               END IF
               IF(i == 8)THEN
                  IF(fracs8(jj,1) >= 0.0_dp)THEN
                     jjcount=jjcount+1
                     aaa=fracs8(jj,1)
                     bbb=fracs8(jj,2)
                     ccc=fracs8(jj,3)
                     eee=fracs8(jj,4)
                  END IF
               END IF
!
               ddd=aaa+bbb+ccc+eee
               compfracs(i,1)=bbb/aaa
               IF(ABS(ddd) <= EPSILON(ddd))THEN
                  compfracs(i,2)=0.0_dp
               ELSE
                  compfracs(i,2)=ccc/ddd
               END IF
               IF(ABS(aaa) <= EPSILON(aaa))THEN
                  compfracs(i,3)=0.0_dp
               ELSE
                  compfracs(i,3)=eee/aaa
               END IF
            END IF
         END DO
      END IF
!
   END DO
!
   fracstring=''
   WRITE(fracstring,50)(compfracs(i,1),i=1,8),(compfracs(i,2),  &
      i=1,8),(compfracs(i,3),i=1,8)
!
50 FORMAT(24(1PE13.6,1X))
!
   DEALLOCATE(xscratch,scratch1,scratch2,scratch3)
!
   RETURN
!
END SUBROUTINE getfracs
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getfracstime(nmaxphase,icount,fracs1,fracs2,  &
   fracs3,fracs4,fracs5,fracs6,fracs7,fracs8,compfracs,sw26,  &
   fracstring)
!
!   October 10, 2007
!
!   This is a new routine that will return the luminosity ratios in
!   each bandpass.  compfracs(i,1) will have L_2/L_1, and
!   compfracs(i,2) will have L_disk/L_tot.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN)                      :: icount
   REAL(KIND=dp), INTENT(IN)                :: fracs1(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN)                :: fracs2(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN)                :: fracs3(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN)                :: fracs4(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN)                :: fracs5(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN)                :: fracs6(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN)                :: fracs7(nmaxphase,4)
   REAL(KIND=dp), INTENT(IN)                :: fracs8(nmaxphase,4)
   REAL(KIND=dp), INTENT(OUT)               :: compfracs(8,3)
   REAL(KIND=dp), INTENT(IN OUT)            :: sw26
   CHARACTER (LEN=350), INTENT(IN OUT)      :: fracstring
!
   REAL(KIND=dp), ALLOCATABLE :: scratch1(:),scratch2(:),scratch3(:)
   REAL(KIND=dp) aaa,rmedian1,rmedian2,rmedian3,bbb,ccc,eee,ddd,q1,q2
   REAL(KIND=dp) diffmin,fred,diff
!
   INTEGER :: nnn,i,jj
!
   ALLOCATE(scratch1(nmaxphase+10),scratch2(nmaxphase+10),  &
      scratch3(nmaxphase+10))
!
   nnn=icount
   aaa=1.0_dp
   bbb=1.0_dp
   ccc=1.0_dp
   eee=1.0_dp
   fred=0.5_dp
   DO  i=1,8
!
      IF(sw26 <= 0.0_dp)THEN
         DO  jj=1,nnn
            IF(i == 1)THEN
               aaa=fracs1(jj,1)
               bbb=fracs1(jj,2)
               ccc=fracs1(jj,3)
               eee=fracs1(jj,4)
            END IF
            IF(i == 2)THEN
               aaa=fracs2(jj,1)
               bbb=fracs2(jj,2)
               ccc=fracs2(jj,3)
               eee=fracs2(jj,4)
            END IF
            IF(i == 3)THEN
               aaa=fracs3(jj,1)
               bbb=fracs3(jj,2)
               ccc=fracs3(jj,3)
               eee=fracs3(jj,4)
            END IF
            IF(i == 4)THEN
               aaa=fracs4(jj,1)
               bbb=fracs4(jj,2)
               ccc=fracs4(jj,3)
               eee=fracs4(jj,4)
            END IF
            IF(i == 5)THEN
               aaa=fracs5(jj,1)
               bbb=fracs5(jj,2)
               ccc=fracs5(jj,3)
               eee=fracs5(jj,4)
            END IF
            IF(i == 6)THEN
               aaa=fracs6(jj,1)
               bbb=fracs6(jj,2)
               ccc=fracs6(jj,3)
               eee=fracs6(jj,4)
            END IF
            IF(i == 7)THEN
               aaa=fracs7(jj,1)
               bbb=fracs7(jj,2)
               ccc=fracs7(jj,3)
               eee=fracs7(jj,4)
            END IF
            IF(i == 8)THEN
               aaa=fracs8(jj,1)
               bbb=fracs8(jj,2)
               ccc=fracs8(jj,3)
               eee=fracs8(jj,4)
            END IF
            ddd=aaa+bbb+ccc+eee
            IF(ABS(aaa) <= EPSILON(aaa))THEN
               scratch1(jj)=0.0_dp
               scratch3(jj)=0.0_dp
            ELSE
               scratch1(jj)=bbb/aaa
               scratch3(jj)=eee/aaa
            END IF
            IF(ABS(ddd) <= EPSILON(ddd))THEN
               scratch2(jj)=0.0_dp
            ELSE
               scratch2(jj)=ccc/ddd
            END IF
         END DO
!
         IF(icount <= 2)THEN
            compfracs(i,1)=0.0_dp
            compfracs(i,2)=0.0_dp
            compfracs(i,3)=0.0_dp
            CYCLE
         END IF
!
         IF(nnn > 1)CALL sort3(nnn,scratch1,scratch2,scratch3)
!
         q1=REAL(nnn/2,KIND=dp)
         q2=REAL(nnn,KIND=dp)/2.0_dp
         IF(ABS(q1-q2) <= EPSILON(q1))THEN
            rmedian1=(scratch1(nnn/2)+scratch1(nnn/2+1))/2.0_dp
         ELSE
            rmedian1=scratch1(nnn/2+1)
         END IF
!
         IF(nnn > 1)CALL sort3(nnn,scratch2,scratch1,scratch3)
!
         q1=REAL(nnn/2,KIND=dp)
         q2=REAL(nnn,KIND=dp)/2.0_dp
         IF(ABS(q1-q2) <= EPSILON(q1))THEN
            rmedian2=(scratch2(nnn/2)+scratch2(nnn/2+1))/2.0_dp
         ELSE
            rmedian2=scratch2(nnn/2+1)
         END IF
!
         IF(nnn > 1)CALL sort3(nnn,scratch3,scratch1,scratch2)
!
         q1=REAL(nnn/2,KIND=dp)
         q2=REAL(nnn,KIND=dp)/2.0_dp
         IF(ABS(q1-q2) <= EPSILON(q1))THEN
            rmedian3=(scratch3(nnn/2)+scratch3(nnn/2+1))/2.0_dp
         ELSE
            rmedian3=scratch3(nnn/2+1)
         END IF
!
         IF(rmedian1 < 0.0_dp)rmedian1=0.0_dp
         IF(rmedian2 < 0.0_dp)rmedian2=0.0_dp
         IF(rmedian3 < 0.0_dp)rmedian3=0.0_dp
!
         compfracs(i,1)=rmedian1
         compfracs(i,2)=rmedian2
         compfracs(i,3)=rmedian3
      ELSE
         diffmin=1.0E+44_dp
         DO  jj=1,nnn
            IF(fred < 0.0_dp)fred=fred+1.0_dp
            IF(fred > 1.0_dp)fred=fred-1.0_dp
            diff=ABS(fred-sw26)
            IF(diff <= diffmin)THEN
               diffmin=diff
!
               IF(i == 1)THEN
                  aaa=fracs1(jj,1)
                  bbb=fracs1(jj,2)
                  ccc=fracs1(jj,3)
                  eee=fracs1(jj,4)
               END IF
               IF(i == 2)THEN
                  aaa=fracs2(jj,1)
                  bbb=fracs2(jj,2)
                  ccc=fracs2(jj,3)
                  eee=fracs2(jj,4)
               END IF
               IF(i == 3)THEN
                  aaa=fracs3(jj,1)
                  bbb=fracs3(jj,2)
                  ccc=fracs3(jj,3)
                  eee=fracs3(jj,4)
               END IF
               IF(i == 4)THEN
                  aaa=fracs4(jj,1)
                  bbb=fracs4(jj,2)
                  ccc=fracs4(jj,3)
                  eee=fracs4(jj,4)
               END IF
               IF(i == 5)THEN
                  aaa=fracs5(jj,1)
                  bbb=fracs5(jj,2)
                  ccc=fracs5(jj,3)
                  eee=fracs5(jj,4)
               END IF
               IF(i == 6)THEN
                  aaa=fracs6(jj,1)
                  bbb=fracs6(jj,2)
                  ccc=fracs6(jj,3)
                  eee=fracs6(jj,4)
               END IF
               IF(i == 7)THEN
                  aaa=fracs7(jj,1)
                  bbb=fracs7(jj,2)
                  ccc=fracs7(jj,3)
                  eee=fracs7(jj,4)
               END IF
               IF(i == 8)THEN
                  aaa=fracs8(jj,1)
                  bbb=fracs8(jj,2)
                  ccc=fracs8(jj,3)
                  eee=fracs8(jj,4)
               END IF
!
               ddd=aaa+bbb+ccc+eee
               compfracs(i,1)=bbb/aaa
               IF(ABS(ddd)  <= EPSILON(ddd))THEN
                  compfracs(i,2)=0.0_dp
               ELSE
                  compfracs(i,2)=ccc/ddd
               END IF
               IF(ABS(aaa) <= EPSILON(aaa))THEN
                  compfracs(i,3)=0.0_dp
               ELSE
                  compfracs(i,3)=eee/aaa
               END IF
            END IF
         END DO
      END IF
!
   END DO
!
   WRITE(fracstring,40)(compfracs(i,1),i=1,8),(compfracs(i,2),  &
      i=1,8),(compfracs(i,3),i=1,8)
!
40 FORMAT(24(1PE13.6,1X))
!
   DEALLOCATE(scratch1,scratch2,scratch3)
!
   RETURN
!
END SUBROUTINE getfracstime
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getgap(ngap,gaplow,gaphigh)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN OUT)                  :: ngap
   REAL(KIND=dp), INTENT(OUT)               :: gaplow(9999)
   REAL(KIND=dp), INTENT(OUT)               :: gaphigh(9999)
!
   INTEGER :: ios,i
!
!   Declare the variable bell to be character*1
!
   CHARACTER(LEN=1) :: bell
!
   bell=CHAR(7)
   ios=0
   OPEN(UNIT=1,FILE='ELCgap.inp',STATUS='old',ERR=20,IOSTAT=ios)
!
   DO  i=1,ngap
      READ(1,*,ERR=30,END=30)gaplow(i),gaphigh(i)
   END DO

   IF(ios == 0)THEN
      CLOSE(1)
      RETURN
   END IF
!
!   Come here if the input file ELCgap.inp does not exist.
!
20 WRITE(*,40)bell
   ngap=0
   RETURN
!
30 WRITE(*,50)bell
   ngap=0
   CLOSE(1)
   RETURN
!
40 FORMAT(a1,'Error:  File ELCgap.inp does not exist,',' setting'  &
      ,' Ngap=0')
50 FORMAT(a1,'Error:  Bad entry in ELCgap.inp, setting Ngap=0')
!
END SUBROUTINE getgap
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getgridbody3(kkk,nalph3,nbet3,tertperiod,tertt0,  &
   tertecos,tertesin,tertincl,tertomega,tertq,dwavex,dwavey,  &
   itconj,it1,it2,it3,it4,tertconj,tertratrad,hh,sw72,sw73,  &
   p2tconj,p2period,p2t0,p2ecos,p2esin,p2incl,p2omega,p2q,  &
   p2ratrad,p3tconj,p3period,p3t0,p3ecos,p3esin,p3incl,p3omega,  &
   p3q,p3ratrad,p4tconj,p4period,p4t0,p4ecos,p4esin,p4incl,  &
   p4omega,p4q,p4ratrad,p5tconj,p5period,p5t0,p5ecos,p5esin,  &
   p5incl,p5omega,p5q,p5ratrad,p6tconj,p6period,p6t0,p6ecos,  &
   p6esin,p6incl,p6omega,p6q,p6ratrad,p7tconj,p7period,p7t0,  &
   p7ecos,p7esin,p7incl,p7omega,p7q,p7ratrad,p8tconj,p8period,  &
   p8t0,p8ecos,p8esin,p8incl,p8omega,p8q,p8ratrad,nbody)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: kkk
   INTEGER, INTENT(OUT)                     :: nalph3
   INTEGER, INTENT(OUT)                     :: nbet3
   REAL(KIND=dp), INTENT(OUT)               :: tertperiod
   REAL(KIND=dp), INTENT(OUT)               :: tertt0
   REAL(KIND=dp), INTENT(OUT)               :: tertecos
   REAL(KIND=dp), INTENT(OUT)               :: tertesin
   REAL(KIND=dp), INTENT(OUT)               :: tertincl
   REAL(KIND=dp), INTENT(OUT)               :: tertomega
   REAL(KIND=dp), INTENT(OUT)               :: tertq
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   INTEGER, INTENT(OUT)                     :: itconj
   INTEGER, INTENT(OUT)                     :: it1
   INTEGER, INTENT(OUT)                     :: it2
   INTEGER, INTENT(OUT)                     :: it3
   INTEGER, INTENT(OUT)                     :: it4
   REAL(KIND=dp), INTENT(OUT)               :: tertconj
   REAL(KIND=dp), INTENT(OUT)               :: tertratrad
   REAL(KIND=dp), INTENT(OUT)               :: hh
   REAL(KIND=dp), INTENT(OUT)               :: sw72
   REAL(KIND=dp), INTENT(OUT)               :: sw73
   REAL(KIND=dp), INTENT(OUT)               :: p2tconj
   REAL(KIND=dp), INTENT(OUT)               :: p2period
   REAL(KIND=dp), INTENT(OUT)               :: p2t0
   REAL(KIND=dp), INTENT(OUT)               :: p2ecos
   REAL(KIND=dp), INTENT(OUT)               :: p2esin
   REAL(KIND=dp), INTENT(OUT)               :: p2incl
   REAL(KIND=dp), INTENT(OUT)               :: p2omega
   REAL(KIND=dp), INTENT(OUT)               :: p2q
   REAL(KIND=dp), INTENT(OUT)               :: p2ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p3tconj
   REAL(KIND=dp), INTENT(OUT)               :: p3period
   REAL(KIND=dp), INTENT(OUT)               :: p3t0
   REAL(KIND=dp), INTENT(OUT)               :: p3ecos
   REAL(KIND=dp), INTENT(OUT)               :: p3esin
   REAL(KIND=dp), INTENT(OUT)               :: p3incl
   REAL(KIND=dp), INTENT(OUT)               :: p3omega
   REAL(KIND=dp), INTENT(OUT)               :: p3q
   REAL(KIND=dp), INTENT(OUT)               :: p3ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p4tconj
   REAL(KIND=dp), INTENT(OUT)               :: p4period
   REAL(KIND=dp), INTENT(OUT)               :: p4t0
   REAL(KIND=dp), INTENT(OUT)               :: p4ecos
   REAL(KIND=dp), INTENT(OUT)               :: p4esin
   REAL(KIND=dp), INTENT(OUT)               :: p4incl
   REAL(KIND=dp), INTENT(OUT)               :: p4omega
   REAL(KIND=dp), INTENT(OUT)               :: p4q
   REAL(KIND=dp), INTENT(OUT)               :: p4ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p5tconj
   REAL(KIND=dp), INTENT(OUT)               :: p5period
   REAL(KIND=dp), INTENT(OUT)               :: p5t0
   REAL(KIND=dp), INTENT(OUT)               :: p5ecos
   REAL(KIND=dp), INTENT(OUT)               :: p5esin
   REAL(KIND=dp), INTENT(OUT)               :: p5incl
   REAL(KIND=dp), INTENT(OUT)               :: p5omega
   REAL(KIND=dp), INTENT(OUT)               :: p5q
   REAL(KIND=dp), INTENT(OUT)               :: p5ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p6tconj
   REAL(KIND=dp), INTENT(OUT)               :: p6period
   REAL(KIND=dp), INTENT(OUT)               :: p6t0
   REAL(KIND=dp), INTENT(OUT)               :: p6ecos
   REAL(KIND=dp), INTENT(OUT)               :: p6esin
   REAL(KIND=dp), INTENT(OUT)               :: p6incl
   REAL(KIND=dp), INTENT(OUT)               :: p6omega
   REAL(KIND=dp), INTENT(OUT)               :: p6q
   REAL(KIND=dp), INTENT(OUT)               :: p6ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p7tconj
   REAL(KIND=dp), INTENT(OUT)               :: p7period
   REAL(KIND=dp), INTENT(OUT)               :: p7t0
   REAL(KIND=dp), INTENT(OUT)               :: p7ecos
   REAL(KIND=dp), INTENT(OUT)               :: p7esin
   REAL(KIND=dp), INTENT(OUT)               :: p7incl
   REAL(KIND=dp), INTENT(OUT)               :: p7omega
   REAL(KIND=dp), INTENT(OUT)               :: p7q
   REAL(KIND=dp), INTENT(OUT)               :: p7ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p8tconj
   REAL(KIND=dp), INTENT(OUT)               :: p8period
   REAL(KIND=dp), INTENT(OUT)               :: p8t0
   REAL(KIND=dp), INTENT(OUT)               :: p8ecos
   REAL(KIND=dp), INTENT(OUT)               :: p8esin
   REAL(KIND=dp), INTENT(OUT)               :: p8incl
   REAL(KIND=dp), INTENT(OUT)               :: p8omega
   REAL(KIND=dp), INTENT(OUT)               :: p8q
   REAL(KIND=dp), INTENT(OUT)               :: p8ratrad
   INTEGER, INTENT(IN OUT)                  :: nbody
!
   INTEGER :: i,ios
!
!   Declare the variable bell to be character*1
!
   CHARACTER (LEN=1) :: bell
   CHARACTER (LEN=4) :: extension
!
   IF (kkk > 9999) THEN
      bell=CHAR(7)
      WRITE(*,70)bell
      STOP
   END IF
!
   IF (kkk < 10) WRITE(extension,30)kkk
   IF ((kkk >= 10).AND.(kkk < 100)) WRITE(extension,40)kkk
   IF ((kkk >= 100).AND.(kkk < 1000)) WRITE(extension,50)kkk
   IF (kkk >= 1000) WRITE (extension,60)kkk+1000
!
   ios=0
   OPEN(UNIT=1,FILE='ELCbody3.'//extension,STATUS='old',ERR=10,IOSTAT=ios)
!
   READ(1,*,END=20,ERR=20)nalph3
   READ(1,*,END=20,ERR=20)nbet3
   READ(1,*,END=20,ERR=20)itconj
   READ(1,*,END=20,ERR=20)it1
   READ(1,*,END=20,ERR=20)it2
   READ(1,*,END=20,ERR=20)it3
   READ(1,*,END=20,ERR=20)it4
   READ(1,*,END=20,ERR=20)tertconj
   READ(1,*,END=20,ERR=20)tertperiod
   READ(1,*,END=20,ERR=20)tertt0
   READ(1,*,END=20,ERR=20)tertecos
   READ(1,*,END=20,ERR=20)tertesin
   READ(1,*,END=20,ERR=20)tertincl
   READ(1,*,END=20,ERR=20)tertomega
   READ(1,*,END=20,ERR=20)tertq
!
!  Load the limb darkening parameters for body 3
!
   DO i=1,8
      READ(1,*,END=20,ERR=20)dwavex(i,3),dwavey(i,3)
   END DO
!
   READ(1,*,END=20,ERR=20)tertratrad
   READ(1,*,END=20,ERR=20)hh
   READ(1,*,END=20,ERR=20)sw72
   READ(1,*,END=20,ERR=20)sw73
!
!   body 4 parameters.  If Nbody < 4, then zero out
!
   READ(1,*)p2tconj
   READ(1,*)p2period
   READ(1,*)p2t0
   READ(1,*)p2ecos
   READ(1,*)p2esin
   READ(1,*)p2incl
   READ(1,*)p2omega
   READ(1,*)p2q
   READ(1,*)p2ratrad
   IF(nbody < 4)THEN
      p2tconj=0.0_dp
      p2period=0.0_dp
      p2t0=0.0_dp
      p2ecos=0.0_dp
      p2esin=0.0_dp
      p2incl=0.0_dp
      p2omega=0.0_dp
      p2q=0.0_dp
      p2ratrad=0.0_dp
   END IF
!
   READ(1,*)p3tconj
   READ(1,*)p3period
   READ(1,*)p3t0
   READ(1,*)p3ecos
   READ(1,*)p3esin
   READ(1,*)p3incl
   READ(1,*)p3omega
   READ(1,*)p3q
   READ(1,*)p3ratrad
   IF(nbody < 5)THEN
      p3tconj=0.0_dp
      p3period=0.0_dp
      p3t0=0.0_dp
      p3ecos=0.0_dp
      p3esin=0.0_dp
      p3incl=0.0_dp
      p3omega=0.0_dp
      p3q=0.0_dp
      p3ratrad=0.0_dp
   END IF
!
   READ(1,*)p4tconj
   READ(1,*)p4period
   READ(1,*)p4t0
   READ(1,*)p4ecos
   READ(1,*)p4esin
   READ(1,*)p4incl
   READ(1,*)p4omega
   READ(1,*)p4q
   READ(1,*)p4ratrad
   IF(nbody < 6)THEN
      p4tconj=0.0_dp
      p4period=0.0_dp
      p4t0=0.0_dp
      p4ecos=0.0_dp
      p4esin=0.0_dp
      p4incl=0.0_dp
      p4omega=0.0_dp
      p4q=0.0_dp
      p4ratrad=0.0_dp
   END IF
!
   READ(1,*)p5tconj
   READ(1,*)p5period
   READ(1,*)p5t0
   READ(1,*)p5ecos
   READ(1,*)p5esin
   READ(1,*)p5incl
   READ(1,*)p5omega
   READ(1,*)p5q
   READ(1,*)p5ratrad
   IF(nbody < 7)THEN
      p5tconj=0.0_dp
      p5period=0.0_dp
      p5t0=0.0_dp
      p5ecos=0.0_dp
      p5esin=0.0_dp
      p5incl=0.0_dp
      p5omega=0.0_dp
      p5q=0.0_dp
      p5ratrad=0.0_dp
   END IF
!
   READ(1,*)p6tconj
   READ(1,*)p6period
   READ(1,*)p6t0
   READ(1,*)p6ecos
   READ(1,*)p6esin
   READ(1,*)p6incl
   READ(1,*)p6omega
   READ(1,*)p6q
   READ(1,*)p6ratrad
   IF(nbody < 8)THEN
      p6tconj=0.0_dp
      p6period=0.0_dp
      p6t0=0.0_dp
      p6ecos=0.0_dp
      p6esin=0.0_dp
      p6incl=0.0_dp
      p6omega=0.0_dp
      p6q=0.0_dp
      p6ratrad=0.0_dp
   END IF
!
   READ(1,*)p7tconj
   READ(1,*)p7period
   READ(1,*)p7t0
   READ(1,*)p7ecos
   READ(1,*)p7esin
   READ(1,*)p7incl
   READ(1,*)p7omega
   READ(1,*)p7q
   READ(1,*)p7ratrad
   IF(nbody < 9)THEN
      p7tconj=0.0_dp
      p7period=0.0_dp
      p7t0=0.0_dp
      p7ecos=0.0_dp
      p7esin=0.0_dp
      p7incl=0.0_dp
      p7omega=0.0_dp
      p7q=0.0_dp
      p7ratrad=0.0_dp
   END IF
!
   READ(1,*)p8tconj
   READ(1,*)p8period
   READ(1,*)p8t0
   READ(1,*)p8ecos
   READ(1,*)p8esin
   READ(1,*)p8incl
   READ(1,*)p8omega
   READ(1,*)p8q
   READ(1,*)p8ratrad
   IF(nbody < 10)THEN
      p8tconj=0.0_dp
      p8period=0.0_dp
      p8t0=0.0_dp
      p8ecos=0.0_dp
      p8esin=0.0_dp
      p8incl=0.0_dp
      p8omega=0.0_dp
      p8q=0.0_dp
      p8ratrad=0.0_dp
   END IF
!
!  Load the limb darkening parameters for body 4
!
   DO i=1,8
      READ(1,*,END=20,ERR=20)dwavex(i,4),dwavey(i,4)
   END DO
!
!  Load the limb darkening parameters for body 5
!
   DO i=1,8
      READ(1,*,END=20,ERR=20)dwavex(i,5),dwavey(i,5)
   END DO
!
   IF(ios == 0)THEN
      CLOSE(1)
      RETURN
   END IF
!
!   Come here if the input file ELCbody3.???? does not exist.
!
10 IF(ios > 0)THEN
      bell=CHAR(7)
      WRITE(*,80)bell,kkk
      STOP
   END IF
!
20 bell=CHAR(7)
   WRITE(*,90)bell,kkk
   CLOSE(1)
!
   RETURN
!
30 FORMAT('100',i1)
40 FORMAT('10',i2)
50 FORMAT('1',i3)
60 FORMAT(i4)
70 FORMAT(a1,'ielete is too large')
80 FORMAT(a1,'Error:  File ELCbody3.???? does not exist for ',  &
      'index ',i4)
90 FORMAT(a1,'Error:  Bad entry in ELCbody3.???? for index ',i4)
!
END SUBROUTINE getgridbody3
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getgridinput(kkk,nalph1,nbet1,nalph2,nbet2,fill1,  &
   fill2,omega1,omega2,dphase,q,finc,teff1,teff2,tgrav1,tgrav2,  &
   betarim,rinner,router,tdisk,xi,ntheta,nradius,alb1,alb2,nref,  &
   rlx,period,fm,separ,gamma,t3,g3,sa3,density,sw1,sw2,sw3,t0,  &
   idraw,iecheck,iidint,iatm,ism1,icnu,icnb,icnv,icnr,icni,icnj,  &
   icnh,icnk,irvfilt,isw1,isw2,isw3,isw4,ilaw,wave,dbolx,dboly,  &
   dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,sw8,sw9,ikeep,  &
   isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,spot2parm,  &
   spotdparm,primmass,primk,primrad,ratrad,frac1,frac2,ecosw,  &
   temprat,idark1,idark2,isw12,isw13,isw21,isw22,isw23,isw24,  &
   bigi,bigbeta,sw23,sw24,powercoeff,sw25,sw26,sw27,sw28,sw29,  &
   sw30,contam,tconj,beam1,beam2,isw25,isw26,isw27,isw28,isw29,  &
   isw30,isw31,isw32,isw33,isw34,ocose,osine,omegadot,contams0,  &
   contams1,contams2,contams3,sw47,sw48,sw49,sw80,sw81,sw82,  &
   sw83,sw84,sw85,sw86,sw87,sw88,sw89,isw80,isw81,isw82,isw83,  &
   isw84,isw85,isw86,isw87,isw88,isw89,sdarkint1,sdarkint2,  &
   sdarkint3,sdarkint4,sdarkint5)
!
!   UPDATE December 20, 2012
!
!   This routine used by geneticELC.  If ieliete > 1, then open ELC.1001
!   ELC.1002, ... ELC.100(ielete-1)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: kkk
   INTEGER, INTENT(OUT)                     :: nalph1
   INTEGER, INTENT(OUT)                     :: nbet1
   INTEGER, INTENT(OUT)                     :: nalph2
   INTEGER, INTENT(OUT)                     :: nbet2
   REAL(KIND=dp), INTENT(OUT)               :: fill1
   REAL(KIND=dp), INTENT(OUT)               :: fill2
   REAL(KIND=dp), INTENT(OUT)               :: omega1
   REAL(KIND=dp), INTENT(OUT)               :: omega2
   REAL(KIND=dp), INTENT(OUT)               :: dphase
   REAL(KIND=dp), INTENT(OUT)               :: q
   REAL(KIND=dp), INTENT(OUT)               :: finc
   REAL(KIND=dp), INTENT(OUT)               :: teff1
   REAL(KIND=dp), INTENT(OUT)               :: teff2
   REAL(KIND=dp), INTENT(OUT)               :: tgrav1
   REAL(KIND=dp), INTENT(OUT)               :: tgrav2
   REAL(KIND=dp), INTENT(OUT)               :: betarim
   REAL(KIND=dp), INTENT(OUT)               :: rinner
   REAL(KIND=dp), INTENT(OUT)               :: router
   REAL(KIND=dp), INTENT(OUT)               :: tdisk
   REAL(KIND=dp), INTENT(OUT)               :: xi
   INTEGER, INTENT(OUT)                     :: ntheta
   INTEGER, INTENT(OUT)                     :: nradius
   REAL(KIND=dp), INTENT(OUT)               :: alb1
   REAL(KIND=dp), INTENT(OUT)               :: alb2
   INTEGER, INTENT(OUT)                     :: nref
   REAL(KIND=dp), INTENT(OUT)               :: rlx
   REAL(KIND=dp), INTENT(OUT)               :: period
   REAL(KIND=dp), INTENT(OUT)               :: fm
   REAL(KIND=dp), INTENT(OUT)               :: separ
   REAL(KIND=dp), INTENT(OUT)               :: gamma
   REAL(KIND=dp), INTENT(OUT)               :: t3
   REAL(KIND=dp), INTENT(OUT)               :: g3
   REAL(KIND=dp), INTENT(OUT)               :: sa3
   REAL(KIND=dp), INTENT(OUT)               :: density
   REAL(KIND=dp), INTENT(OUT)               :: sw1
   REAL(KIND=dp), INTENT(OUT)               :: sw2
   REAL(KIND=dp), INTENT(OUT)               :: sw3
   REAL(KIND=dp), INTENT(OUT)               :: t0
   INTEGER, INTENT(OUT)                     :: idraw
   INTEGER, INTENT(OUT)                     :: iecheck
   INTEGER, INTENT(OUT)                     :: iidint
   INTEGER, INTENT(OUT)                     :: iatm
   INTEGER, INTENT(OUT)                     :: ism1
   INTEGER, INTENT(OUT)                     :: icnu
   INTEGER, INTENT(OUT)                     :: icnb
   INTEGER, INTENT(OUT)                     :: icnv
   INTEGER, INTENT(OUT)                     :: icnr
   INTEGER, INTENT(OUT)                     :: icni
   INTEGER, INTENT(OUT)                     :: icnj
   INTEGER, INTENT(OUT)                     :: icnh
   INTEGER, INTENT(OUT)                     :: icnk
   INTEGER, INTENT(OUT)                     :: irvfilt
   INTEGER, INTENT(OUT)                     :: isw1
   INTEGER, INTENT(OUT)                     :: isw2
   INTEGER, INTENT(OUT)                     :: isw3
   INTEGER, INTENT(OUT)                     :: isw4
   INTEGER, INTENT(OUT)                     :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: wave(8)
   REAL(KIND=dp), INTENT(OUT)               :: dbolx(8,2)
   REAL(KIND=dp), INTENT(OUT)               :: dboly(8,2)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: ecc
   REAL(KIND=dp), INTENT(OUT)               :: argper
   REAL(KIND=dp), INTENT(OUT)               :: pshift
   REAL(KIND=dp), INTENT(OUT)               :: sw5
   REAL(KIND=dp), INTENT(OUT)               :: sw6
   REAL(KIND=dp), INTENT(OUT)               :: sw7
   REAL(KIND=dp), INTENT(OUT)               :: sw8
   REAL(KIND=dp), INTENT(OUT)               :: sw9
   INTEGER, INTENT(OUT)                     :: ikeep
   INTEGER, INTENT(OUT)                     :: isynch
   INTEGER, INTENT(OUT)                     :: isw5
   INTEGER, INTENT(OUT)                     :: isw6
   INTEGER, INTENT(OUT)                     :: isw7
   INTEGER, INTENT(OUT)                     :: isw8
   INTEGER, INTENT(OUT)                     :: isw9
   REAL(KIND=dp), INTENT(OUT)               :: spot1parm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: spot2parm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: spotdparm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: primmass
   REAL(KIND=dp), INTENT(OUT)               :: primk
   REAL(KIND=dp), INTENT(OUT)               :: primrad
   REAL(KIND=dp), INTENT(OUT)               :: ratrad
   REAL(KIND=dp), INTENT(OUT)               :: frac1
   REAL(KIND=dp), INTENT(OUT)               :: frac2
   REAL(KIND=dp), INTENT(OUT)               :: ecosw
   REAL(KIND=dp), INTENT(OUT)               :: temprat
   INTEGER, INTENT(OUT)                     :: idark1
   INTEGER, INTENT(OUT)                     :: idark2
   INTEGER, INTENT(OUT)                     :: isw12
   INTEGER, INTENT(OUT)                     :: isw13
   INTEGER, INTENT(OUT)                     :: isw21
   INTEGER, INTENT(OUT)                     :: isw22
   INTEGER, INTENT(OUT)                     :: isw23
   INTEGER, INTENT(OUT)                     :: isw24
   REAL(KIND=dp), INTENT(OUT)               :: bigi
   REAL(KIND=dp), INTENT(OUT)               :: bigbeta
   REAL(KIND=dp), INTENT(OUT)               :: sw23
   REAL(KIND=dp), INTENT(OUT)               :: sw24
   REAL(KIND=dp), INTENT(OUT)               :: powercoeff(8,9)
   REAL(KIND=dp), INTENT(OUT)               :: sw25
   REAL(KIND=dp), INTENT(OUT)               :: sw26
   REAL(KIND=dp), INTENT(OUT)               :: sw27
   REAL(KIND=dp), INTENT(OUT)               :: sw28
   REAL(KIND=dp), INTENT(OUT)               :: sw29
   REAL(KIND=dp), INTENT(OUT)               :: sw30
   REAL(KIND=dp), INTENT(OUT)               :: contam
   REAL(KIND=dp), INTENT(OUT)               :: tconj
   REAL(KIND=dp), INTENT(OUT)               :: beam1
   REAL(KIND=dp), INTENT(OUT)               :: beam2
   INTEGER, INTENT(OUT)                     :: isw25
   INTEGER, INTENT(OUT)                     :: isw26
   INTEGER, INTENT(OUT)                     :: isw27
   INTEGER, INTENT(OUT)                     :: isw28
   INTEGER, INTENT(OUT)                     :: isw29
   INTEGER, INTENT(OUT)                     :: isw30
   INTEGER, INTENT(OUT)                     :: isw31
   INTEGER, INTENT(OUT)                     :: isw32
   INTEGER, INTENT(OUT)                     :: isw33
   INTEGER, INTENT(OUT)                     :: isw34
   REAL(KIND=dp), INTENT(OUT)               :: ocose
   REAL(KIND=dp), INTENT(OUT)               :: osine
   REAL(KIND=dp), INTENT(OUT)               :: omegadot
   REAL(KIND=dp), INTENT(OUT)               :: contams0
   REAL(KIND=dp), INTENT(OUT)               :: contams1
   REAL(KIND=dp), INTENT(OUT)               :: contams2
   REAL(KIND=dp), INTENT(OUT)               :: contams3
   REAL(KIND=dp), INTENT(OUT)               :: sw47
   REAL(KIND=dp), INTENT(OUT)               :: sw48
   REAL(KIND=dp), INTENT(OUT)               :: sw49
   REAL(KIND=dp), INTENT(OUT)               :: sw80
   REAL(KIND=dp), INTENT(OUT)               :: sw81
   REAL(KIND=dp), INTENT(OUT)               :: sw82
   REAL(KIND=dp), INTENT(OUT)               :: sw83
   REAL(KIND=dp), INTENT(OUT)               :: sw84
   REAL(KIND=dp), INTENT(OUT)               :: sw85
   REAL(KIND=dp), INTENT(OUT)               :: sw86
   REAL(KIND=dp), INTENT(OUT)               :: sw87
   REAL(KIND=dp), INTENT(OUT)               :: sw88
   REAL(KIND=dp), INTENT(OUT)               :: sw89
   INTEGER, INTENT(OUT)                     :: isw80
   INTEGER, INTENT(OUT)                     :: isw81
   INTEGER, INTENT(OUT)                     :: isw82
   INTEGER, INTENT(OUT)                     :: isw83
   INTEGER, INTENT(OUT)                     :: isw84
   INTEGER, INTENT(OUT)                     :: isw85
   INTEGER, INTENT(OUT)                     :: isw86
   INTEGER, INTENT(OUT)                     :: isw87
   INTEGER, INTENT(OUT)                     :: isw88
   INTEGER, INTENT(OUT)                     :: isw89
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint1(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint2(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint3(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint4(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint5(8)
!
   INTEGER :: ios,i,k,jj
!
   CHARACTER (LEN=4) :: extension
   CHARACTER (LEN=1) :: bell
!
   IF(kkk > 9999)THEN
      bell=CHAR(7)
      WRITE(*,80)bell
      STOP
   END IF
!
   IF(kkk < 10)WRITE(extension,40)kkk
   IF((kkk >= 10).AND.(kkk < 100))WRITE(extension,50)kkk
   IF((kkk >= 100).AND.(kkk < 1000))WRITE(extension,60)kkk
   IF(kkk >= 1000)WRITE(extension,70)kkk
!
   IF(kkk < 8999)WRITE(extension,70)kkk+1000
!
   ios=0
   OPEN(UNIT=1,FILE='ELC.'//extension,STATUS='old',ERR=20,IOSTAT= ios)
!
   READ(1,*,END=30,ERR=30)nalph1
   READ(1,*,END=30,ERR=30)nbet1
   READ(1,*,END=30,ERR=30)nalph2
   READ(1,*,END=30,ERR=30)nbet2
   READ(1,*,END=30,ERR=30)fill1
   READ(1,*,END=30,ERR=30)fill2
   READ(1,*,END=30,ERR=30)omega1
   READ(1,*,END=30,ERR=30)omega2
   READ(1,*,END=30,ERR=30)dphase
   READ(1,*,END=30,ERR=30)q
   READ(1,*,END=30,ERR=30)finc
   READ(1,*,END=30,ERR=30)teff1
   READ(1,*,END=30,ERR=30)teff2
   READ(1,*,END=30,ERR=30)tgrav1
   READ(1,*,END=30,ERR=30)tgrav2
   READ(1,*,END=30,ERR=30)betarim
   READ(1,*,END=30,ERR=30)rinner
   READ(1,*,END=30,ERR=30)router
   READ(1,*,END=30,ERR=30)tdisk
   READ(1,*,END=30,ERR=30)xi
   READ(1,*,END=30,ERR=30)ntheta
   READ(1,*,END=30,ERR=30)nradius
   READ(1,*,END=30,ERR=30)alb1
   READ(1,*,END=30,ERR=30)alb2
   READ(1,*,END=30,ERR=30)nref
   READ(1,*,END=30,ERR=30)rlx
   READ(1,*,END=30,ERR=30)period
   READ(1,*,END=30,ERR=30)fm
   READ(1,*,END=30,ERR=30)separ
   READ(1,*,END=30,ERR=30)gamma
   READ(1,*,END=30,ERR=30)t3
   READ(1,*,END=30,ERR=30)g3
   READ(1,*,END=30,ERR=30)sa3
   READ(1,*,END=30,ERR=30)density
   READ(1,*,END=30,ERR=30)sw1
   READ(1,*,END=30,ERR=30)sw2
   READ(1,*,END=30,ERR=30)sw3
   READ(1,*,END=30,ERR=30)t0
   READ(1,*,END=30,ERR=30)idraw
   READ(1,*,END=30,ERR=30)iecheck
   READ(1,*,END=30,ERR=30)iidint
   READ(1,*,END=30,ERR=30)iatm
   READ(1,*,END=30,ERR=30)ism1
   READ(1,*,END=30,ERR=30)icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk
   READ(1,*,END=30,ERR=30)irvfilt
   READ(1,*,END=30,ERR=30)isw1
   READ(1,*,END=30,ERR=30)isw2
   READ(1,*,END=30,ERR=30)isw3
   READ(1,*,END=30,ERR=30)isw4
   READ(1,*,END=30,ERR=30)ilaw
   DO  i=1,8
      READ(1,*,END=30,ERR=30)wave(i),dbolx(i,1),dboly(i,1),  &
         dbolx(i,2),dboly(i,2),dwavex(i,1),dwavey(i,1),dwavex(i,2),dwavey(i,2)
   END DO
   READ(1,*,END=30,ERR=30)ecc
   READ(1,*,END=30,ERR=30)argper
   READ(1,*,END=30,ERR=30)pshift
   READ(1,*,END=30,ERR=30)sw5
   READ(1,*,END=30,ERR=30)sw6
   READ(1,*,END=30,ERR=30)sw7
   READ(1,*,END=30,ERR=30)sw8
   READ(1,*,END=30,ERR=30)sw9
   READ(1,*,END=30,ERR=30)ikeep
   READ(1,*,END=30,ERR=30)isynch
   READ(1,*,END=30,ERR=30)isw5
   READ(1,*,END=30,ERR=30)isw6
   READ(1,*,END=30,ERR=30)isw7
   READ(1,*,END=30,ERR=30)isw8
   READ(1,*,END=30,ERR=30)isw9
   ios=0
   READ(1,*,END=30,ERR=30)spot1parm(1,1)
   READ(1,*,END=30,ERR=30)spot1parm(1,2)
   READ(1,*,END=30,ERR=30)spot1parm(1,3)
   READ(1,*,END=30,ERR=30)spot1parm(1,4)
   READ(1,*,END=30,ERR=30)spot1parm(2,1)
   READ(1,*,END=30,ERR=30)spot1parm(2,2)
   READ(1,*,END=30,ERR=30)spot1parm(2,3)
   READ(1,*,END=30,ERR=30)spot1parm(2,4)
   READ(1,*,END=30,ERR=30)spot2parm(1,1)
   READ(1,*,END=30,ERR=30)spot2parm(1,2)
   READ(1,*,END=30,ERR=30)spot2parm(1,3)
   READ(1,*,END=30,ERR=30)spot2parm(1,4)
   READ(1,*,END=30,ERR=30)spot2parm(2,1)
   READ(1,*,END=30,ERR=30)spot2parm(2,2)
   READ(1,*,END=30,ERR=30)spot2parm(2,3)
   READ(1,*,END=30,ERR=30)spot2parm(2,4)
   READ(1,*,END=30,ERR=30)spotdparm(1,1)
   READ(1,*,END=30,ERR=30)spotdparm(1,2)
   READ(1,*,END=30,ERR=30)spotdparm(1,3)
   READ(1,*,END=30,ERR=30)spotdparm(1,4)
   READ(1,*,END=30,ERR=30)spotdparm(2,1)
   READ(1,*,END=30,ERR=30)spotdparm(2,2)
   READ(1,*,END=30,ERR=30)spotdparm(2,3)
   READ(1,*,END=30,ERR=30)spotdparm(2,4)
   READ(1,*,END=30,ERR=30)primmass
   READ(1,*,END=30,ERR=30)primk
   READ(1,*,END=30,ERR=30)primrad
   READ(1,*,END=30,ERR=30)ratrad
   READ(1,*,END=30,ERR=30)frac1
   READ(1,*,END=30,ERR=30)frac2
   READ(1,*,END=30,ERR=30)ecosw
   READ(1,*,END=30,ERR=30)temprat
   READ(1,*,END=30,ERR=30)idark1
   READ(1,*,END=30,ERR=30)idark2
   READ(1,*,END=30,ERR=30)isw12
   READ(1,*,END=30,ERR=30)isw13
   READ(1,*,END=30,ERR=30)isw21
   READ(1,*,END=30,ERR=30)isw22
   READ(1,*,END=30,ERR=30)isw23
   READ(1,*,END=30,ERR=30)isw24
   READ(1,*,END=30,ERR=30)(powercoeff(1,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(2,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(3,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(4,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(5,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(6,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(7,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(8,k),k=1,9)
   READ(1,*,END=30,ERR=30)bigi
   READ(1,*,END=30,ERR=30)bigbeta
   READ(1,*,END=30,ERR=30)sw23
   READ(1,*,END=30,ERR=30)sw24
   READ(1,*,END=30,ERR=30)sw25
   READ(1,*,END=30,ERR=30)sw26
   READ(1,*,END=30,ERR=30)sw27
   READ(1,*,END=30,ERR=30)sw28
   READ(1,*,END=30,ERR=30)sw29
   READ(1,*,END=30,ERR=30)sw30
   READ(1,*,END=30,ERR=30)contam
   READ(1,*,END=30,ERR=30)tconj
   READ(1,*,END=30,ERR=30)beam1
   READ(1,*,END=30,ERR=30)beam2
   READ(1,*,END=30,ERR=30)isw25
   READ(1,*,END=30,ERR=30)isw26
   READ(1,*,END=30,ERR=30)isw27
   READ(1,*,END=30,ERR=30)isw28
   READ(1,*,END=30,ERR=30)isw29
   READ(1,*,END=30,ERR=30)isw30
   READ(1,*,END=30,ERR=30)isw31
   READ(1,*,END=30,ERR=30)isw32
   READ(1,*,END=30,ERR=30)isw33
   READ(1,*,END=30,ERR=30)isw34
   READ(1,*,END=30,ERR=30)ocose
   READ(1,*,END=30,ERR=30)osine
   READ(1,*,END=30,ERR=30)omegadot
   READ(1,*,END=30,ERR=30)contams0
   READ(1,*,END=30,ERR=30)contams1
   READ(1,*,END=30,ERR=30)contams2
   READ(1,*,END=30,ERR=30)contams3
   READ(1,*,END=30,ERR=30)sw47
   READ(1,*,END=30,ERR=30)sw48
   READ(1,*,END=30,ERR=30)sw49
   READ(1,*,END=30,ERR=30)sw80
   READ(1,*,END=30,ERR=30)sw81
   READ(1,*,END=30,ERR=30)sw82
   READ(1,*,END=30,ERR=30)sw83
   READ(1,*,END=30,ERR=30)sw84
   READ(1,*,END=30,ERR=30)sw85
   READ(1,*,END=30,ERR=30)sw86
   READ(1,*,END=30,ERR=30)sw87
   READ(1,*,END=30,ERR=30)sw88
   READ(1,*,END=30,ERR=30)sw89
   READ(1,*,END=30,ERR=30)isw80
   READ(1,*,END=30,ERR=30)isw81
   READ(1,*,END=30,ERR=30)isw82
   READ(1,*,END=30,ERR=30)isw83
   READ(1,*,END=30,ERR=30)isw84
   READ(1,*,END=30,ERR=30)isw85
   READ(1,*,END=30,ERR=30)isw86
   READ(1,*,END=30,ERR=30)isw87
   READ(1,*,END=30,ERR=30)isw88
   READ(1,*,END=30,ERR=30)isw89
   READ(1,*,END=30,ERR=30)(sdarkint1(jj),jj=1,8)
   READ(1,*,END=30,ERR=30)(sdarkint2(jj),jj=1,8)
   READ(1,*,END=30,ERR=30)(sdarkint3(jj),jj=1,8)
   READ(1,*,END=30,ERR=30)(sdarkint4(jj),jj=1,8)
   READ(1,*,END=30,ERR=30)(sdarkint5(jj),jj=1,8)
!
   IF(ios == 0)THEN
      CLOSE(1)
      RETURN
   END IF
!
!   Come here if the input file ELC.???? does not exist.
!
20 IF(ios > 0)THEN
      bell=CHAR(7)
      WRITE(*,90) bell,kkk
      STOP
   END IF
30 bell=CHAR(7)
!
!   file ended too soon
!
   WRITE(*,100) bell,kkk
   CLOSE(1)
!
   RETURN
!
40 FORMAT('100',i1)
50 FORMAT('10',i2)
60 FORMAT('1',i3)
70 FORMAT(i4)
80 FORMAT(a1,'ielete is too large')
90 FORMAT(a1,'Error:  File ELC.???? does not exist for index ', i4)
100 FORMAT(a1,'Error:  Bad entry in ELC.???? for index ',i4)
!
END SUBROUTINE getgridinput
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gethorizon(istar,ialphmax,ibetmax,nalf,ibetlim,  &
   phase,finc,q,psi0,omega,xarray,yarray,zarray,radarray,gradx,  &
   grady,gradz,xend,nhoriz,xhoriz,yhoriz,phiar,iedgestar,  &
   delphiedge,bdist,mmdx,xhmin,xhmax,yhmin,yhmax,tidephi,itide,  &
   phihor,ecc,thetamis,phimis,tertincl,tertbdist,tertphase,  &
   tertq,axisscale,isw30,isw7,tertomega)
!
!  October 9, 1999
!
!  This subroutine will return the sky coordinates of the horizon of the star
!  xhoriz(1:Nhoriz),yhoriz(1:Nhoriz).  For phases near conjunction, go along
!  the alpha direction and record when the "projection factor" turns negative.
!  For phases near quadrature, so a similar loop in the beta direction.
!
!  Set istar=1 to do star 1, istar=2 to do star2
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN OUT)            :: psi0
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: xarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: yarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: zarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: radarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gradx(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: grady(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gradz(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: xend(4)
   INTEGER, INTENT(IN OUT)                  :: nhoriz
   REAL(KIND=dp), INTENT(IN OUT)            :: xhoriz(4*ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: yhoriz(4*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: phiar(ialphmax*ibetmax)
   INTEGER, INTENT(OUT)                     :: iedgestar(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: delphiedge(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: bdist
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: xhmin
   REAL(KIND=dp), INTENT(IN OUT)            :: xhmax
   REAL(KIND=dp), INTENT(IN OUT)            :: yhmin
   REAL(KIND=dp), INTENT(IN OUT)            :: yhmax
   REAL(KIND=dp), INTENT(IN OUT)            :: tidephi
   INTEGER, INTENT(IN OUT)                  :: itide
   REAL(KIND=dp), INTENT(OUT)               :: phihor(ialphmax,4)
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp) :: overq,phivis,xxoff,yyoff,rvis,diff,phitemp,xp,yp
   REAL(KIND=dp) :: xxoff1,yyoff1,tertxcen,tertycen,ytran,tomrad,xtran
   REAL(KIND=dp) :: phaser,fincr,az,ax,ay,rsign,xvis,yvis,zvis
   REAL(KIND=dp) :: xhid,yhid,zhid,rhid,phihid,xx,yy,zacc,xacc,yacc,zz
!
   INTEGER :: i,iidx,izz,jzz
   INTEGER :: ndummy,ihorcount,INDEX, kk
   INTEGER :: ialf,ibet
!
   INTEGER, PARAMETER :: itemp=10000
!
   REAL(KIND=dp), ALLOCATABLE :: arrproj(:),xdummy(:),ydummy(:)
!
   ALLOCATE(xdummy(itemp),ydummy(itemp),arrproj(itemp))
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!    November 18, 2012
!
!    If there is a third body, offset all x and y sky coordinates
!
   xxoff=0.0_dp
   yyoff=0.0_dp
   IF((isw30 >= 3).AND.(isw7 >= 2))THEN
      xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      tomrad=tertomega*degtorad
      xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
      yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
   END IF
!
!  initialize
!
   DO  i=1,itemp
      xdummy(i)=0.0_dp
      ydummy(i)=0.0_dp
   END DO
!
   DO  ialf=1,nalf
      phihor(ialf,1)=-99.00_dp
      phihor(ialf,2)=-99.00_dp
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         iedgestar(iidx)=0
         delphiedge(iidx)=-99.99_dp
      END DO
   END DO
!
   overq=q
   IF(istar == 2)overq=1.0_dp/q
   phaser=phase*degtorad
   fincr=finc*degtorad
   az=COS(fincr)
   IF(az < 0.0_dp)az=0.0_dp
   ax=-SIN(fincr)*COS(phaser)
   ay=SIN(fincr)*SIN(phaser)
!
   ndummy=0
!
!   Loop over alpha first.
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         arrproj(ibet)=ax*gradx(iidx)+ay*grady(iidx)+az*gradz(iidx)
      END DO
!
!   We have the array of projection factors along a given direction.
!   Now find out where the sign change is.  This is where the line of sight
!   has moved over the horizon.
!
      ihorcount=1
      DO  ibet=1,ibetlim(ialf)
         IF(ibet < ibetlim(ialf))THEN
            INDEX=ibet+1
         ELSE
            INDEX=1
         END IF
         rsign=arrproj(ibet)*arrproj(INDEX)
!
!   crossed over
!
         IF(rsign <= 0.0_dp)THEN
            IF(arrproj(ibet) > 0.0_dp)THEN
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
               xvis=xarray(iidx)
               yvis=yarray(iidx)
               zvis=zarray(iidx)
               rvis=radarray(iidx)
               phivis=phiar(iidx)
               iedgestar(iidx)=10
               izz=ialf
               jzz=INDEX
               iidx=mmdx(izz,jzz)
               xhid=xarray(iidx)
               yhid=yarray(iidx)
               zhid=zarray(iidx)
               rhid=radarray(iidx)
               phihid=phiar(iidx)
               iedgestar(iidx)=-10
               INDEX=ibet
            ELSE
               izz=ialf
               jzz=INDEX
               iidx=mmdx(izz,jzz)
               xvis=xarray(iidx)
               yvis=yarray(iidx)
               zvis=zarray(iidx)
               rvis=radarray(iidx)
               phivis=phiar(iidx)
!
!    just appeared at limb
!
               iedgestar(iidx)=20
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
               xhid=xarray(iidx)
               yhid=yarray(iidx)
               zhid=zarray(iidx)
               rhid=radarray(iidx)
               phihid=phiar(iidx)
!
!   just went behind limb
!
               iedgestar(iidx)=-10
            END IF
!
            CALL acchor(overq,psi0,omega,xvis,yvis,zvis,rvis,  &
               phivis,xhid,yhid,zhid,rhid,phihid,ax,ay,az,xacc,yacc,  &
               zacc,bdist,tidephi,itide,ecc,thetamis,phimis)
            xx=xacc
            yy=yacc
            zz=zacc
            phihor(ialf,ihorcount)=phivis
            ihorcount=ihorcount+1
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            diff=(phiar(iidx)-phivis)
            IF(ABS(diff) < 2.0_dp)THEN
               izz=ialf
               jzz=INDEX
               iidx=mmdx(izz,jzz)
               delphiedge(iidx)=ABS(phiar(iidx)-phivis)
            END IF
            IF(ABS(diff) >= 2.0_dp)THEN
               izz=ialf
               jzz=INDEX
               iidx=mmdx(izz,jzz)
               IF(phiar(iidx) > 4.0_dp)THEN
                  phitemp=twopie-phiar(iidx)
                  delphiedge(iidx)=(phitemp+phivis)
               END IF
               IF(phivis > 4.0_dp)THEN
                  phitemp=twopie-phivis
                  izz=ialf
                  jzz=INDEX
                  iidx=mmdx(izz,jzz)
                  delphiedge(iidx)=(phitemp+phiar(iidx))
               END IF
            END IF
            xp=xtran(xx,yy,phase,q,istar,bdist)
            yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
            xp=xp+xxoff
            yp=yp+yyoff
            ndummy=ndummy+1
            xdummy(ndummy)=xp
            ydummy(ndummy)=yp
         END IF
      END DO
   END DO
!
!   Now put beta on the outside loop and look for points when the line
!   of sight passes over the horizon.
!
   kk=1
   DO  ibet=1,ibetlim(kk)
      DO  ialf=kk,nalf
         izz=ialf
         jzz=ibet
         iidx=mmdx(izz,jzz)
         arrproj(ialf)=ax*gradx(iidx)+ay*grady(iidx)+az*gradz(iidx)
      END DO
!
!   Now find out where the sign change is.  This is where the line of sight
!   has moved over the horizon.
!
      DO  ialf=kk,nalf-1
         IF(ialf < nalf)THEN
            INDEX=ialf+1
         ELSE
            INDEX=kk
         END IF
         rsign=arrproj(ialf)*arrproj(INDEX)
!
!   crossed over
!
         IF(rsign <= 0.0_dp)THEN
            IF(arrproj(ialf) > 0.0_dp)THEN
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
               xvis=xarray(iidx)
               yvis=yarray(iidx)
               zvis=zarray(iidx)
               rvis=radarray(iidx)
               phivis=phiar(iidx)
!
!   just appeared at limb
!
               iedgestar(iidx)=30
               izz=INDEX
               jzz=ibet
               iidx=mmdx(izz,jzz)
               xhid=xarray(iidx)
               yhid=yarray(iidx)
               zhid=zarray(iidx)
               rhid=radarray(iidx)
               phihid=phiar(iidx)
            ELSE
               izz=INDEX
               jzz=ibet
               iidx=mmdx(izz,jzz)
               xvis=xarray(iidx)
               yvis=yarray(iidx)
               zvis=zarray(iidx)
               rvis=radarray(iidx)
               phivis=phiar(iidx)
!
!   just appeared at limb
!
               iedgestar(iidx)=30
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
               xhid=xarray(iidx)
               yhid=yarray(iidx)
               zhid=zarray(iidx)
               rhid=radarray(iidx)
               phihid=phiar(iidx)
            END IF
            CALL acchor(overq,psi0,omega,xvis,yvis,zvis,rvis,  &
               phivis,xhid,yhid,zhid,rhid,phihid,ax,ay,az,xacc,yacc,  &
               zacc,bdist,tidephi,itide,ecc,thetamis,phimis)
            xx=xacc
            yy=yacc
            zz=zacc
            xp=xtran(xx,yy,phase,q,istar,bdist)
            yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
            xp=xp+xxoff
            yp=yp+yyoff
            ndummy=ndummy+1
            xdummy(ndummy)=xp
            ydummy(ndummy)=yp
         END IF
      END DO
   END DO
!
!   Check the visibility of the nose and see if it should be in
!   the horzon
!
   IF((ABS(phase-90.0_dp) <= EPSILON(phase)).OR.(ABS(phase-270.0_dp) <= &
           EPSILON(phase)))THEN
!
!   both ends visible
!
      xp=xtran(xend(3),0.0_dp,phase,q,istar,bdist)
      yp=ytran(xend(3),0.0_dp,0.0_dp,phase,fincr,q,istar,bdist)
!
!  outside the first ring.  Include the
!  point in the horizon
!
      ndummy=ndummy+1
      xdummy(ndummy)=xp
      ydummy(ndummy)=yp
      xp=xtran(xend(4),0.0_dp,phase,q,istar,bdist)
      yp=ytran(xend(4),0.0_dp,0.0_dp,phase,fincr,q,istar,bdist)
      xp=xp+xxoff
      yp=yp+yyoff
   END IF
!
!   Now 'sort' the horizon points so that a regular polygon is made.  If
!   we are near the quadrature phases, then use the old algorithm.  For
!   other phases, use the new algorithm which returns horizon points for
!   every degree in polar coordinates.
!
   CALL newsortcircle(ndummy,xdummy,ydummy,nhoriz,xhoriz,yhoriz,  &
      ibetmax,xhmin,xhmax,yhmin,yhmax)
!
   DEALLOCATE(xdummy,ydummy,arrproj)
!
   RETURN
!
END SUBROUTINE gethorizon
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gethorizon3(nhoriz3,xhoriz3,yhoriz3,reff3,  &
   axisscale,tertbdist,tertphase,tertincl,tertq,tertomega)
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nhoriz3
   REAL(KIND=dp), INTENT(OUT)               :: xhoriz3(nhoriz3)
   REAL(KIND=dp), INTENT(OUT)               :: yhoriz3(nhoriz3)
   REAL(KIND=dp), INTENT(IN)                :: reff3
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp)  :: tertycen,theta,xcent1,ycent1,tomrad,xcent,ycent,tertxcen
!
   INTEGER :: iflag,i
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   iflag=1
   xcent1=tertxcen(iflag,tertincl,tertbdist,tertphase,tertq,axisscale)
   ycent1=tertycen(iflag,tertincl,tertbdist,tertphase,tertq,axisscale)
   tomrad=tertomega*degtorad
   xcent=xcent1*COS(tomrad)-ycent1*SIN(tomrad)
   ycent=xcent1*SIN(tomrad)+ycent1*COS(tomrad)
!
   DO  i=1,360
      theta=REAL(i,KIND=dp)*degtorad
      xhoriz3(i)=reff3*COS(theta)+xcent
      yhoriz3(i)=reff3*SIN(theta)+ycent
   END DO
!
   iflag=2
!
   RETURN
!
END SUBROUTINE gethorizon3
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getibc(nbody,rmass,ribcinp,qq,pp,tstart,itconj,  &
   isw28)
!
!   takes input Keplerian elements and returns x,y,z positions and
!   velocities
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, PARAMETER :: ndim=30
!
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: ribcinp(10,6)
   REAL(KIND=dp), INTENT(OUT)               :: qq(ndim)
   REAL(KIND=dp), INTENT(OUT)               :: pp(ndim)
   REAL(KIND=dp), INTENT(IN)                :: tstart
   INTEGER, INTENT(IN)                      :: itconj
   INTEGER, INTENT(IN)                      :: isw28
!
   REAL(KIND=dp), DIMENSION(30) :: qqbc,ppbc
   REAL(KIND=dp), DIMENSION(3)  :: qqm2,ppm2
   REAL(KIND=dp)                :: esin,argper,ecc,rm1,rm2,period,ecos
   REAL(KIND=dp)                :: tconj,rmean,t0b,rmeanbin,finc,omega,total
   REAL(KIND=dp)                :: planetm,trueatomeana
!
   INTEGER :: kk
!
!DIMENSION qqbc(30),ppbc(30)
!DIMENSION qqm2(3),ppm2(3)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   threehalfpie=1.5_dp*pie
!
   rm1=rmass(1)
   rm2=rmass(2)
   period=ribcinp(1,1)
   ecos=ribcinp(1,2)
   esin=ribcinp(1,3)
   argper=ATAN2(esin,ecos)
   ecc=SQRT(ecos*ecos+esin*esin)
   IF(ecc >= 1.0_dp)ecc=0.99_dp
   tconj=ribcinp(1,6)
   rmean=trueatomeana(halfpie-argper,ecc)
   IF(isw28 == 2)THEN
      rmean=trueatomeana(halfpie-argper,ecc)
   END IF
   t0b=tconj-period*rmean/(twopie)
   rmeanbin=twopie*(tstart-t0b)/period
   finc=ribcinp(1,4)
   omega=ribcinp(1,5)
!
   CALL m2tom1centric(rm1,rm2,period,ecc,rmeanbin,argper,finc,omega,qqm2,ppm2)
!
   qq(1)=0.0_dp
   qq(2)=0.0_dp
   qq(3)=0.0_dp
   qq(4)=qqm2(1)
   qq(5)=qqm2(2)
   qq(6)=qqm2(3)
   pp(1)=0.0_dp
   pp(2)=0.0_dp
   pp(3)=0.0_dp
   pp(4)=ppm2(1)
   pp(5)=ppm2(2)
   pp(6)=ppm2(3)
!
   qqbc(1)=0.0_dp
   qqbc(2)=0.0_dp
   qqbc(3)=0.0_dp
   qqbc(4)=qqm2(1)
   qqbc(5)=qqm2(2)
   qqbc(6)=qqm2(3)
   ppbc(1)=0.0_dp
   ppbc(2)=0.0_dp
   ppbc(3)=0.0_dp
   ppbc(4)=ppm2(1)
   ppbc(5)=ppm2(2)
   ppbc(6)=ppm2(3)
!
   total=rm1+rm2
   DO kk=2,nbody-1
      period=ribcinp(kk,1)
      ecos=ribcinp(kk,2)
      esin=ribcinp(kk,3)
      argper=ATAN2(esin,ecos)
      ecc=SQRT(ecos*ecos+esin*esin)
      IF(ecc >= 1.0_dp)ecc=0.99_dp
      tconj=ribcinp(kk,6)
      rmean=trueatomeana(halfpie-argper,ecc)
      IF(itconj == 2)THEN
         rmean=trueatomeana(threehalfpie-argper,ecc)
      END IF
      t0b=tconj-period*rmean/(twopie)
      rmeanbin=twopie*(tstart-t0b)/period
      finc=ribcinp(kk,4)
      omega=ribcinp(kk,5)
      planetm=rmass(kk+1)
!
      CALL m2tom1centric(total,planetm,period,ecc,rmeanbin,  &
         argper,finc,omega,qqm2,ppm2)
      total=total+planetm
!
      qqbc(3*kk+1)=qqm2(1)
      qqbc(3*kk+2)=qqm2(2)
      qqbc(3*kk+3)=qqm2(3)
      ppbc(3*kk+1)=ppm2(1)
      ppbc(3*kk+2)=ppm2(2)
      ppbc(3*kk+3)=ppm2(3)
   END DO
!
   CALL newmovetobarycenter(nbody,rmass,qqbc,ppbc,qq,pp)
!
   RETURN
!
END SUBROUTINE getibc
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getinput(nalph1,nbet1,nalph2,nbet2,fill1,fill2,  &
   omega1,omega2,dphase,q,finc,teff1,teff2,tgrav1,tgrav2,  &
   betarim,rinner,router,tdisk,xi,ntheta,nradius,alb1,alb2,nref,  &
   rlx,period,fm,separ,gamma,t3,g3,sa3,density,sw1,sw2,sw3,t0,  &
   idraw,iecheck,iidint,iatm,ism1,icnu,icnb,icnv,icnr,icni,icnj,  &
   icnh,icnk,irvfilt,isw1,isw2,isw3,isw4,ilaw,wave,dbolx,dboly,  &
   dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,sw8,sw9,ikeep,  &
   isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,spot2parm,  &
   spotdparm,primmass,primk,primrad,ratrad,frac1,frac2,ecosw,  &
   temprat,idark1,idark2,isw12,isw13,isw21,isw22,isw23,isw24,  &
   bigi,bigbeta,sw23,sw24,powercoeff,sw25,sw26,sw27,sw28,sw29,  &
   sw30,contam,tconj,beam1,beam2,isw25,isw26,isw27,isw28,isw29,  &
   isw30,isw31,isw32,isw33,isw34,ocose,osine,omegadot,contams0,  &
   contams1,contams2,contams3,sw47,sw48,sw49,sw80,sw81,sw82,  &
   sw83,sw84,sw85,sw86,sw87,sw88,sw89,isw80,isw81,isw82,isw83,  &
   isw84,isw85,isw86,isw87,isw88,isw89,sdarkint1,sdarkint2,  &
   sdarkint3,sdarkint4,sdarkint5)
!
   USE accur
!
   IMPLICIT NONE

   INTEGER, INTENT(OUT)                     :: nalph1
   INTEGER, INTENT(OUT)                     :: nbet1
   INTEGER, INTENT(OUT)                     :: nalph2
   INTEGER, INTENT(OUT)                     :: nbet2
   REAL(KIND=dp), INTENT(OUT)               :: fill1
   REAL(KIND=dp), INTENT(OUT)               :: fill2
   REAL(KIND=dp), INTENT(OUT)               :: omega1
   REAL(KIND=dp), INTENT(OUT)               :: omega2
   REAL(KIND=dp), INTENT(OUT)               :: dphase
   REAL(KIND=dp), INTENT(OUT)               :: q
   REAL(KIND=dp), INTENT(OUT)               :: finc
   REAL(KIND=dp), INTENT(OUT)               :: teff1
   REAL(KIND=dp), INTENT(OUT)               :: teff2
   REAL(KIND=dp), INTENT(OUT)               :: tgrav1
   REAL(KIND=dp), INTENT(OUT)               :: tgrav2
   REAL(KIND=dp), INTENT(OUT)               :: betarim
   REAL(KIND=dp), INTENT(OUT)               :: rinner
   REAL(KIND=dp), INTENT(OUT)               :: router
   REAL(KIND=dp), INTENT(OUT)               :: tdisk
   REAL(KIND=dp), INTENT(OUT)               :: xi
   INTEGER, INTENT(OUT)                     :: ntheta
   INTEGER, INTENT(OUT)                     :: nradius
   REAL(KIND=dp), INTENT(OUT)               :: alb1
   REAL(KIND=dp), INTENT(OUT)               :: alb2
   INTEGER, INTENT(OUT)                     :: nref
   REAL(KIND=dp), INTENT(OUT)               :: rlx
   REAL(KIND=dp), INTENT(OUT)               :: period
   REAL(KIND=dp), INTENT(OUT)               :: fm
   REAL(KIND=dp), INTENT(OUT)               :: separ
   REAL(KIND=dp), INTENT(OUT)               :: gamma
   REAL(KIND=dp), INTENT(OUT)               :: t3
   REAL(KIND=dp), INTENT(OUT)               :: g3
   REAL(KIND=dp), INTENT(OUT)               :: sa3
   REAL(KIND=dp), INTENT(OUT)               :: density
   REAL(KIND=dp), INTENT(OUT)               :: sw1
   REAL(KIND=dp), INTENT(OUT)               :: sw2
   REAL(KIND=dp), INTENT(OUT)               :: sw3
   REAL(KIND=dp), INTENT(OUT)               :: t0
   INTEGER, INTENT(OUT)                     :: idraw
   INTEGER, INTENT(OUT)                     :: iecheck
   INTEGER, INTENT(OUT)                     :: iidint
   INTEGER, INTENT(OUT)                     :: iatm
   INTEGER, INTENT(OUT)                     :: ism1
   INTEGER, INTENT(OUT)                     :: icnu
   INTEGER, INTENT(OUT)                     :: icnb
   INTEGER, INTENT(OUT)                     :: icnv
   INTEGER, INTENT(OUT)                     :: icnr
   INTEGER, INTENT(OUT)                     :: icni
   INTEGER, INTENT(OUT)                     :: icnj
   INTEGER, INTENT(OUT)                     :: icnh
   INTEGER, INTENT(OUT)                     :: icnk
   INTEGER, INTENT(OUT)                     :: irvfilt
   INTEGER, INTENT(OUT)                     :: isw1
   INTEGER, INTENT(OUT)                     :: isw2
   INTEGER, INTENT(OUT)                     :: isw3
   INTEGER, INTENT(OUT)                     :: isw4
   INTEGER, INTENT(OUT)                     :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: wave(8)
   REAL(KIND=dp), INTENT(OUT)               :: dbolx(8,2)
   REAL(KIND=dp), INTENT(OUT)               :: dboly(8,2)
   REAL(KIND=dp), INTENT(OUT)               :: dwavex(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: dwavey(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: ecc
   REAL(KIND=dp), INTENT(OUT)               :: argper
   REAL(KIND=dp), INTENT(OUT)               :: pshift
   REAL(KIND=dp), INTENT(OUT)               :: sw5
   REAL(KIND=dp), INTENT(OUT)               :: sw6
   REAL(KIND=dp), INTENT(OUT)               :: sw7
   REAL(KIND=dp), INTENT(OUT)               :: sw8
   REAL(KIND=dp), INTENT(OUT)               :: sw9
   INTEGER, INTENT(OUT)                     :: ikeep
   INTEGER, INTENT(OUT)                     :: isynch
   INTEGER, INTENT(OUT)                     :: isw5
   INTEGER, INTENT(OUT)                     :: isw6
   INTEGER, INTENT(OUT)                     :: isw7
   INTEGER, INTENT(OUT)                     :: isw8
   INTEGER, INTENT(OUT)                     :: isw9
   REAL(KIND=dp), INTENT(OUT)               :: spot1parm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: spot2parm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: spotdparm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: primmass
   REAL(KIND=dp), INTENT(OUT)               :: primk
   REAL(KIND=dp), INTENT(OUT)               :: primrad
   REAL(KIND=dp), INTENT(OUT)               :: ratrad
   REAL(KIND=dp), INTENT(OUT)               :: frac1
   REAL(KIND=dp), INTENT(OUT)               :: frac2
   REAL(KIND=dp), INTENT(OUT)               :: ecosw
   REAL(KIND=dp), INTENT(OUT)               :: temprat
   INTEGER, INTENT(OUT)                     :: idark1
   INTEGER, INTENT(OUT)                     :: idark2
   INTEGER, INTENT(OUT)                     :: isw12
   INTEGER, INTENT(OUT)                     :: isw13
   INTEGER, INTENT(OUT)                     :: isw21
   INTEGER, INTENT(OUT)                     :: isw22
   INTEGER, INTENT(OUT)                     :: isw23
   INTEGER, INTENT(OUT)                     :: isw24
   REAL(KIND=dp), INTENT(OUT)               :: bigi
   REAL(KIND=dp), INTENT(OUT)               :: bigbeta
   REAL(KIND=dp), INTENT(OUT)               :: sw23
   REAL(KIND=dp), INTENT(OUT)               :: sw24
   REAL(KIND=dp), INTENT(OUT)               :: powercoeff(8,9)
   REAL(KIND=dp), INTENT(OUT)               :: sw25
   REAL(KIND=dp), INTENT(OUT)               :: sw26
   REAL(KIND=dp), INTENT(OUT)               :: sw27
   REAL(KIND=dp), INTENT(OUT)               :: sw28
   REAL(KIND=dp), INTENT(OUT)               :: sw29
   REAL(KIND=dp), INTENT(OUT)               :: sw30
   REAL(KIND=dp), INTENT(OUT)               :: contam
   REAL(KIND=dp), INTENT(OUT)               :: tconj
   REAL(KIND=dp), INTENT(OUT)               :: beam1
   REAL(KIND=dp), INTENT(OUT)               :: beam2
   INTEGER, INTENT(OUT)                     :: isw25
   INTEGER, INTENT(OUT)                     :: isw26
   INTEGER, INTENT(OUT)                     :: isw27
   INTEGER, INTENT(OUT)                     :: isw28
   INTEGER, INTENT(OUT)                     :: isw29
   INTEGER, INTENT(OUT)                     :: isw30
   INTEGER, INTENT(OUT)                     :: isw31
   INTEGER, INTENT(OUT)                     :: isw32
   INTEGER, INTENT(OUT)                     :: isw33
   INTEGER, INTENT(OUT)                     :: isw34
   REAL(KIND=dp), INTENT(OUT)               :: ocose
   REAL(KIND=dp), INTENT(OUT)               :: osine
   REAL(KIND=dp), INTENT(OUT)               :: omegadot
   REAL(KIND=dp), INTENT(OUT)               :: contams0
   REAL(KIND=dp), INTENT(OUT)               :: contams1
   REAL(KIND=dp), INTENT(OUT)               :: contams2
   REAL(KIND=dp), INTENT(OUT)               :: contams3
   REAL(KIND=dp), INTENT(OUT)               :: sw47
   REAL(KIND=dp), INTENT(OUT)               :: sw48
   REAL(KIND=dp), INTENT(OUT)               :: sw49
   REAL(KIND=dp), INTENT(OUT)               :: sw80
   REAL(KIND=dp), INTENT(OUT)               :: sw81
   REAL(KIND=dp), INTENT(OUT)               :: sw82
   REAL(KIND=dp), INTENT(OUT)               :: sw83
   REAL(KIND=dp), INTENT(OUT)               :: sw84
   REAL(KIND=dp), INTENT(OUT)               :: sw85
   REAL(KIND=dp), INTENT(OUT)               :: sw86
   REAL(KIND=dp), INTENT(OUT)               :: sw87
   REAL(KIND=dp), INTENT(OUT)               :: sw88
   REAL(KIND=dp), INTENT(OUT)               :: sw89
   INTEGER, INTENT(OUT)                     :: isw80
   INTEGER, INTENT(OUT)                     :: isw81
   INTEGER, INTENT(OUT)                     :: isw82
   INTEGER, INTENT(OUT)                     :: isw83
   INTEGER, INTENT(OUT)                     :: isw84
   INTEGER, INTENT(OUT)                     :: isw85
   INTEGER, INTENT(OUT)                     :: isw86
   INTEGER, INTENT(OUT)                     :: isw87
   INTEGER, INTENT(OUT)                     :: isw88
   INTEGER, INTENT(OUT)                     :: isw89
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint1(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint2(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint3(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint4(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint5(8)
!
   INTEGER :: ios,i,k,jj
!
!   UPDATE June 22, 2002
!
!   Declare the variable bell to be character*1
!
   CHARACTER (LEN=1) :: bell
!
!   UPDATE August 12, 2016
!
!   initalize some new integer flags
!
   isw80=0
   isw81=0
   isw82=0
   isw83=0
   isw84=0
   isw85=0
   isw86=0
   isw87=0
   isw88=0
   isw89=0
!
   ios=0
   OPEN(UNIT=1,FILE='ELC.inp',STATUS='old',ERR=30,IOSTAT=ios)
!
   READ(1,*)nalph1
   READ(1,*)nbet1
   READ(1,*)nalph2
   READ(1,*)nbet2
   READ(1,*)fill1
   READ(1,*)fill2
   READ(1,*)omega1
   READ(1,*)omega2
   READ(1,*)dphase
   READ(1,*)q
   READ(1,*)finc
   READ(1,*)teff1
   READ(1,*)teff2
   READ(1,*)tgrav1
   READ(1,*)tgrav2
   READ(1,*)betarim
   READ(1,*)rinner
   READ(1,*)router
   READ(1,*)tdisk
   READ(1,*)xi
   READ(1,*)ntheta
   READ(1,*)nradius
   READ(1,*)alb1
   READ(1,*)alb2
   READ(1,*)nref
   READ(1,*)rlx
   READ(1,*)period
   READ(1,*)fm
   READ(1,*)separ
   READ(1,*)gamma
   READ(1,*)t3
   READ(1,*)g3
   READ(1,*)sa3
   READ(1,*)density
   READ(1,*)sw1
   READ(1,*)sw2
   READ(1,*)sw3
   READ(1,*)t0
   READ(1,*)idraw
   READ(1,*)iecheck
   READ(1,*)iidint
   READ(1,*)iatm
   READ(1,*)ism1
   READ(1,*)icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk
   READ(1,*)irvfilt
   READ(1,*)isw1
   READ(1,*)isw2
   READ(1,*)isw3
   READ(1,*)isw4
   READ(1,*)ilaw
!
!  Load the limb darkening parameters.
!
   DO  i=1,8
      READ(1,*)wave(i),dbolx(i,1),dboly(i,1),dbolx(i,2),dboly(i,  &
         2),dwavex(i,1),dwavey(i,1),dwavex(i,2),dwavey(i,2)
      dwavex(i,3)=dwavex(i,1)
      dwavey(i,3)=dwavey(i,1)
      dwavex(i,4)=dwavex(i,1)
      dwavey(i,4)=dwavey(i,1)
      dwavex(i,5)=dwavex(i,1)
      dwavey(i,5)=dwavey(i,1)
   END DO
   READ(1,*,END=20)ecc
   READ(1,*)argper
   READ(1,*)pshift
   READ(1,*)sw5
   READ(1,*)sw6
   READ(1,*)sw7
   READ(1,*)sw8
   READ(1,*)sw9
   READ(1,*)ikeep
   READ(1,*)isynch
   READ(1,*)isw5
   READ(1,*)isw6
   READ(1,*)isw7
   READ(1,*)isw8
   READ(1,*)isw9
   ios=0
   READ(1,*,END=40,ERR=40)spot1parm(1,1)
   READ(1,*,END=40,ERR=40)spot1parm(1,2)
   READ(1,*,END=40,ERR=40)spot1parm(1,3)
   READ(1,*,END=40,ERR=40)spot1parm(1,4)
   READ(1,*,END=40,ERR=40)spot1parm(2,1)
   READ(1,*,END=40,ERR=40)spot1parm(2,2)
   READ(1,*,END=40,ERR=40)spot1parm(2,3)
   READ(1,*,END=40,ERR=40)spot1parm(2,4)
   READ(1,*,END=40,ERR=40)spot2parm(1,1)
   READ(1,*,END=40,ERR=40)spot2parm(1,2)
   READ(1,*,END=40,ERR=40)spot2parm(1,3)
   READ(1,*,END=40,ERR=40)spot2parm(1,4)
   READ(1,*,END=40,ERR=40)spot2parm(2,1)
   READ(1,*,END=40,ERR=40)spot2parm(2,2)
   READ(1,*,END=40,ERR=40)spot2parm(2,3)
   READ(1,*,END=40,ERR=40)spot2parm(2,4)
   READ(1,*,END=40,ERR=40)spotdparm(1,1)
   READ(1,*,END=40,ERR=40)spotdparm(1,2)
   READ(1,*,END=40,ERR=40)spotdparm(1,3)
   READ(1,*,END=40,ERR=40)spotdparm(1,4)
   READ(1,*,END=40,ERR=40)spotdparm(2,1)
   READ(1,*,END=40,ERR=40)spotdparm(2,2)
   READ(1,*,END=40,ERR=40)spotdparm(2,3)
   READ(1,*,END=40,ERR=40)spotdparm(2,4)
   READ(1,*,END=40,ERR=40)primmass
   READ(1,*,END=40,ERR=40)primk
   READ(1,*,END=40,ERR=40)primrad
   READ(1,*,END=40,ERR=40)ratrad
   READ(1,*,END=40,ERR=40)frac1
   READ(1,*,END=40,ERR=40)frac2
   READ(1,*,END=40,ERR=40)ecosw
   READ(1,*,END=40,ERR=40)temprat
   READ(1,*,END=40,ERR=40)idark1
   READ(1,*,END=40,ERR=40)idark2
   READ(1,*,END=40,ERR=40)isw12
   READ(1,*,END=40,ERR=40)isw13
   READ(1,*,END=40,ERR=40)isw21
   READ(1,*,END=40,ERR=40)isw22
   READ(1,*,END=40,ERR=40)isw23
   READ(1,*,END=40,ERR=40)isw24
   READ(1,*,END=40,ERR=40)(powercoeff(1,k),k=1,9)
   READ(1,*,END=40,ERR=40)(powercoeff(2,k),k=1,9)
   READ(1,*,END=40,ERR=40)(powercoeff(3,k),k=1,9)
   READ(1,*,END=40,ERR=40)(powercoeff(4,k),k=1,9)
   READ(1,*,END=40,ERR=40)(powercoeff(5,k),k=1,9)
   READ(1,*,END=40,ERR=40)(powercoeff(6,k),k=1,9)
   READ(1,*,END=40,ERR=40)(powercoeff(7,k),k=1,9)
   READ(1,*,END=40,ERR=40)(powercoeff(8,k),k=1,9)
   READ(1,*,END=40,ERR=40)bigi
   READ(1,*,END=40,ERR=40)bigbeta
   READ(1,*,END=40,ERR=40)sw23
   READ(1,*,END=40,ERR=40)sw24
   READ(1,*,END=40,ERR=40)sw25
   READ(1,*,END=40,ERR=40)sw26
   READ(1,*,END=40,ERR=40)sw27
   READ(1,*,END=40,ERR=40)sw28
   READ(1,*,END=40,ERR=40)sw29
   READ(1,*,END=40,ERR=40)sw30
   READ(1,*,END=40,ERR=40)contam
   READ(1,*,END=40,ERR=40)tconj
   READ(1,*,END=40,ERR=40)beam1
   READ(1,*,END=40,ERR=40)beam2
   READ(1,*,END=40,ERR=40)isw25
   READ(1,*,END=40,ERR=40)isw26
   READ(1,*,END=40,ERR=40)isw27
   READ(1,*,END=40,ERR=40)isw28
   READ(1,*,END=40,ERR=40)isw29
   READ(1,*,END=40,ERR=40)isw30
   READ(1,*,END=40,ERR=40)isw31
   READ(1,*,END=40,ERR=40)isw32
   READ(1,*,END=40,ERR=40)isw33
   READ(1,*,END=40,ERR=40)isw34
   READ(1,*,END=40,ERR=40)ocose
   READ(1,*,END=40,ERR=40)osine
   READ(1,*,END=40,ERR=40)omegadot
   READ(1,*,END=40,ERR=40)contams0
   READ(1,*,END=40,ERR=40)contams1
   READ(1,*,END=40,ERR=40)contams2
   READ(1,*,END=40,ERR=40)contams3
   READ(1,*,END=40,ERR=40)sw47
   READ(1,*,END=40,ERR=40)sw48
   READ(1,*,END=40,ERR=40)sw49
   READ(1,*,END=40,ERR=40)sw80
   READ(1,*,END=40,ERR=40)sw81
   READ(1,*,END=40,ERR=40)sw82
   READ(1,*,END=40,ERR=40)sw83
   READ(1,*,END=40,ERR=40)sw84
   READ(1,*,END=40,ERR=40)sw85
   READ(1,*,END=40,ERR=40)sw86
   READ(1,*,END=40,ERR=40)sw87
   READ(1,*,END=40,ERR=40)sw88
   READ(1,*,END=40,ERR=40)sw89
   READ(1,*,END=40,ERR=40)isw80
   READ(1,*,END=40,ERR=40)isw81
   READ(1,*,END=40,ERR=40)isw82
   READ(1,*,END=40,ERR=40)isw83
   READ(1,*,END=40,ERR=40)isw84
   READ(1,*,END=40,ERR=40)isw85
   READ(1,*,END=40,ERR=40)isw86
   READ(1,*,END=40,ERR=40)isw87
   READ(1,*,END=40,ERR=40)isw88
   READ(1,*,END=40,ERR=40)isw89
   READ(1,*,END=40,ERR=40)(sdarkint1(jj),jj=1,8)
   READ(1,*,END=40,ERR=40)(sdarkint2(jj),jj=1,8)
   READ(1,*,END=40,ERR=40)(sdarkint3(jj),jj=1,8)
   READ(1,*,END=40,ERR=40)(sdarkint4(jj),jj=1,8)
   READ(1,*,END=40,ERR=40)(sdarkint5(jj),jj=1,8)
!
20 CLOSE(1)
!
!   Come here if the input file ELC.inp does not exist.  The subroutine
!   writeinput will make the correct file and set default values.
!
30 IF(ios > 0)CALL writeinput(nalph1,nbet1,nalph2,nbet2,fill1,  &
      fill2,omega1,omega2,dphase,q,finc,teff1,teff2,tgrav1,tgrav2,  &
      betarim,rinner,router,tdisk,xi,ntheta,nradius,alb1,alb2,nref,  &
      rlx,period,fm,separ,gamma,t3,g3,sa3,density,sw1,sw2,sw3,t0,  &
      idraw,iecheck,iidint,iatm,ism1,icnu,icnb,icnv,icnr,icni,icnj,  &
      icnh,icnk,irvfilt,isw1,isw2,isw3,isw4,ilaw,wave,dbolx,dboly,  &
      dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,sw8,sw9,ikeep,  &
      isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,spot2parm,  &
      spotdparm,primmass,primk,primrad,ratrad,frac1,frac2,ecosw,  &
      temprat,idark1,idark2,isw12,isw13,isw21,isw22,isw23,isw24,  &
      bigi,bigbeta,sw23,sw24,powercoeff,sw25,sw26,sw27,sw28,sw29,  &
      sw30,contam,tconj,beam1,beam2,isw25,isw26,isw27,isw28,isw29,  &
      isw30,isw31,isw32,isw33,isw34,ocose,osine,omegadot,contams0,  &
      contams1,contams2,contams3,sw47,sw48,sw49,sw80,sw81,sw82,  &
      sw83,sw84,sw85,sw86,sw87,sw88,sw89,isw80,isw81,isw82,isw83,  &
      isw84,isw85,isw86,isw87,isw88,isw89,sdarkint1,sdarkint2,  &
      sdarkint3,sdarkint4,sdarkint5)
!
!   Put this if-then block for successful completion.
!
   IF(ios == 0)THEN
      CLOSE(1)
      RETURN
   END IF
!
!  file ended too soon
!
40 bell=CHAR(7)
   WRITE(*,50)bell
   CLOSE(1)
!
   RETURN
!
50 FORMAT(a1,'Error:  Bad entry in ELC.inp')
!
END SUBROUTINE getinput
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getline(yline,xp,x1,x2,y1,y2)
!
!    October 8, 1999
!
!    Check to see if the point (xp,yp) is above the line connecting
!    (x1,y1) and (x2,y2).  This is from 1995-1996 changes to the
!    Avni code by Orosz.
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(OUT)                      :: yline
   REAL(KIND=dp), INTENT(IN)                       :: xp
   REAL(KIND=dp), INTENT(IN)                       :: x1
   REAL(KIND=dp), INTENT(IN)                       :: x2
   REAL(KIND=dp), INTENT(IN)                       :: y1
   REAL(KIND=dp), INTENT(IN)                       :: y2
!
   REAL(KIND=dp) :: slope
!
   IF(ABS(x1-x2) <= EPSILON(x1))THEN
      yline=(y1)
      RETURN
   END IF
!
   slope=(y1-y2)/(x1-x2)
   yline=slope*(xp-x1)+y1
!
   RETURN
!
END SUBROUTINE getline
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getmaxvalues(n,xdata,ydata,xmin,xmax,ymin,ymax)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: xdata(n)
   REAL(KIND=dp), INTENT(IN)                :: ydata(n)
   REAL(KIND=dp), INTENT(OUT)               :: xmin
   REAL(KIND=dp), INTENT(OUT)               :: xmax
   REAL(KIND=dp), INTENT(OUT)               :: ymin
   REAL(KIND=dp), INTENT(OUT)               :: ymax
!
   REAL(KIND=dp) :: t1,q1
!
   INTEGER :: i
!
   xmin=1.0E+44_dp
   ymin=1.0E+44_dp
   xmax=-1.0E+44_dp
   ymax=-1.0E+44_dp
!
   DO  i=1,n
      t1=xdata(i)
      q1=ydata(i)
      IF(t1 > xmax)xmax=t1
      IF(t1 < xmin)xmin=t1
      IF(q1 > ymax)ymax=q1
      IF(q1 < ymin)ymin=q1
   END DO
!
   RETURN
!
END SUBROUTINE getmaxvalues
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getnorm(n,xx,yy,ynorm)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: xx(n)
   REAL(KIND=dp), INTENT(IN)                :: yy(n)
   REAL(KIND=dp), INTENT(OUT)               :: ynorm
!
   REAL(KIND=dp) :: ymax,diffmin,diff
!
   INTEGER :: i
!
   ymax=1.0_dp
   diffmin=1.0E+44_dp
   DO  i=1,n
      diff=ABS(xx(i)-0.2500_dp)
      IF(diff < diffmin)THEN
         ymax=yy(i)
         diffmin=diff
      END IF
   END DO
   ynorm=ymax
!
   RETURN
!
END SUBROUTINE getnorm
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getom(ecc,ecosw,argper)
!
!   July 29, 2005
!
!   This routine will return the value of omega when given the
!   eccentricity and the phase difference between secondary and
!   primary eclipse.
!
!   It is assumed ecosw is in phase units, so multiply by 2pi to get
!   radians The value of omega will be returned in degrees.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: ecc
   REAL(KIND=dp), INTENT(IN)                       :: ecosw
   REAL(KIND=dp), INTENT(OUT)                      :: argper
!
   REAL(KIND=dp)  :: ppp,ttt,www,argrad,xxx
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   IF(ABS(ecosw) <= EPSILON(ecosw))RETURN
   IF(ecc <= 0.0_dp)RETURN
   IF(ecc >= 1.0_dp)RETURN
!
   ppp=ecosw*twopie
   CALL getx(ppp,xxx)
!
   ttt=TAN((xxx-pie)*0.5_dp)
   www=ttt*SQRT(1.0_dp-ecc*ecc)/ecc
   IF(www < -1.0_dp)www=-1.0_dp
   IF(www > 1.0_dp)www=1.0_dp
   argrad=ACOS(www)
   argper=argrad*radtodeg
   RETURN
!
END SUBROUTINE getom
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getradius(q,finc,rad_in_cm,fm,period,ecc)
!
!   November 1, 1999
!
!   This routine will return the radius of the orbit in cm,
!   given the mass function fm in solar masses, the period in days, the
!   inclination finc in degrees, and mass ratio Q.  It is assumed that
!   the mass function of star 2 was measured from the motion of star 1.
!
!   April 19, 2001
!
!   Add the variable ecc to the argument list of getradius.  Define fmnew
!   as down below.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE

   REAL(KIND=dp), INTENT(IN)                       :: q
   REAL(KIND=dp), INTENT(IN)                       :: finc
   REAL(KIND=dp), INTENT(OUT)                      :: rad_in_cm
   REAL(KIND=dp), INTENT(IN)                       :: fm
   REAL(KIND=dp), INTENT(IN)                       :: period
   REAL(KIND=dp), INTENT(IN)                       :: ecc
!
   REAL(KIND=dp) :: ppp,fincr,fmnew
   REAL(KIND=dp) :: ovq,sinecubed,x_mass,total_mass,rfac,eccfac,sec_mass
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   eccfac=SQRT(1.0_dp-ecc*ecc)**3
   fmnew=fm/eccfac
!
!    UPDATE Oct 31, 2002
!
!    Define fmnew as fm
!
   fmnew=fm
   fincr=finc*degtorad
   ppp=period*24.0_dp
   ovq=1.0_dp/q
   sinecubed=(SIN(fincr)**3)
   x_mass=fmnew*(1.0_dp+ovq)*(1.0_dp+ovq)/sinecubed
   sec_mass=x_mass*ovq
   total_mass=x_mass+sec_mass
   rfac=3600.0_dp**2*gnewton*solarmass/(4.0_dp*pie*pie)
   rfac=(rfac)**(1.0_dp/3.0_dp)
   rad_in_cm=(rfac)*(ppp*ppp*total_mass)**(1.0_dp/3.0_dp)
!
   RETURN
!
END SUBROUTINE getradius
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getrefatmflux(ialphmax,ibetmax,nalf,ibetlim,visib,  &
   projarray,temp,surf,garray,rinty,flum,maxlines,maxmu,nlines,  &
   atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,atmint5,  &
   atmint6,atmint7,atmint8,gscale,fluxu,fluxb,fluxv,fluxr,fluxi,  &
   fluxj,fluxh,fluxk,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,  &
   irvfilt,separ,mmdx,dwavex,dwavey,ilaw,iatm,istar)
!
!     June 16, 2003
!
!     This routine will return the 'reference ATM flux' for use in
!     the EBOP mode.
!
   USE accur
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: visib(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: projarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: temp(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: surf(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: garray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: rinty(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: flum(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: maxlines
   INTEGER, INTENT(IN)                      :: maxmu
   INTEGER, INTENT(IN)                      :: nlines
   REAL(KIND=dp), INTENT(IN)                :: atmt(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmg(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmmu(maxlines,maxmu)
   INTEGER, INTENT(IN)                      :: nmu(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmint1(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint2(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint3(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint4(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint5(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint6(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint7(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint8(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: gscale
   REAL(KIND=dp), INTENT(OUT)               :: fluxu
   REAL(KIND=dp), INTENT(OUT)               :: fluxb
   REAL(KIND=dp), INTENT(OUT)               :: fluxv
   REAL(KIND=dp), INTENT(OUT)               :: fluxr
   REAL(KIND=dp), INTENT(OUT)               :: fluxi
   REAL(KIND=dp), INTENT(OUT)               :: fluxj
   REAL(KIND=dp), INTENT(OUT)               :: fluxh
   REAL(KIND=dp), INTENT(OUT)               :: fluxk
   INTEGER, INTENT(IN)                      :: icnu
   INTEGER, INTENT(IN)                      :: icnb
   INTEGER, INTENT(IN)                      :: icnv
   INTEGER, INTENT(IN)                      :: icnr
   INTEGER, INTENT(IN)                      :: icni
   INTEGER, INTENT(IN)                      :: icnj
   INTEGER, INTENT(IN)                      :: icnh
   INTEGER, INTENT(IN)                      :: icnk
   INTEGER, INTENT(IN)                      :: irvfilt
   REAL(KIND=dp), INTENT(IN)                :: separ
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: iatm
   INTEGER, INTENT(IN)                      :: istar
!
   REAL(KIND=dp) :: corr2,tin,gin,rmuin,outinty,corr1
!
   INTEGER :: ialf,ibet,iidx,itguess,indext,k,izz,jzz
!
!   Set these to the value of ialphmax,ibetmax
!
   INTEGER, PARAMETER :: tempalf=600
   INTEGER, PARAMETER :: tempbet=600
!
   DIMENSION outinty(8),corr1(8),corr2(8)
!
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   IF(tempalf < ialphmax)THEN
      WRITE(*,*) 'dimension error in getATMflux'
      STOP
   END IF
   IF(tempbet < ibetmax)THEN
      WRITE(*,*) 'dimension error in getATMflux'
      STOP
   END IF
!
   fluxu=0.0_dp
   fluxb=0.0_dp
   fluxv=0.0_dp
   fluxr=0.0_dp
   fluxi=0.0_dp
   fluxj=0.0_dp
   fluxh=0.0_dp
   fluxk=0.0_dp
   corr1(1)=0.0_dp
   corr1(2)=0.0_dp
   corr1(3)=0.0_dp
   corr1(4)=0.0_dp
   corr1(5)=0.0_dp
   corr1(6)=0.0_dp
   corr1(7)=0.0_dp
   corr1(8)=0.0_dp
   corr2(1)=0.0_dp
   corr2(2)=0.0_dp
   corr2(3)=0.0_dp
   corr2(4)=0.0_dp
   corr2(5)=0.0_dp
   corr2(6)=0.0_dp
   corr2(7)=0.0_dp
   corr2(8)=0.0_dp
!
!   Initialize the flum matrix.
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
         iidx=mmdx(ialf,ibet)
         flum(iidx)=0.0_dp
         rinty(iidx)=0.0_dp
      END DO
   END DO
!
!   Find the rough place in the atmosphere table.
!
   tin=temp(1)
   CALL locate(atmt,nlines,tin,indext)
   itguess=indext
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
         iidx=mmdx(ialf,ibet)
         IF(projarray(iidx) <= 0.0_dp)CYCLE
         tin=temp(iidx)
         gin=LOG10(gscale*garray(iidx))
         rmuin=projarray(iidx)
         CALL computeinty(tin,gin,rmuin,maxlines,maxmu,nlines,  &
            atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
            atmint5,atmint6,atmint7,atmint8,outinty,icnu,icnb,icnv,  &
            icnr,icni,icnj,icnh,icnk,itguess,dwavex,dwavey,ilaw,iatm,istar)
!
!   save intensities for plotting
!
         rinty(iidx)=outinty(irvfilt)
!
         DO  k=1,8
            outinty(k)=outinty(k)*surf(iidx)*visib(iidx)
         END DO
!
         fluxu=fluxu+outinty(1)
         fluxb=fluxb+outinty(2)
         fluxv=fluxv+outinty(3)
         fluxr=fluxr+outinty(4)
         fluxi=fluxi+outinty(5)
         fluxj=fluxj+outinty(6)
         fluxh=fluxh+outinty(7)
         fluxk=fluxk+outinty(8)
         izz=ialf
         jzz=ibet
         iidx=mmdx(izz,jzz)
         flum(iidx)=outinty(irvfilt)+corr1(irvfilt)+corr2(irvfilt)
      END DO
   END DO
!
!  UPDATE April 3, 2002
!
!  Scale the fluxes.
!
   fluxu=fluxu*(separ*solarrad)**2
   fluxb=fluxb*(separ*solarrad)**2
   fluxv=fluxv*(separ*solarrad)**2
   fluxr=fluxr*(separ*solarrad)**2
   fluxi=fluxi*(separ*solarrad)**2
   fluxj=fluxj*(separ*solarrad)**2
   fluxh=fluxh*(separ*solarrad)**2
   fluxk=fluxk*(separ*solarrad)**2
!
   RETURN
!
END SUBROUTINE getrefatmflux
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!

SUBROUTINE getrefbbflux(ialphmax,ibetmax,nalf,ibetlim,wave,  &
   visib,projarray,temp,surf,flimbx,flimby,ilaw,rinty,flum,flux,  &
   rldint,separ,mmdx)
!
!     June 16, 2003
!
!     This routine will return the 'reference BB flux' for use in
!     the EBOP mode.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: wave
   REAL(KIND=dp), INTENT(IN)                :: visib(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: projarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: temp(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: surf(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: flimbx
   REAL(KIND=dp), INTENT(IN OUT)            :: flimby
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: rinty(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: flum(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: flux
   REAL(KIND=dp), INTENT(OUT)               :: rldint
   REAL(KIND=dp), INTENT(IN)                :: separ
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
!
   REAL(KIND=dp) :: savefx,savefy,rdint,wavemu,c1,c2,tkkelv,c3,dark
!
   INTEGER :: iidx,ialf,ibet
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmassinsolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
!   December 15, 2013:  add triangular sampling
!
   IF((ilaw == 5).OR.(ilaw == 15))THEN
      savefx=flimbx
      savefy=flimby
      flimbx=2.0_dp*SQRT(savefx)*savefy
      flimby=SQRT(savefx)*(1.0_dp-2.0_dp*savefy)
   END IF
!
   IF((ilaw == 6).OR.(ilaw == 16))THEN
      savefx=flimbx
      savefy=flimby
      flimbx=1.0_dp-SQRT(savefx)*savefy
      flimby=1.0_dp-SQRT(savefx)
   END IF
!
   IF((ilaw == 7).OR.(ilaw == 17))THEN
      savefx=flimbx
      savefy=flimby
      flimbx=SQRT(savefx)*(1.0_dp-2.0_dp*savefy)
      flimby=2.0_dp*SQRT(savefx)*savefy
   END IF
!
   rdint=pie*(1.0_dp-flimbx/3.0_dp)
   IF((ilaw == 2).OR.(ilaw == 12))THEN
      rdint=pie*(1.0_dp-flimbx/3.0_dp+2.0_dp*flimby/9.0_dp)
   END IF
   IF((ilaw == 6).OR.(ilaw == 16))THEN
      rdint=pie*(1.0_dp-flimbx/3.0_dp+2.0_dp*flimby/9.0_dp)
   END IF
   IF((ilaw == 3).OR.(ilaw == 13))THEN
      rdint=pie*(1.0_dp-flimbx/3.0_dp-flimby/5.0_dp)
   END IF
   IF((ilaw == 7).OR.(ilaw == 17))THEN
      rdint=pie*(1.0_dp-flimbx/3.0_dp-flimby/5.0_dp)
   END IF
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic limb darkening law, ilaw=4
!
   IF((ilaw == 4).OR.(ilaw == 14))THEN
      rdint=pie*(1.0_dp-flimbx/3.0_dp-flimby/6.0_dp)
   END IF
   IF((ilaw == 5).OR.(ilaw == 15))THEN
      rdint=pie*(1.0_dp-flimbx/3.0_dp-flimby/6.0_dp)
   END IF
!
   wavemu=wave/10000.0_dp
!
!   Initialize the flum matrix.
!
!   c1=3.74185_dp
!   c2=14.3883_dp
!
   c1=2.0_dp*pie*planck*speedlightm*speedlightm*1.0E+16_dp
   c2=speedlightm*planck/boltzmann*1.0E+3_dp
!
   flux=0.0_dp
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         flum(iidx)=0.0_dp
         rinty(iidx)=0.0_dp
      END DO
   END DO
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         IF((projarray(iidx) <= 0.0_dp))CYCLE
         tkkelv=temp(iidx)/1000.0_dp
         c3=c2/(wavemu*tkkelv)
         flum(iidx)=c1/(EXP(c3)-1.0_dp)/wavemu**5
         dark=(1.0_dp-flimbx+flimbx*projarray(iidx))
         IF(ilaw == 2)dark=dark-flimby*projarray(iidx)*LOG(projarray(iidx))
         IF(ilaw == 6)dark=dark-flimby*projarray(iidx)*LOG(projarray(iidx))
         IF(ilaw == 3)dark=dark-flimby*(1.0_dp-SQRT(projarray(iidx)))
         IF(ilaw == 7)dark=dark-flimby*(1.0_dp-SQRT(projarray(iidx)))
         IF(ilaw == 12)dark=dark-flimby*projarray(iidx)*LOG(projarray(iidx))
         IF(ilaw == 16)dark=dark-flimby*projarray(iidx)*LOG(projarray(iidx))
         IF(ilaw == 13)dark=dark-flimby*(1.0_dp-SQRT(projarray(iidx)) )
         IF(ilaw == 17)dark=dark-flimby*(1.0_dp-SQRT(projarray(iidx)) )
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic limb darkening law, ilaw=4
!
         IF(ilaw == 4)dark=dark-flimby*(1.0_dp-(projarray(iidx)))**2
         IF(ilaw == 14)dark=dark-flimby*(1.0_dp-(projarray(iidx)))**2
         IF(ilaw == 5)dark=dark-flimby*(1.0_dp-(projarray(iidx)))**2
         IF(ilaw == 15)dark=dark-flimby*(1.0_dp-(projarray(iidx)))**2
!
         flum(iidx)=flum(iidx)*dark
!
!   save intensities for plotting
!
         rinty(iidx)=flum(iidx)
         flum(iidx)=surf(iidx)*flum(iidx)*visib(iidx)
         flux=flux+flum(iidx)
      END DO
   END DO
!
!   Scale the light curve by the integral of the limb darkening law
!   for compatibility with Wilson-Devinney.
!
!   Scale the light curve by the integral of the limb darkening law
!   for compatibility with Wilson-Devinney.
!
   flux=pie*flux/rdint
!
!   UPDATE April 3, 2002
!
!   Scale the fluxes.
!
!          solarrad=6.9598d10
!
   flux=flux*(separ*solarrad)**2
!
   rldint=rdint
!
   RETURN
!
END SUBROUTINE getrefbbflux
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getrefvel(istar,phase,finc,q,separ,period,gamma,  &
   vel,ecc,argrad)
!
!    November 12, 1999
!
!    This routine will compute the flux-weighted radial velocity of the
!    star in question.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                             :: istar
   REAL(KIND=dp), INTENT(IN)                       :: phase
   REAL(KIND=dp), INTENT(IN)                       :: finc
   REAL(KIND=dp), INTENT(IN)                       :: q
   REAL(KIND=dp), INTENT(IN)                       :: separ
   REAL(KIND=dp), INTENT(IN)                       :: period
   REAL(KIND=dp), INTENT(IN)                       :: gamma
   REAL(KIND=dp), INTENT(OUT)                      :: vel
   REAL(KIND=dp), INTENT(IN)                       :: ecc
   REAL(KIND=dp), INTENT(IN)                       :: argrad
!
   REAL(KIND=dp)  :: argfac,efact,overq,phaser,fincr,siphase,sifinc,a,p,velamp,ppp
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   argfac=ecc*COS(argrad)
   efact=1.0_dp/SQRT(1.0_dp-ecc*ecc)
   vel=0.0_dp
   overq=q
   IF(istar == 2)overq=1.0_dp/q
!
   phaser=phase*degtorad
   fincr=finc*degtorad
   siphase=SIN(phaser)
   sifinc=SIN(fincr)
!
!   Compute the expected K velocity, which is the circular
!   velocity times dsin(finc).
!
   a=separ*solarrad/1000.0_dp
   p=period*secinday
   velamp=twopie*a/p*efact
   ppp=phase*degtorad
   siphase=SIN(ppp)
   vel=overq/(1.0_dp+overq)*(siphase+argfac)*sifinc
   vel=vel*velamp+gamma
!
   RETURN
!
END SUBROUTINE getrefvel
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getrefvisib(ialphmax,ibetmax,nalf,ibetlim,phase,  &
   finc,gradx,grady,gradz,visib,projarray,mmdx)
!
!   June 16, 2003
!
!   This routine will return the 'reference visibilities' for use
!   in the EBOP mode.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE

   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: gradx(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: grady(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gradz(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: visib(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: projarray(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
!
   REAL(KIND=dp)  :: phaser,fincr,ax,ay,az,proj
!
   INTEGER :: i,j,iidx,ialf,ibet
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!  initialize the visibities!
!
   DO  i=1,nalf
      DO  j=1,ibetlim(i)
         iidx=mmdx(i,j)
         visib(iidx)=0.0_dp
         projarray(iidx)=-1.0_dp
      END DO
   END DO
   phaser=phase*degtorad
   fincr=finc*degtorad
   az=COS(fincr)
   IF(az < 0.0_dp)az=0.0_dp
   ax=-SIN(fincr)*COS(phaser)
   ay=SIN(fincr)*SIN(phaser)
!
!   Check to see of the star in question is in front.  If so, then
!   simply find the projection factors.
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         proj=ax*gradx(iidx)+ay*grady(iidx)+az*gradz(iidx)
         projarray(iidx)=proj
         visib(iidx)=proj
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE getrefvisib
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getsc(nsc,xsc,ysc)
!
   USE accur
!
   IMPLICIT NONE

   INTEGER, INTENT(IN OUT)                     :: nsc
   REAL(KIND=dp), INTENT(OUT)                  :: xsc(9999)
   REAL(KIND=dp), INTENT(OUT)                  :: ysc(9999)
!
   INTEGER :: ios,i
!
!   Declare the variable bell to be character*1
!
   CHARACTER (LEN=1) :: bell
!
   DO i=1,9999
      xsc(i)=0.0_dp
      ysc(i)=0.0_dp
   END DO
!
   IF(nsc == 0)RETURN
!
   bell=CHAR(7)
   ios=0
   OPEN(UNIT=1,FILE='ELCSC.inp',STATUS='old',ERR=20,IOSTAT=ios)
!
   IF(nsc > 9999)nsc=9999
!
   DO  i=1,nsc
      READ(1,*,ERR=30,END=30)xsc(i),ysc(i)
      IF(xsc(i) > ysc(i))GO TO 30
   END DO
!
   IF(ios == 0)THEN
      CLOSE(1)
      RETURN
   END IF
!
!   Come here if the input file ELCSC.inp does not exist.
!
20 WRITE(*,40)bell
   nsc=0
   RETURN
!
30 WRITE(*,50)bell
   nsc=0
   CLOSE(1)
!
40 FORMAT(a1,'Error:  ELCSC.inp not found, setting NSC=0')
50 FORMAT(a1,'Error:  Bad entry in ELCSC.inp, setting NSC=0')
!
   RETURN
!
END SUBROUTINE getsc
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gett0(finc,period,ecc,argper,t0,tconj)
!
!   January 30, 2010.
!
!   This routine is the inverse of getcontimes.  Given a time
!   of transit, it will figure out the T0 needed.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: finc
   REAL(KIND=dp), INTENT(IN)                       :: period
   REAL(KIND=dp), INTENT(IN)                       :: ecc
   REAL(KIND=dp), INTENT(IN)                       :: argper
   REAL(KIND=dp), INTENT(OUT)                      :: t0
   REAL(KIND=dp), INTENT(IN)                       :: tconj
!
   REAL(KIND=dp)  :: fincr,omegar,ft,guess
   REAL(KIND=dp)  :: htrc,diff,ecan,xmc,deltat,deltapp,deltap
!
   INTEGER :: jj
!
!   If the input value of the eccentricity is more than
!   0.995 then set T0=Tconj and return
!
   IF(ecc > 0.995_dp)THEN
      t0=tconj
      RETURN
   END IF
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   threehalfpie=1.5_dp*pie
!
   fincr=finc*degtorad
   omegar=(argper+180.0_dp)*degtorad
   ft=threehalfpie-omegar
   CALL checkangle(ft)
   guess=ft
   DO  jj=1,20
      guess=guess-deltap(fincr,omegar,ecc,guess)/deltapp(fincr,omegar,ecc,guess)
      diff=ABS(guess-ft)
      IF(diff < 1.0E-09_dp)EXIT
      ft=guess
   END DO
!
   ft=guess
   htrc=0.5_dp*ft
   IF(ABS(halfpie-htrc) < 7.0E-06_dp)GO TO 30
   IF(ABS(threehalfpie-htrc) < 7.0E-06_dp)GO TO 30
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-ecc)/(1.0_dp+ecc))*TAN(htrc))
   GO TO 40
30 ecan=pie
40 xmc=ecan-ecc*SIN(ecan)
   deltat=(xmc*period)/(twopie)
   t0=tconj-deltat
!
   ft=halfpie-omegar
   CALL checkangle(ft)
   guess=ft
   DO  jj=1,20
      guess=guess-deltap(fincr,omegar,ecc,guess)/deltapp(fincr,omegar,ecc,guess)
      diff=ABS(ft-guess)
      IF(diff < 1.0E-09_dp)EXIT
      ft=guess
   END DO
!
   ft=guess
   htrc=0.5_dp*ft
   IF(ABS(halfpie-htrc) < 7.0E-06_dp)GO TO 70
   IF(ABS(threehalfpie-htrc) < 7.0E-06_dp)GO TO 70
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-ecc)/(1.0_dp+ecc))*TAN(htrc))
   GO TO 80
70 ecan=pie
80 xmc=ecan-ecc*SIN(ecan)
   deltat=(xmc*period)/(twopie)
   t0=tconj-deltat
!
   RETURN
!
END SUBROUTINE gett0
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gett0star(finc,period,ecc,argper,t0,tconj)
!
!   January 30, 2010.
!
!   This routine is the inverse of getcontimes.  Given a time of
!   transit, it will figure out the T0 needed.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: finc
   REAL(KIND=dp), INTENT(IN)                       :: period
   REAL(KIND=dp), INTENT(IN)                       :: ecc
   REAL(KIND=dp), INTENT(IN)                       :: argper
   REAL(KIND=dp), INTENT(OUT)                      :: t0
   REAL(KIND=dp), INTENT(IN)                       :: tconj
!
   REAL(KIND=dp)  :: fincr,omegar,ft,guess
   REAL(KIND=dp)  :: diff,ecan,xmc,deltat,htrc,deltap,deltapp
!
   INTEGER :: jj
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   threehalfpie=1.5_dp*pie
!
   fincr=finc*degtorad
   omegar=argper*degtorad
   ft=threehalfpie-omegar
   CALL checkangle(ft)
   guess=ft
   DO  jj=1,20
      guess=guess-deltap(fincr,omegar,ecc,guess)/deltapp(fincr,omegar,ecc,guess)
      diff=ABS(guess-ft)
      IF(diff < 1.0E-09_dp)EXIT
      ft=guess
   END DO
!
   ft=guess
   htrc=0.5_dp*ft
   IF(ABS(halfpie-htrc) < 7.0E-6_dp)GO TO 30
   IF(ABS(threehalfpie-htrc) < 7.0E-06_dp)GO TO 30
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-ecc)/(1.0_dp+ecc))*TAN(htrc))
   GO TO 40
30 ecan=pie
40 xmc=ecan-ecc*SIN(ecan)
   deltat=(xmc*period)/(twopie)
!
   ft=halfpie-omegar
   CALL checkangle(ft)
   guess=ft
   DO  jj=1,20
      guess=guess-deltap(fincr,omegar,ecc,guess)/deltapp(fincr,omegar,ecc,guess)
      diff=ABS(guess-ft)
      IF(diff < 1.0E-09_dp)EXIT
      ft=guess
   END DO
!
   ft=guess
   htrc=0.5_dp*ft
   IF(ABS(halfpie-htrc) < 7.0E-06_dp)GO TO 70
   IF(ABS(threehalfpie-htrc) < 7.0E-06_dp)GO TO 70
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-ecc)/(1.0_dp+ecc))*TAN(htrc))
   GO TO 80
70 ecan=pie
80 xmc=ecan-ecc*SIN(ecan)
!
   deltat=(xmc*period)/(twopie)
   t0=tconj-deltat
!
   RETURN
!
END SUBROUTINE gett0star
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gett0tran(finc,period,ecc,argper,t0,tconj)
!
!   January 30, 2010.
!
!   This routine is the inverse of getcontimes.  Given a time of
!   transit, it will figure out the T0 needed.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: finc
   REAL(KIND=dp), INTENT(IN)                       :: period
   REAL(KIND=dp), INTENT(IN)                       :: ecc
   REAL(KIND=dp), INTENT(IN)                       :: argper
   REAL(KIND=dp), INTENT(OUT)                      :: t0
   REAL(KIND=dp), INTENT(IN)                       :: tconj
!
   REAL(KIND=dp)  :: guess,fincr,omegar,ft
   REAL(KIND=dp)  :: diff,ecan,xmc,deltat,htrc,deltap,deltapp
!
   INTEGER :: jj
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   threehalfpie=1.5_dp*pie
!
   IF(period <= 0.0_dp)THEN
      t0=0.0_dp
      RETURN
   END IF
!
   fincr=finc*degtorad
   omegar=argper*degtorad
!
   ft=halfpie-omegar+twopie
   CALL checkangle(ft)
   guess=ft
   DO  jj=1,20
      guess=guess-deltap(fincr,omegar,ecc,guess)/deltapp(fincr,omegar,ecc,guess)
      diff=ABS(guess-ft)
      IF(diff < 1.0E-09_dp)EXIT
      ft=guess
   END DO
!
   ft=guess
   htrc=0.5_dp*ft
   IF(ABS(halfpie-htrc) < 7.0E-06_dp)GO TO 30
   IF(ABS(threehalfpie-htrc) < 7.0E-06_dp)GO TO 30
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-ecc)/(1.0_dp+ecc))*TAN(htrc))
   GO TO 40
30 ecan=pie
40 xmc=ecan-ecc*SIN(ecan)
   deltat=(xmc*period)/(twopie)
   ft=threehalfpie-omegar+twopie
   CALL checkangle(ft)
   guess=ft
   DO  jj=1,20
      guess=guess-deltap(fincr,omegar,ecc,guess)/deltapp(fincr,omegar,ecc,guess)
      diff=ABS(guess-ft)
      IF(diff < 1.0E-09_dp)EXIT
      ft=guess
   END DO
!
   ft=guess
   htrc=0.5_dp*ft
   IF(ABS(halfpie-htrc) < 7.0E-06_dp)GO TO 70
   IF(ABS(threehalfpie-htrc) < 7.0E-06_dp)GO TO 70
   ecan=2.0_dp*ATAN(SQRT((1.0_dp-ecc)/(1.0_dp+ecc))*TAN(htrc))
   GO TO 80
70 ecan=pie
80 xmc=ecan-ecc*SIN(ecan)
   deltat=(xmc*period)/(twopie)
!
   t0=tconj-deltat
!
   RETURN
!
END SUBROUTINE gett0tran
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gettophorizon(istar,ialphmax,ibetmax,nalf,ibetlim,  &
   phase,finc,q,xarray,yarray,zarray,gradx,grady,gradz,nhoriz,  &
   xhoriz,yhoriz,bdist,mmdx,tertincl,tertbdist,tertphase,tertq,  &
   axisscale,isw30,isw7,tertomega)
!
!  November 3, 1999
!
!  This routine will consider only positive z-values of the star and
!  find the apparent horizon.  This horizon for star 2 is needed if there
!  is a disk---points on the disk that project (in sky coordinates)
!  inside this horizon are behind star 2.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: xarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: yarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: zarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gradx(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: grady(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gradz(ialphmax*ibetmax)
   INTEGER, INTENT(OUT)                     :: nhoriz
   REAL(KIND=dp), INTENT(OUT)               :: xhoriz(4*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: yhoriz(4*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: bdist
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp), ALLOCATABLE  :: xdummy(:),ydummy(:),arrproj(:)
   REAL(KIND=dp)  :: xxoff,yyoff,xxoff1,yyoff1,tomrad,tertxcen,tertycen,yy
   REAL(KIND=dp)  :: phaser,fincr,ax,ay,az,a2,a3
   REAL(KIND=dp)  :: zz,xx,xp,yp,xtran,ytran,rsign,xvis,yvis,zvis
!
   INTEGER :: i,ndummy,iidx,ibet,ialf,izz,jzz,INDEX
!
   ALLOCATE(arrproj(10000),xdummy(10000),ydummy(10000))
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!    November 18, 2012
!
!    If there is a third body, offset all x and y sky coordinates
!
   xxoff=0.0_dp
   yyoff=0.0_dp
   IF((isw30 >= 3).AND.(isw7 >= 2))THEN
      xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      tomrad=tertomega*degtorad
      xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
      yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
   END IF
!
!  Initialize.
!
   DO  i=1,5000
      xdummy(i)=0.0_dp
      ydummy(i)=0.0_dp
   END DO
!
   phaser=phase*degtorad
   fincr=finc*degtorad
   az=COS(fincr)
   IF(az < 0.0_dp)az=0.0_dp
   ax=-SIN(fincr)*COS(phaser)
   ay=SIN(fincr)*SIN(phaser)
   a2=ACOS(ax)
   a3=SIN(a2)
   IF(a3 < 0.0_dp)a3=0.0_dp
!
   ndummy=0
!
!   Loop over alpha first.
!
   DO  ialf=1,nalf/2
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=(ialf-1)*ibetlim(ialf)+ibet
!               iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         arrproj(ibet)=ax*gradx(iidx)+ay*grady(iidx)+az*gradz(iidx)
!
!   Check the last latitude row before the xy plane and include that
!   in the top horizon
!
         IF(ialf == nalf/2)THEN
            IF(arrproj(ibet) >= 0.0_dp)THEN
               izz=ialf
               jzz=1
               iidx=mmdx(izz,jzz)
               xx=xarray(iidx)
               yy=yarray(iidx)
               zz=zarray(iidx)
               xp=xtran(xx,yy,phase,q,istar,bdist)
               yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
               xp=xp+xxoff
               yp=yp+yyoff
               ndummy=ndummy+1
               xdummy(ndummy)=xp
               ydummy(ndummy)=yp
            END IF
         END IF
      END DO
!
!   We have the array of projection factors along a given direction.
!   Now find out where the sign change is.  This is where the line of sight
!   has moved over the horizon.
!
      DO  ibet=1,ibetlim(ialf)
         IF(ibet < ibetlim(ialf))THEN
            INDEX=ibet+1
         ELSE
            INDEX=1
         END IF
         rsign=arrproj(ibet)*arrproj(INDEX)
!
!  crossed over
!
         IF(rsign <= 0.0_dp)THEN
            IF(arrproj(ibet) > 0.0_dp)THEN
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
               xvis=xarray(iidx)
               yvis=yarray(iidx)
               zvis=zarray(iidx)
               izz=ialf
               jzz=INDEX
               iidx=mmdx(izz,jzz)
            ELSE
               izz=ialf
               jzz=INDEX
               iidx=mmdx(izz,jzz)
               xvis=xarray(iidx)
               yvis=yarray(iidx)
               zvis=zarray(iidx)
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
            END IF
            xx=xvis
            yy=yvis
            zz=zvis
            xp=xtran(xx,yy,phase,q,istar,bdist)
            yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
            xp=xp+xxoff
            yp=yp+yyoff
            ndummy=ndummy+1
            xdummy(ndummy)=xp
            ydummy(ndummy)=yp
         END IF
      END DO
   END DO
!
!   Now 'sort' the horizon points so that a regular polygon is made.
!
   CALL sortcircle(ndummy,xdummy,ydummy)
!
!   The above array may have repeated points.  Remove them.
!
   CALL uniquepoint(ndummy,xdummy,ydummy,nhoriz,xhoriz,yhoriz)
!
   DEALLOCATE(arrproj,xdummy,ydummy)
!
   RETURN
!
END SUBROUTINE gettophorizon
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getvel(ialphmax,ibetmax,nalf,ibetlim,istar,omega,  &
   phase,finc,q,flum,xcoords,ycoords,flux,separ,period,gamma,  &
   vel,delvel,rldint,ecc,argrad,mmdx,isw13,ialfmin,ialfmax,bigi,  &
   bigbeta,zcoords)
!
!    November 12, 1999
!
!    This routine will compute the flux-weighted radial velocity of the
!    star in question.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: flum(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: xcoords(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: ycoords(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: flux
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: gamma
   REAL(KIND=dp), INTENT(OUT)               :: vel
   REAL(KIND=dp), INTENT(OUT)               :: delvel
   REAL(KIND=dp), INTENT(IN)                :: rldint
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: argrad
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   INTEGER, INTENT(IN)                      :: isw13
   INTEGER, INTENT(IN)                      :: ialfmin
   INTEGER, INTENT(IN)                      :: ialfmax
   REAL(KIND=dp), INTENT(IN)                :: bigi
   REAL(KIND=dp), INTENT(IN)                :: bigbeta
   REAL(KIND=dp), INTENT(IN)                :: zcoords(ialphmax*ibetmax)
!
   REAL(KIND=dp) ::  argfac,efact,a,tempbeta,v1,p
   REAL(KIND=dp) ::  rdint,overq,phaser,fincr,siphase,cophase,sifinc,cofinc
   REAL(KIND=dp) ::  ppp,sb,cb,si,velamp,bigbetar,sscale,xxx,yyy,zzz,xp,yp
!
   INTEGER :: ialf,ibet,iidx
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   argfac=ecc*COS(argrad)
   efact=1.0_dp/SQRT(1.0_dp-ecc*ecc)
   rdint=rldint
   vel=0.0_dp
   delvel=0.0_dp
   overq=q
   IF(istar == 2)overq=1.0_dp/q
   phaser=phase*degtorad
   fincr=finc*degtorad
   siphase=SIN(phaser)
   cophase=COS(phaser)
   sifinc=SIN(fincr)
   cofinc=COS(fincr)
!
!   Compute the expected K velocity, which is the
!   circular velocity times dsin(finc).
!
!  separation in km
!
   a=separ*solarrad/1000.0_dp
!
!   period in seconds
!
   p=period*secinday
   velamp=twopie*a/p*efact
!
!    Check to see if the star has any flux before going further!
!
   IF(flux <= 0.0_dp)THEN
!
!   April 23, 2001
!
!   Move this if-then block a bit further down.
!   Set delvel=0.0d0 in the case when the flux is 0.  Also, set
!   the velocity to the velocity expected from orbital motion so the
!   output velocity curve is smooth during the eclipse
!
      ppp=phase*degtorad
      siphase=SIN(ppp)
      vel=overq/(1.0_dp+overq)*(siphase+argfac)*sifinc
      vel=vel*velamp+gamma
      delvel=0.0_dp
      RETURN
   END IF
!
!   UPDATE October 21, 2002
!
!   Scale the fluxes by (separ*solarrad)**2
!
   si=SIN(bigi*degtorad)
   tempbeta=bigbeta
   bigbetar=tempbeta*degtorad
   cb=COS(bigbetar)
   sb=SIN(bigbetar)
!
   sscale=(separ*solarrad)**2
   DO  ialf=1,nalf
      IF((isw13 > 0).AND.(istar == 0))THEN
         IF((ialf < ialfmin).OR.(ialf > ialfmax))CYCLE
      END IF
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=(ialf-1)*ibetlim(ialf)+ibet
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         xxx=xcoords(iidx)
         yyy=ycoords(iidx)
         zzz=zcoords(iidx)
         xp=-xxx*siphase-yyy*cophase
         yp=xxx*cofinc*cophase-yyy*cofinc*siphase+zzz*sifinc
         v1=omega*si*(xp*cb+yp*sb)
         v1=v1*flum(iidx)*sscale
         delvel=delvel+v1
      END DO
   END DO
!
   phaser=phase*degtorad
!
   siphase=SIN(phaser)
   delvel=delvel/flux
   vel=overq/(1.0_dp+overq)*(siphase+argfac)*sifinc
   delvel=delvel*100.0_dp
   vel=velamp*vel
   vel=vel+delvel
   vel=vel+gamma
!
   RETURN
!
END SUBROUTINE getvel
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getvisib(istar,ialphmax,ibetmax,nalf,ibetlim,  &
   phase,finc,q,psi0,omega,gradx,grady,gradz,xarray,yarray,  &
   zarray,xend,visib,nhoriz,xhoriz,yhoriz,iidint,ndhoriz,  &
   dxhoriz,dyhoriz,ndtop,dtopx,dtopy,ncoords,xcoords,ycoords,  &
   projarray,iecheck,neclipse,phiar,radarray,delphi,iedgehor,  &
   bdist,mmdx,montecarlo,isw13,ialfmin,ialfmax,xhmin,xhmax,  &
   yhmin,yhmax,tidephi,itide,phistart,ecc,thetamis,phimis,  &
   nhoriz3,xhoriz3,yhoriz3,i3flag,tertincl,tertbdist,tertphase,  &
   tertq,axisscale,isw30,isw7,tertomega,arrsobx,arrsoby,  &
   montemax)
!
!  October 9, 1999
!
!  This routine will compute the 'projection' factor of each grid
!  element on the star (istar=1 to do star 1, istar=2 to do star2),
!  check for eclipses (the horizon of the other body is in xhoriz,yhoriz),
!  and return the sky coordinates of the visible points.  Set iecheck = -1
!  to skip the check for eclipses.
!
!  UPDATE JULY 4, 2004
!
!  Add jdum and MonteCarlo to the argument list.  If MonteCarlo > 10,
!  then use Monte Carlo integration to determine fractionally
!  eclipsed pixels.  If MonteCarlo < 10, then proceed as before
!  and use interpolation in getBBflux and getATMflux.
!
!   UPDATE May 3, 2006
!
!   Add a "fast transit" mode.  If isw13 > 0, then consider ialf ranges
!   only between ialfmin and ialfmax
!
!   UPDATE May 8, 2006
!
!   Add the minimum and maximum x and y-values of the horizon.  Do
!   an if-then check to determine of insidecircle should be called.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: montemax
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: psi0
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: gradx(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: grady(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gradz(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: xarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: yarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: zarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: xend(4)
   REAL(KIND=dp), INTENT(OUT)               :: visib(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: nhoriz
   REAL(KIND=dp), INTENT(IN)                :: xhoriz(nhoriz)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz(nhoriz)
   INTEGER, INTENT(IN)                      :: iidint
   INTEGER, INTENT(IN)                      :: ndhoriz
   REAL(KIND=dp), INTENT(IN)                :: dxhoriz(ndhoriz)
   REAL(KIND=dp), INTENT(IN)                :: dyhoriz(ndhoriz)
   INTEGER, INTENT(IN)                      :: ndtop
   REAL(KIND=dp), INTENT(IN)                :: dtopx(ndtop)
   REAL(KIND=dp), INTENT(IN)                :: dtopy(ndtop)
   INTEGER, INTENT(OUT)                     :: ncoords
   REAL(KIND=dp), INTENT(OUT)               :: xcoords(ialphmax*ibetmax*4)
   REAL(KIND=dp), INTENT(OUT)               :: ycoords(ialphmax*ibetmax*4)
   REAL(KIND=dp), INTENT(OUT)               :: projarray(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: iecheck
   INTEGER, INTENT(OUT)                     :: neclipse
   REAL(KIND=dp), INTENT(IN)                :: phiar(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: radarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: delphi(ialphmax*ibetmax)
   INTEGER, INTENT(OUT)                     :: iedgehor(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: bdist
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   INTEGER, INTENT(IN)                      :: montecarlo
   INTEGER, INTENT(IN)                      :: isw13
   INTEGER, INTENT(IN)                      :: ialfmin
   INTEGER, INTENT(IN)                      :: ialfmax
   REAL(KIND=dp), INTENT(IN)                :: xhmin
   REAL(KIND=dp), INTENT(IN)                :: xhmax
   REAL(KIND=dp), INTENT(IN)                :: yhmin
   REAL(KIND=dp), INTENT(IN)                :: yhmax
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   INTEGER, INTENT(IN)                      :: itide
   REAL(KIND=dp), INTENT(IN)                :: phistart(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
   INTEGER, INTENT(IN)                      :: nhoriz3
   REAL(KIND=dp), INTENT(IN)                :: xhoriz3(nhoriz3)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz3(nhoriz3)
   INTEGER, INTENT(IN)                      :: i3flag
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
   REAL(KIND=dp), INTENT(IN)                :: arrsobx(montemax)
   REAL(KIND=dp), INTENT(IN)                :: arrsoby(montemax)
!
   REAL(KIND=dp) :: yp,xxoff1,xtran,rhid,tomrad,az,ax,ay,ytran,xp
   REAL(KIND=dp) :: phivis,tertxcen,tertycen,xhid,yhid,xxoff,yyoff
   REAL(KIND=dp) :: yyoff1,xx,yy,zz,zhid,rvis,xvis,yvis,zvis
   REAL(KIND=dp) :: phaser,fincr,xpv,proj,theta,phihid,ypv,xph,yph,diff
   REAL(KIND=dp) :: phiacc,phitemp,dtheta,overq,r,dphi,phi,phinew,thetanew
   REAL(KIND=dp) :: snth,cnth,cox,coy,coz,psi,psix,psixx,psiy,psiz
!
   INTEGER, ALLOCATABLE  :: ihid(:)
   INTEGER :: ibet,iidx,i,j,infront
   INTEGER :: iyes,iimin,iimax,ialf,icut,INDEX,izz,jzz,jjdx,ksign
   INTEGER :: nloop,nnhid,kk,jj,nvis,ll
!
   INTEGER, PARAMETER :: itemp=2000000
!
   ALLOCATE(ihid(itemp))
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   IF(itemp < ialphmax*ibetmax)THEN
      WRITE(*,*)itemp,ialphmax,ibetmax
      WRITE(*,*)'dimension error in subroutine getvisib'
      WRITE(*,*)'make itemp larger than ialphmax*ibetmax'
      STOP
   END IF
!
!   Initialize some variables here
!
   proj=0.0_dp
   theta=0.0_dp
   ibet=1
!
!    November 18, 2012
!
!    If there is a third body, offset all x and y sky coordinates
!
   xxoff=0.0_dp
   yyoff=0.0_dp
   IF((isw30 >= 3).AND.(isw7 >= 2))THEN
      xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      tomrad=tertomega*degtorad
      xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
      yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
   END IF
!
!  initialize the visibities!
!
   DO  i=1,nalf
      DO  j=1,ibetlim(i)
         iidx=mmdx(i,j)
         visib(iidx)=0.0_dp
         projarray(iidx)=-1.0_dp
         ihid(iidx)=-1
         delphi(iidx)=-999.9_dp
         iedgehor(iidx)=-999
      END DO
   END DO
   phaser=phase*degtorad
   fincr=finc*degtorad
   az=COS(fincr)
   IF(az < 0.0_dp)az=0.0_dp
   ax=-SIN(fincr)*COS(phaser)
   ay=SIN(fincr)*SIN(phaser)
!
!   Check to see of the star in question is in front.  If so, then simply
!   find the projection factors.
!
   infront=0
   ncoords=0
   neclipse=0
   IF((istar == 1).AND.((phase >= 0.0_dp).AND.(phase < 90.0_dp)))infront=1
   IF((istar == 1).AND.((phase >= 270.0_dp).AND.(phase <= 360.0_dp)))infront=1
   IF((istar == 2).AND.((phase >= 0.0_dp).AND.(phase < 90.0_dp)))infront=1
   IF((istar == 2).AND.((phase >= 270.0_dp).AND.(phase <= 360.0_dp)))infront=1
!
   DO  i=1,2
      IF(i == 1)proj=ax
      IF(i == 2)proj=-ax
      IF(proj > 0.0_dp)THEN
         xp=xtran(xend(i+2),0.0_dp,phase,q,istar,bdist)
         yp=ytran(xend(i+2),0.0_dp,0.0_dp,phase,fincr,q,istar,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
!
!   If we are looking at star 2 and there is a disk, then check to see if
!   the points are *inside* the top horizon of the disk.
!
         IF((iidint >= 1).AND.(istar == 2))THEN
            IF(iecheck >= 0)THEN
               iyes=-100
               CALL insidecircle(ndtop,dtopx,dtopy,xp,yp,iyes,icut)
!
!  the point is outside the top horizon, so it is beneath the rim
!
               IF(iyes /= 100)CYCLE
            END IF
         END IF
         IF(infront == 1)THEN
            ncoords=ncoords+1
            xcoords(ncoords)=xp
            ycoords(ncoords)=yp
         ELSE
            IF(iecheck >= 0)THEN
               iyes=-100
               CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
               IF(iyes == 100)THEN
!
!  eclipsed by star 2
!
                  CYCLE
               END IF
            END IF
!
!   UPDATE JUNE 17, 2005
!
!   Add if.iidint.gt.0 to if-then
!
            IF((istar == 1).AND.(iidint > 0))THEN
               IF(iecheck >= 0)THEN
                  CALL insidecircle(ndhoriz,dxhoriz,dyhoriz,xp,yp,iyes,icut)
                  IF(iyes == 100)THEN
!
!   eclipsed by disk
!
                     CYCLE
                  END IF
               END IF
            END IF
            ncoords=ncoords+1
            xcoords(ncoords)=xp
            ycoords(ncoords)=yp
         END IF
      END IF
   END DO
!
   iimin=123456
   iimax=-12345
   DO  ialf=1,nalf
      IF((isw13 > 0).AND.(istar == 1))THEN
         IF((ialf < ialfmin).OR.(ialf > ialfmax))CYCLE
      END IF
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         proj=ax*gradx(iidx)+ay*grady(iidx)+az*gradz(iidx)
         projarray(iidx)=proj
!
!  is the surface element visible?
!
         IF(proj < 0.0_dp)CYCLE
         xx=xarray(iidx)
         yy=yarray(iidx)
         zz=zarray(iidx)
         xp=xtran(xx,yy,phase,q,istar,bdist)
         yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
!
!  if I3flag=1, then the third body is in front of the binary.  Check
!  for eclipses
!
         IF(i3flag >= 1)THEN
            iyes=-100
            CALL insidecircle(nhoriz3,xhoriz3,yhoriz3,xp,yp,iyes,icut)
            IF(iyes == 100)THEN
               neclipse=neclipse+1
               ihid(iidx)=4
               CYCLE
            END IF
         END IF
!
!   Check to see of the point in question is eclipsed by the other star, or
!   in the case of star 1, eclipsed by the disk, or
!   in the case of a point on the bottom half of star 2, eclipsed by the disk.
!   icut=2 for points outside and below the horizon.
!
         IF(infront == 1)THEN
            IF((iidint >= 1).AND.(istar == 2).AND.(zz < 0.0_dp)) THEN
               iyes=-100
               CALL insidecircle(ndhoriz,dxhoriz,dyhoriz,xp,yp,iyes,icut)
               IF(iyes == 100)THEN
!
!   eclipsed by disk
!
                  ihid(iidx)=2
                  CYCLE
               END IF
            END IF
            IF((iidint >= 1).AND.(istar == 2).AND.(zz >= 0.0_dp)) THEN
               icut=-100
               iyes=-100
               CALL insidecircle(ndtop,dtopx,dtopy,xp,yp,iyes,icut)
               IF((iyes == 0).AND.(icut == 2))THEN
                  ihid(iidx)=3
                  CYCLE
               END IF
            END IF
            ncoords=ncoords+1
            xcoords(ncoords)=xp
            ycoords(ncoords)=yp
            visib(iidx)=proj
         ELSE
            iyes=-100
            IF(iecheck >= 0)THEN
!
!   UPDATE May 8, 2006
!
!   Add these if-then statements to see if insidecircle should be called.
!
               IF(((xhmin < xp).AND.(xp < xhmax)).AND.((yhmin <  &
                  yp).AND.(yp < yhmax)))THEN
                  CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
                  IF(iyes == 100)THEN
                     neclipse=neclipse+1
                     ihid(iidx)=1
!
!   UPDATE JULY 1, 2004
!
!   Add this to determine the latitude rows above and below the eclipsing
!   horizon.
!
                     IF(ialf < iimin)iimin=ialf
                     IF(ialf > iimax)iimax=ialf
                     CYCLE
                  END IF
               END IF
            END IF
            IF((iidint >= 1).AND.(istar == 2).AND.(zz < 0.0_dp)) THEN
               iyes=-100
               CALL insidecircle(ndhoriz,dxhoriz,dyhoriz,xp,yp,iyes,icut)
               IF(iyes == 100)THEN
                  ihid(iidx)=2
                  CYCLE
               END IF
            END IF
            IF((iidint >= 1).AND.(istar == 1).AND.(iecheck >= 0)) THEN
               iyes=-100
               CALL insidecircle(ndhoriz,dxhoriz,dyhoriz,xp,yp,iyes,icut)
               IF(iyes == 100)THEN
                  neclipse=neclipse+1
                  ihid(iidx)=2
                  CYCLE
               END IF
            END IF
!
!   Finally, if the star in question is star 2 and there is a disk, we
!   must check to see if the point is inside the top horizon of the disk.
!   Points outside this horizon and below it are beneath the rim.  Points
!   outside this horizon and above it are still visible.  icut=2
!   for points outside and below.
!
            IF((iidint >= 1).AND.(istar == 2).AND.(zz >= 0.0_dp)) THEN
               icut=-100
               iyes=-100
               CALL insidecircle(ndtop,dtopx,dtopy,xp,yp,iyes,icut)
               IF((iyes == 0).AND.(icut == 2))THEN
                  ihid(iidx)=3
                  CYCLE
               END IF
            END IF
            ncoords=ncoords+1
            xcoords(ncoords)=xp
            ycoords(ncoords)=yp
            visib(iidx)=proj
!
!   end if in front
!
         END IF
!
      END DO
   END DO
!
!   Now we have to go along the beta direction and find out which visible
!   point is nearest to the eclipsing horizon.
!
   DO  ialf=1,nalf
      IF((isw13 > 0).AND.(istar == 1))THEN
         IF((ialf < ialfmin).OR.(ialf > ialfmax))CYCLE
      END IF
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         IF(projarray(iidx) <= 0.0_dp)CYCLE
         IF(ibet < ibetlim(ialf))THEN
            INDEX=ibet+1
         ELSE
            INDEX=1
         END IF
         izz=ialf
         jzz=INDEX
         jjdx=mmdx(izz,jzz)
         IF(projarray(jjdx) <= 0.0_dp)CYCLE
         izz=ialf
         jzz=ibet
         iidx=mmdx(izz,jzz)
         ksign=ihid(iidx)*ihid(jjdx)
!
!   crossed through the horizon
!
         IF(ksign <= -1)THEN
            IF(ihid(iidx) == -1)THEN
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
               xvis=xarray(iidx)
               yvis=yarray(iidx)
               zvis=zarray(iidx)
               rvis=radarray(iidx)
               phivis=phiar(iidx)
               iedgehor(iidx)=10
               izz=ialf
               jzz=INDEX
               iidx=mmdx(izz,jzz)
               xhid=xarray(iidx)
               yhid=yarray(iidx)
               zhid=zarray(iidx)
               rhid=radarray(iidx)
               phihid=phiar(iidx)
               iedgehor(iidx)=-10
               INDEX=ibet
            ELSE
               izz=ialf
               jzz=INDEX
               iidx=mmdx(izz,jzz)
               xvis=xarray(iidx)
               yvis=yarray(iidx)
               zvis=zarray(iidx)
               rvis=radarray(iidx)
               phivis=phiar(iidx)
               iedgehor(iidx)=20
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
               xhid=xarray(iidx)
               yhid=yarray(iidx)
               zhid=zarray(iidx)
               rhid=radarray(iidx)
               phihid=phiar(iidx)
               iedgehor(iidx)=-10
            END IF
            xpv=xtran(xvis,yvis,phase,q,istar,bdist)
            ypv=ytran(xvis,yvis,zvis,phase,fincr,q,istar,bdist)
            xpv=xpv+xxoff
            ypv=ypv+yyoff
            xph=xtran(xhid,yhid,phase,q,istar,bdist)
            yph=ytran(xhid,yhid,zhid,phase,fincr,q,istar,bdist)
            xph=xph+xxoff
            yph=yph+yyoff
!
!   UPDATE March 26, 2002
!
!   Remove the variable separ from the argument list of accphi.
!
!   UPDATE JULY 4, 2004
!
!   If MonteCarlo<10, then we need these calls to use interpolation.
!
            IF(montecarlo < 10)THEN
               IF(ksign == -1)CALL accphi(q,psi0,omega,phase,fincr,  &
                  istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,rhid,  &
                  phihid,nhoriz,xhoriz,yhoriz,phiacc,bdist,tidephi,  &
                  itide,ecc,thetamis,phimis,tertincl,tertbdist,  &
                  tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
               IF(ksign == -2)CALL accphi(q,psi0,omega,phase,fincr,  &
                  istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,rhid,  &
                  phihid,ndhoriz,dxhoriz,dyhoriz,phiacc,bdist,tidephi,  &
                  itide,ecc,thetamis,phimis,tertincl,tertbdist,  &
                  tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
               IF(ksign == -3)CALL accphi(q,psi0,omega,phase,fincr,  &
                  istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,rhid,  &
                  phihid,ndtop,dtopx,dtopy,phiacc,bdist,tidephi,itide,  &
                  ecc,thetamis,phimis,tertincl,tertbdist,tertphase,  &
                  tertq,axisscale,isw30,isw7,tertomega)
!
               IF(ksign == -4)CALL accphi(q,psi0,omega,phase,fincr,  &
                  istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,rhid,  &
                  phihid,nhoriz3,xhoriz3,yhoriz3,phiacc,bdist,tidephi,  &
                  itide,ecc,thetamis,phimis,tertincl,tertbdist,  &
                  tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
               iidx=mmdx(ialf,INDEX)
               diff=(phiar(iidx)-phiacc)
               IF(ABS(diff) < 2.0_dp)THEN
                  delphi(iidx)=(phiar(iidx)-phiacc)
               END IF
               IF(ABS(diff) >= 2.0_dp)THEN
                  IF(phiar(iidx) > 4.0_dp)THEN
                     phitemp=twopie-phiar(iidx)
                     delphi(iidx)=(phitemp+phiacc)
                  END IF
                  IF(phiacc > 4.0_dp)THEN
                     phitemp=twopie-phiacc
                     delphi(iidx)=(phitemp+phiar(iidx))
                  END IF
               END IF
!
!   end if Monte Carlo < 10
!
            END IF
!
!   end if ksign < 1
!
         END IF
!
      END DO
   END DO
!
!   UPDATE JULY 4, 2004
!
!   if -10 < MonteCarlo < 10, then we are done.
!
   IF((montecarlo < 10).AND.(montecarlo > -10))THEN
      DEALLOCATE(ihid)
      RETURN
   END IF

!   UPDATE JULY 1, 2004
!
!   Add a loop which will use Monte Carlo integration to
!   determine what fraction of a pixel is partially eclipsed
!   by the horizon of the star in front.  The variable MonteCarlo
!   sets the number of integrations.
!
   dtheta=pie/REAL(nalf,KIND=dp)
   overq=q
   IF(istar == 2)overq=1.0_dp/q
   iimin=iimin-1
   IF(montecarlo > 10)THEN
      IF(iimin < 1)iimin=1
   END IF
   iimax=iimax+1
   IF(montecarlo > 10)THEN
      IF(iimax > nalf)iimax=nalf
   END IF
!
   DO  ialf=1,nalf
      IF((isw13 > 0).AND.(istar == 1))THEN
         IF((ialf < ialfmin).OR.(ialf > ialfmax))CYCLE
      END IF
      r=0.0000001_dp
      theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
      DO  ibet=1,ibetlim(ialf)
         iidx=mmdx(ialf,ibet)
         IF(projarray(iidx) < 0.0_dp)CYCLE
!
!   UPDATE July 14, 2004
!
!   We have two options here.  If MonteCarlo > 10, then check
!   all pixels near the eclipsing horizon and get fractional
!   areas.  If MonteCarlo < -10, then check only the latitude row just
!   above the eclipsing horizon and the latitude row just below the
!   eclipsing horizon.
!
         IF(montecarlo > 10)THEN
            IF((iedgehor(iidx) == -10).OR.(iedgehor(iidx) > 5).OR.  &
               (ialf == iimin).OR.(ialf == iimax).OR.(ialf == iimin+1)  &
               .OR.(ialf == iimax-1))THEN
               dphi=twopie/REAL(ibetlim(ialf),KIND=dp)
               phi=-0.5_dp*dphi+dphi*REAL(ibet,KIND=dp)
               phi=phi+phistart(ialf)
!
!   This loop will find random theta,phi locations on the pixel in
!   question, compute x,y,z coordinates on the star, and determine
!   if that location is eclipsed.  It will then determine the fraction
!   of the pixel that is eclipsed.
!
               nloop=montecarlo
               nnhid=0
!
!   Do a check of the pixel corners and edges to see if they are eclipsed.
!   If all corners and all edges are eclipsed, then assume that the pixel
!   is completely hidden.  Likewise, if none of the corners or edges
!   are eclipsed, assume the pixel is completely visible
!
               DO  kk=-3,3
                  DO  ll=-3,3
                     phinew=(REAL(ll,KIND=dp)/6.0_dp)*dphi+phi
                     thetanew=(REAL(kk,KIND=dp)/6.0_dp)*dtheta+theta
                     snth=SIN(thetanew)
                     cnth=COS(thetanew)
                     cox=COS(phinew)*snth
                     coy=SIN(phinew)*snth
                     coz=cnth
                     CALL rad(overq,omega,cox,coy,coz,psi0,r,xx,yy,zz,  &
                        1,bdist,tidephi,itide,ecc,thetamis,phimis)
                     CALL poten(overq,omega,xx,yy,zz,psi,psix,psixx,  &
                        psiy,psiz,1,bdist,cox,coy,tidephi,itide,ecc,  &
                        thetamis,phimis)
                     xp=xtran(xx,yy,phase,q,istar,bdist)
                     yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
                     xp=xp+xxoff
                     yp=yp+yyoff
                     iyes=-1000
                     CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
                     IF(i3flag >= 1)THEN
                        CALL insidecircle(nhoriz3,xhoriz3,yhoriz3,xp,yp,iyes,icut)
                     END IF
                     IF(iyes == 100)THEN
                        nnhid=nnhid+1
                     END IF
                  END DO
               END DO
!
!   completely visible
!
               IF(nnhid == 0)GO TO 110
               IF(nnhid == 49)THEN
                  nnhid=nloop
!
!   completely hidden
!
                  GO TO 110
               END IF
               nnhid=0
!
!   UPDATE July 7, 2004
!
!   Use the Sobel sequence instead of ran9.
!
               DO  jj=1,nloop
                  phinew=(arrsobx(jj)-0.5_dp)*dphi+phi
                  thetanew=(arrsoby(jj)-0.5_dp)*dtheta+theta
                  snth=SIN(thetanew)
                  cnth=COS(thetanew)
                  cox=COS(phinew)*snth
                  coy=SIN(phinew)*snth
                  coz=cnth
                  CALL rad(overq,omega,cox,coy,coz,psi0,r,xx,yy,zz,1,  &
                     bdist,tidephi,itide,ecc,thetamis,phimis)
                  CALL poten(overq,omega,xx,yy,zz,psi,psix,psixx,  &
                     psiy,psiz,1,bdist,cox,coy,tidephi,itide,ecc,  &
                     thetamis,phimis)
                  xp=xtran(xx,yy,phase,q,istar,bdist)
                  yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
                  xp=xp+xxoff
                  yp=yp+yyoff
                  iyes=-1000
                  CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
                  IF(i3flag >= 1)THEN
                     CALL insidecircle(nhoriz3,xhoriz3,yhoriz3,xp,yp,iyes,icut)
                  END IF
                  IF(iyes == 100)THEN
                     nnhid=nnhid+1
                  END IF
               END DO
110            nvis=nloop-nnhid
               visib(iidx)=projarray(iidx)*(REAL(nvis,KIND=dp)/REAL(nloop,KIND=dp))
            END IF
!
!   end if MonteCarlo > 10
!
         END IF
!
!  Check only the latitude row just above and just below.
!
         IF(montecarlo < -10)THEN
            IF((ialf == iimin).OR.(ialf == iimax))THEN
               dphi=twopie/REAL(ibetlim(ialf),KIND=dp)
               phi=-0.5_dp*dphi+dphi*REAL(ibet,KIND=dp)
               phi=phi+phistart(ialf)
!
!   This loop will find random theta,phi locations on the pixel in
!   question, compute x,y,z coordinates on the star, and determine
!   if that location is eclipsed.  It will then determine the fraction
!   of the pixel that is eclipsed.
!
               nloop=ABS(montecarlo)
               nnhid=0
!
!   Do a check of the pixel corners and edges to see if they are eclipsed.
!   If all corners and all edges are eclipsed, then assume that the pixel
!   is completely hidden.  Likewise, if none of the corners or edges
!   are eclipsed, assume the pixel is completely visible
!
               DO  kk=-3,3
                  DO  ll=-3,3
                     phinew=(REAL(ll,KIND=dp)/6.0_dp)*dphi+phi
                     thetanew=(REAL(kk,KIND=dp)/6.0_dp)*dtheta+theta
                     snth=SIN(thetanew)
                     cnth=COS(thetanew)
                     cox=COS(phinew)*snth
                     coy=SIN(phinew)*snth
                     coz=cnth
                     CALL rad(overq,omega,cox,coy,coz,psi0,r,xx,yy,zz,  &
                        1,bdist,tidephi,itide,ecc,thetamis,phimis)
                     CALL poten(overq,omega,xx,yy,zz,psi,psix,psixx,  &
                        psiy,psiz,1,bdist,cox,coy,tidephi,itide,ecc, &
                        thetamis,phimis)
                     xp=xtran(xx,yy,phase,q,istar,bdist)
                     yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
                     xp=xp+xxoff
                     yp=yp+yyoff
                     iyes=-1000
                     CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
                     IF(i3flag >= 1)THEN
                        CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
                     END IF
                     IF(iyes == 100)THEN
                        nnhid=nnhid+1
                     END IF
                  END DO
               END DO
!
!    completely visible
!
               IF(nnhid == 0)GO TO 150
               IF(nnhid == 49)THEN
                  nnhid=nloop
!
!   completely hidden
!
                  GO TO 150
               END IF
!
!   UPDATE July 7, 2004
!
!   Use the Sobel sequence instead of ran9.
!
               nnhid=0
               DO  jj=1,nloop
                  phinew=(arrsobx(jj)-0.5_dp)*dphi+phi
                  thetanew=(arrsoby(jj)-0.5_dp)*dtheta+theta
                  snth=SIN(thetanew)
                  cnth=COS(thetanew)
                  cox=COS(phinew)*snth
                  coy=SIN(phinew)*snth
                  coz=cnth
                  CALL rad(overq,omega,cox,coy,coz,psi0,r,xx,yy,zz,1,  &
                     bdist,tidephi,itide,ecc,thetamis,phimis)
                  CALL poten(overq,omega,xx,yy,zz,psi,psix,psixx,  &
                     psiy,psiz,1,bdist,cox,coy,tidephi,itide,ecc,  &
                     thetamis,phimis)
                  xp=xtran(xx,yy,phase,q,istar,bdist)
                  yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
                  xp=xp+xxoff
                  yp=yp+yyoff
                  iyes=-1000
                  CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
                  IF(i3flag >= 1)THEN
                     CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
                  END IF
                  IF(iyes == 100)THEN
                     nnhid=nnhid+1
                  END IF
               END DO
150            nvis=nloop-nnhid
               visib(iidx)=projarray(iidx)*(REAL(nvis,KIND=dp)/REAL(nloop,KIND=dp))
            END IF
!
!   end if MonteCarlo < -10
!
         END IF
!
!  UPDATE January 9, 2010
!
!  Check points near the limb and find the fractions of points
!  visible.
!
         CYCLE
!
      END DO
   END DO
!
   DEALLOCATE(ihid)
!
   RETURN
!
END SUBROUTINE getvisib
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getvisib3(istar,ialphmax,ibetmax,nalf,ibetlim,  &
   phase,finc,q,omega,gradx,grady,gradz,xarray,yarray,  &
   zarray,visib,nhoriz1,xhoriz1,yhoriz1,nhoriz2,xhoriz2,yhoriz2,  &
   ncoords,xcoords,ycoords,projarray,neclipse,phiar,  &
   radarray,delphi,mmdx,montecarlo,phistart,thetamis,phimis,  &
   i3flag,iedgehor,tertincl,tertbdist,tertphase,tertq,axisscale,  &
   isw30,isw7,tertomega)
!
!   January 2, 2013
!
!   This routine will find the visibilities of the third star, if
!   present
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: gradx(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: grady(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gradz(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: xarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: yarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: zarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: visib(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: nhoriz1
   REAL(KIND=dp), INTENT(IN)                :: xhoriz1(nhoriz1)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz1(nhoriz1)
   INTEGER, INTENT(IN)                      :: nhoriz2
   REAL(KIND=dp), INTENT(IN)                :: xhoriz2(nhoriz2)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz2(nhoriz2)
   INTEGER, INTENT(OUT)                     :: ncoords
   REAL(KIND=dp), INTENT(OUT)               :: xcoords(ialphmax*ibetmax*4)
   REAL(KIND=dp), INTENT(OUT)               :: ycoords(ialphmax*ibetmax*4)
   REAL(KIND=dp), INTENT(OUT)               :: projarray(ialphmax*ibetmax)
   INTEGER, INTENT(OUT)                     :: neclipse
   REAL(KIND=dp), INTENT(IN)                :: phiar(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: radarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: delphi(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   INTEGER, INTENT(IN)                      :: montecarlo
   REAL(KIND=dp), INTENT(IN)                :: phistart(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
   INTEGER, INTENT(IN)                      :: i3flag
   INTEGER, INTENT(OUT)                     :: iedgehor(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp) :: proj,theta,xsob,fincr,phaser,ax,tidephi,ay
   REAL(KIND=dp) :: xp,yp,tertxtrans,tertytrans,bdist,az,rhid,phiacc
   REAL(KIND=dp) :: xx,yy,zz,xvis,yvis,zvis,rvis,phivis,xhid,yhid,zhid,ecc
   REAL(KIND=dp) :: diff,phitemp,dtheta,r,dphi,phi,phinew,thetanew,snth
   REAL(KIND=dp) :: cnth,cox,coy,coz,psix,psiy,psiz,psixx,overq,psi,phihid
!
   INTEGER, ALLOCATABLE   :: ihid(:)
   INTEGER :: i,ialf,ibet,j,iidx,iimin
   INTEGER :: iimax,iyes1,icut,iyes2,INDEX,izz,jzz,jjdx,ksign
   INTEGER :: itide,nloop,nnhid,kk,ll,iyes,nnn,nvis,jj
!
   DIMENSION xsob(2)
!
   ALLOCATE(ihid(200000))
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!   Initialize some variables here
!
   proj=0.0_dp
   theta=0.0_dp
   ibet=1
!
   fincr=finc*degtorad
   xp=tertxtrans(0.0_dp,0.0_dp,0.0_dp,tertphase,tertincl,tertq,  &
      tertbdist,axisscale,tertomega)
   yp=tertytrans(0.0_dp,0.0_dp,0.0_dp,tertphase,tertincl,tertq,  &
      tertbdist,axisscale,tertomega)
!
!  initialize the visibities!
!
   DO  i=1,nalf
      DO  j=1,ibetlim(i)
         iidx=mmdx(i,j)
         visib(iidx)=0.0_dp
         projarray(iidx)=-1.0_dp
         ihid(iidx)=-1
         delphi(iidx)=-999.9_dp
      END DO
   END DO
!
   phaser=tertphase*degtorad
   fincr=tertincl*degtorad
   az=COS(fincr)
   IF(az < 0.0_dp)az=0.0_dp
   ax=-SIN(fincr)*COS(phaser)
   ay=SIN(fincr)*SIN(phaser)
!
!   find the projection factors.
!
   ncoords=0
   neclipse=0
   iimin=12345678
   iimax=-12345678
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
         iidx=mmdx(ialf,ibet)
         proj=ax*gradx(iidx)+ay*grady(iidx)+az*gradz(iidx)
         projarray(iidx)=proj
         visib(iidx)=proj
!
!  is the surface element visible?
!
         IF(proj < 0.0_dp)CYCLE
         xx=xarray(iidx)
         yy=yarray(iidx)
         zz=zarray(iidx)
         xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertq,tertbdist,  &
            axisscale,tertomega)
         yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertq,tertbdist,  &
            axisscale,tertomega)
!
!  if I3flag=0, then the third body is behind  the binary.  Check
!  for eclipses
!
         IF(i3flag < 1)THEN
            iyes1=-100
            CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes1,icut)
            IF(iyes1 == 100)THEN
               neclipse=neclipse+1
               visib(iidx)=0.0_dp
               ihid(iidx)=1
               CYCLE
            END IF
         END IF
!
!   Check to see of the point in question is eclipsed by the other star.
!
         IF(i3flag < 1)THEN
            iyes2=-100
            CALL insidecircle(nhoriz2,xhoriz2,yhoriz2,xp,yp,iyes2,icut)
            IF(iyes2 == 100)THEN
!
!  eclipsed by secondary
!
               ihid(iidx)=2
               neclipse=neclipse+1
               visib(iidx)=0.0_dp
               CYCLE
            END IF
         END IF
         ncoords=ncoords+1
         xcoords(ncoords)=xp
         ycoords(ncoords)=yp
!
      END DO
   END DO
!
!   Now we have to go along the beta direction and find out which visible
!   point is nearest to the eclipsing horizon.
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
         iidx=mmdx(ialf,ibet)
         IF(projarray(iidx) <= 0.0_dp)CYCLE
         IF(ibet < ibetlim(ialf))THEN
            INDEX=ibet+1
         ELSE
            INDEX=1
         END IF
!
         izz=ialf
         jzz=INDEX
         jjdx=mmdx(izz,jzz)
         IF(projarray(jjdx) <= 0.0_dp)CYCLE
         izz=ialf
         jzz=ibet
         iidx=mmdx(izz,jzz)
         ksign=ihid(iidx)*ihid(jjdx)
!
         IF(ksign == -1)THEN
!
!  crossed through the horizon
!
            IF(ihid(iidx) == -1)THEN
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
               xvis=xarray(iidx)
               yvis=yarray(iidx)
               zvis=zarray(iidx)
               rvis=radarray(iidx)
               phivis=phiar(iidx)
               iedgehor(iidx)=10
!
               izz=ialf
               jzz=INDEX
               iidx=mmdx(izz,jzz)
               xhid=xarray(iidx)
               yhid=yarray(iidx)
               zhid=zarray(iidx)
               rhid=radarray(iidx)
               phihid=phiar(iidx)
               iedgehor(iidx)=-10
               INDEX=ibet
            ELSE
               izz=ialf
               jzz=INDEX
               iidx=mmdx(izz,jzz)
               xvis=xarray(iidx)
               yvis=yarray(iidx)
               zvis=zarray(iidx)
               rvis=radarray(iidx)
               phivis=phiar(iidx)
               iedgehor(iidx)=20
!
               izz=ialf
               jzz=ibet
               iidx=mmdx(izz,jzz)
               xhid=xarray(iidx)
               yhid=yarray(iidx)
               zhid=zarray(iidx)
               rhid=radarray(iidx)
               phihid=phiar(iidx)
               iedgehor(iidx)=-10
            END IF
!
            psi=1.0E+03_dp
            overq=1.0_dp/30.0_dp
            IF(montecarlo < 10)THEN
               IF(ksign == -1)CALL accphi(overq,psi,omega,phase,  &
                  fincr,istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,  &
                  zhid,rhid,phihid,nhoriz1,xhoriz1,yhoriz1,phiacc,  &
                  bdist,tidephi,itide,ecc,thetamis,phimis,tertincl,  &
                  tertbdist,tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
               IF(ksign == -2)CALL accphi(overq,psi,omega,phase,  &
                  fincr,istar,xvis,yvis,zvis,rvis,phivis,xhid,yhid,  &
                  zhid,rhid,phihid,nhoriz2,xhoriz2,yhoriz2,phiacc,  &
                  bdist,tidephi,itide,ecc,thetamis,phimis,tertincl,  &
                  tertbdist,tertphase,tertq,axisscale,isw30,isw7,tertomega)
!
               iidx=mmdx(ialf,INDEX)
               diff=(phiar(iidx)-phiacc)
!
               IF(ABS(diff) < 2.0_dp)THEN
                  delphi(iidx)=(phiar(iidx)-phiacc)
               END IF
               IF(ABS(diff) >= 2.0_dp)THEN
                  IF(phiar(iidx) > 4.0_dp)THEN
                     phitemp=twopie-phiar(iidx)
                     delphi(iidx)=(phitemp+phiacc)
                  END IF
                  IF(phiacc > 4.0_dp)THEN
                     phitemp=twopie-phiacc
                     delphi(iidx)=(phitemp+phiar(iidx))
                  END IF
               END IF
!
!  end if MonteCarlo < 10
!
            END IF
         END IF
!
      END DO
   END DO
!
!   UPDATE JULY 4, 2004
!
!   if -10 < MonteCarlo < 10, then we are done.
!
   IF((montecarlo < 10).AND.(montecarlo > -10))THEN
      DEALLOCATE(ihid)
      RETURN
   END IF
!
!   UPDATE JULY 1, 2004
!
!   Add a loop which will use Monte Carlo integration to
!   determine what fraction of a pixel is partially eclipsed
!   by the horizon of the star in front.  The variable MonteCarlo
!   sets the number of integrations.
!
   dtheta=pie/REAL(nalf,KIND=dp)
   overq=q
   IF(istar == 2)overq=1.0_dp/q
!
   iimin=iimin-1
   IF(montecarlo > 10)THEN
      IF(iimin < 1)iimin=1
   END IF
   iimax=iimax+1
   IF(montecarlo > 10)THEN
      IF(iimax > nalf)iimax=nalf
   END IF
!
   DO  ialf=1,nalf
      r=0.0000001_dp
      theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
      DO  ibet=1,ibetlim(ialf)
         iidx=mmdx(ialf,ibet)
!
         IF(projarray(iidx) < 0.0_dp)CYCLE
!
!   UPDATE July 14, 2004
!
!   We have two options here.  If MonteCarlo > 10, then check
!   all pixels near the eclipsing horizon and get fractional
!   areas.  If MonteCarlo < -10, then check only the latitude row just
!   above the eclipsing horizon and the latitude row just below the
!   eclipsing horizon.
!
         IF(montecarlo > 10)THEN
            IF((iedgehor(iidx) == -10).OR.(iedgehor(iidx) > 5).OR.  &
               (ialf == iimin).OR.(ialf == iimax).OR.(ialf == iimin+1)  &
               .OR.(ialf == iimax-1))THEN
               dphi=twopie/REAL(ibetlim(ialf),KIND=dp)
               phi=-0.5_dp*dphi+dphi*REAL(ibet,KIND=dp)
               phi=phi+phistart(ialf)
!
!   This loop will find random theta,phi locations on the pixel in
!   question, compute x,y,z coordinates on the star, and determine
!   if that location is eclipsed.  It will then determine the fraction
!   of the pixel that is eclipsed.
!
               nloop=montecarlo
               nnhid=0
!
!   Do a check of the pixel corners and edges to see if they are eclipsed.
!   If all corners and all edges are eclipsed, then assume that the pixel
!   is completely hidden.  Likewise, if none of the corners or edges
!   are eclipsed, assume the pixel is completely visible
!
               DO  kk=-3,3
                  DO  ll=-3,3
                     phinew=(REAL(ll,KIND=dp)/6.0_dp)*dphi+phi
                     thetanew=(REAL(kk,KIND=dp)/6.0_dp)*dtheta+theta
                     snth=SIN(thetanew)
                     cnth=COS(thetanew)
                     cox=COS(phinew)*snth
                     coy=SIN(phinew)*snth
                     coz=cnth
                     CALL rad(overq,omega,cox,coy,coz,psi,r,xx,yy,zz,  &
                        1,bdist,tidephi,itide,ecc,thetamis,phimis)
                     CALL poten(overq,omega,xx,yy,zz,psi,psix,psixx,  &
                        psiy,psiz,1,bdist,cox,coy,tidephi,itide,ecc, &
                        thetamis,phimis)
                     xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertq,  &
                        tertbdist,axisscale,tertomega)
                     yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertq,  &
                        tertbdist,axisscale,tertomega)
                     iyes=-1000
                     IF(i3flag < 1)THEN
                        CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,icut)
                        CALL insidecircle(nhoriz2,xhoriz2,yhoriz2,xp,yp,iyes,icut)
                     END IF
!
                     IF(iyes == 100)THEN
                        nnhid=nnhid+1
                     END IF
                  END DO
               END DO
!
               IF(nnhid == 0)GO TO 100
!
!   completely visible
!
               IF(nnhid == 49)THEN
!
!   completely hidden
!
                  nnhid=nloop
                  GO TO 100
               END IF
               nnhid=0
!
!   UPDATE July 7, 2004
!
!   Use the Sobel sequence instead of ran9.
!
               nnn=2
               DO  jj=1,nloop
                  CALL sobseq(nnn,xsob)
                  phinew=(xsob(1)-0.5_dp)*dphi+phi
                  thetanew=(xsob(2)-0.5_dp)*dtheta+theta
!
                  snth=SIN(thetanew)
                  cnth=COS(thetanew)
                  cox=COS(phinew)*snth
                  coy=SIN(phinew)*snth
                  coz=cnth
                  CALL rad(overq,omega,cox,coy,coz,psi,r,xx,yy,zz,1,  &
                     bdist,tidephi,itide,ecc,thetamis,phimis)
                  CALL poten(overq,omega,xx,yy,zz,psi,psix,psixx,  &
                     psiy,psiz,1,bdist,cox,coy,tidephi,itide,ecc,  &
                     thetamis,phimis)
                  xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertq,  &
                     tertbdist,axisscale,tertomega)
                  yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertq,  &
                     tertbdist,axisscale,tertomega)
!
                  iyes=-1000
                  IF(i3flag < 1)THEN
                     CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,icut)
                     CALL insidecircle(nhoriz2,xhoriz2,yhoriz2,xp,yp,iyes,icut)
                  END IF
                  IF(iyes == 100)THEN
                     nnhid=nnhid+1
                  END IF
               END DO
100            nvis=nloop-nnhid
               visib(iidx)=projarray(iidx)*(REAL(nvis,KIND=dp)/REAL(nloop,KIND=dp))
            END IF
!
!   end if MonteCarlo > 10
!
         END IF
!
!  Check only the latitude row just above and just below.
!
         IF(montecarlo < -10)THEN
            IF((ialf == iimin).OR.(ialf == iimax))THEN
               dphi=twopie/REAL(ibetlim(ialf),KIND=dp)
               phi=-0.5_dp*dphi+dphi*REAL(ibet,KIND=dp)
               phi=phi+phistart(ialf)
!
!   This loop will find random theta,phi locations on the pixel in
!   question, compute x,y,z coordinates on the star, and determine
!   if that location is eclipsed.  It will then determine the fraction
!   of the pixel that is eclipsed.
!
               nloop=ABS(montecarlo)
               nnhid=0
!
!   Do a check of the pixel corners and edges to see if they are eclipsed.
!   If all corners and all edges are eclipsed, then assume that the pixel
!   is completely hidden.  Likewise, if none of the corners or edges
!   are eclipsed, assume the pixel is completely visible
!
               DO  kk=-3,3
                  DO  ll=-3,3
                     phinew=(REAL(ll,KIND=dp)/6.0_dp)*dphi+phi
                     thetanew=(REAL(kk,KIND=dp)/6.0_dp)*dtheta+theta
                     snth=SIN(thetanew)
                     cnth=COS(thetanew)
                     cox=COS(phinew)*snth
                     coy=SIN(phinew)*snth
                     coz=cnth
                     CALL rad(overq,omega,cox,coy,coz,psi,r,xx,yy,zz,  &
                        1,bdist,tidephi,itide,ecc,thetamis,phimis)
                     CALL poten(overq,omega,xx,yy,zz,psi,psix,psixx,  &
                        psiy,psiz,1,bdist,cox,coy,tidephi,itide,ecc,  &
                        thetamis,phimis)
                     xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertq,  &
                        tertbdist,axisscale,tertomega)
                     yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertq,  &
                        tertbdist,axisscale,tertomega)
!
                     iyes=-1000
                     IF(i3flag >= 1)THEN
                        CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,icut)
                        CALL insidecircle(nhoriz2,xhoriz2,yhoriz2,xp,yp,iyes,icut)
                     END IF
                     IF(iyes == 100)THEN
                        nnhid=nnhid+1
                     END IF
                  END DO
               END DO
!
               IF(nnhid == 0)GO TO 140
!
!    completely visible
!
               IF(nnhid == 49)THEN
!
!    completely hidden
!
                  nnhid=nloop
                  GO TO 140
               END IF
               nnhid=0
!
!   UPDATE July 7, 2004
!
!   Use the Sobel sequence instead of ran9.
!
               nnn=2
               DO  jj=1,nloop
                  CALL sobseq(nnn,xsob)
                  phinew=(xsob(1)-0.5_dp)*dphi+phi
                  thetanew=(xsob(2)-0.5_dp)*dtheta+theta
!
                  snth=SIN(thetanew)
                  cnth=COS(thetanew)
                  cox=COS(phinew)*snth
                  coy=SIN(phinew)*snth
                  coz=cnth
                  CALL rad(overq,omega,cox,coy,coz,psi,r,xx,yy,zz,1,  &
                     bdist,tidephi,itide,ecc,thetamis,phimis)
                  CALL poten(overq,omega,xx,yy,zz,psi,psix,psixx,  &
                     psiy,psiz,1,bdist,cox,coy,tidephi,itide,ecc,  &
                     thetamis,phimis)
                  xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertq,  &
                     tertbdist,axisscale,tertomega)
                  yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertq,  &
                     tertbdist,axisscale,tertomega)
!
                  iyes=-1000
                  IF(i3flag >= 1)THEN
                     CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,icut)
                     CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,icut)
                  END IF
                  IF(iyes == 100)THEN
                     nnhid=nnhid+1
                  END IF
               END DO
140            nvis=nloop-nnhid
               visib(iidx)=projarray(iidx)*(REAL(nvis,KIND=dp)/REAL(nloop,KIND=dp))
            END IF
!
!   end if Monte Carlo < -10
!
         END IF
!
         CYCLE
      END DO
   END DO
!
   DEALLOCATE(ihid)
!
   RETURN
!
END SUBROUTINE getvisib3
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getwin(ndynwin,dynwinlow,dynwinhigh,tstart,tend,hh)
!
!  Gets the "windows" used for the dynamical integrator
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN OUT)                  :: ndynwin
   REAL(KIND=dp), INTENT(OUT)               :: dynwinlow(1000)
   REAL(KIND=dp), INTENT(OUT)               :: dynwinhigh(1000)
   REAL(KIND=dp), INTENT(IN)                :: tstart
   REAL(KIND=dp), INTENT(IN)                :: tend
   REAL(KIND=dp), INTENT(IN)                :: hh
!
   REAL(KIND=dp)  :: tin,tmin,diff,diffmin
!
   INTEGER :: ios,i,j,nstep
!
!   Declare the variable bell to be character*1
!
   CHARACTER (LEN=1) :: bell
!
   tmin=0.0_dp
!
   DO i=1,1000
      dynwinlow(i)=0.0_dp
      dynwinhigh(i)=0.0_dp
   END DO
!
   dynwinlow(1)=tstart
   dynwinhigh(1)=tend
   IF(ndynwin == 0)THEN
      ndynwin=1
      RETURN
   END IF
   IF(ndynwin == 1)RETURN
!
   bell=CHAR(7)
   ios=0
   OPEN(UNIT=1,FILE='ELCdynwin.inp',STATUS='old',ERR=20,IOSTAT=ios)
!
   IF(ndynwin > 999)ndynwin=999
!
   DO  i=1,ndynwin
      READ(1,*,ERR=30,END=30)dynwinlow(i),dynwinhigh(i)
      IF(dynwinlow(i) > dynwinhigh(i))GO TO 30
   END DO
!
   dynwinlow(1)=tstart
   dynwinhigh(ndynwin)=tend
!
!  Make sure the boundaries are multiples of hh from tstart
!
   IF(ndynwin > 1)THEN
      nstep=INT((tend-tstart)/hh)
      DO i=1,ndynwin-1
         diffmin=1.0E33_dp
         DO j=1,nstep
            tin=REAL(j,KIND=dp)*hh+tstart
            diff=ABS(tin-dynwinhigh(i))
            IF(diff < diffmin)THEN
               diffmin=diff
               tmin=tin
            END IF
         END DO
         dynwinhigh(i)=tmin
      END DO
!
      DO i=2,ndynwin
         diffmin=1.0E33_dp
         DO j=1,nstep
            tin=REAL(j,KIND=dp)*hh+tstart
            diff=ABS(tin-dynwinlow(i))
            IF(diff < diffmin)THEN
               diffmin=diff
               tmin=tin
            END IF
         END DO
         dynwinlow(i)=tmin
      END DO
   END IF
!
   IF(ios == 0)THEN
      CLOSE(1)
      RETURN
   END IF
!
!   Come here if the input file ELCdynwin.inp does not exist.
!
20 WRITE(*,40)bell
   ndynwin=1
   RETURN
!
30 WRITE(*,50)bell
   ndynwin=1
   CLOSE(1)
!
40 FORMAT(a1,'Error:  ELCdynwin.inp not found, setting Ndynwin', '=1')
50 FORMAT(a1,'Error:  Bad entry in ELCdynwin.inp, setting ',  &
      'Ndynwin=1')
!
   RETURN
!
END SUBROUTINE getwin
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getx(em,bige)
!
!    Solve for bigE in  em = bigE - sin(bigE)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: em
   REAL(KIND=dp), INTENT(OUT)                      :: bige
!
   REAL(KIND=dp) ::  eold,top,bottom,diff,enew
!
   INTEGER :: i
!
   eold=em
   DO  i=1,20
      top=eold-SIN(eold)-em
      bottom=1.0_dp-COS(eold)
      enew=eold-top/bottom
      diff=ABS(enew-eold)
!
!      IF(PRECISION(diff).ge.18)THEN
!        IF(diff < 1.0E-18_dp)EXIT
!      ELSE
!        IF(diff < 1.0E-15_dp)EXIT
!      END IF
!
      IF(diff < 10.0_dp*EPSILON(diff))EXIT
      eold=enew
   END DO
!
   bige=eold
!
   RETURN
!
END SUBROUTINE getx
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE getxecl(nhoriz,xhoriz,yhoriz,ixecl,q,finc,bdist,  &
   phase,tertincl,tertbdist,tertphase,tertq,axisscale,isw30,  &
   isw7,tertomega)
!
!   UPDATE September 10, 2001
!
!   This routine will check to see if the center of star 2 is eclipsed
!   by star 1.  ixecl=100 if eclipsed, zero otherwise.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nhoriz
   REAL(KIND=dp), INTENT(IN)                :: xhoriz(nhoriz)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz(nhoriz)
   INTEGER, INTENT(OUT)                     :: ixecl
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp)  :: fincr,xp,yp,xxoff,yyoff
   REAL(KIND=dp)  :: xxoff1,yyoff1,tomrad,tertxcen,tertycen,xtran,ytran
!
   INTEGER :: iyes,icut,istar
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!    November 18, 2012
!
!    If there is a third body, offset all x and y sky coordinates
!
   xxoff=0.0_dp
   yyoff=0.0_dp
   IF((isw30 >= 3).AND.(isw7 >= 2))THEN
      xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      tomrad=tertomega*degtorad
      xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
      yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
   END IF
!
   fincr=finc*degtorad
!
   istar=1
!
   xp=xtran(bdist,0.0_dp,phase,q,istar,bdist)
   yp=ytran(bdist,0.0_dp,0.0_dp,phase,fincr,q,istar,bdist)
   xp=xp+xxoff
   yp=yp+yyoff
!
!   If we are looking at star 2 and there is a disk, then check to
!   see if the points are *inside* the top horizon of the disk.
!
   ixecl=-100
   iyes=-100
   CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
   IF(iyes == 100)ixecl=100
!
   RETURN
!
END SUBROUTINE getxecl
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gni_irk2(n,nstep,x,p,q,meth,iout,  &
   rpar,ipar,rmass,nbody,posarray,velarray,odetime,zzq,  &
   timeinterp,ndyn,h,igr)
!
!-----------------------------------------------------------------
!                 VERSION OF SEPTEMBER 4,2002
!  E-MAIL CONTACT ADDRESS : Ernst.Hairer@math.unige.ch
!------------------------------------------------------------------
!  SOLVES SECOND ORDER ORDINARY DIFFERENTIAL EQUATIONS OF THE FORM
!                       Q'' = F(X,Q)
!  BASED ON THE SYMPLECTIC AND SYMMETRIC GAUSS (IRK) METHODS
!  DESCRIBED IN SECTIONS II.1, VIII.6 OF THE BOOK:
!
!      E. HAIRER, C. LUBICH, G. WANNER, GEOMETRIC NUMERICAL
!         INTEGRATION, STRUCTURE-PRESERVING ALGORITHMS FOR ODES.
!         SPRINGER SERIES IN COMPUT. MATH. 31, SPRINGER 2002.
!
!  AND IN THE PUBLICATION
!
!      E. HAIRER, M. HAIRER, GNI-CODES - MATLAB PROGRAMS FOR
!         GEOMETRIC NUMERICAL INTEGRATION.
!
!  INPUT..
!     N           DIMENSION OF Q AND F(X,Q)
!
!     FCN         NAME (EXTERNAL) OF SUBROUTINE COMPUTING F(X,Q):
!                    SUBROUTINE FCN(N,X,Q,F,RPAR,IPAR)
!                    REAL*8 Q(N),F(N)
!                    F(1)=...   ETC.
!
!     NSTEP       NUMBER OF INTEGRATION STEPS
!                    CONSTANT STEP SIZE, H=(XEND-X)/NSTEP
!
!     X           INITIAL X-VALUE
!     P(N)        INITIAL VELOCITY VECTOR
!     Q(N)        INITIAL POSITION VECTOR
!     XEND        FINAL X-VALUE
!
!     METH        NUMBER OF STAGES OF THE GAUSS METHOD
!                    FOR THE MOMENT ONLY POSSIBLE VALUES: 2,4,6.
!
!     SOLFIX      NAME (EXTERNAL) OF SUBROUTINE PROVIDING THE
!                 NUMERICAL SOLUTION DURING INTEGRATION.
!                 IF IOUT=1, IT IS CALLED AFTER EVERY STEP.
!                 SUPPLY A DUMMY SUBROUTINE IF IOUT=0.
!                    SUBROUTINE SOLFIX (NR,XOLD,X,P,Q,N,IRTRN,RPAR,IPAR)
!                    DOUBLE PRECISION X,Y(N),CONT(LRC)
!                      ....
!                 SOLFIX FURNISHES THE SOLUTION "Q,P" AT THE NR-TH
!                    GRID-POINT "X" (INITIAL VALUE FOR NR=0).
!                 "XOLD" IS THE PRECEEDING GRID-POINT.
!                 "IRTRN" SERVES TO INTERRUPT THE INTEGRATION. IF IRTRN
!                    IS SET <0, RETURN TO THE CALLING PROGRAM.
!     IOUT        SWITCH FOR CALLING THE SUBROUTINE SOLFIX:
!                    IOUT=0: SUBROUTINE IS NEVER CALLED
!                    IOUT=1: SUBROUTINE IS AVAILABLE FOR OUTPUT.
!
!     RPAR(LR)    REAL PARAMETER ARRAY; LR MUST BE AT LEAST LR=10
!                    RPAR(1),...,RPAR(10) SERVE AS PARAMETERS FOR
!                    THE CODE. FURTHER VALUES CAN BE USED FOR DEFINING
!                    PARAMETERS IN THE PROBLEM
!     IPAR(LI)    INTEGER PARAMETER ARRAY; LI MUST BE AT LEAST LI=10
!                    IPAR(1),...,IPAR(10) SERVE AS PARAMETERS FOR
!                    THE CODE. FURTHER VALUES CAN BE USED FOR DEFINING
!                    PARAMETERS IN THE PROBLEM
!
!  OUTPUT..
!     P(N)        SOLUTION (VELOCITY) AT XEND
!     Q(N)        SOLUTION (POSITION) AT XEND
!--------------------------------------------------------------------
!     SOPHISTICATED SETTING OF PARAMETERS
!--------------------------------------------------------------------
!    RPAR(1)   UROUND, THE ROUNDING UNIT, DEFAULT 1.D-16.
!    IPAR(1)   NITMAX, MAXIMAL NUMER OF FIXED POINT ITERAT.,
!    DEFAULT 50
!--------------------------------------------------------------------
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(IN)                      :: n
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN OUT)            :: x
   REAL(KIND=dp), INTENT(IN OUT)            :: p(n)
   REAL(KIND=dp), INTENT(IN OUT)            :: q(n)
   INTEGER, INTENT(IN)                      :: meth
   INTEGER, INTENT(IN)                      :: iout
   REAL(KIND=dp), INTENT(IN OUT)            :: rpar(*)
   INTEGER, INTENT(IN OUT)                  :: ipar(*)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(OUT)               :: posarray(2,30)
   REAL(KIND=dp), INTENT(OUT)               :: velarray(2,30)
   REAL(KIND=dp), INTENT(OUT)               :: odetime(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: zzq(6,60,2)
   REAL(KIND=dp), INTENT(OUT)               :: timeinterp(6)
   REAL(KIND=dp), INTENT(IN)                :: h
   INTEGER, INTENT(IN)                      :: igr
!
   REAL(KIND=dp)  :: f,EQ,ep,yh,qq,c,aa,e,b,bc
   REAL(KIND=dp)  :: sm,am,aat,fs,ps,zq,fm,rsult,fakeb,fakec,uround
   REAL(KIND=dp)  :: fac,dynold,dyno,dotprodij,eqi,qi,ay,epi,pi
!
   INTEGER :: nitmax,ns,jj,is,i,istep,ii,nm,niter,j,js,k
!
   INTEGER, PARAMETER :: ndgl=500
   INTEGER, PARAMETER :: nsd=6
   INTEGER, PARAMETER :: nmd=3
!
   DIMENSION f(ndgl*nsd),EQ(ndgl),ep(ndgl),yh(ndgl),qq(ndgl)
   DIMENSION c(nsd),aa(nsd,nsd),e(nsd,nsd+nmd),b(nsd),bc(nsd)
   DIMENSION sm(nmd),am(nsd+nmd),aat(nsd,nsd)
   DIMENSION fs(ndgl),ps(ndgl),zq(ndgl,nsd)
   DIMENSION fm(30,6),rsult(30,6),fakeb(6),fakec(6)
!
!   old dimension for zzq when
!
!          DIMENSION zzq(6,60,Ndyn)
!
!          EXTERNAL FCN
!          EXTERNAL SOLFIX
!
! -------- UROUND   SMALLEST NUMBER SATISFYING 1.0D0+UROUND>1.0D0
!
   IF(ABS(rpar(1)) <= EPSILON(rpar(1)))THEN
      uround=1.0E-16_dp
   ELSE
      uround=rpar(1)
   END IF
!
! -------- NITMAX, MAXIMAL NUMER OF FIXED POINT ITERATIONS
!
   IF(ipar(1) == 0)THEN
      nitmax=50
   ELSE
      nitmax=ipar(1)
   END IF
!
! --------
!
   ns=meth
   IF(PRECISION(uround).eq.18)THEN
     uround=1.0E-22_dp
   ELSE
     uround=1.0E-19_dp
   END IF
!
   CALL coefg(ns,c,b,bc,nsd,aa,e,nm,sm,nmd,am,h)
!
!          write(*,*)'C = ',C
!          write(*,*)'B = ',B
!          write(*,*)'AA(1,1) = ',AA(1,1)
!          write(*,*)'AA(1,2) = ',AA(1,2)
!          write(*,*)'AA(1,3) = ',AA(1,3)
!          write(*,*)'AA(1,4) = ',AA(1,4)
!          write(*,*)'AA(1,5) = ',AA(1,5)
!          write(*,*)'AA(1,6) = ',AA(1,6)

   DO jj=1,6
      timeinterp(jj)=c(jj)
   END DO
   IF(iout /= 0)CALL solfix(0,p,q,n,rpar,rmass,nbody)
   CALL equa(n,q,fs,ipar,rmass,nbody)
   DO is=1,ns
      fac=c(is)**2/2.0_dp
      DO i=1,n
         zq(i,is)=c(is)*p(i)+fac*fs(i)
      END DO
   END DO
   DO i=1,n
      ps(i)=p(i)
      EQ(i)=0.0_dp
      ep(i)=0.0_dp
   END DO
!
! --- LOOP FOR THE ITERATIONS
!
   DO istep=1,nstep
      IF(istep > 1)CALL startb(n,p,q,ns,ndgl,fs,ps,zq,nsd,  &
         e,yh,nm,am,f,c,ipar,rmass,nbody)
!
! --- FIXED POINT ITERATION
!
      DO i=1,n
         DO is=1,6
            IF(istep <= 2)zzq(is,i,istep)=q(i)+zq(i,is)
         END DO
      END DO
      odetime(istep)=x
      IF(istep < 2)THEN
         DO ii=1,n
            posarray(istep,ii)=q(ii)
            velarray(istep,ii)=p(ii)
         END DO
      END IF
!
      niter=0
      dynold=0.0_dp
!
10    CALL rknite(n,ns,q,p,nsd,aa,c,ndgl,qq,zq,f,dyno,  &
         ipar,rmass,nbody)
      niter=niter+1
      IF(igr > 0.AND.niter >= 2)GO TO 20
      IF(dynold < dyno.AND.dyno < 10*uround)GO TO 20
      IF(niter >= nitmax)THEN
         WRITE(6,*) 'NO CONVERGENCE OF ITERATION',dyno
         IF(dyno > uround*1.0E06_dp)RETURN
      END IF
      IF(dyno > 0.1_dp*uround)GO TO 10
!
20    CONTINUE
!
      CALL gaussq(6,fakec,fakeb,6,aat)
      DO js=1,6
         DO j=1,n
            fm(j,js)=f(j+(js-1)*n)
         END DO
      END DO
!
      DO i=1,n
         DO j=1,6
            dotprodij=0.0_dp
            DO k=1,6
               dotprodij=dotprodij+fm(i,k)*(aat(j,k))
            END DO
            rsult(i,j)=dotprodij
         END DO
      END DO
!
      DO ii=1,n
         DO is=1,6
            IF(istep <= 2)zzq(is,ii+n,istep)=p(ii)+rsult(ii,is)*h
         END DO
      END DO
!
      DO i=1,n
         DO is=1,6
            IF(istep <= 2)zzq(is,i,istep)=q(i)+zq(i,is)
         END DO
      END DO
!
! --- UPDATE OF THE SOLUTION
!
      x=x+h
      DO i=1,n
         eqi=EQ(i)
         qi=q(i)
         ay=qi
         eqi=eqi+h*p(i)
         qi=ay+eqi
         eqi=eqi+(ay-qi)
         DO is=1,ns
            ay=qi
            eqi=eqi+f(i+(is-1)*n)*bc(is)
            qi=ay+eqi
            eqi=eqi+(ay-qi)
         END DO
         ay=q(i)
         q(i)=qi
         EQ(i)=eqi
         epi=ep(i)
         pi=p(i)
         DO is=1,ns/2
            ay=pi
            epi=epi+(f(i+(is-1)*n)+f(i+(ns-is)*n))*b(is)
            pi=ay+epi
            epi=epi+(ay-pi)
         END DO
         p(i)=pi
         ep(i)=epi
      END DO
!
      IF(iout /= 0)CALL solfix(istep,p,q,n,rpar,rmass,nbody)
!
!  the times were here
!
   END DO
!
   RETURN
!
END SUBROUTINE gni_irk2
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE goback(nbody,h,tstart,tend,nstep,qq,pp,rmass,  &
   posarray,velarray,odetime,zzq,timeinterp,ndyn,igr,tideparm,  &
   isw80)
!
!   This will integrate the equations of motion using a 12th order
!   Gaussian Runga Kutta scheme devised by E. Hairer.
!
!   It will be used in cases where tstart is not equal to tref
!
!   Nbody = number of bodies, limit 10.  Body 1 is the primary
!   of the binary and body 2 is the secondary.
!
!   h = the stepsize in days.  It should be about P_binary/400
!     or smaller
!
!   tstart,tend =  The start and end times of the integration, in days
!
!   Nstep = the number of integration steps, which is computed below
!
!   QQ = the array with the positions of each body in AU:
!        QQ(1) = x-coordinate of primary
!        QQ(2) = y-coordinate of primary
!        QQ(3) = z-coordinate of primary
!        QQ(4) = x-coordinate of secondary
!
!   PP = the array with the velocities, in AU/day
!
!   rmass = the array with the masses in solar masses
!
!   posarray, velarray = arrays of dimension (Nstep,30) with the
!     positions and velocities of all of the bodies
!
!   odetime = array of size Nstep with the times at each point
!
!   zzq = array of dimension (6,30,Nstep) interior node points from
!    the ode solver.  These will be used to interpolate intermediate
!    values
!
!   timeinterp = array of dimension 6 that has the times of the interior
!     node points
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, PARAMETER                       :: ndim=30
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: h
   REAL(KIND=dp), INTENT(IN)                :: tstart
   REAL(KIND=dp), INTENT(IN)                :: tend
   INTEGER, INTENT(OUT)                     :: nstep
   REAL(KIND=dp), INTENT(IN OUT)            :: qq(ndim)
   REAL(KIND=dp), INTENT(IN OUT)            :: pp(ndim)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN OUT)            :: posarray(2,30)
   REAL(KIND=dp), INTENT(IN OUT)            :: velarray(2,30)
   REAL(KIND=dp), INTENT(IN OUT)            :: odetime(ndyn)
   REAL(KIND=dp), INTENT(IN OUT)            :: zzq(6,60,2)
   REAL(KIND=dp), INTENT(IN OUT)            :: timeinterp(6)
   INTEGER, INTENT(IN)                      :: igr
   REAL(KIND=dp), INTENT(IN)                :: tideparm(20)
   INTEGER, INTENT(IN)                      :: isw80
!
   REAL(KIND=dp), DIMENSION(20)   :: rpar,dpar
   REAL(KIND=dp), DIMENSION(60)   :: dy
   REAL(KIND=dp)                  :: x,xend,dx,dxend
!
   INTEGER, DIMENSION(20)  :: ipar
   INTEGER, DIMENSION(10)  :: meth
   INTEGER                 :: nequ,kk
   INTEGER                 :: mmeth,iprob,i,iout
!
!   old dimensions
!
!          DIMENSION zzq(6,60,Ndyn)
!
!          EXTERNAL EQUA,SOLFIX,DEQUA
!
! --- CHOOSE THE PROBLEM
!  IPROB = 1 : KEPLER PROBLEM, ECCENTRICITY IN RPAR(1)
!  IPROB = 2 : HARMONIC OSCILLATOR
!  IPROB = 3 : PENDULUM
!  IPROB = 4 : OUTER SOLAR SYSTEM
!
   iprob=4
   ipar(11)=iprob
!
! --- CHOOSE THE THE METHOD
! --- GAUSS METHOD OF ORDER 2*METH
!
   mmeth=6
!
   x=tstart
   xend=tend
   nstep=nint((xend-x)/h)
   nstep=ABS(nstep)
   IF(nstep > ndyn)THEN
      WRITE(*,*) 'Error:  Number of integration steps > Ndyn'
      STOP
   END IF
   DO i=1,10
      rpar(i)=0.0_dp
      ipar(i)=0
   END DO
   ipar(12)=0
   iout=0
!
   IF(igr <= 0)THEN
      CALL gni_irk2(nbody*3,nstep,x,pp,qq,mmeth,  &
         iout,rpar,ipar,rmass,nbody,posarray,velarray,odetime,zzq,  &
         timeinterp,ndyn,h,igr)
   END IF
!
   IF(igr >= 1)THEN
      nequ=nbody*6
      meth(1)=6
      meth(2)=0
      meth(3)=0
      meth(4)=0
      meth(5)=0
      meth(6)=0
      meth(7)=0
      meth(8)=0
      meth(9)=0
      meth(10)=0
      dx=x
      dxend=xend
      IF(PRECISION(x).eq.18)THEN
        dpar(1)=2.0E-19_dp
      ELSE
        dpar(1)=2.0E-16_dp 
      END IF
      iout=0
      DO kk=1,3*nbody
         dy(kk)=qq(kk)
         dy(kk+3*nbody)=pp(kk)
      END DO
      CALL oldgrkaad(nequ,nstep,dx,dy,meth,iout,dpar,  &
         rmass,nbody,posarray,velarray,odetime,zzq,timeinterp,ndyn,  &
         h,igr,tideparm,isw80)
      DO kk=1,3*nbody
         qq(kk)=dy(kk)
         pp(kk)=dy(kk+3*nbody)
      END DO
   END IF
!
   RETURN
!
END SUBROUTINE goback
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE gravexp(teff,tgrav,istar,ioutflag)
!
!   May 16, 2001
!
!   This routine will return a value of the gravity darkening exponent
!   Tgrav based on the input effective temperature teff.
!
!   Reference:  A. Claret, 2000, A&A, 359, 289
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: teff
   REAL(KIND=dp), INTENT(OUT)               :: tgrav
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp), DIMENSION(45) :: xarray,yarray,y2
   REAL(KIND=dp)                :: tlog,yp1,yout
!
!   xarray = log(t),  yarray = beta_1, where Tgrav=beta_1/4.0
!
   DATA xarray/3.3010_dp,3.3640_dp,3.4217_dp,3.4490_dp,3.4849_dp,3.5097_dp,  &
      3.5180_dp,3.5361_dp,3.5470_dp,3.5640_dp,3.5920_dp,3.6280_dp,3.6633_dp, &
      3.7031_dp,3.7424_dp,3.7557_dp,3.7707_dp,3.7844_dp,3.7964_dp,3.8116_dp, &
      3.8251_dp,3.8458_dp,3.8553_dp,3.8648_dp,3.8736_dp,3.8802_dp,3.8868_dp, &
      3.8912_dp,3.8956_dp,3.9022_dp,3.9088_dp,3.9491_dp,4.0249_dp,4.0960_dp, &
      4.1630_dp,4.2285_dp,4.2891_dp,4.3468_dp,4.4008_dp,4.4551_dp,4.4966_dp, &
      4.5376_dp,4.5749_dp,4.6072_dp,4.6350_dp/
!
   DATA yarray/0.2150_dp,0.2200_dp,0.2150_dp,0.2000_dp,0.1900_dp,0.1800_dp,  &
      0.1700_dp,0.1800_dp,0.1800_dp,0.1900_dp,0.2300_dp,0.3400_dp,0.4100_dp, &
      0.4345_dp,0.4048_dp,0.3888_dp,0.3675_dp,0.3463_dp,0.3239_dp,0.3004_dp, &
      0.2753_dp,0.2499_dp,0.2047_dp,0.1599_dp,0.1731_dp,0.3150_dp,0.5862_dp, &
      0.7292_dp,0.8160_dp,0.9350_dp,0.9435_dp,0.9857_dp,0.9985_dp,0.9962_dp, &
      1.0000_dp,1.0000_dp,1.0000_dp,1.0000_dp,1.0000_dp,1.0000_dp,1.0000_dp, &
      1.0000_dp,1.0000_dp,1.0000_dp,1.0000_dp/
!
   tlog=LOG10(teff)
!
   IF(tlog < 3.301_dp)THEN
      tgrav=0.25_dp*0.2150_dp
      IF(ioutflag == 1)WRITE(2,10)istar,tgrav
      RETURN
   END IF
!
   IF(tlog > 4.2_dp)THEN
      tgrav=0.25_dp
      IF(ioutflag == 1)WRITE(2,10)istar,tgrav
      RETURN
   END IF
!
!   Set up the splines.
!
   yp1=1.0E+31_dp
   CALL spline(xarray,yarray,45,yp1,yp1,y2)
   CALL splint(xarray,yarray,y2,45,tlog,yout)
   tgrav=0.25_dp*yout
   IF(ioutflag == 1)WRITE(2,10)istar,tgrav
!
   RETURN
!
10 FORMAT('Info:  The gravity darkening exponent for star ',i1,  &
      ' has been set to ',f9.7)
!
END SUBROUTINE gravexp
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE grkaad(n,nstep,x,y,meth,iout,rpar,rmass,  &
   nbody,posarray,velarray,odetime,zzq,timeinterp,ndyn,h,igr,  &
   oldzzq,tideparm,isw80)
!
!   from Ernst Hairer, solves first-order force equations with GR and
!   tidal apsidal motion corrections
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(IN)                      :: n
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(OUT)               :: x
   REAL(KIND=dp), INTENT(IN OUT)            :: y(n)
   INTEGER, INTENT(IN)                      :: meth(10)
   INTEGER, INTENT(IN)                      :: iout
   REAL(KIND=dp), INTENT(IN)                :: rpar(10)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(OUT)               :: posarray(2,30)
   REAL(KIND=dp), INTENT(OUT)               :: velarray(2,30)
   REAL(KIND=dp), INTENT(OUT)               :: odetime(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: zzq(6,60,2)
   REAL(KIND=dp), INTENT(OUT)               :: timeinterp(6)
   REAL(KIND=dp), INTENT(IN)                :: h
   INTEGER, INTENT(IN)                      :: igr
   REAL(KIND=dp), INTENT(IN)                :: oldzzq(6,60,2)
   REAL(KIND=dp), INTENT(IN)                :: tideparm(20)
   INTEGER, INTENT(IN)                      :: isw80
!
   REAL(KIND=dp)  :: a,c,ap,b,bp,ycs,f
   REAL(KIND=dp)  :: z,dymin,dyno,eps,suma,sume,ff,temp,ycsi,yi
!
   INTEGER :: i,j,jj,ns
   INTEGER :: nss,icos,itsw,isym,istep,is,ii,iter,isn,icount
   INTEGER, PARAMETER :: ndgl=50
   INTEGER, PARAMETER :: nsd=15
!
   DIMENSION ycs(ndgl),f(ndgl*nsd),z(ndgl*nsd)
   DIMENSION c(nsd),a(nsd,nsd),ap(nsd,nsd),b(nsd),bp(nsd)
!
!   old dimensions for zzq
!
!          DIMENSION zzq(6,60,Ndyn),oldzzq(6,60,Ndyn)
!
!          EXTERNAL FCN
!
   ns=meth(1)
   nss=ns*n
   icos=meth(2)
   itsw=meth(3)
   isym=meth(4)
   IF(icos /= 0)WRITE(6,*) ' METH(2) = ',icos,' NOT ALLOWED'
   IF(isym /= 0)WRITE(6,*) ' METH(4) = ',isym,' NOT ALLOWED'
!
   DO i=1,nsd
      DO j=1,nsd
         a(j,i)=0.0_dp
         ap(j,i)=0.0_dp
         b(i)=0.0_dp
         bp(i)=0.0_dp
         c(i)=0.0_dp
      END DO
   END DO
!
   CALL gauspd(ns,c,b,bp,nsd,a,ap)
!
!write(*,*)'ns   nsd  = ',ns,nsd
!write(*,*)'b(1) = ',b(1),'   b(2) = ',b(2)
!write(*,*)'b(3) = ',b(3),'   b(4) = ',b(4)
!write(*,*)'b(5) = ',b(5),'   b(6) = ',b(6)
!write(*,*)'bp(1) = ',bp(1),'   bp(2) = ',bp(2)
!write(*,*)'bp(3) = ',bp(3),'   bp(4) = ',bp(4)
!write(*,*)'bp(5) = ',bp(5),'   bp(6) = ',bp(6)
!
   DO jj=1,6
      timeinterp(jj)=c(jj)*h
   END DO
!
   IF(iout /= 0)CALL solfid(0,x,y,n,rmass,nbody)
   DO i=1,n
      ycs(i)=0.0_dp
   END DO
!
   DO istep=1,nstep
      CALL dequa(n,y,f,igr,rmass,nbody,tideparm,isw80)
      DO i=1,n/2
         DO is=1,6
            z(i+(is-1)*n)=oldzzq(is,i,istep)
         END DO
      END DO
!
      DO i=n/2+1,n
         DO is=1,6
            z(i+(is-1)*n)=oldzzq(is,i,istep)
         END DO
      END DO
!
      odetime(istep)=x
      DO ii=1,n/2
         posarray(istep,ii)=y(ii)
         velarray(istep,ii)=y(ii+n/2)
      END DO
!
      dymin=100.0_dp
      dyno=10.0_dp
      iter=0
      eps=rpar(1)
      itsw=0
      IF(itsw == 0)THEN
         icount=0
         DO WHILE (((dyno < dymin).AND.(ABS(dyno) > EPSILON(dyno))))
            dymin=MIN(dymin,dyno)
            CALL itaad(n,ns,y,nsd,a,ap,ndgl,f,z,h,  &
               dyno,igr,rmass,nbody,tideparm,isw80)
            icount=icount+1
         END DO
      ELSE
         DO WHILE (dyno > eps.AND.iter <= 50)
            iter=iter+1
            CALL itaad(n,ns,y,nsd,a,ap,ndgl,f,z,h,  &
               dyno,igr,rmass,nbody,tideparm,isw80)
         END DO
         IF(iter >= 49)WRITE(6,*) ' no convergence',iter,dyno
         DO is=1,ns
            isn=1+(is-1)*n
            CALL dequa(n,z(isn),f(isn),igr,rmass,nbody,tideparm,isw80)
         END DO
      END IF
!
      x=x+h
!cpgi$ noassoc
      DO i=1,n                    !n = 24 when Nbody = 4
         suma=0.0_dp
         sume=0.0_dp
         DO is=1,ns/2              !ns = 6
            ff=f(i+(is-1)*n)+f(i+(ns-is)*n)
            suma=suma+b(is)*ff
            sume=sume+bp(is)*ff
         END DO
!
!    write(*,*) 2*(ns/2),ns
!    IF(2*(ns/2) /= ns)THEN
!      is=1+ns/2
!      ff=f(i+(is-1)*n)
!      suma=suma+b(is)*ff
!      sume=sume+bp(is)*ff
!    END IF
!
         temp=y(i)
         ycsi=ycs(i)+h*suma
         yi=temp+ycsi
         ycsi=ycsi+(temp-yi)
         ycsi=ycsi+h*sume
         y(i)=yi+ycsi
         ycs(i)=ycsi+(yi-y(i))
!
         DO is=1,6
            IF(i <= n/2)zzq(is,i,istep)=z(i+(is-1)*n)
         END DO
      END DO
      IF(iout /= 0)CALL solfid(istep,x,y,n,rmass,nbody)
   END DO
!
   RETURN
!
END SUBROUTINE grkaad
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE hamilton(n,q,p,hamil,rmass,nbody)
!
!    from Ernst Hairer
!
   USE accur
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: q(n)
   REAL(KIND=dp), INTENT(IN)                :: p(n)
   REAL(KIND=dp), INTENT(OUT)               :: hamil
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
!
   INTEGER :: i,i1,iprob,j1,j
!
   REAL(KIND=dp) :: d(10,10),y(100),pot
!
!   CALL constants(earthmassinsolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   iprob=4
   IF(iprob == 4)THEN
      DO i=1,n
         y(i)=q(i)
         y(i+n)=p(i)
      END DO
!
      DO i=1,nbody-1
         i1=3*(i-1)+1
         DO j=i+1,nbody
            j1=3*(j-1)+1
            d(i,j)=SQRT((y(i1)-y(j1))**2+(y(i1+1)-y(j1+1))**2+(y(i1+2)-y(j1+2))**2)
            d(j,i)=d(i,j)
         END DO
      END DO
!
      hamil=0.0_dp
      DO i=1,nbody
         i1=n+3*(i-1)+1
         hamil=hamil+rmass(i)*(y(i1)**2+y(i1+1)**2+y(i1+2)**2)
      END DO
      hamil=hamil/2.0_dp
      pot=0.0_dp
      DO i=2,nbody
         DO j=1,i-1
            pot=pot+rmass(i)*rmass(j)/d(i,j)
         END DO
      END DO
      hamil=hamil-g*pot
   END IF
   RETURN
!
END SUBROUTINE hamilton
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE hermint(nmodel,xmodel,ymodel,xin,yout,ii)
!
!   Will use cubic hermite interpolaton.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmodel
   REAL(KIND=dp), INTENT(IN)                :: xmodel(nmodel)
   REAL(KIND=dp), INTENT(IN)                :: ymodel(nmodel)
   REAL(KIND=dp), INTENT(IN)                :: xin
   REAL(KIND=dp), INTENT(OUT)               :: yout
   INTEGER, INTENT(IN OUT)                  :: ii
!
   REAL(KIND=dp), DIMENSION(3)   :: xx,yy
   REAL(KIND=dp)  :: h,dy0,a,b,c,d,y0,y1,ym
   REAL(KIND=dp)  :: yp,x0,x1,p,dy1
!
!   find the time index just before the time timein
!
   CALL hunt(xmodel,nmodel,xin,ii)
   IF(ii <= 0)ii=1
!
   IF(ii > 1)THEN
      h=xmodel(ii)-xmodel(ii-1)
   ELSE
      h=xmodel(2)-xmodel(1)
   END IF
!
   IF(ii >= nmodel-2)THEN
      xx(1)=xmodel(nmodel-2)
      xx(2)=xmodel(nmodel-1)
      xx(3)=xmodel(nmodel)
      yy(1)=ymodel(nmodel-2)
      yy(2)=ymodel(nmodel-1)
      yy(3)=ymodel(nmodel)
      CALL polint(xx,yy,3,xin,yout,dy0)
      RETURN
   END IF
!
   IF(ii <= 1)THEN
      xx(1)=xmodel(1)
      xx(2)=xmodel(2)
      yy(1)=ymodel(1)
      yy(2)=ymodel(2)
      CALL polint(xx,yy,2,xin,yout,dy0)
      RETURN
   END IF
!
   x0=xmodel(ii)
   x1=xmodel(ii+1)
   p=xin
!
   y0=ymodel(ii)
   y1=ymodel(ii+1)
   ym=ymodel(ii-1)
   yp=ymodel(ii+2)
   dy0=(y1-ym)/(2.0_dp*h)
   dy1=(yp-y0)/(2.0_dp*h)
   a=(y1-y0)/h
   b=(a-dy0)/h
   c=(dy1-a)/h
   d=(c-b)/h
   yout=y0+(p-x0)*(dy0+(p-x0)*(b+(p-x1)*d))
!
   RETURN
!
END SUBROUTINE hermint
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE hermsky(ndyn,nstep,odetime,timein,posarray,  &
   velarray,jndx,xout,velxout,ii)
!
!   Will use cubic hermite interpolation to find sky positions
!   at time=timein  This routine also returns the velocity
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN)                :: odetime(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: timein
   REAL(KIND=dp), INTENT(IN)                :: posarray(ndyn,30)
   REAL(KIND=dp), INTENT(IN)                :: velarray(ndyn,30)
   INTEGER, INTENT(IN OUT)                  :: jndx
   REAL(KIND=dp), INTENT(OUT)               :: xout
   REAL(KIND=dp), INTENT(OUT)               :: velxout
   INTEGER, INTENT(IN OUT)                  :: ii
!
   REAL(KIND=dp), DIMENSION(3)   :: xx,yy,vvx,vvy
   REAL(KIND=dp)                 :: h,x0,x1,y0,y1,dy0,dy1,a,b,c,d,p,ym,yp
!
   h=odetime(2)-odetime(1)
!
!   find the time index just before the time timein
!
   CALL hunt(odetime,nstep,timein,ii)
   IF(ii <= 0)ii=1
!
   x0=odetime(ii)
   x1=odetime(ii+1)
   p=timein
!
!          if(ii.ge.Nstep)then
!            ii=Nstep
!            xx(1)=odetime(Nstep-1)
!            xx(2)=odetime(Nstep)
!            yy(1)=posarray(Nstep-1,jndx)
!            yy(2)=posarray(Nstep,jndx)
!            call polint(xx,yy,2,p,xout,dy0)
!          endif
!
   IF(ii >= nstep-2)THEN
      ii=nstep
      vvx(1)=odetime(nstep-2)
      vvx(2)=odetime(nstep-1)
      vvx(3)=odetime(nstep)
      vvy(1)=velarray(nstep-2,jndx)
      vvy(2)=velarray(nstep-1,jndx)
      vvy(3)=velarray(nstep,jndx)
      CALL polint(vvx,vvy,3,p,velxout,dy0)
!
      xx(1)=odetime(nstep-2)
      xx(2)=odetime(nstep-1)
      xx(3)=odetime(nstep)
      yy(1)=posarray(nstep-2,jndx)
      yy(2)=posarray(nstep-1,jndx)
      yy(3)=posarray(nstep,jndx)
      CALL polint(xx,yy,3,p,xout,dy0)
!
      RETURN
   END IF
!
   IF(ii <= 1)THEN
      ii=9
      vvx(1)=odetime(1)
      vvx(2)=odetime(2)
      vvx(3)=odetime(3)
      vvy(1)=velarray(1,jndx)
      vvy(2)=velarray(2,jndx)
      vvy(3)=velarray(3,jndx)
      CALL polint(vvx,vvy,3,p,velxout,dy0)
!
      xx(1)=odetime(1)
      xx(2)=odetime(2)
      xx(3)=odetime(3)
      yy(1)=posarray(1,jndx)
      yy(2)=posarray(2,jndx)
      yy(3)=posarray(3,jndx)
      CALL polint(xx,yy,3,p,xout,dy0)
!
      RETURN
   END IF
!
!   here is the position
!
   y0=posarray(ii,jndx)
   y1=posarray(ii+1,jndx)
   dy0=velarray(ii,jndx)
   dy1=velarray(ii+1,jndx)
   a=(y1-y0)/h
   b=(a-dy0)/h
   c=(dy1-a)/h
   d=(c-b)/h
   xout=y0+(p-x0)*(dy0+(p-x0)*(b+(p-x1)*d))
!
!   here is the velocity
!
   y0=velarray(ii,jndx)
   y1=velarray(ii+1,jndx)
   ym=velarray(ii-1,jndx)
   yp=velarray(ii+2,jndx)
   dy0=(y1-ym)/(2.0_dp*h)
   dy1=(yp-y0)/(2.0_dp*h)
   a=(y1-y0)/h
   b=(a-dy0)/h
   c=(dy1-a)/h
   d=(c-b)/h
   velxout=y0+(p-x0)*(dy0+(p-x0)*(b+(p-x1)*d))
!
   RETURN
!
END SUBROUTINE hermsky
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE hermskycoord(ndyn,nstep,odetime,timein,xout,ii,  &
   frontpos,frontvel)
!
!   Will use cubic hermite interpolation to find sky positions
!   at time=timein  This routine also returns the velocity
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN)                :: odetime(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: timein
   REAL(KIND=dp), INTENT(OUT)               :: xout
   INTEGER, INTENT(IN OUT)                  :: ii
   REAL(KIND=dp), INTENT(IN)                :: frontpos(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: frontvel(ndyn)
!
   REAL(KIND=dp), DIMENSION(3)    ::  xx,yy
   REAL(KIND=dp)                  :: h,x0,x1,y0,y1,dy0,dy1,a,b,c,d,p
!
   h=odetime(2)-odetime(1)
!
!   ii is the time index just before the time timein
!
   IF(ii <= 0)ii=1
!
   x0=odetime(ii)
   x1=odetime(ii+1)
   p=timein
!
   IF(ii >= nstep-2)THEN
      ii=nstep
      xx(1)=odetime(nstep-2)
      xx(2)=odetime(nstep-1)
      xx(3)=odetime(nstep)
      yy(1)=frontpos(nstep-2)
      yy(2)=frontpos(nstep-1)
      yy(3)=frontpos(nstep-0)
      CALL polint(xx,yy,3,p,xout,dy0)
      RETURN
   END IF
!
   IF(ii <= 1)THEN
      ii=9
      xx(1)=odetime(1)
      xx(2)=odetime(2)
      xx(3)=odetime(3)
      yy(1)=frontpos(1)
      yy(2)=frontpos(2)
      yy(3)=frontpos(3)
      CALL polint(xx,yy,3,p,xout,dy0)
      RETURN
   END IF
!
!   here is the position
!
   y0=frontpos(ii)
   y1=frontpos(ii+1)
   dy0=frontvel(ii)
   dy1=frontvel(ii+1)
   a=(y1-y0)/h
   b=(a-dy0)/h
   c=(dy1-a)/h
   d=(c-b)/h
   xout=y0+(p-x0)*(dy0+(p-x0)*(b+(p-x1)*d))
!
   RETURN
!
END SUBROUTINE hermskycoord
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE hermskyvel(ndyn,nstep,odetime,timein,velxout,ii,  &
   frontvel)
!
!   Will use cubic hermite interpolation to find velocity
!   at time=timein
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN)                :: odetime(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: timein
   REAL(KIND=dp), INTENT(OUT)               :: velxout
   INTEGER, INTENT(IN OUT)                  :: ii
   REAL(KIND=dp), INTENT(IN)                :: frontvel(ndyn)
!
   REAL(KIND=dp), DIMENSION(3)   :: vvx,vvy
   REAL(KIND=dp)                 :: h,x0,x1,y0,y1,dy0,dy1,a,b,c,d,p,ym,yp
!
   h=odetime(2)-odetime(1)
!
!   ii is the timeindex just before timein
!
   IF(ii <= 0)ii=1
!
   x0=odetime(ii)
   x1=odetime(ii+1)
   p=timein
!
   IF(ii >= nstep-2)THEN
      ii=nstep
      vvx(1)=odetime(nstep-2)
      vvx(2)=odetime(nstep-1)
      vvx(3)=odetime(nstep)
      vvy(1)=frontvel(nstep-2)
      vvy(2)=frontvel(nstep-1)
      vvy(3)=frontvel(nstep-0)
      CALL polint(vvx,vvy,3,p,velxout,dy0)
      RETURN
   END IF
!
   IF(ii <= 1)THEN
      ii=9
      vvx(1)=odetime(1)
      vvx(2)=odetime(2)
      vvx(3)=odetime(3)
      vvy(1)=frontvel(1)
      vvy(2)=frontvel(2)
      vvy(3)=frontvel(3)
      CALL polint(vvx,vvy,3,p,velxout,dy0)
      RETURN
   END IF
!
!   here is the velocity
!
   y0=frontvel(ii)
   y1=frontvel(ii+1)
   ym=frontvel(ii-1)
   yp=frontvel(ii+2)
   dy0=(y1-ym)/(2.0_dp*h)
   dy1=(yp-y0)/(2.0_dp*h)
   a=(y1-y0)/h
   b=(a-dy0)/h
   c=(dy1-a)/h
   d=(c-b)/h
   velxout=y0+(p-x0)*(dy0+(p-x0)*(b+(p-x1)*d))
!
   RETURN
!
END SUBROUTINE hermskyvel
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE hermskyxy(ndyn,nstep,odetime,timein,posarray,  &
   velarray,jndx,xout,velxout,ii)
!
!   Will use cubic hermite interpolation to find sky positions
!   at time=timein.  This one only returns the position.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN)                :: odetime(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: timein
   REAL(KIND=dp), INTENT(IN)                :: posarray(ndyn,30)
   REAL(KIND=dp), INTENT(IN)                :: velarray(ndyn,30)
   INTEGER, INTENT(IN)                      :: jndx
   REAL(KIND=dp), INTENT(OUT)               :: xout
   REAL(KIND=dp), INTENT(OUT)               :: velxout
   INTEGER, INTENT(IN OUT)                  :: ii
!
   REAL(KIND=dp), DIMENSION(2)      :: xx,yy
   REAL(KIND=dp)                    :: h,x0,x1,y0,y1,dy0,dy1,a,b,c,d,p
!
   h=odetime(2)-odetime(1)
!
!   find the time index just before the time timein
!
   CALL hunt(odetime,nstep,timein,ii)
   IF(ii <= 0)ii=1
!
   x0=odetime(ii)
   x1=odetime(ii+1)
   p=timein
!
   IF(ii >= nstep)THEN
      ii=nstep
      xx(1)=odetime(nstep-1)
      xx(2)=odetime(nstep)
      yy(1)=posarray(nstep-1,jndx)
      yy(2)=posarray(nstep,jndx)
      CALL polint(xx,yy,2,p,xout,dy0)
      velxout=velarray(nstep,jndx)
      RETURN
   END IF
!
!   here is x position
!
   y0=posarray(ii,jndx)
   y1=posarray(ii+1,jndx)
   dy0=velarray(ii,jndx)
   dy1=velarray(ii+1,jndx)
   a=(y1-y0)/h
   b=(a-dy0)/h
   c=(dy1-a)/h
   d=(c-b)/h
   xout=y0+(p-x0)*(dy0+(p-x0)*(b+(p-x1)*d))
   velxout=dy0
!
   RETURN
!
END SUBROUTINE hermskyxy
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE hiddiskgrid(nrmax,nthetamax,nradius,ntheta,  &
   diskproj,edgeproj,dtemp,tedge,dx,dy,dz,xxedge,yyedge,zzedge,  &
   dinty,einty,phase,finc,q,nhoriz,xhoriz,yhoriz,extension,  &
   separation,flux,bdist,tertincl,tertbdist,tertphase,tertq,  &
   axisscale,isw30,isw7,tertomega)
!
!   January 14, 2000
!
!   This routine will output files used for various external plotting
!   packages.  This routine is for the disk.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nrmax
   INTEGER, INTENT(IN)                      :: nthetamax
   INTEGER, INTENT(IN)                      :: nradius
   INTEGER, INTENT(IN)                      :: ntheta
   REAL(KIND=dp), INTENT(IN)                :: diskproj(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: edgeproj(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: dtemp(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: tedge(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: dx(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: dy(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: dz(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: xxedge(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: yyedge(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: zzedge(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: dinty(nrmax*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: einty(nthetamax*11)
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: q
   INTEGER, INTENT(IN)                      :: nhoriz
   REAL(KIND=dp), INTENT(IN)                :: xhoriz(nhoriz)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz(nhoriz)
   CHARACTER (LEN=9), INTENT(IN)            :: extension
   REAL(KIND=dp), INTENT(IN)                :: separation
   REAL(KIND=dp), INTENT(IN)                :: flux
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp) :: tertxcen,tertycen,xxoff,yyoff,xxoff1,yyoff1,tomrad
   REAL(KIND=dp) :: fincr,xx,yy,zz,xp,yp,diskxtran,diskytran,xx1,yy1,xx2
   REAL(KIND=dp) :: xx1new,xedge,yedge,yy1new,xx2new,yy2new,xx4new,yy4new
   REAL(KIND=dp) :: xx3new,yy3new,yy2,xx3,yy3,xx4,yy4
!
   INTEGER :: infront,istar,iidx,ithet,ir,iv1,iyes,izz
   INTEGER :: iv2,iv3,iv4,ncorner,icut,iz,jzz
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!    November 18, 2012
!
!    If there is a third body, offset all x and y sky coordinates
!
   xxoff=0.0_dp
   yyoff=0.0_dp
   IF((isw30 >= 3).AND.(isw7 >= 2))THEN
      xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      tomrad=tertomega*degtorad
      xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
      yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
   END IF
   fincr=finc*degtorad
!
   OPEN(UNIT=40,FILE='diskinty.'//extension,STATUS='unknown')
!
!   Check to see if star 1 is in front.
!
   istar=1
   infront=0
   IF((istar == 1).AND.((phase >= 0.0_dp).AND.(phase < 90.0_dp)))infront=1
   IF((istar == 1).AND.((phase >= 270.0_dp).AND.(phase <= 360.0_dp)))infront=1
!
!   Find the sky coordinates of the center of mass of the disk.  This
!   will be recorded as the first line of the diskinty.???.?? file.
!
   xx=1.0_dp
   yy=0.0_dp
   zz=0.0_dp
   xp=diskxtran(xx,yy,phase,q,istar,bdist)
   yp=diskytran(xx,yy,zz,phase,fincr,q,istar,bdist)
   xp=xp+xxoff
   yp=yp+yyoff
!
   WRITE(40,70)xp*separation,yp*separation,flux
!
   DO  ir=1,nradius-1
      DO  ithet=1,ntheta
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=(ir-1)*ntheta+ithet
!
         iv1=1
!
!  is the surface element visible?
!
         IF(diskproj(iidx) <= 0.0_dp)CYCLE
         xx=dx(iidx)
         yy=dy(iidx)
         zz=dz(iidx)
         xp=diskxtran(xx,yy,phase,q,istar,bdist)
         yp=diskytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
!
         IF(infront == 1)THEN
            iyes=-100
            iv1=1
            CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
!
!   point could be visible but is eclipsed
!
            IF((iyes == 100))iv1=0
!
         END IF
!
!   Record the x,y,z coordinates of the nearby points.  These points
!   will be used for area filling
!
         xx1=xp
         yy1=yp
!
         IF(ithet > 1)THEN
            izz=ir
            jzz=ithet-1
            iidx=(izz-1)*ntheta+jzz
            xx=dx(iidx)
            yy=dy(iidx)
            zz=dz(iidx)
         ELSE
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            xx=dx(iidx)
            yy=dy(iidx)
            zz=dz(iidx)
         END IF
         xx2=diskxtran(xx,yy,phase,q,istar,bdist)
         yy2=diskytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx2=xx2+xxoff
         yy2=yy2+yyoff
!
         IF(ithet > 1)THEN
            izz=ir+1
            jzz=ithet-1
            iidx=(izz-1)*ntheta+jzz
            xx=dx(iidx)
            yy=dy(iidx)
            zz=dz(iidx)
         ELSE
            izz=ir+1
            jzz=ntheta
            iidx=(izz-1)*ntheta+jzz
            xx=dx(iidx)
            yy=dy(iidx)
            zz=dz(iidx)
         END IF
         xx3=diskxtran(xx,yy,phase,q,istar,bdist)
         yy3=diskytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx3=xx3+xxoff
         yy3=yy3+yyoff
!
         izz=ir+1
         jzz=ithet
         iidx=(izz-1)*ntheta+jzz
         xx=dx(iidx)
         yy=dy(iidx)
         zz=dz(iidx)
         xx4=diskxtran(xx,yy,phase,q,istar,bdist)
         yy4=diskytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx4=xx4+xxoff
         yy4=yy4+yyoff
!
!   Check the corners for eclipsed points.
!
         iv2=1
         iv3=1
         iv4=1
         IF(infront == 1)THEN
            iyes=-100
            iv2=1
            CALL insidecircle(nhoriz,xhoriz,yhoriz,xx2,yy2,iyes,icut)
            IF((iyes == 100))iv2=0
            iv3=1
            iyes=-100
            CALL insidecircle(nhoriz,xhoriz,yhoriz,xx3,yy3,iyes,icut)
            IF(iyes == 100)iv3=0
            iv4=1
            iyes=-100
            CALL insidecircle(nhoriz,xhoriz,yhoriz,xx4,yy4,iyes,icut)
            IF(iyes == 100)iv4=0
         END IF
!
!   There are 13 possibilities for which corners were hidden.  Do each
!   case separately.
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1new*separation,  &
               yy1new*separation,xx2new*separation,yy2new*separation,  &
               xx3*separation,yy3*separation,xx4*separation,yy4*separation
            GO TO 10
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx4new*separation,  &
               yy4new*separation,xx1new*separation,yy1new*separation,  &
               xx2new*separation,yy2new*separation,xx3*separation,yy3*separation
            GO TO 10
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            ncorner=5
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1new*separation,  &
               yy1new*separation,xx2*separation,yy2*separation,xx3*  &
               separation,yy3*separation,xx4*separation,yy4*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 10
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1new*separation,  &
               yy1new*separation,xx2new*separation,yy2new*separation,  &
               xx3new*separation,yy3new*separation,xx4*separation,yy4*separation
            GO TO 10
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1new*separation,  &
               yy1new*separation,xx2*separation,yy2*separation,xx3*  &
               separation,yy3*separation,xx4new*separation,yy4new*separation
            GO TO 10
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1new*separation,  &
               yy1new*separation,xx2*separation,yy2*separation,xx3new*  &
               separation,yy3new*separation,xx4new*separation,yy4new*separation
            GO TO 10
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            ncorner=4
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2*separation,yy2*separation,xx3*  &
               separation,yy3*separation,xx4*separation,yy4*separation
            GO TO 10
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=5
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2new*separation,yy2new*separation,  &
               xx3new*separation,yy3new*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation
            GO TO 10
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=5
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2*separation,yy2*separation,xx3new*  &
               separation,yy3new*separation,xx4new*separation,yy4new*  &
               separation,xx4*separation,yy4*separation
            GO TO 10
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            ncorner=5
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2*separation,yy2*separation,xx3*  &
               separation,yy3*separation,xx4new*separation,yy4new*  &
               separation,xx1new*separation,yy1new*separation
            GO TO 10
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=4
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2new*separation,yy2new*separation,  &
               xx3new*separation,yy3new*separation,xx4*separation,yy4*separation
            GO TO 10
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2*separation,yy2*separation,xx3new*  &
               separation,yy3new*separation,xx4new*separation,yy4new*separation
            GO TO 10
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=ir
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)dinty(iidx),ncorner,diskproj(iidx),  &
               dtemp(iidx),ir,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2new*separation,yy2new*separation,  &
               xx3new*separation,yy3new*separation,xx4new*separation, yy4new*separation
            GO TO 10
         END IF
10       CONTINUE
      END DO
   END DO
!
   DO  iz=1,10
      DO  ithet=1,ntheta
         iidx=(iz-1)*ntheta+ithet
         iv1=1
!
!  is the surface element visible?
!
         IF(edgeproj(iidx) <= 0.0_dp)CYCLE
         xx=xxedge(iidx)
         yy=yyedge(iidx)
         zz=zzedge(iidx)
         xp=diskxtran(xx,yy,phase,q,istar,bdist)
         yp=diskytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
!
         IF(infront == 1)THEN
            iyes=-100
            iv1=1
            CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
!
!   point could be visible but is eclipsed
!
            IF((iyes == 100))iv1=0
         END IF
!
!   Record the x,y,z coordinates of the nearby points.  These points
!   will be used for area filling
!
         xx1=xp
         yy1=yp
!
         IF(ithet > 1)THEN
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            xx=xxedge(iidx)
            yy=yyedge(iidx)
            zz=zzedge(iidx)
         ELSE
            izz=iz
            jzz=ntheta
            iidx=(izz-1)*ntheta+jzz
            xx=xxedge(iidx)
            yy=yyedge(iidx)
            zz=zzedge(iidx)
         END IF
         xx2=diskxtran(xx,yy,phase,q,istar,bdist)
         yy2=diskytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx2=xx2+xxoff
         yy2=yy2+yyoff
!
         IF(ithet > 1)THEN
            izz=iz+1
            jzz=ithet-1
            iidx=(izz-1)*ntheta+jzz
            xx=xxedge(iidx)
            yy=yyedge(iidx)
            zz=zzedge(iidx)
         ELSE
            izz=iz+1
            jzz=ntheta
            iidx=(izz-1)*ntheta+jzz
            xx=xxedge(iidx)
            yy=yyedge(iidx)
            zz=zzedge(iidx)
         END IF
         xx3=diskxtran(xx,yy,phase,q,istar,bdist)
         yy3=diskytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx3=xx3+xxoff
         yy3=yy3+yyoff
!
         izz=iz+1
         jzz=ithet
         iidx=(izz-1)*ntheta+jzz
         xx=xxedge(iidx)
         yy=yyedge(iidx)
         zz=zzedge(iidx)
         xx4=diskxtran(xx,yy,phase,q,istar,bdist)
         yy4=diskytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx4=xx4+xxoff
         yy4=yy4+yyoff
!
!   Check the corners for eclipsed points.
!
         iv2=1
         iv3=1
         iv4=1
         IF(infront == 1)THEN
            iyes=-100
            iv2=1
            CALL insidecircle(nhoriz,xhoriz,yhoriz,xx2,yy2,iyes, icut)
            IF((iyes == 100))iv2=0
            iv3=1
            iyes=-100
            CALL insidecircle(nhoriz,xhoriz,yhoriz,xx3,yy3,iyes, icut)
            IF(iyes == 100)iv3=0
            iv4=1
            iyes=-100
            CALL insidecircle(nhoriz,xhoriz,yhoriz,xx4,yy4,iyes, icut)
            IF(iyes == 100)iv4=0
         END IF
!
!   There are 13 possibilities for which corners were hidden.  Do each
!   case separately.
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1new*separation,  &
               yy1new*separation,xx2new*separation,yy2new*separation,  &
               xx3*separation,yy3*separation,xx4*separation,yy4*separation
            GO TO 40
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx4new*separation,  &
               yy4new*separation,xx1new*separation,yy1new*separation,  &
               xx2new*separation,yy2new*separation,xx3*separation,yy3*separation
            GO TO 40
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            ncorner=5
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1new*separation,  &
               yy1new*separation,xx2*separation,yy2*separation,xx3*  &
               separation,yy3*separation,xx4*separation,yy4*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 40
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1new*separation,  &
               yy1new*separation,xx2new*separation,yy2new*separation,  &
               xx3new*separation,yy3new*separation,xx4*separation,yy4*separation
            GO TO 40
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1new*separation,  &
               yy1new*separation,xx2*separation,yy2*separation,xx3*  &
               separation,yy3*separation,xx4new*separation,yy4new*separation
            GO TO 40
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1new*separation,  &
               yy1new*separation,xx2*separation,yy2*separation,xx3new*  &
               separation,yy3new*separation,xx4new*separation,yy4new*separation
            GO TO 40
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            ncorner=4
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2*separation,yy2*separation,xx3*  &
               separation,yy3*separation,xx4*separation,yy4*separation
            GO TO 40
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=5
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2new*separation,yy2new*separation,  &
               xx3new*separation,yy3new*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation
            GO TO 40
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=5
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2*separation,yy2*separation,xx3new*  &
               separation,yy3new*separation,xx4new*separation,yy4new*  &
               separation,xx4*separation,yy4*separation
            GO TO 40
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            ncorner=5
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2*separation,yy2*separation,xx3*  &
               separation,yy3*separation,xx4new*separation,yy4new*  &
               separation,xx1new*separation,yy1new*separation
            GO TO 40
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=4
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2new*separation,yy2new*separation,  &
               xx3new*separation,yy3new*separation,xx4*separation,yy4*separation
            GO TO 40
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2*separation,yy2*separation,xx3new*  &
               separation,yy3new*separation,xx4new*separation,yy4new*separation
            GO TO 40
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=iz
            jzz=ithet
            iidx=(izz-1)*ntheta+jzz
            WRITE(40,80)einty(iidx),ncorner,edgeproj(iidx),  &
               tedge(iidx),iz,ithet,iv1,iv2,iv3,iv4,xx1*separation,  &
               yy1*separation,xx2new*separation,yy2new*separation,  &
               xx3new*separation,yy3new*separation,xx4new*separation, &
               yy4new*separation
            GO TO 40
         END IF
!
40       CONTINUE
      END DO
   END DO
!
   CLOSE(40)
!
   RETURN
!
70 FORMAT(2(f9.4,3X),e16.9)
80 FORMAT(e16.9,3X,i3,4X,f6.4,2X,e13.6,1X,1X,2(i3,1X),6X,4(i1,1X)  &
      /,10(f9.4,1X))
!
END SUBROUTINE hiddiskgrid
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE hidgrid(istar,ialphmax,ibetmax,nalf,ibetlim,phase,  &
   finc,q,xarray,yarray,zarray,xend,projarray,garray,gscale,  &
   surf,nhoriz,xhoriz,yhoriz,rinty,extension,separation,flux,  &
   reff,iecheck,tarray,nh,xh,yh,bdist,mmdx,tertincl,tertbdist,  &
   tertphase,tertq,axisscale,isw30,isw7,tertomega,  &
   nhoriz3,xhoriz3,yhoriz3,i3flag,bigi,bigbeta,omega,flum)
!
!   January 14, 2000
!
!   This routine will output files used for various external plotting
!   packages.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: xarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: yarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: zarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: xend(4)
   REAL(KIND=dp), INTENT(IN)                :: projarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: garray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gscale
   REAL(KIND=dp), INTENT(IN)                :: surf(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: nhoriz
   REAL(KIND=dp), INTENT(IN)                :: xhoriz(nhoriz)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz(nhoriz)
   REAL(KIND=dp), INTENT(IN)                :: rinty(ialphmax*ibetmax)
   CHARACTER (LEN=9), INTENT(IN)            :: extension
   REAL(KIND=dp), INTENT(IN)                :: separation
   REAL(KIND=dp), INTENT(IN)                :: flux
   REAL(KIND=dp), INTENT(IN)                :: reff
   INTEGER, INTENT(IN)                      :: iecheck
   REAL(KIND=dp), INTENT(IN)                :: tarray(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: nh
   REAL(KIND=dp), INTENT(IN)                :: xh(nh)
   REAL(KIND=dp), INTENT(IN)                :: yh(nh)
   REAL(KIND=dp), INTENT(IN)                :: bdist
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: tertomega
   INTEGER, INTENT(IN)                      :: nhoriz3
   REAL(KIND=dp), INTENT(IN)                :: xhoriz3(nhoriz3)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz3(nhoriz3)
   INTEGER, INTENT(IN)                      :: i3flag
   REAL(KIND=dp), INTENT(IN)                :: bigi
   REAL(KIND=dp), INTENT(IN)                :: bigbeta
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: flum(ialphmax*ibetmax)
!
   REAL(KIND=dp), ALLOCATABLE   ::  svex(:),svey(:)
   REAL(KIND=dp) :: tertxcen,tertycen,yy5,yy3new,conex,coney,xxoff,yyoff,rrrr
   REAL(KIND=dp) :: xxoff1,yyoff1,tomrad,fincr,ppp,xx,yy,zz,xp,yp,xx5
   REAL(KIND=dp) :: xx1,yy1,xx3,yy3,xtran,ytran,xx4,yy4,xedge,yedge,xx1new
   REAL(KIND=dp) :: yy1new,xx2new,yy2new,xx2,yy2,xx4new,yy4new,xx3new,vvvv
   REAL(KIND=dp) :: xxx,yyy,zzz,siphase,cophase,si,sscale,cb,sb,cofinc,sifinc
!
   INTEGER :: iidx
   INTEGER :: ialf,ibet,i,izz,jzz,iv1,iv2,iv3,iv4,iv1_3,iv2_3,iv3_3
   INTEGER :: iv4_3,infront,iyes,isve,iyes3,icut,ncorner
!
   DIMENSION conex(5),coney(5)
!
   ALLOCATE(svex(2000000),svey(2000000))
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   si=SIN(bigi*degtorad)
   cb=COS(bigbeta*degtorad)
   sb=SIN(bigbeta*degtorad)
   sscale=(separation*solarrad)**2
!
!    November 18, 2012
!
!    If there is a third body, offset all x and y sky coordinates
!
   xxoff=0.0_dp
   yyoff=0.0_dp
   IF((isw30 >= 3).AND.(isw7 >= 2))THEN
      xxoff1=tertxcen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      yyoff1=tertycen(2,tertincl,tertbdist,tertphase,tertq,axisscale)
      tomrad=tertomega*degtorad
      xxoff=xxoff1*COS(tomrad)-yyoff1*SIN(tomrad)
      yyoff=xxoff1*SIN(tomrad)+yyoff1*COS(tomrad)
   END IF
!
   fincr=finc*degtorad
!
   IF(istar == 1)OPEN(UNIT=40,FILE='star1inty.'//extension,STATUS='unknown')
   IF(istar == 2)OPEN(UNIT=40,FILE='star2inty.'//extension,STATUS='unknown')
   IF(istar == 1)OPEN(UNIT=240,FILE='star1vel.'//extension,STATUS='unknown')
   IF(istar == 2)OPEN(UNIT=240,FILE='star2vel.'//extension,STATUS='unknown')
!
!   Check to see of the star in question is in front.
!
   infront=0
   ppp=MOD(phase,360.0_dp)
   IF(ppp < 0.0_dp)ppp=ppp+360.0_dp
   IF(ppp >= 360.0_dp)ppp=ppp-360.0_dp
   IF((istar == 1).AND.((ppp >= 0.0_dp).AND.(ppp < 90.0_dp)))infront=1
   IF((istar == 1).AND.((ppp >= 270.0_dp).AND.(ppp <= 360.0_dp)))infront=1
   IF((istar == 2).AND.((ppp >= 0.0_dp).AND.(ppp < 90.0_dp)))infront=1
   IF((istar == 2).AND.((ppp >= 270.0_dp).AND.(ppp <= 360.0_dp)))infront=1
!
!   Find the sky coordinates of the center of mass of the star.  This
!   will be recorded as the first line of the star?inty.???.?? file.
!
   IF(istar == 1)THEN
      xx=0.0_dp
      yy=0.0_dp
      zz=0.0_dp
   END IF
   IF(istar == 2)THEN
      xx=0.0_dp
      yy=0.0_dp
      zz=0.0_dp
   END IF
!
   xp=xtran(xx,yy,phase,q,istar,bdist)
   yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
   xp=xp+xxoff
   yp=yp+yyoff
!
   WRITE(40,70)xp*separation,yp*separation,flux,reff*separation,separation
   WRITE(240,70)xp*separation,yp*separation,flux,reff*separation,separation
!
   isve=0
   siphase=SIN(phase*degtorad)
   cophase=COS(phase*degtorad)
   cofinc=COS(fincr)
   sifinc=SIN(fincr)
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=(ialf-1)*ibetlim(ialf)+ibet
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
         iidx=mmdx(ialf,ibet)
!
!   UPDATE March 4, 2010
!
!   Record the radius of each point.
!
         xxx=xarray(iidx)
         yyy=yarray(iidx)
         zzz=zarray(iidx)
         rrrr=SQRT(xxx**2+yyy**2+zzz**2)
!
         xp=-xxx*siphase-yyy*cophase
         yp=xxx*cofinc*cophase-yyy*cofinc*siphase+zzz*sifinc
         vvvv=omega*si*(xp*cb+yp*sb)
         vvvv=vvvv*flum(iidx)*sscale/flux*100.0_dp
!
         iv1=1
         iv1_3=1
!
!   is the surface element visible?
!
         IF(projarray(iidx) <= 0.0_dp)CYCLE
!
         WRITE(240,90)ialf,ibet,rrrr,projarray(iidx),surf(iidx),  &
            LOG10(gscale*garray(iidx)),tarray(iidx),rinty(iidx),vvvv
!
         xx=xarray(iidx)
         yy=yarray(iidx)
         zz=zarray(iidx)
         xp=xtran(xx,yy,phase,q,istar,bdist)
         yp=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xp=xp+xxoff
         yp=yp+yyoff
         IF((infront /= 1).OR.(i3flag > 0))THEN
            iyes=-100
            iyes3=-100
            iv1=1
            iv1_3=1
            IF(iecheck >= 0)THEN
               IF(infront == 0)THEN
                  CALL insidecircle(nhoriz,xhoriz,yhoriz,xp,yp,iyes,icut)
               END IF
               IF(i3flag > 0)THEN
                  CALL insidecircle(nhoriz3,xhoriz3,yhoriz3,xp,yp,iyes3,icut)
               END IF
            END IF
            IF((iyes == 100))iv1=0
            IF((iyes3 == 100))iv1_3=0
         END IF
!
!   Record the x,y,z coordinates of the nearby points.  These points
!   will be used for area filling
!
         xx1=xp
         yy1=yp
!
         isve=isve+1
         svex(isve)=xp*separation
         svey(isve)=yp*separation
!
         IF(ibet > 1)THEN
            izz=ialf
            jzz=ibet-1
            iidx=mmdx(izz,jzz)
            xx=xarray(iidx)
            yy=yarray(iidx)
            zz=zarray(iidx)
         ELSE
            izz=ialf
            jzz=ibetlim(ialf)
            iidx=mmdx(izz,jzz)
            xx=xarray(iidx)
            yy=yarray(iidx)
            zz=zarray(iidx)
         END IF
         xx2=xtran(xx,yy,phase,q,istar,bdist)
         yy2=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx2=xx2+xxoff
         yy2=yy2+yyoff
         IF(ialf > 1)THEN
            IF(ibet > 1)THEN
               izz=ialf-1
               jzz=MIN(ibet-1,ibetlim(ialf-1))
               iidx=mmdx(izz,jzz)
               xx=xarray(iidx)
               yy=yarray(iidx)
               zz=zarray(iidx)
            ELSE
               izz=ialf-1
               jzz=ibetlim(ialf-1)
               iidx=mmdx(izz,jzz)
               xx=xarray(iidx)
               yy=yarray(iidx)
               zz=zarray(iidx)
            END IF
         ELSE
            xx=0.0_dp
            yy=0.0_dp
            zz=xend(1)
         END IF
         xx3=xtran(xx,yy,phase,q,istar,bdist)
         yy3=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx3=xx3+xxoff
         yy3=yy3+yyoff
         IF(ialf > 1)THEN
            izz=ialf-1
            jzz=MIN(ibet,ibetlim(ialf-1))
            iidx=mmdx(izz,jzz)
            xx=xarray(iidx)
            yy=yarray(iidx)
            zz=zarray(iidx)
         ELSE
            xx=0.0_dp
            yy=0.0_dp
            zz=xend(1)
         END IF
         xx4=xtran(xx,yy,phase,q,istar,bdist)
         yy4=ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
         xx4=xx4+xxoff
         yy4=yy4+yyoff
!
!   Check the corners for eclipsed points.
!
         iv2=1
         iv3=1
         iv4=1
         iv2_3=1
         iv3_3=1
         iv4_3=1
         IF((infront == 0).OR.(i3flag > 0))THEN
            iyes=-100
            iyes3=-100
            iv2=1
            iv2_3=1
            IF(infront == 0)THEN
               CALL insidecircle(nhoriz,xhoriz,yhoriz,xx2,yy2,iyes,icut)
            END IF
            IF(i3flag >= 1)THEN
               CALL insidecircle(nhoriz3,xhoriz3,yhoriz3,xx2,yy2,iyes3,icut)
            END IF
            IF((iyes == 100))iv2=0
            IF((iyes3 == 100))iv2_3=0
            iv3=1
            iyes=-100
            iv3_3=1
            iyes3=-100
            IF(infront == 0)THEN
               CALL insidecircle(nhoriz,xhoriz,yhoriz,xx3,yy3,iyes,icut)
            END IF
            IF(i3flag >= 1)THEN
               CALL insidecircle(nhoriz3,xhoriz3,yhoriz3,xx3,yy3,iyes3,icut)
            END IF
            IF(iyes == 100)iv3=0
            IF(iyes3 == 100)iv3_3=0
            iv4=1
            iyes=-100
            iv4_3=1
            iyes3=-100
            IF(infront == 0)THEN
               CALL insidecircle(nhoriz,xhoriz,yhoriz,xx4,yy4,iyes,icut)
            END IF
            IF(i3flag >= 1)THEN
               CALL insidecircle(nhoriz3,xhoriz3,yhoriz3,xx4,yy4,iyes3,icut)
            END IF
            IF(iyes == 100)iv4=0
            IF(iyes3 == 100)iv4_3=0
         END IF
         IF(iecheck <= -1)THEN
            iv1=1
            iv2=1
            iv3=1
            iv4=1
         END IF
!
!   There are 13 possibilities for which corners were hidden.  Do each
!   case separately.  This is for the tertiary.
!
         IF(i3flag == 0)GO TO 10
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv3 == 0) )GO TO 10
!
         IF((iv1_3 == 0).AND.(iv2_3 == 0).AND.(iv3_3 == 1).AND. &
               (iv4_3 == 1))THEN
            ncorner=4
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            izz=ialf
            jzz=ibet
!                iidx=(izz-1)*ibetlim(ialf)+jzz
!                iidx=kount(ialphmax,izz,ibetlim)+jzz
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2new*separation,yy2new*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 0).AND.(iv2_3 == 0).AND.(iv3_3 == 1).AND. &
              (iv4_3 == 0))THEN
            ncorner=4
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx4new*separation,yy4new*separation,  &
               xx1new*separation,yy1new*separation,xx2new*separation,  &
               yy2new*separation,xx3*separation,yy3*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 0).AND.(iv2_3 == 1).AND.(iv3_3 == 1).AND. &
              (iv4_3 == 1))THEN
            ncorner=5
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx1,yy1,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation,xx4new*  &
               separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 0).AND.(iv2_3 == 0).AND.(iv3_3 == 0).AND. &
               (iv4_3 == 1))THEN
            ncorner=4
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2new*separation,yy2new*separation,xx3new*separation,  &
               yy3new*separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 0).AND.(iv2_3 == 1).AND.(iv3_3 == 1).AND. &
              (iv4_3 == 0))THEN
            ncorner=4
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 0).AND.(iv2_3 == 1).AND.(iv3_3 == 0).AND. &
               (iv4_3 == 0))THEN
            ncorner=4
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 1).AND.(iv2_3 == 1).AND.(iv3_3 == 1).AND. &
              (iv4_3 == 1))THEN
            IF(iv1 == 0)GO TO 10
            IF(iv2 == 0)GO TO 10
            IF(iv3 == 0)GO TO 10
            IF(iv4 == 0)GO TO 10
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 1).AND.(iv2_3 == 0).AND.(iv3_3 == 1).AND. &
               (iv4_3 == 1))THEN
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx2,yy2,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx3*separation,yy3*separation,xx4*separation, &
               yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 1).AND.(iv2_3 == 1).AND.(iv3_3 == 0).AND. &
             (iv4_3 == 1))THEN
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx3,yy3,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation,xx4*  &
               separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 1).AND.(iv2_3 == 1).AND.(iv3_3 == 1).AND. &
              (iv4_3 == 0))THEN
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx4,yy4,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4new*separation,yy4new*separation,xx1new*  &
               separation,yy1new*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 1).AND.(iv2_3 == 0).AND.(iv3_3 == 0).AND. &
               (iv4_3 == 1))THEN
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 1).AND.(iv2_3 == 1).AND.(iv3_3 == 0).AND. &
                (iv4_3 == 0))THEN
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1_3 == 1).AND.(iv2_3 == 0).AND.(iv3_3 == 0).AND. &
               (iv4_3 == 0))THEN
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz3,xhoriz3,yhoriz3,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
10       IF((iv1_3 == 0).AND.(iv2_3 == 0).AND.(iv3_3 == 0).AND.  &
            (iv4_3 == 0))GO TO 20
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 1) )THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2new*separation,yy2new*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx4new*separation,yy4new*separation,  &
               xx1new*separation,yy1new*separation,xx2new*separation,  &
               yy2new*separation,xx3*separation,yy3*separation
            GO TO 20
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            ncorner=5
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation,xx4new*  &
               separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2new*separation,yy2new*separation,xx3new*separation,  &
               yy3new*separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx2,yy2,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx3*separation,yy3*separation,xx4*separation, &
               yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation,xx4*  &
               separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4new*separation,yy4new*separation,xx1new*  &
               separation,yy1new*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz,xhoriz,yhoriz,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
!   Add an extra step for the back end.
!
20       CONTINUE
      END DO
   END DO
!
!   Add the L1 point for plotting if phase=90.0 or 180.0
!
   IF(ABS(phase-90.0_dp) <= EPSILON(phase))THEN
      DO  i=1,nh
         isve=isve+1
         svex(isve)=xh(i)*separation
         svey(isve)=yh(i)*separation
      END DO
!
      IF(isve > 1)THEN
         CALL sort3(isve,svex,svey,svey)
      END IF
!
!  We want the 5 points with the smallest x-coordinates
!
      DO  i=1,5
         conex(i)=svex(i)
         coney(i)=svey(i)
      END DO
!
      CALL sortcircle(5,conex,coney)
!
      xx1=conex(1)
      xx2=conex(2)
      xx3=conex(3)
      xx4=conex(4)
      xx5=conex(5)
!
      yy1=coney(1)
      yy2=coney(2)
      yy3=coney(3)
      yy4=coney(4)
      yy5=coney(5)
!
      ialf=nalf/2
      ibet=1
      ncorner=5
      iidx=mmdx(ialf,ibet)
      WRITE(40,80)rinty(iidx),ncorner,projarray(iidx),surf(iidx),  &
         LOG10(gscale*garray(iidx)),ialf,ibet,tarray(iidx),rrrr,  &
         xx1,yy1,xx2,yy2,xx3,yy3,xx4,yy4,xx5,yy5
   END IF
!
   CLOSE(40)
   CLOSE(240)
!
   DEALLOCATE(svex,svey)
!
   RETURN
!
70 FORMAT(2(f14.8,3X),e16.9,f10.4,2X,f10.4)
80 FORMAT(e16.9,1X,i3,1X,f10.7,1X,e13.6,1X,f8.5,1X,2(i3,1X),1X,  &
      f10.3,2X,f11.6/,10(f11.6,1X))
90 FORMAT(2(i3,1X),3X,f12.10,2X,f13.10,2X,f17.12,2X,f8.5,2X,  &
      f10.4,2X,1PE24.16,2X,1PE24.16)
!
END SUBROUTINE hidgrid
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE hidgrid3(ialphmax,ibetmax,nalf,ibetlim,  &
   xarray,yarray,zarray,projarray,garray,gscale,surf,nhoriz1,  &
   xhoriz1,yhoriz1,rinty,extension,separation,flux,reff,iecheck,  &
   tarray,mmdx,tertincl,tertbdist,tertphase,tertq,  &
   axisscale,tertomega,nhoriz2,xhoriz2,  &
   yhoriz2,i3flag)
!
!   January 14, 2000
!
!   This routine will output files used for various external plotting
!   packages.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: xarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: yarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: zarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: projarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: garray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gscale
   REAL(KIND=dp), INTENT(IN)                :: surf(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: nhoriz1
   REAL(KIND=dp), INTENT(IN)                :: xhoriz1(nhoriz1)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz1(nhoriz1)
   REAL(KIND=dp), INTENT(IN)                :: rinty(ialphmax*ibetmax)
   CHARACTER (LEN=9), INTENT(IN)            :: extension
   REAL(KIND=dp), INTENT(IN)                :: separation
   REAL(KIND=dp), INTENT(IN)                :: flux
   REAL(KIND=dp), INTENT(IN)                :: reff
   INTEGER, INTENT(IN)                      :: iecheck
   REAL(KIND=dp), INTENT(IN)                :: tarray(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   REAL(KIND=dp), INTENT(IN)                :: tertomega
   INTEGER, INTENT(IN)                      :: nhoriz2
   REAL(KIND=dp), INTENT(IN)                :: xhoriz2(nhoriz2)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz2(nhoriz2)
   INTEGER, INTENT(IN)                      :: i3flag
!
   REAL(KIND=dp) :: yp,yy3new,rrrr,tertxtrans,tertytrans,xp
   REAL(KIND=dp) :: xx1,yy1,xx3,yy3,xx4,yy4,xedge,yedge,xx1new,xx,yy
   REAL(KIND=dp) :: yy1new,xx2new,yy2new,xx2,yy2,xx4new,yy4new,xx3new,zz
!
   INTEGER :: iidx,ncorner,izz
   INTEGER :: iv1,iv2,iv3,iv4,icut,iv1_2,iyes1,iyes2,iv2_2
   INTEGER :: iv3_2,iv4_2,ibet,jzz,ialf
!
   OPEN(UNIT=40,FILE='star3inty.'//extension,STATUS='unknown')
!
!   Check to see of the star in question is in front.
!
!   Find the sky coordinates of the center of mass of the star.  This
!   will be recorded as the first line of the star?inty.???.?? file.
!
   xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertq,tertbdist,  &
      axisscale,tertomega)
   yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertq,tertbdist,  &
      axisscale,tertomega)
!
   WRITE(40,50)xp*separation,yp*separation,flux,reff*separation,separation
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
         iidx=mmdx(ialf,ibet)
         rrrr=SQRT(xarray(iidx)**2+yarray(iidx)**2+zarray(iidx)**2)
         iv1=1
         iv1_2=1
!
!   is the surface element visible?
!
         IF(projarray(iidx) <= 0.0_dp)CYCLE
         xx=xarray(iidx)
         yy=yarray(iidx)
         zz=zarray(iidx)
         xp=tertxtrans(xx,yy,zz,tertphase,tertincl,tertq,tertbdist,  &
            axisscale,tertomega)
         yp=tertytrans(xx,yy,zz,tertphase,tertincl,tertq,tertbdist,  &
            axisscale,tertomega)
         IF(i3flag == 0)THEN
            iyes1=-100
            iyes2=-100
            CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes1,icut)
            CALL insidecircle(nhoriz2,xhoriz2,yhoriz2,xp,yp,iyes2,icut)
            IF((iyes1 == 100))iv1=0
            IF((iyes2 == 100))iv1_2=0
         END IF
!
!   Record the x,y,z coordinates of the nearby points.  These points
!   will be used for area filling
!
         xx1=xp
         yy1=yp
!
         IF(ibet > 1)THEN
            izz=ialf
            jzz=ibet-1
            iidx=mmdx(izz,jzz)
            xx=xarray(iidx)
            yy=yarray(iidx)
            zz=zarray(iidx)
         ELSE
            izz=ialf
            jzz=ibetlim(ialf)
            iidx=mmdx(izz,jzz)
            xx=xarray(iidx)
            yy=yarray(iidx)
            zz=zarray(iidx)
         END IF
         xx2=tertxtrans(xx,yy,zz,tertphase,tertincl,tertq,  &
            tertbdist,axisscale,tertomega)
         yy2=tertytrans(xx,yy,zz,tertphase,tertincl,tertq,  &
            tertbdist,axisscale,tertomega)
         IF(ialf > 1)THEN
            IF(ibet > 1)THEN
               izz=ialf-1
               jzz=MIN(ibet-1,ibetlim(ialf-1))
               iidx=mmdx(izz,jzz)
               xx=xarray(iidx)
               yy=yarray(iidx)
               zz=zarray(iidx)
            ELSE
               izz=ialf-1
               jzz=ibetlim(ialf-1)
               iidx=mmdx(izz,jzz)
               xx=xarray(iidx)
               yy=yarray(iidx)
               zz=zarray(iidx)
            END IF
         ELSE
            xx=0.0_dp
            yy=0.0_dp
            zz=zarray(1)
         END IF
         xx3=tertxtrans(xx,yy,zz,tertphase,tertincl,tertq,  &
            tertbdist,axisscale,tertomega)
         yy3=tertytrans(xx,yy,zz,tertphase,tertincl,tertq,  &
            tertbdist,axisscale,tertomega)
         IF(ialf > 1)THEN
            izz=ialf-1
            jzz=MIN(ibet,ibetlim(ialf-1))
            iidx=mmdx(izz,jzz)
            xx=xarray(iidx)
            yy=yarray(iidx)
            zz=zarray(iidx)
         ELSE
            xx=0.0_dp
            yy=0.0_dp
            zz=zarray(1)
         END IF
         xx4=tertxtrans(xx,yy,zz,tertphase,tertincl,tertq,  &
            tertbdist,axisscale,tertomega)
         yy4=tertytrans(xx,yy,zz,tertphase,tertincl,tertq,  &
            tertbdist,axisscale,tertomega)
!
!   Check the corners for eclipsed points.
!
         iv2=1
         iv3=1
         iv4=1
         iv2_2=1
         iv3_2=1
         iv4_2=1
         IF(i3flag == 0)THEN
            iyes1=-100
            iyes2=-100
            iv2=1
            iv2_2=1
            CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xx2,yy2,iyes1,icut)
            CALL insidecircle(nhoriz2,xhoriz2,yhoriz2,xx2,yy2,iyes2,icut)
            IF((iyes1 == 100))iv2=0
            IF((iyes2 == 100))iv2_2=0
            iv3=1
            iyes1=-100
            iv3_2=1
            iyes2=-100
            CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xx3,yy3,iyes1,icut)
            CALL insidecircle(nhoriz2,xhoriz2,yhoriz2,xx3,yy3,iyes2,icut)
            IF(iyes1 == 100)iv3=0
            IF(iyes2 == 100)iv3_2=0
            iv4=1
            iyes1=-100
            iv4_2=1
            iyes2=-100
            CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xx4,yy4,iyes1,icut)
            CALL insidecircle(nhoriz2,xhoriz2,yhoriz2,xx4,yy4,iyes2,icut)
            IF(iyes1 == 100)iv4=0
            IF(iyes2 == 100)iv4_2=0
         END IF
         IF(iecheck <= -1)THEN
            iv1=1
            iv2=1
            iv3=1
            iv4=1
         END IF
!
!   There are 13 possibilities for which corners were hidden.  Do each
!   case separately.  This is for the tertiary.
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv3 == 0))GO TO 10
!
!   points hidden by secondary/primary above
!
         IF((iv1_2 == 0).AND.(iv2_2 == 0).AND.(iv3_2 == 1).AND.(iv4_2 == 1))THEN
            ncorner=4
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2new*separation,yy2new*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 0).AND.(iv2_2 == 0).AND.(iv3_2 == 1).AND.(iv4_2 == 0))THEN
            ncorner=4
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx4new*separation,yy4new*separation,  &
               xx1new*separation,yy1new*separation,xx2new*separation,  &
               yy2new*separation,xx3*separation,yy3*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 0).AND.(iv2_2 == 1).AND.(iv3_2 == 1).AND.(iv4_2 == 1))THEN
            ncorner=5
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx1,yy1,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation,xx4new*  &
               separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 0).AND.(iv2_2 == 0).AND.(iv3_2 == 0).AND.(iv4_2 == 1))THEN
            ncorner=4
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2new*separation,yy2new*separation,xx3new*separation,  &
               yy3new*separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 0).AND.(iv2_2 == 1).AND.(iv3_2 == 1).AND.(iv4_2 == 0))THEN
            ncorner=4
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 0).AND.(iv2_2 == 1).AND.(iv3_2 == 0).AND.(iv4_2 == 0))THEN
            ncorner=4
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 1).AND.(iv2_2 == 1).AND.(iv3_2 == 1).AND.(iv4_2 == 1))THEN
            IF(iv1 == 0)GO TO 10
            IF(iv2 == 0)GO TO 10
            IF(iv3 == 0)GO TO 10
            IF(iv4 == 0)GO TO 10
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 1).AND.(iv2_2 == 0).AND.(iv3_2 == 1).AND.(iv4_2 == 1))THEN
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx2,yy2, xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx3*separation,yy3*separation,xx4*separation, &
               yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 1).AND.(iv2_2 == 1).AND.(iv3_2 == 0).AND.(iv4_2 == 1))THEN
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx3,yy3,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation,xx4*  &
               separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 1).AND.(iv2_2 == 1).AND.(iv3_2 == 1).AND.(iv4_2 == 0))THEN
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx4,yy4,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4new*separation,yy4new*separation,xx1new*  &
               separation,yy1new*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 1).AND.(iv2_2 == 0).AND.(iv3_2 == 0).AND.(iv4_2 == 1))THEN
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 1).AND.(iv2_2 == 1).AND.(iv3_2 == 0).AND.(iv4_2 == 0))THEN
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1_2 == 1).AND.(iv2_2 == 0).AND.(iv3_2 == 0).AND.(iv4_2 == 0))THEN
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz2,xhoriz2,yhoriz2,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
10       IF((iv1_2 == 0).AND.(iv2_2 == 0).AND.(iv3_2 == 0).AND.  &
            (iv4_2 == 0))GO TO 20
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            ncorner=4
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2new*separation,yy2new*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx4new*separation,yy4new*separation,  &
               xx1new*separation,yy1new*separation,xx2new*separation,  &
               yy2new*separation,xx3*separation,yy3*separation
            GO TO 20
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            ncorner=5
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx1,yy1,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation,xx4new*  &
               separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            ncorner=4
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2new*separation,yy2new*separation,xx3new*separation,  &
               yy3new*separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1 == 0).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            ncorner=4
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx1,yy1,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1new*separation,yy1new*separation,  &
               xx2*separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 1).AND.(iv4 == 1))THEN
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx2,yy2,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx3*separation,yy3*separation,xx4*separation, &
               yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx3,yy3,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation,xx4*  &
               separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 1).AND.(iv4 == 0))THEN
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx3,yy3,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx4,yy4,xedge,yedge)
            xx1new=xedge
            yy1new=yedge
            ncorner=5
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3*separation,yy3*  &
               separation,xx4new*separation,yy4new*separation,xx1new*  &
               separation,yy1new*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 1))THEN
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx4,yy4,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx4*separation,yy4*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 1).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx2,yy2,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2*  &
               separation,yy2*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
         IF((iv1 == 1).AND.(iv2 == 0).AND.(iv3 == 0).AND.(iv4 == 0))THEN
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx2,yy2,xedge,yedge)
            xx2new=xedge
            yy2new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx3,yy3,xedge,yedge)
            xx3new=xedge
            yy3new=yedge
            CALL clip(nhoriz1,xhoriz1,yhoriz1,xx1,yy1,xx4,yy4,xedge,yedge)
            xx4new=xedge
            yy4new=yedge
            ncorner=4
            izz=ialf
            jzz=ibet
            iidx=mmdx(izz,jzz)
            WRITE(40,60)rinty(iidx),ncorner,projarray(iidx),  &
               surf(iidx),LOG10(gscale*garray(iidx)),ialf,ibet,  &
               tarray(iidx),rrrr,xx1*separation,yy1*separation,xx2new*  &
               separation,yy2new*separation,xx3new*separation,yy3new*  &
               separation,xx4new*separation,yy4new*separation
            GO TO 20
         END IF
!
20       CONTINUE
      END DO
   END DO
!
   CLOSE(40)
!
   RETURN
!
50 FORMAT(2(f14.8,3X),e16.9,f10.4,2X,f10.4)
60 FORMAT(e16.9,1X,i3,1X,f9.7,1X,e13.6,1X,f8.5,1X,2(i3,1X),1X,  &
      f10.3,2X,f11.6/,10(f11.6,1X))
!
END SUBROUTINE hidgrid3
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE hunt(xx,n,x,jlo)
!
!   This routine was taken from Numerical Recipes, second edition.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: xx(n)
   REAL(KIND=dp), INTENT(IN)                :: x
   INTEGER, INTENT(IN OUT)                  :: jlo
!
   INTEGER :: inc,jhi,jm
   LOGICAL :: ascnd
!
   ascnd=xx(n) > xx(1)
   IF(jlo <= 0.OR.jlo > n)THEN
      jlo=0
      jhi=n+1
      GO TO 30
   END IF
   inc=1
   IF((x >= xx(jlo)).EQV.ascnd)THEN
10    jhi=jlo+inc
      IF(jhi > n)THEN
         jhi=n+1
      ELSE IF((x >= xx(jhi)).EQV.ascnd)THEN
         jlo=jhi
         inc=inc+inc
         GO TO 10
      END IF
   ELSE
      jhi=jlo
20    jlo=jhi-inc
      IF(jlo < 1)THEN
         jlo=0
      ELSE IF((x < xx(jlo)).EQV.ascnd)THEN
         jhi=jlo
         inc=inc+inc
         GO TO 20
      END IF
   END IF
30 IF(jhi-jlo == 1)RETURN
   jm=(jhi+jlo)/2
   IF((x > xx(jm)).EQV.ascnd)THEN
      jlo=jm
   ELSE
      jhi=jm
   END IF
   GO TO 30
!
END SUBROUTINE hunt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION iceiling(x)
!
!    returns the nearest integer greater than or equal to x
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: x
!
   INTEGER :: i,iceiling
!
   i=0
   IF(x >= 0.0_dp)i=INT(x+1.0_dp)
   IF(REAL(i,KIND=dp)-x >= 1.0_dp)i=i-1
   IF(x < 0.0_dp)i=INT(x)
   iceiling=i
!
   RETURN
!
END FUNCTION iceiling
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
INTEGER FUNCTION ifloor(x)
!
!    returns the nearest integer less than or equal to x
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                   :: x
!
   INTEGER :: i
!
   i=INT(x)
   IF(REAL(i,kind=dp) > x)i=i-1
   ifloor=i
!
   RETURN
!
END FUNCTION ifloor
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE indexinty(index,maxlines,maxmu,atmmu,atmint1,  &
   atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,atmint8,nmu,  &
   rmuin,outinty,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk)
!
!   November 25, 1999
!
!   This subroutine will read the return values of the intensity at the
!   angle rmuin for model index in the table.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN OUT)                  :: index
   INTEGER, INTENT(IN)                      :: maxlines
   INTEGER, INTENT(IN)                      :: maxmu
   REAL(KIND=dp), INTENT(IN)                :: atmmu(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint1(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint2(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint3(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint4(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint5(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint6(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint7(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint8(maxlines,maxmu)
   INTEGER, INTENT(IN)                      :: nmu(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: rmuin
   REAL(KIND=dp), INTENT(OUT)               :: outinty(8)
   INTEGER, INTENT(IN)                  :: icnu
   INTEGER, INTENT(IN)                  :: icnb
   INTEGER, INTENT(IN)                  :: icnv
   INTEGER, INTENT(IN)                  :: icnr
   INTEGER, INTENT(IN)                  :: icni
   INTEGER, INTENT(IN)                  :: icnj
   INTEGER, INTENT(IN)                  :: icnh
   INTEGER, INTENT(IN)                  :: icnk
!
   REAL(KIND=dp), DIMENSION(400)   :: xmu
   REAL(KIND=dp)                   :: qqq
!
   INTEGER :: k,m,n,i,muindex
!
   outinty=0.0_dp
!
!   This if-then clause seems to be needed...
!
   IF(index > maxlines)index=maxlines
   IF((index <= 0))THEN
      DO  i=1,8
         outinty(i)=0.0_dp
      END DO
      RETURN
   END IF
!
!   Copy the mu values to a one dimensional array
!
   k=8
   DO  i=1,nmu(index)
      xmu(i)=atmmu(index,i)
   END DO
!
   n=nmu(index)
!
   muindex=1
   CALL locate(xmu,n,rmuin,muindex)
   m=2
   k=MIN(MAX(muindex-(m-1)/2,1),n+1-m)
   IF(k >= n)k=n-1
   IF(k < 1)k=1
   DO  i=1,8
      IF((i == 1).AND.(icnu == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 2).AND.(icnb == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 3).AND.(icnv == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 4).AND.(icnr == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 5).AND.(icni == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 6).AND.(icnj == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 7).AND.(icnh == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
      IF((i == 8).AND.(icnk == 430))THEN
         outinty(i)=1.0_dp
         CYCLE
      END IF
!
      IF(i == 1)THEN
         qqq=((xmu(k+1)-rmuin)*atmint1(index,k)+(rmuin-xmu(k))*  &
            atmint1(index,k+1))/(xmu(k+1)-xmu(k))
         outinty(i)=ABS(qqq)
      END IF
      IF(i == 2)THEN
         qqq=((xmu(k+1)-rmuin)*atmint2(index,k)+(rmuin-xmu(k))*  &
            atmint2(index,k+1))/(xmu(k+1)-xmu(k))
         outinty(i)=ABS(qqq)
      END IF
      IF(i == 3)THEN
         qqq=((xmu(k+1)-rmuin)*atmint3(index,k)+(rmuin-xmu(k))*  &
            atmint3(index,k+1))/(xmu(k+1)-xmu(k))
         outinty(i)=ABS(qqq)
      END IF
      IF(i == 4)THEN
         qqq=((xmu(k+1)-rmuin)*atmint4(index,k)+(rmuin-xmu(k))*  &
            atmint4(index,k+1))/(xmu(k+1)-xmu(k))
         outinty(i)=ABS(qqq)
      END IF
      IF(i == 5)THEN
         qqq=((xmu(k+1)-rmuin)*atmint5(index,k)+(rmuin-xmu(k))*  &
            atmint5(index,k+1))/(xmu(k+1)-xmu(k))
         outinty(i)=ABS(qqq)
      END IF
      IF(i == 6)THEN
         qqq=((xmu(k+1)-rmuin)*atmint6(index,k)+(rmuin-xmu(k))*  &
            atmint6(index,k+1))/(xmu(k+1)-xmu(k))
         outinty(i)=ABS(qqq)
      END IF
      IF(i == 7)THEN
         qqq=((xmu(k+1)-rmuin)*atmint7(index,k)+(rmuin-xmu(k))*  &
            atmint7(index,k+1))/(xmu(k+1)-xmu(k))
         outinty(i)=ABS(qqq)
      END IF
      IF(i == 8)THEN
         qqq=((xmu(k+1)-rmuin)*atmint8(index,k)+(rmuin-xmu(k))*  &
            atmint8(index,k+1))/(xmu(k+1)-xmu(k))
         outinty(i)=ABS(qqq)
      END IF
   END DO
!
   RETURN
!
END SUBROUTINE indexinty
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE indexx(n,arr,indx)
!
!  Used by geneticELC to rank arrays by fitness.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: arr(n)
   INTEGER, INTENT(OUT)                     :: indx(n)
!
   INTEGER, PARAMETER :: m=7
   INTEGER, PARAMETER :: nstack=80
!
   INTEGER :: i,indxt,ir,itemp,j,jstack,k,l,istack(nstack)
!
   REAL(KIND=dp) ::  a
!
   DO  j=1,n
      indx(j)=j
   END DO
!
   jstack=0
   l=1
   ir=n
20 IF(ir-l < m)THEN
      DO  j=l+1,ir
         indxt=indx(j)
         a=arr(indxt)
         DO  i=j-1,1,-1
            IF(arr(indx(i)) <= a)GO TO 40
            indx(i+1)=indx(i)
         END DO
         i=0
40       indx(i+1)=indxt
      END DO
      IF(jstack == 0)RETURN
      ir=istack(jstack)
      l=istack(jstack-1)
      jstack=jstack-2
   ELSE
      k=(l+ir)/2
      itemp=indx(k)
      indx(k)=indx(l+1)
      indx(l+1)=itemp
      IF(arr(indx(l+1)) > arr(indx(ir)))THEN
         itemp=indx(l+1)
         indx(l+1)=indx(ir)
         indx(ir)=itemp
      END IF
      IF(arr(indx(l)) > arr(indx(ir)))THEN
         itemp=indx(l)
         indx(l)=indx(ir)
         indx(ir)=itemp
      END IF
      IF(arr(indx(l+1)) > arr(indx(l)))THEN
         itemp=indx(l+1)
         indx(l+1)=indx(l)
         indx(l)=itemp
      END IF
      i=l+1
      j=ir
      indxt=indx(l)
      a=arr(indxt)
60    i=i+1
      IF(arr(indx(i)) < a)GO TO 60
70    j=j-1
      IF(arr(indx(j)) > a)GO TO 70
      IF(j < i)GO TO 80
      itemp=indx(i)
      indx(i)=indx(j)
      indx(j)=itemp
      GO TO 60
80    indx(l)=indx(j)
      indx(j)=indxt
      jstack=jstack+2
      IF(jstack > nstack)THEN
         WRITE(*,*)'nstack too small in indexx'
         STOP
      END IF
      IF(ir-i+1 >= j-l)THEN
         istack(jstack)=ir
         istack(jstack-1)=i
         ir=j-1
      ELSE
         istack(jstack)=j-1
         istack(jstack-1)=l
         l=i
      END IF
   END IF
   GO TO 20
!
END SUBROUTINE indexx
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE inform1(igr,hh,nbody,tideparm,omega1,omega2,vrot1,  &
   hutfac,vrot2,period,isw80,solarrad,twopie,secinday,separ,  &
   reff3,reff4,p2period,fincsin2,omega3,omega4,vrot3,vrot4,  &
   hutfac2,rk3,rk4,rmass,auslrrad,reff5,reff6,reff7,reff8,  &
   reff9,reff10,ilaw,dwavex,dwavey,contams0,contams1,contams2,  &
   contams3,sdarkint1,sdarkint2,sdarkint3,sdarkint4,sdarkint5,  &
   sdarkint6,sdarkint7,sdarkint8,sdarkint9,isw86,darkint1,  &
   darkint2,darkint3,darkint4,darkint5,tref,ribcinp,dynqq,dynpp,  &
   ecc_arr,a_arr,ma_arr,argper_arr,f_arr,reff1,reff2,radtodeg,  &
   teff1,teff2,teff3,teff4,teff5)
!
!  Writes the first part of ELCdynamics.out (ELC only)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: igr
   REAL(KIND=dp), INTENT(IN)                :: hh
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: tideparm(20)
   REAL(KIND=dp), INTENT(IN)                :: omega1
   REAL(KIND=dp), INTENT(IN)                :: omega2
   REAL(KIND=dp), INTENT(IN)                :: vrot1
   REAL(KIND=dp), INTENT(IN)                :: hutfac
   REAL(KIND=dp), INTENT(IN)                :: vrot2
   REAL(KIND=dp), INTENT(IN)                :: period
   INTEGER, INTENT(IN)                      :: isw80
   REAL(KIND=dp), INTENT(IN)                :: solarrad
   REAL(KIND=dp), INTENT(IN)                :: twopie
   REAL(KIND=dp), INTENT(IN)                :: secinday
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: reff3
   REAL(KIND=dp), INTENT(IN)                :: reff4
   REAL(KIND=dp), INTENT(IN)                :: p2period
   REAL(KIND=dp), INTENT(IN)                :: fincsin2
   REAL(KIND=dp), INTENT(IN)                :: omega3
   REAL(KIND=dp), INTENT(IN)                :: omega4
   REAL(KIND=dp), INTENT(OUT)               :: vrot3
   REAL(KIND=dp), INTENT(OUT)               :: vrot4
   REAL(KIND=dp), INTENT(IN)                :: hutfac2
   REAL(KIND=dp), INTENT(IN)                :: rk3
   REAL(KIND=dp), INTENT(IN)                :: rk4
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: auslrrad
   REAL(KIND=dp), INTENT(IN)                :: reff5
   REAL(KIND=dp), INTENT(IN)                :: reff6
   REAL(KIND=dp), INTENT(IN)                :: reff7
   REAL(KIND=dp), INTENT(IN)                :: reff8
   REAL(KIND=dp), INTENT(IN)                :: reff9
   REAL(KIND=dp), INTENT(IN)                :: reff10
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(IN)                :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN)                :: dwavey(8,10)
   REAL(KIND=dp), INTENT(IN)                :: contams0
   REAL(KIND=dp), INTENT(IN)                :: contams1
   REAL(KIND=dp), INTENT(IN)                :: contams2
   REAL(KIND=dp), INTENT(IN)                :: contams3
   REAL(KIND=dp), INTENT(IN)                :: sdarkint1(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint2(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint3(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint4(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint5(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint6(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint7(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint8(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint9(8)
   INTEGER, INTENT(IN)                      :: isw86
   REAL(KIND=dp), INTENT(IN)                :: darkint1(8)
   REAL(KIND=dp), INTENT(IN)                :: darkint2(8)
   REAL(KIND=dp), INTENT(IN)                :: darkint3(8)
   REAL(KIND=dp), INTENT(IN)                :: darkint4(8)
   REAL(KIND=dp), INTENT(IN)                :: darkint5(8)
   REAL(KIND=dp), INTENT(IN)                :: tref
   REAL(KIND=dp), INTENT(IN)                :: ribcinp(10,6)
   REAL(KIND=dp), INTENT(IN)                :: dynqq(30)
   REAL(KIND=dp), INTENT(IN)                :: dynpp(30)
   REAL(KIND=dp), INTENT(IN)                :: ecc_arr(9)
   REAL(KIND=dp), INTENT(IN)                :: a_arr(9)
   REAL(KIND=dp), INTENT(IN)                :: ma_arr(9)
   REAL(KIND=dp), INTENT(IN)                :: argper_arr(9)
   REAL(KIND=dp), INTENT(IN)                :: f_arr(9)
   REAL(KIND=dp), INTENT(IN)                :: reff1
   REAL(KIND=dp), INTENT(IN)                :: reff2
   REAL(KIND=dp), INTENT(IN)                :: radtodeg
   REAL(KIND=dp), INTENT(IN)                :: teff1
   REAL(KIND=dp), INTENT(IN)                :: teff2
   REAL(KIND=dp), INTENT(IN)                :: teff3
   REAL(KIND=dp), INTENT(IN)                :: teff4
   REAL(KIND=dp), INTENT(IN)                :: teff5
!
   REAL(KIND=dp) :: ftot,fact,totmas,lambda
   REAL(KIND=dp) :: centerx,centery,centerz,centervx,centervy,centervz
!
   INTEGER :: ilength1,ilength2,jj
!
   CHARACTER(LEN=40) :: outstring1,outstring2
!
   OPEN(UNIT=91,FILE='ELCdynamics.out',STATUS='unknown')
   CALL ispacestring('precision',dp,outstring1,ilength1)
   IF(igr == 0)WRITE(91,30)hh,TRIM(outstring1)
   IF(igr == 1)WRITE(91,40)hh,TRIM(outstring1)
   IF(igr == 2)WRITE(91,50)hh,TRIM(outstring1)
   IF(igr == 3)WRITE(91,60)hh,TRIM(outstring1)
   IF(igr == 4)WRITE(91,70)hh,TRIM(outstring1)
!
   WRITE(91,100)nbody
   IF(igr == 2.OR.igr == 3)THEN
      WRITE(91,80)
      WRITE(91,150)
      WRITE(91,80)
      CALL pspacestring('w_rot/w_kep(1)',8,omega1,outstring1,ilength1)
      CALL pspacestring('w_rot/w_kep(2)',8,omega2,outstring2,ilength2)
      WRITE(91,170)TRIM(outstring1),TRIM(outstring2)
      CALL pspacestring('v_rot*sin(i)_1',6,vrot1*hutfac,outstring1,ilength1)
      CALL pspacestring('v_rot*sin(i)_2',6,vrot2*hutfac,outstring2,ilength2)
      WRITE(91,180)TRIM(outstring1),TRIM(outstring2)
      WRITE(91,80)
      WRITE(91,10)tideparm(1),'k2 for star 1'
      WRITE(91,10)omega1*hutfac*twopie/period,  &
         'Omega1, spin rate in rad/day, star 1'
      WRITE(91,10)tideparm(2),'k2 for star 2'
      WRITE(91,10)omega2*hutfac*twopie/period,  &
         'Omega2, spin rate in rad/day, star 2'
      IF(isw80 > 0)THEN
         WRITE(91,80)
         fact=solarrad*twopie/secinday/1.0E+05_dp
         vrot3=fact*reff3*separ/p2period*fincsin2*100.0_dp
         vrot4=fact*reff4*separ/p2period*fincsin2*100.0_dp
         CALL pspacestring('w_rot/w_kep(3)',6,omega3,outstring1,ilength1)
         CALL pspacestring('w_rot/w_kep(4)',6,omega4,outstring2,ilength2)
         WRITE(91,170)TRIM(outstring1),TRIM(outstring2)
         CALL pspacestring('v_rot*sin(i)_3',6,vrot3*hutfac2,outstring1,ilength1)
         CALL pspacestring('v_rot*sin(i)_4',6,vrot4*hutfac2,outstring2,ilength2)
         WRITE(91,180)TRIM(outstring1),TRIM(outstring2)
         WRITE(91,80)
         WRITE(91,10)rk3,'k2 for star 3'
         WRITE(91,10)omega3*hutfac*twopie/p2period,  &
            'Omega3, spin rate in rad/day, star 3'
         WRITE(91,10)rk4,'k2 for star 4'
         WRITE(91,10)omega4*hutfac*twopie/p2period,  &
            'Omega4, spin rate in rad/day, star 4'
      END IF
   END IF
   WRITE(91,80)
   WRITE(91,160)
   WRITE(91,80)
   WRITE(91,10)rmass(1),'mass #1 (solar)'
   WRITE(91,10)rmass(2),'mass #2 (solar)'
   WRITE(91,10)rmass(3),'mass #3 (solar)'
   IF(nbody >= 4)THEN
      WRITE(91,10)rmass(4),'mass #4 (solar)'
   END IF
   IF(nbody >= 5)THEN
      WRITE(91,10)rmass(5),'mass #5 (solar)'
   END IF
   IF(nbody >= 6)THEN
      WRITE(91,10)rmass(6),'mass #6 (solar)'
   END IF
   IF(nbody >= 7)THEN
      WRITE(91,10)rmass(7),'mass #7 (solar)'
   END IF
   IF(nbody >= 8)THEN
      WRITE(91,10)rmass(8),'mass #8 (solar)'
   END IF
   IF(nbody >= 9)THEN
      WRITE(91,10)rmass(9),'mass #9 (solar)'
   END IF
   IF(nbody >= 10)THEN
      WRITE(91,10)rmass(10),'mass #10 (solar)'
   END IF
!
   WRITE(91,10)reff1*separ*auslrrad,'radius #1 (AU)'
   WRITE(91,10)reff2*separ*auslrrad,'radius #2 (AU)'
   WRITE(91,10)reff3*separ*auslrrad,'radius #3 (AU)'
   IF(nbody >= 4)THEN
      WRITE(91,10)reff4*separ*auslrrad,'radius #4 (AU)'
   END IF
   IF(nbody >= 5)THEN
      WRITE(91,10)reff5*separ*auslrrad,'radius #5 (AU)'
   END IF
   IF(nbody >= 6)THEN
      WRITE(91,10)reff6*separ*auslrrad,'radius #6 (AU)'
   END IF
   IF(nbody >= 7)THEN
      WRITE(91,10)reff7*separ*auslrrad,'radius #7 (AU)'
   END IF
   IF(nbody >= 8)THEN
      WRITE(91,10)reff8*separ*auslrrad,'radius #8 (AU)'
   END IF
   IF(nbody >= 9)THEN
      WRITE(91,10)reff9*separ*auslrrad,'radius #9 (AU)'
   END IF
   IF(nbody >= 10)THEN
      WRITE(91,10)reff10*separ*auslrrad,'radius #10 (AU)'
   END IF
!
   WRITE(91,10)reff1*separ,'radius #1 (solar)'
   WRITE(91,10)reff2*separ,'radius #2 (solar)'
   WRITE(91,10)reff3*separ,'radius #3 (solar)'
   IF(nbody >= 4)THEN
      WRITE(91,10)reff4*separ,'radius #4 (solar)'
   END IF
   IF(nbody >= 5)THEN
      WRITE(91,10)reff5*separ,'radius #5 (solar)'
   END IF
   IF(nbody >= 6)THEN
      WRITE(91,10)reff6*separ,'radius #6 (solar)'
   END IF
   IF(nbody >= 7)THEN
      WRITE(91,10)reff7*separ,'radius #7 (solar)'
   END IF
   IF(nbody >= 8)THEN
      WRITE(91,10)reff8*separ,'radius #8 (solar)'
   END IF
   IF(nbody >= 9)THEN
      WRITE(91,10)reff9*separ,'radius #9 (solar)'
   END IF
   IF(nbody >= 10)THEN
      WRITE(91,10)reff10*separ,'radius #10 (solar)'
   END IF
!
   WRITE(91,80)
   WRITE(91,120)
   WRITE(91,80)
   IF(ilaw == 1.OR.ilaw == 11)THEN
      WRITE(91,20)dwavex(1,1),'u1 primary, linear law'
      WRITE(91,80)
      WRITE(91,20)dwavex(1,2),'u1 secondary, linear law'
      WRITE(91,80)
      WRITE(91,20)dwavex(1,3),'u1 tertiary, linear law'
      IF(nbody >= 4)THEN
         WRITE(91,80)
         WRITE(91,20)dwavex(1,4),'u1 body 4, linear law'
      END IF
      IF(nbody >= 5)THEN
         WRITE(91,80)
         WRITE(91,20)dwavex(1,5),'u1 body 5, linear law'
      END IF
   END IF
!
   IF(ilaw == 4.OR.ilaw == 14)THEN
      WRITE(91,20)dwavex(1,1),'u1 primary, quad law'
      WRITE(91,20)dwavey(1,1),'u2 primary, quad law'
      WRITE(91,80)
      WRITE(91,20)dwavex(1,2),'u1 secondary, quad law'
      WRITE(91,20)dwavey(1,2),'u2 secondary, quad law'
      WRITE(91,80)
      WRITE(91,20)dwavex(1,3),'u1 tertiary, quad law'
      WRITE(91,20)dwavey(1,3),'u2 tertiary, quad law'
      IF(nbody >= 4)THEN
         WRITE(91,80)
         WRITE(91,20)dwavex(1,4),'u1 body 4, quad law'
         WRITE(91,20)dwavey(1,4),'u2 body 4, quad law'
      END IF
      IF(nbody >= 5)THEN
         WRITE(91,80)
         WRITE(91,20)dwavex(1,4),'u1 body 5, quad law'
         WRITE(91,20)dwavey(1,4),'u2 body 5, quad law'
      END IF
   END IF
!
   IF(ilaw == 2.OR.ilaw == 12)THEN
      WRITE(91,20)dwavex(1,1),'u1 primary, log law'
      WRITE(91,20)dwavey(1,1),'u2 primary, log law'
      WRITE(91,80)
      WRITE(91,20)dwavex(1,2),'u1 secondary, log law'
      WRITE(91,20)dwavey(1,2),'u2 secondary, log law'
      WRITE(91,80)
      WRITE(91,20)dwavex(1,3),'u1 tertiary, log law'
      WRITE(91,20)dwavey(1,3),'u2 tertiary, log law'
      IF(nbody >= 4)THEN
         WRITE(91,80)
         WRITE(91,20)dwavex(1,4),'u1 body 4, log law'
         WRITE(91,20)dwavey(1,4),'u2 body 4, log law'
      END IF
      IF(nbody >= 5)THEN
         WRITE(91,80)
         WRITE(91,20)dwavex(1,4),'u1 body 5, log law'
         WRITE(91,20)dwavey(1,4),'u2 body 5, log law'
      END IF
   END IF
!
   IF(ilaw == 3.OR.ilaw == 13)THEN
      WRITE(91,20)dwavex(1,1),'u1 primary, sqrt law'
      WRITE(91,20)dwavey(1,1),'u2 primary, sqrt law'
      WRITE(91,80)
      WRITE(91,20)dwavex(1,2),'u1 secondary, sqrt law'
      WRITE(91,20)dwavey(1,2),'u2 secondary, sqrt law'
      WRITE(91,80)
      WRITE(91,20)dwavex(1,3),'u1 tertiary, sqrt law'
      WRITE(91,20)dwavey(1,3),'u2 tertiary, sqrt law'
      IF(nbody >= 4)THEN
         WRITE(91,80)
         WRITE(91,20)dwavex(1,4),'u1 body 4, sqrt law'
         WRITE(91,20)dwavey(1,4),'u2 body 4, sqrt law'
      END IF
      IF(nbody >= 5)THEN
         WRITE(91,80)
         WRITE(91,20)dwavex(1,4),'u1 body 5, sqrt law'
         WRITE(91,20)dwavey(1,4),'u2 body 5, sqrt law'
      END IF
   END IF
!
   IF(ilaw == 5.OR.ilaw == 15)THEN
      WRITE(91,20)dwavex(1,1),'q1 primary, Kipping quad law'
      WRITE(91,20)dwavey(1,1),'q2 primary, Kipping quad law'
      WRITE(91,80)
      WRITE(91,20)2.0_dp*SQRT(dwavex(1,1))*dwavey(1,1),'u1 primary, quad law'
      WRITE(91,20)SQRT(dwavex(1,1))*(1.0_dp-2.0_dp*dwavey(1,1)),  &
         'u2 primary, quad law'
      WRITE(91,80)
      WRITE(91,80)
      WRITE(91,20)dwavex(1,2),'q1 secondary, Kipping quad law'
      WRITE(91,20)dwavey(1,2),'q2 secondary, Kipping quad law'
      WRITE(91,80)
      WRITE(91,20)2.0_dp*SQRT(dwavex(1,2))*dwavey(1,2),'u1 secondary, quad law'
      WRITE(91,20)SQRT(dwavex(1,2))*(1.0_dp-2.0_dp*dwavey(1,2)),  &
         'u2 secondary, quad law'
      WRITE(91,80)
      WRITE(91,80)
      WRITE(91,20)dwavex(1,3),'q1 tertiary, Kipping quad law'
      WRITE(91,20)dwavey(1,3),'q2 tertiary, Kipping quad law'
      WRITE(91,80)
      WRITE(91,20)2.0_dp*SQRT(dwavex(1,3))*dwavey(1,3),'u1 tertiary, quad law'
      WRITE(91,20)SQRT(dwavex(1,3))*(1.0_dp-2.0_dp*dwavey(1,3)),  &
         'u2 tertiary, quad law'
      IF(nbody >= 4)THEN
         WRITE(91,80)
         WRITE(91,80)
         WRITE(91,20)dwavex(1,4),'q1 body 4, Kipping quad law'
         WRITE(91,20)dwavey(1,4),'q2 body 4, Kipping quad law'
         WRITE(91,80)
         WRITE(91,20)2.0_dp*SQRT(dwavex(1,4))*dwavey(1,4),'u1 body 4, quad law'
         WRITE(91,20)SQRT(dwavex(1,4))*(1.0_dp-2.0_dp*dwavey(1,4)),  &
            'u2 body 4, quad law'
      END IF
   END IF
!
   IF(ilaw == 6.OR.ilaw == 16)THEN
      WRITE(91,20)dwavex(1,1),'q1 primary, triangular log law'
      WRITE(91,20)dwavey(1,1),'q2 primary, triangular log law'
      WRITE(91,80)
      WRITE(91,20)1.0_dp-SQRT(dwavex(1,1))*dwavey(1,1),'u1 primary, log law'
      WRITE(91,20)1.0_dp-SQRT(dwavex(1,1)),'u2 primary, log law'
      WRITE(91,80)
      WRITE(91,80)
      WRITE(91,20)dwavex(1,2),'q1 secondary, triangular log law'
      WRITE(91,20)dwavey(1,2),'q2 secondary, triangular log law'
      WRITE(91,80)
      WRITE(91,20)1.0_dp-SQRT(dwavex(1,2))*dwavey(1,2),'u1 secondary, log law'
      WRITE(91,20)1.0_dp-SQRT(dwavex(1,2)),'u2 secondary, log law'
      WRITE(91,80)
      WRITE(91,80)
      WRITE(91,20)dwavex(1,3),'q1 tertiary, triangular log law'
      WRITE(91,20)dwavey(1,3),'q2 tertiary, triangular log law'
      WRITE(91,80)
      WRITE(91,20)1.0_dp-SQRT(dwavex(1,3))*dwavey(1,3),'u1 tertiary, log law'
      WRITE(91,20)1.0_dp-SQRT(dwavex(1,3)),'u2 tertiary, log law'
      IF(nbody >= 4)THEN
         WRITE(91,80)
         WRITE(91,80)
         WRITE(91,20)dwavex(1,4),'q1 body 4, triangular log law'
         WRITE(91,20)dwavey(1,4),'q2 body 4, triangular log law'
         WRITE(91,80)
         WRITE(91,20)1.0_dp-SQRT(dwavex(1,4))*dwavey(1,4),'u1 body 4, log law'
         WRITE(91,20)1.0_dp-SQRT(dwavex(1,4)),'u2 body 4, log law'
      END IF
!
      IF(nbody >= 5)THEN
         WRITE(91,80)
         WRITE(91,80)
         WRITE(91,20)dwavex(1,5),'q1 body 5, triangular log law'
         WRITE(91,20)dwavey(1,5),'q2 body 5, triangluar log law'
         WRITE(91,80)
         WRITE(91,20)1.0_dp-SQRT(dwavex(1,5))*dwavey(1,5),'u1 body 5, log law'
         WRITE(91,20)1.0_dp-SQRT(dwavex(1,5)),'u2 body 5, log law'
      END IF
   END IF
!
   IF(ilaw == 7.OR.ilaw == 17)THEN
      WRITE(91,20)dwavex(1,1),'q1 primary, triangular sqrt law'
      WRITE(91,20)dwavey(1,1),'q2 primary, triangular sqrt law'
      WRITE(91,80)
      WRITE(91,20)SQRT(dwavex(1,1))*(1.0_dp-2.0_dp*dwavey(1,1)),  &
         'u1 primary, sqrt law'
      WRITE(91,20)2.0_dp*SQRT(dwavex(1,1))*dwavey(1,1),'u2 primary, sqrt law'
      WRITE(91,80)
      WRITE(91,80)
      WRITE(91,20)dwavex(1,2),'q1 secondary, triangular sqrt law'
      WRITE(91,20)dwavey(1,2),'q2 secondary, triangular sqrt law'
      WRITE(91,80)
      WRITE(91,20)SQRT(dwavex(1,2))*(1.0_dp-2.0_dp*dwavey(1,2)),  &
         'u1 secondary, sqrt law'
      WRITE(91,20)2.0_dp*SQRT(dwavex(1,2))*dwavey(1,2),'u2 secondary, sqrt law'
      WRITE(91,80)
      WRITE(91,80)
      WRITE(91,20)dwavex(1,3),'q1 tertiary, triangular sqrt law'
      WRITE(91,20)dwavey(1,3),'q2 tertiary, triangular sqrt law'
      WRITE(91,80)
      WRITE(91,20)SQRT(dwavex(1,3))*(1.0_dp-2.0_dp*dwavey(1,3)),  &
         'u1 tertiary, sqrt law'
      WRITE(91,20)2.0_dp*SQRT(dwavex(1,3))*dwavey(1,3),'u2 tertiary, sqrt law'
      IF(nbody >= 4)THEN
         WRITE(91,80)
         WRITE(91,80)
         WRITE(91,20)dwavex(1,4),'q1 body 4, triangular sqrt law'
         WRITE(91,20)dwavey(1,4),'q2 body 4, triangular sqrt law'
         WRITE(91,80)
         WRITE(91,20)SQRT(dwavex(1,4))*(1.0_dp-2.0_dp*dwavey(1,4)),  &
            'u1 body 4, sqrt law'
         WRITE(91,20) 2.0_dp*SQRT(dwavex(1,4))*dwavey(1,4),'u2 body 4, sqrt law'
      END IF

      IF(nbody >= 5)THEN
         WRITE(91,80)
         WRITE(91,80)
         WRITE(91,20)dwavex(1,5),'q1 body 5, triangular sqrt law'
         WRITE(91,20)dwavey(1,5),'q2 body 5, triangluar sqrt law'
         WRITE(91,80)
         WRITE(91,20)SQRT(dwavex(1,5))*(1.0_dp-2.0_dp*dwavey(1,5)),  &
            'u1 body 5, sqrt law'
         WRITE(91,20)2.0_dp*SQRT(dwavex(1,5))*dwavey(1,5),'u2 body 5, sqrt law'
      END IF
   END IF
!
   WRITE(91,80)
   WRITE(91,130)
   WRITE(91,80)
   WRITE(91,20)contams0,'Q1, Q5, Q9, Q13, Q17'
   WRITE(91,20)contams1,'Q2, Q6, Q10, Q14'
   WRITE(91,20)contams2,'Q3, Q7, Q11, Q15'
   WRITE(91,20)contams3,'Q4, Q8, Q12, Q16'
   WRITE(91,80)
   WRITE(91,140)
   WRITE(91,80)
   IF(isw86 >= 1)THEN
      WRITE(91,20)sdarkint1(1),'flux primary'
      IF(isw86 >= 2)THEN
         WRITE(91,20)sdarkint1(1)*sdarkint2(1),'flux secondary'
      ELSE
         WRITE(91,20)sdarkint2(1),'flux secondary'
      END IF
      IF(isw86 >= 2)THEN
         WRITE(91,20)sdarkint1(1)*sdarkint3(1),'flux tertiary'
      ELSE
         WRITE(91,20)sdarkint3(1),'flux tertiary'
      END IF
      IF(nbody >= 4)THEN
         IF(isw86 >= 2)THEN
            WRITE(91,20)sdarkint1(1)*sdarkint4(1),'flux body 4'
         ELSE
            WRITE(91,20)sdarkint4(1),'flux body 4'
         END IF
      END IF
      IF(nbody >= 5)THEN
         IF(isw86 >= 2)THEN
            WRITE(91,20)sdarkint1(1)*sdarkint5(1),'flux body 5'
         ELSE
            WRITE(91,20)sdarkint5(1),'flux body 5'
         END IF
      END IF
      IF(nbody >= 6)THEN
         IF(isw86 >= 2)THEN
            WRITE(91,20)sdarkint1(1)*sdarkint6(1),'flux body 6'
         ELSE
            WRITE(91,20)sdarkint6(1),'flux body 6'
         END IF
      END IF
      IF(nbody >= 7)THEN
         IF(isw86 >= 2)THEN
            WRITE(91,20)sdarkint1(1)*sdarkint7(1),'flux body 7'
         ELSE
            WRITE(91,20)sdarkint7(1),'flux body 7'
         END IF
      END IF
      IF(nbody >= 8)THEN
         IF(isw86 >= 2)THEN
            WRITE(91,20)sdarkint1(1)*sdarkint8(1),'flux body 8'
         ELSE
            WRITE(91,20)sdarkint8(1),'flux body 8'
         END IF
      END IF
      IF(nbody >= 9)THEN
         IF(isw86 >= 2)THEN
            WRITE(91,20)sdarkint1(1)*sdarkint9(1),'flux body 9'
         ELSE
            WRITE(91,20)sdarkint9(1),'flux body 9'
         END IF
      END IF
   ELSE
      ftot=darkint1(1)+darkint2(1)+darkint3(1)
      IF(nbody >= 4)ftot=ftot+darkint4(1)
      IF(nbody >= 5)ftot=ftot+darkint5(1)
      WRITE(91,20)darkint1(1)/ftot,'flux primary'
      WRITE(91,20)darkint2(1)/ftot,'flux secondary'
      WRITE(91,20)darkint3(1)/ftot,'flux tertiary'
      IF(nbody >= 4)WRITE(91,20)darkint4(1)/ftot,'flux body 4'
      IF(nbody >= 5)WRITE(91,20)darkint5(1)/ftot,'flux body 5'
      IF(nbody >= 6)WRITE(91,20)darkint5(1)/ftot,'flux body 6'
      IF(nbody >= 7)WRITE(91,20)darkint5(1)/ftot,'flux body 7'
      IF(nbody >= 8)WRITE(91,20)darkint5(1)/ftot,'flux body 8'
      IF(nbody >= 9)WRITE(91,20)darkint5(1)/ftot,'flux body 9'
      IF(nbody >= 10)WRITE(91,20)darkint5(1)/ftot,'flux body 10'
   END IF
   WRITE(91,25)teff1,'Teff1 (K)'
   WRITE(91,25)teff2,'Teff2 (K)'
   WRITE(91,25)teff3,'Teff3 (K)'
   IF(nbody >= 4)WRITE(91,25)teff4,'Teff4 (K)'
   IF(nbody >= 5)WRITE(91,25)teff5,'Teff5 (K)'
   WRITE(91,80)
   WRITE(91,110)tref
   WRITE(91,80)
   WRITE(91,10)ribcinp(1,1),'period 1 (days)'
   WRITE(91,10)ribcinp(1,2),'e*cos(omega) 1'
   WRITE(91,10)ribcinp(1,3),'e*sin(omega) 1'
   WRITE(91,10)ribcinp(1,4),'inclination 1 (rad)'
   WRITE(91,10)ribcinp(1,5),'Omega 1 (rad)'
   WRITE(91,10)ribcinp(1,6),'Tconj 1'
   WRITE(91,10)a_arr(1),'semimajor axis 1 (AU)'
   WRITE(91,10)ecc_arr(1),'eccentricity 1'
   WRITE(91,10)argper_arr(1)*radtodeg,'arg. per. 1 (deg)'
   WRITE(91,10)f_arr(1)*radtodeg,'true anomaly 1 (deg)'
   WRITE(91,10)ma_arr(1)*radtodeg,'mean anomaly 1 (deg)'
   lambda=(argper_arr(1)+f_arr(1)+ribcinp(1,5))*radtodeg
   WRITE(91,10)lambda,'mean longitude 1 (deg)'
   WRITE(91,10)ribcinp(1,4)*radtodeg,'inclination 1 (deg)'
   WRITE(91,10)ribcinp(1,5)*radtodeg,'Omega 1 (deg)'
!
   WRITE(91,80)
   WRITE(91,10)ribcinp(2,1),'period 2 (days)'
   WRITE(91,10)ribcinp(2,2),'e*cos(omega) 2'
   WRITE(91,10)ribcinp(2,3),'e*sin(omega) 2'
   WRITE(91,10)ribcinp(2,4),'inclination 2 (rad)'
   WRITE(91,10)ribcinp(2,5),'Omega 2 (rad)'
   WRITE(91,10)ribcinp(2,6),'Tconj 2'
   WRITE(91,10)a_arr(2),'semimajor axis 2 (AU)'
   WRITE(91,10)ecc_arr(2),'eccentricity 2'
   WRITE(91,10)argper_arr(2)*radtodeg,'arg. per. 2 (deg)'
   WRITE(91,10)f_arr(2)*radtodeg,'true anomaly 2 (deg)'
   WRITE(91,10)ma_arr(2)*radtodeg,'mean anomaly 2 (deg)'
   lambda=(argper_arr(2)+f_arr(2)+ribcinp(2,5))*radtodeg
   WRITE(91,10)lambda,'mean longitude 2 (deg)'
   WRITE(91,10)ribcinp(2,4)*radtodeg,'inclination 2 (deg)'
   WRITE(91,10)ribcinp(2,5)*radtodeg,'Omega 2 (deg)'
!
   WRITE(91,80)
   IF(nbody >= 4)THEN
      WRITE(91,10)ribcinp(3,1),'period 3 (days)'
      WRITE(91,10)ribcinp(3,2),'e*cos(omega) 3'
      WRITE(91,10)ribcinp(3,3),'e*sin(omega) 3'
      WRITE(91,10)ribcinp(3,4),'inclination 3 (rad)'
      WRITE(91,10)ribcinp(3,5),'Omega 3 (rad)'
      WRITE(91,10)ribcinp(3,6),'Tconj 3'
      WRITE(91,10)a_arr(3),'semimajor axis 3 (AU)'
      WRITE(91,10)ecc_arr(3),'eccentricity 3'
      WRITE(91,10)argper_arr(3)*radtodeg,'arg. per. 3 (deg)'
      WRITE(91,10)f_arr(3)*radtodeg,'true anomaly 3 (deg)'
      WRITE(91,10)ma_arr(3)*radtodeg,'mean anomaly 3 (deg)'
      lambda=(argper_arr(3)+f_arr(3)+ribcinp(3,5))*radtodeg
      WRITE(91,10)lambda,'mean longitude 3 (deg)'
      WRITE(91,10)ribcinp(3,4)*radtodeg,'inclination 3 (deg)'
      WRITE(91,10)ribcinp(3,5)*radtodeg,'Omega 3 (deg)'
      WRITE(91,80)
   END IF
   IF(nbody >= 5)THEN
      WRITE(91,10)ribcinp(4,1),'period 4 (days)'
      WRITE(91,10)ribcinp(4,2),'e*cos(omega) 4'
      WRITE(91,10)ribcinp(4,3),'e*sin(omega) 4'
      WRITE(91,10)ribcinp(4,4),'inclination 4 (rad)'
      WRITE(91,10)ribcinp(4,5),'Omega 4 (rad)'
      WRITE(91,10)ribcinp(4,6),'Tconj 4'
      WRITE(91,10)a_arr(4),'semimajor axis 4 (AU)'
      WRITE(91,10)ecc_arr(4),'eccentricity 4'
      WRITE(91,10)argper_arr(4)*radtodeg,'arg. per. 4 (deg)'
      WRITE(91,10)f_arr(4)*radtodeg,'true anomaly 4 (deg)'
      WRITE(91,10)ma_arr(4)*radtodeg,'mean anomaly 4 (deg)'
      lambda=(argper_arr(4)+f_arr(4)+ribcinp(4,5))*radtodeg
      WRITE(91,10)lambda,'mean longitude 4 (deg)'
      WRITE(91,10)ribcinp(4,4)*radtodeg,'inclination 4 (deg)'
      WRITE(91,10)ribcinp(4,5)*radtodeg,'Omega 4 (deg)'
      WRITE(91,80)
   END IF
   IF(nbody >= 6)THEN
      WRITE(91,10)ribcinp(5,1),'period 5 (days)'
      WRITE(91,10)ribcinp(5,2),'e*cos(omega) 5'
      WRITE(91,10)ribcinp(5,3),'e*sin(omega) 5'
      WRITE(91,10)ribcinp(5,4),'inclination 5 (rad)'
      WRITE(91,10)ribcinp(5,5),'Omega 5 (rad)'
      WRITE(91,10)ribcinp(5,6),'Tconj 5'
      WRITE(91,10)a_arr(5),'semimajor axis 5 (AU)'
      WRITE(91,10)ecc_arr(5),'eccentricity 5'
      WRITE(91,10)argper_arr(5)*radtodeg,'arg. per. 5 (deg)'
      WRITE(91,10)f_arr(5)*radtodeg,'true anomaly 5 (deg)'
      WRITE(91,10)ma_arr(5)*radtodeg,'mean anomaly 5 (deg)'
      lambda=(argper_arr(5)+f_arr(5)+ribcinp(5,5))*radtodeg
      WRITE(91,10)lambda,'mean longitude 5 (deg)'
      WRITE(91,10)ribcinp(5,4)*radtodeg,'inclination 5 (deg)'
      WRITE(91,10)ribcinp(5,5)*radtodeg,'Omega 5 (deg)'
      WRITE(91,80)
   END IF
   IF(nbody >= 7)THEN
      WRITE(91,10)ribcinp(6,1),'period 6 (days)'
      WRITE(91,10)ribcinp(6,2),'e*cos(omega) 6'
      WRITE(91,10)ribcinp(6,3),'e*sin(omega) 6'
      WRITE(91,10)ribcinp(6,4),'inclination 6 (rad)'
      WRITE(91,10)ribcinp(6,5),'Omega 6 (rad)'
      WRITE(91,10)ribcinp(6,6),'Tconj 6'
      WRITE(91,10)a_arr(6),'semimajor axis 6 (AU)'
      WRITE(91,10)ecc_arr(6),'eccentricity 6'
      WRITE(91,10)argper_arr(6)*radtodeg,'arg. per. 6 (deg)'
      WRITE(91,10)f_arr(6)*radtodeg,'true anomaly 6 (deg)'
      WRITE(91,10)ma_arr(6)*radtodeg,'mean anomaly 6 (deg)'
      lambda=(argper_arr(6)+f_arr(6)+ribcinp(6,5))*radtodeg
      WRITE(91,10)lambda,'mean longitude 6 (deg)'
      WRITE(91,10)ribcinp(6,4)*radtodeg,'inclination 6 (deg)'
      WRITE(91,10)ribcinp(6,5)*radtodeg,'Omega 6 (deg)'
      WRITE(91,80)
   END IF
   IF(nbody >= 8)THEN
      WRITE(91,10)ribcinp(7,1),'period 7 (days)'
      WRITE(91,10)ribcinp(7,2),'e*cos(omega) 7'
      WRITE(91,10)ribcinp(7,3),'e*sin(omega) 7'
      WRITE(91,10)ribcinp(7,4),'inclination 7 (rad)'
      WRITE(91,10)ribcinp(7,5),'Omega 7 (rad)'
      WRITE(91,10)ribcinp(7,6),'Tconj 7'
      WRITE(91,10)a_arr(7),'semimajor axis 7 (AU)'
      WRITE(91,10)ecc_arr(7),'eccentricity 7'
      WRITE(91,10)argper_arr(7)*radtodeg,'arg. per. 7 (deg)'
      WRITE(91,10)f_arr(7)*radtodeg,'true anomaly 7 (deg)'
      WRITE(91,10)ma_arr(7)*radtodeg,'mean anomaly 7 (deg)'
      lambda=(argper_arr(7)+f_arr(7)+ribcinp(7,5))*radtodeg
      WRITE(91,10)lambda,'mean longitude 7 (deg)'
      WRITE(91,10)ribcinp(7,4)*radtodeg,'inclination 7 (deg)'
      WRITE(91,10)ribcinp(7,5)*radtodeg,'Omega 7 (deg)'
      WRITE(91,80)
   END IF
   IF(nbody >= 9)THEN
      WRITE(91,10)ribcinp(8,1),'period 8 (days)'
      WRITE(91,10)ribcinp(8,2),'e*cos(omega) 8'
      WRITE(91,10)ribcinp(8,3),'e*sin(omega) 8'
      WRITE(91,10)ribcinp(8,4),'inclination 8 (rad)'
      WRITE(91,10)ribcinp(8,5),'Omega 8 (rad)'
      WRITE(91,10)ribcinp(8,6),'Tconj 8'
      WRITE(91,10)a_arr(8),'semimajor axis 8 (AU)'
      WRITE(91,10)ecc_arr(8),'eccentricity 8'
      WRITE(91,10)argper_arr(8)*radtodeg,'arg. per. 8 (deg)'
      WRITE(91,10)f_arr(8)*radtodeg,'true anomaly 8 (deg)'
      WRITE(91,10)ma_arr(8)*radtodeg,'mean anomaly 8 (deg)'
      lambda=(argper_arr(8)+f_arr(8)+ribcinp(8,5))*radtodeg
      WRITE(91,10)lambda,'mean longitude 8 (deg)'
      WRITE(91,10)ribcinp(8,4)*radtodeg,'inclination 8 (deg)'
      WRITE(91,10)ribcinp(8,5)*radtodeg,'Omega 8 (deg)'
      WRITE(91,80)
   END IF
   IF(nbody >= 10)THEN
      WRITE(91,10)ribcinp(9,1),'period 9 (days)'
      WRITE(91,10)ribcinp(9,2),'e*cos(omega) 9'
      WRITE(91,10)ribcinp(9,3),'e*sin(omega) 9'
      WRITE(91,10)ribcinp(9,4),'inclination 9 (rad)'
      WRITE(91,10)ribcinp(9,5),'Omega 9 (rad)'
      WRITE(91,10)ribcinp(9,6),'Tconj 9'
      WRITE(91,10)a_arr(9),'semimajor axis 9 (AU)'
      WRITE(91,10)ecc_arr(9),'eccentricity 9'
      WRITE(91,10)argper_arr(9)*radtodeg,'arg. per. 9 (deg)'
      WRITE(91,10)f_arr(9)*radtodeg,'true anomaly 9 (deg)'
      WRITE(91,10)ma_arr(9)*radtodeg,'mean anomaly 9 (deg)'
      lambda=(argper_arr(9)+f_arr(9)+ribcinp(9,5))*radtodeg
      WRITE(91,10)lambda,'mean longitude 9 (deg)'
      WRITE(91,10)ribcinp(9,4)*radtodeg,'inclination 9 (deg)'
      WRITE(91,10)ribcinp(9,5)*radtodeg,'Omega 9 (deg)'
      WRITE(91,80)
   END IF
!WRITE(91,80)
   WRITE(91,90) tref
   WRITE(91,80)
   WRITE(91,10)dynqq(1),'x-coordinate, body 1 (AU)'
   WRITE(91,10)dynqq(2),'y-coordinate, body 1 (AU)'
   WRITE(91,10)dynqq(3),'z-coordinate, body 1 (AU)'
   WRITE(91,80)
   WRITE(91,10)dynqq(4),'x-coordinate, body 2 (AU)'
   WRITE(91,10)dynqq(5),'y-coordinate, body 2 (AU)'
   WRITE(91,10)dynqq(6),'z-coordinate, body 2 (AU)'
   WRITE(91,80)
   WRITE(91,10)dynqq(7),'x-coordinate, body 3 (AU)'
   WRITE(91,10)dynqq(8),'y-coordinate, body 3 (AU)'
   WRITE(91,10)dynqq(9),'z-coordinate, body 3 (AU)'
   WRITE(91,80)
   IF(nbody >= 4)THEN
      WRITE(91,10)dynqq(10),'x-coordinate, body 4 (AU)'
      WRITE(91,10)dynqq(11),'y-coordinate, body 4 (AU)'
      WRITE(91,10)dynqq(12),'z-coordinate, body 4 (AU)'
      WRITE(91,80)
   END IF
   IF(nbody >= 5)THEN
      WRITE(91,10)dynqq(13),'x-coordinate, body 5 (AU)'
      WRITE(91,10)dynqq(14),'y-coordinate, body 5 (AU)'
      WRITE(91,10)dynqq(15),'z-coordinate, body 5 (AU)'
      WRITE(91,80)
   END IF
   IF(nbody >= 6)THEN
      WRITE(91,10)dynqq(16),'x-coordinate, body 6 (AU)'
      WRITE(91,10)dynqq(17),'y-coordinate, body 6 (AU)'
      WRITE(91,10)dynqq(18),'z-coordinate, body 6 (AU)'
      WRITE(91,80)
   END IF
   IF(nbody >= 7)THEN
      WRITE(91,10)dynqq(19),'x-coordinate, body 7 (AU)'
      WRITE(91,10)dynqq(20),'y-coordinate, body 7 (AU)'
      WRITE(91,10)dynqq(21),'z-coordinate, body 7 (AU)'
      WRITE(91,80)
   END IF
   IF(nbody >= 8)THEN
      WRITE(91,10)dynqq(22),'x-coordinate, body 8 (AU)'
      WRITE(91,10)dynqq(23),'y-coordinate, body 8 (AU)'
      WRITE(91,10)dynqq(24),'z-coordinate, body 8 (AU)'
      WRITE(91,80)
   END IF
   IF(nbody >= 9)THEN
      WRITE(91,10)dynqq(25),'x-coordinate, body 9 (AU)'
      WRITE(91,10)dynqq(26),'y-coordinate, body 9 (AU)'
      WRITE(91,10)dynqq(27),'z-coordinate, body 9 (AU)'
      WRITE(91,80)
   END IF
   IF(nbody >= 10)THEN
      WRITE(91,10)dynqq(28),'x-coordinate, body 10 (AU)'
      WRITE(91,10)dynqq(29),'y-coordinate, body 10 (AU)'
      WRITE(91,10)dynqq(30),'z-coordinate, body 10 (AU)'
      WRITE(91,80)
   END IF
!
   WRITE(91,10)dynpp(1),'x-velocity, body 1 (AU/day)'
   WRITE(91,10)dynpp(2),'y-velocity, body 1 (AU/day)'
   WRITE(91,10)dynpp(3),'z-velocity, body 1 (AU/day)'
   WRITE(91,80)
   WRITE(91,10)dynpp(4),'x-velocity, body 2 (AU/day)'
   WRITE(91,10)dynpp(5),'y-velocity, body 2 (AU/day)'
   WRITE(91,10)dynpp(6),'z-velocity, body 2 (AU/day)'
   WRITE(91,80)
   WRITE(91,10)dynpp(7),'x-velocity, body 3 (AU/day)'
   WRITE(91,10)dynpp(8),'y-velocity, body 3 (AU/day)'
   WRITE(91,10)dynpp(9),'z-velocity, body 3 (AU/day)'
   WRITE(91,80)
   IF(nbody >= 4)THEN
      WRITE(91,10)dynpp(10),'x-velocity, body 4 (AU/day)'
      WRITE(91,10)dynpp(11),'y-velocity, body 4 (AU/day)'
      WRITE(91,10)dynpp(12),'z-velocity, body 4 (AU/day)'
      WRITE(91,80)
   END IF
   IF(nbody >= 5)THEN
      WRITE(91,10)dynpp(13),'x-velocity, body 5 (AU/day)'
      WRITE(91,10)dynpp(14),'y-velocity, body 5 (AU/day)'
      WRITE(91,10)dynpp(15),'z-velocity, body 5 (AU/day)'
      WRITE(91,80)
   END IF
   IF(nbody >= 6)THEN
      WRITE(91,10)dynpp(16),'x-velocity, body 6 (AU/day)'
      WRITE(91,10)dynpp(17),'y-velocity, body 6 (AU/day)'
      WRITE(91,10)dynpp(18),'z-velocity, body 6 (AU/day)'
      WRITE(91,80)
   END IF
   IF(nbody >= 7)THEN
      WRITE(91,10)dynpp(19),'x-velocity, body 7 (AU/day)'
      WRITE(91,10)dynpp(20),'y-velocity, body 7 (AU/day)'
      WRITE(91,10)dynpp(21),'z-velocity, body 7 (AU/day)'
      WRITE(91,80)
   END IF
   IF(nbody >= 8)THEN
      WRITE(91,10)dynpp(22),'x-velocity, body 8 (AU/day)'
      WRITE(91,10)dynpp(23),'y-velocity, body 8 (AU/day)'
      WRITE(91,10)dynpp(24),'z-velocity, body 8 (AU/day)'
      WRITE(91,80)
   END IF
   IF(nbody >= 9)THEN
      WRITE(91,10)dynpp(25),'x-velocity, body 9 (AU/day)'
      WRITE(91,10)dynpp(26),'y-velocity, body 9 (AU/day)'
      WRITE(91,10)dynpp(27),'z-velocity, body 9 (AU/day)'
      WRITE(91,80)
   END IF
   IF(nbody >= 10)THEN
      WRITE(91,10)dynpp(28),'x-velocity, body 10 (AU/day)'
      WRITE(91,10)dynpp(29),'y-velocity, body 10 (AU/day)'
      WRITE(91,10)dynpp(30),'z-velocity, body 10 (AU/day)'
      WRITE(91,80)
   END IF
!
   centerx=0.0_dp
   centery=0.0_dp
   centerz=0.0_dp
   centervx=0.0_dp
   centervy=0.0_dp
   centervz=0.0_dp
   totmas=0.0_dp
   DO jj=1,nbody
      totmas=totmas+rmass(jj)
      centerx=centerx+rmass(jj)*dynqq(1+(jj-1)*3)
      centery=centery+rmass(jj)*dynqq(2+(jj-1)*3)
      centerz=centerz+rmass(jj)*dynqq(3+(jj-1)*3)
      centervx=centervx+rmass(jj)*dynpp(1+(jj-1)*3)
      centervy=centervy+rmass(jj)*dynpp(2+(jj-1)*3)
      centervz=centervz+rmass(jj)*dynpp(3+(jj-1)*3)
   END DO
   WRITE(91,10)centerx/totmas,'x-coordinate of C.O.M.'
   WRITE(91,10)centery/totmas,'y-coordinate of C.O.M.'
   WRITE(91,10)centerz/totmas,'z-coordinate of C.O.M.'
   WRITE(91,80)
   WRITE(91,10)centervx/totmas,'x-velocity of C.O.M.'
   WRITE(91,10)centervy/totmas,'y-velocity of C.O.M.'
   WRITE(91,10)centervz/totmas,'z-velocity of C.O.M.'
   WRITE(91,80)
!
   CALL writetex(nbody,ribcinp,dynpp,dynqq,rmass,tref,hh,isw80)
!
10 FORMAT(1PE24.17,10X,a)
20 FORMAT(f17.14,17X,a)
25 FORMAT(f10.4,24X,a)
30 FORMAT('#  Second-order system, integration step = ',f10.7, ' days, ',a)
40 FORMAT('#  First-order system, GR included,',' integration ',  &
      'step = ',f10.7,' days, ',a)
50 FORMAT('#  First-order system, tidal apsidal included,',' int'  &
      ,'egration step = ',f10.7,' days, ',a)
60 FORMAT('#  First-order system, GR and tidal apsidal',/'#  i',  &
      'ncluded, integration step = ',f10.7,' days, ',a)
70 FORMAT('#  First-order system,',' integration step = ',f10.7,  &
      ' days, ',a)
80 FORMAT('#')
90 FORMAT('#  Cartesian coordinates at day ',f15.5)
100 FORMAT('#  Number of bodies = ',i1)
110 FORMAT('#  Keplerian elements at day ',f15.9)
120 FORMAT('#  Limb darkening parameters for Kepler ','bandpass:')
130 FORMAT('#  Contamination parameters:')
140 FORMAT('#  Fluxes and temperatures:')
150 FORMAT('#  Apsidal parameters:')
160 FORMAT('#  Masses and radii:')
170 FORMAT('#',2X,a,',',1X,a)
180 FORMAT('#',2X,a,1X,'km/sec,',1X,a,1X,'km/sec')
!
   RETURN
!
END SUBROUTINE inform1
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE inform2(nbody,dynqq,dynpp,rmass,tstart,tref,  &
   radtodeg,isw80)
!
!   writes part 2 of ELCdynamics.out (ELC only)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: dynqq(30)
   REAL(KIND=dp), INTENT(IN)                :: dynpp(30)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: tstart
   REAL(KIND=dp), INTENT(IN)                :: tref
   REAL(KIND=dp), INTENT(IN)                :: radtodeg
   INTEGER, INTENT(IN)                      :: isw80
!
   REAL(KIND=dp), DIMENSION(9)  :: p_arr,ecc_arr,a_arr,ma_arr,argper_arr
   REAL(KIND=dp), DIMENSION(9)  :: inc_arr,long_arr,tconj_arr,f_arr
   REAL(KIND=dp)  :: centerx,centery,centerz,lambda
   REAL(KIND=dp)  :: totmas,centervx,centervy,centervz,fred
!
   INTEGER :: jj
!
   IF((Nbody.eq.4).and.(isw80.ge.1))THEN
      CALL newcartkepbinbin(rmass,dynQQ,dynPP,Tref,p_arr, &
         ecc_arr,a_arr,MA_arr,ArgPer_arr,inc_arr,long_arr, &
         Tconj_arr,f_arr)
   ELSE
      CALL newcartkep(nbody,rmass,dynqq,dynpp,tref,p_arr,  &
         ecc_arr,a_arr,ma_arr,argper_arr,inc_arr,long_arr,  &
         tconj_arr,f_arr)
   END IF
!!
   WRITE(91,10)tstart
   WRITE(91,30)
   WRITE(91,20)p_arr(1),'period 1 (days)'
   fred=ecc_arr(1)*COS(argper_arr(1))
   WRITE(91,20) fred,'e*cos(omega) 1'
   fred=ecc_arr(1)*SIN(argper_arr(1))
   WRITE(91,20)fred,'e*sin(omega) 1'
   WRITE(91,20)inc_arr(1),'inclination 1 (rad)'
   WRITE(91,20)long_arr(1),'Omega 1 (rad)'
   WRITE(91,20)tconj_arr(1),'Tconj 1'
   WRITE(91,20)a_arr(1),'semimajor axis 1 (AU)'
   WRITE(91,20)ecc_arr(1),'eccentricity 1'
   WRITE(91,20)argper_arr(1)*radtodeg,'arg. per. 1 (deg)'
   WRITE(91,20)f_arr(1)*radtodeg,'true anomaly 1 (deg)'
   WRITE(91,20)ma_arr(1)*radtodeg,'mean anomaly 1 (deg)'
   lambda=(argper_arr(1)+f_arr(1)+long_arr(1))*radtodeg
   WRITE(91,20)lambda,'mean longitude 1 (deg)'
   WRITE(91,20)inc_arr(1)*radtodeg,'inclination 1 (deg)'
   WRITE(91,20)long_arr(1)*radtodeg,'Omega 1 (deg)'
   WRITE(91,30)
!
   WRITE(91,20)p_arr(2),'period 2 (days)'
   fred=ecc_arr(2)*COS(argper_arr(2))
   WRITE(91,20)fred,'e*cos(omega) 2'
   fred=ecc_arr(2)*SIN(argper_arr(2))
   WRITE(91,20)fred,'e*sin(omega) 2'
   WRITE(91,20)inc_arr(2),'inclination 2 (rad)'
   WRITE(91,20)long_arr(2),'Omega 2 (rad)'
   WRITE(91,20)tconj_arr(2),'Tconj 2'
   WRITE(91,20)a_arr(2),'semimajor axis 2 (AU)'
   WRITE(91,20)ecc_arr(2),'eccentricity 2'
   WRITE(91,20)argper_arr(2)*radtodeg,'arg. per. 2 (deg)'
   WRITE(91,20)f_arr(2)*radtodeg,'true anomaly 2 (deg)'
   WRITE(91,20)ma_arr(2)*radtodeg,'mean anomaly 2 (deg)'
   lambda=(argper_arr(2)+f_arr(2)+long_arr(2))*radtodeg
   WRITE(91,20)lambda,'mean longitude 2 (deg)'
   WRITE(91,20)inc_arr(2)*radtodeg,'inclination 2 (deg)'
   WRITE(91,20)long_arr(2)*radtodeg,'Omega 2 (deg)'
   WRITE(91,30)
!
   IF(nbody >= 4)THEN
      WRITE(91,20)p_arr(3),'period 3 (days)'
      fred=ecc_arr(3)*COS(argper_arr(3))
      WRITE(91,20)fred,'e*cos(omega) 3'
      fred=ecc_arr(3)*SIN(argper_arr(3))
      WRITE(91,20)fred,'e*sin(omega) 3'
      WRITE(91,20)inc_arr(3),'inclination 3 (rad)'
      WRITE(91,20)long_arr(3),'Omega 3 (rad)'
      WRITE(91,20)tconj_arr(3),'Tconj 3'
      WRITE(91,20)a_arr(3),'semimajor axis 3 (AU)'
      WRITE(91,20)ecc_arr(3),'eccentricity 3'
      WRITE(91,20)argper_arr(3)*radtodeg,'arg. per. 3 (deg)'
      WRITE(91,20)f_arr(3)*radtodeg,'true anomaly 3 (deg)'
      WRITE(91,20)ma_arr(3)*radtodeg,'mean anomaly 3 (deg)'
      lambda=(argper_arr(3)+f_arr(3)+long_arr(3))*radtodeg
      WRITE(91,20)lambda,'mean longitude 3 (deg)'
      WRITE(91,20)inc_arr(3)*radtodeg,'inclination 3 (deg)'
      WRITE(91,20)long_arr(3)*radtodeg,'Omega 3 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 5)THEN
      WRITE(91,20)p_arr(4),'period 4 (days)'
      fred=ecc_arr(4)*COS(argper_arr(4))
      WRITE(91,20)fred,'e*cos(omega) 4'
      fred=ecc_arr(4)*SIN(argper_arr(4))
      WRITE(91,20)fred,'e*sin(omega) 4'
      WRITE(91,20)inc_arr(4),'inclination 4 (rad)'
      WRITE(91,20)long_arr(4),'Omega 4 (rad)'
      WRITE(91,20)tconj_arr(4),'Tconj 4'
      WRITE(91,20)a_arr(4),'semimajor axis 4 (AU)'
      WRITE(91,20)ecc_arr(4),'eccentricity 4'
      WRITE(91,20)argper_arr(4)*radtodeg,'arg. per. 4 (deg)'
      WRITE(91,20)f_arr(4)*radtodeg,'true anomaly 4 (deg)'
      WRITE(91,20)ma_arr(4)*radtodeg,'mean anomaly 4 (deg)'
      lambda=(argper_arr(4)+f_arr(4)+long_arr(4))*radtodeg
      WRITE(91,20)lambda,'mean longitude 4 (deg)'
      WRITE(91,20)inc_arr(4)*radtodeg,'inclination 4 (deg)'
      WRITE(91,20)long_arr(4)*radtodeg,'Omega 4 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 6)THEN
      WRITE(91,20)p_arr(5),'period 5 (days)'
      fred=ecc_arr(5)*COS(argper_arr(5))
      WRITE(91,20)fred,'e*cos(omega) 5'
      fred=ecc_arr(5)*SIN(argper_arr(5))
      WRITE(91,20)fred,'e*sin(omega) 5'
      WRITE(91,20)inc_arr(5),'inclination 5 (rad)'
      WRITE(91,20)long_arr(5),'Omega 5 (rad)'
      WRITE(91,20)tconj_arr(5),'Tconj 5'
      WRITE(91,20)a_arr(5),'semimajor axis 5 (AU)'
      WRITE(91,20)ecc_arr(5),'eccentricity 5'
      WRITE(91,20)argper_arr(5)*radtodeg,'arg. per. 5 (deg)'
      WRITE(91,20)f_arr(5)*radtodeg,'true anomaly 5 (deg)'
      WRITE(91,20)ma_arr(5)*radtodeg,'mean anomaly 5 (deg)'
      lambda=(argper_arr(5)+f_arr(5)+long_arr(5))*radtodeg
      WRITE(91,20)lambda,'mean longitude 5 (deg)'
      WRITE(91,20)inc_arr(5)*radtodeg,'inclination 5 (deg)'
      WRITE(91,20)long_arr(5)*radtodeg,'Omega 5 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 7)THEN
      WRITE(91,20)p_arr(6),'period 6 (days)'
      fred=ecc_arr(6)*COS(argper_arr(6))
      WRITE(91,20)fred,'e*cos(omega) 6'
      fred=ecc_arr(6)*SIN(argper_arr(6))
      WRITE(91,20)fred,'e*sin(omega) 6'
      WRITE(91,20)inc_arr(6),'inclination 6 (rad)'
      WRITE(91,20)long_arr(6),'Omega 6 (rad)'
      WRITE(91,20)tconj_arr(6),'Tconj 6'
      WRITE(91,20)a_arr(6),'semimajor axis 6 (AU)'
      WRITE(91,20)ecc_arr(6),'eccentricity 6'
      WRITE(91,20)argper_arr(6)*radtodeg,'arg. per. 6 (deg)'
      WRITE(91,20)f_arr(6)*radtodeg,'true anomaly 6 (deg)'
      WRITE(91,20)ma_arr(6)*radtodeg,'mean anomaly 6 (deg)'
      lambda=(argper_arr(6)+f_arr(6)+long_arr(6))*radtodeg
      WRITE(91,20)lambda,'mean longitude 6 (deg)'
      WRITE(91,20)inc_arr(6)*radtodeg,'inclination 6 (deg)'
      WRITE(91,20)long_arr(6)*radtodeg,'Omega 6 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 8)THEN
      WRITE(91,20)p_arr(7),'period 7 (days)'
      fred=ecc_arr(7)*COS(argper_arr(7))
      WRITE(91,20)fred,'e*cos(omega) 7'
      fred=ecc_arr(7)*SIN(argper_arr(7))
      WRITE(91,20)fred,'e*sin(omega) 7'
      WRITE(91,20)inc_arr(7),'inclination 7 (rad)'
      WRITE(91,20)long_arr(7),'Omega 7 (rad)'
      WRITE(91,20)tconj_arr(7),'Tconj 7'
      WRITE(91,20)a_arr(7),'semimajor axis 7 (AU)'
      WRITE(91,20)ecc_arr(7),'eccentricity 7'
      WRITE(91,20)argper_arr(7)*radtodeg,'arg. per. 7 (deg)'
      WRITE(91,20)f_arr(7)*radtodeg,'true anomaly 7 (deg)'
      WRITE(91,20)ma_arr(7)*radtodeg,'mean anomaly 7 (deg)'
      lambda=(argper_arr(7)+f_arr(7)+long_arr(7))*radtodeg
      WRITE(91,20)lambda,'mean longitude 7 (deg)'
      WRITE(91,20)inc_arr(7)*radtodeg,'inclination 7 (deg)'
      WRITE(91,20)long_arr(7)*radtodeg,'Omega 7 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 9)THEN
      WRITE(91,20)p_arr(8),'period 8 (days)'
      fred=ecc_arr(8)*COS(argper_arr(8))
      WRITE(91,20)fred,'e*cos(omega) 8'
      fred=ecc_arr(8)*SIN(argper_arr(8))
      WRITE(91,20)fred,'e*sin(omega) 8'
      WRITE(91,20)inc_arr(8),'inclination 8 (rad)'
      WRITE(91,20)long_arr(8),'Omega 8 (rad)'
      WRITE(91,20)tconj_arr(8),'Tconj 8'
      WRITE(91,20)a_arr(8),'semimajor axis 8 (AU)'
      WRITE(91,20)ecc_arr(8),'eccentricity 8'
      WRITE(91,20)argper_arr(8)*radtodeg,'arg. per. 8 (deg)'
      WRITE(91,20)f_arr(8)*radtodeg,'true anomaly 8 (deg)'
      WRITE(91,20)ma_arr(8)*radtodeg,'mean anomaly 8 (deg)'
      lambda=(argper_arr(8)+f_arr(8)+long_arr(8))*radtodeg
      WRITE(91,20)lambda,'mean longitude 8 (deg)'
      WRITE(91,20)inc_arr(8)*radtodeg,'inclination 8 (deg)'
      WRITE(91,20)long_arr(8)*radtodeg,'Omega 8 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 10)THEN
      WRITE(91,20)p_arr(9),'period 9 (days)'
      fred=ecc_arr(9)*COS(argper_arr(9))
      WRITE(91,20)fred,'e*cos(omega) 9'
      fred=ecc_arr(9)*SIN(argper_arr(9))
      WRITE(91,20)fred,'e*sin(omega) 9'
      WRITE(91,20)inc_arr(9),'inclination 9 (rad)'
      WRITE(91,20)long_arr(9),'Omega 9 (rad)'
      WRITE(91,20)tconj_arr(9),'Tconj 9'
      WRITE(91,20)a_arr(9),'semimajor axis 9 (AU)'
      WRITE(91,20)ecc_arr(9),'eccentricity 9'
      WRITE(91,20)argper_arr(9)*radtodeg,'arg. per. 9 (deg)'
      WRITE(91,20)f_arr(9)*radtodeg,'true anomaly 9 (deg)'
      WRITE(91,20)ma_arr(9)*radtodeg,'mean anomaly 9 (deg)'
      lambda=(argper_arr(9)+f_arr(9)+long_arr(9))*radtodeg
      WRITE(91,20)lambda,'mean longitude 9 (deg)'
      WRITE(91,20)inc_arr(9)*radtodeg,'inclination 9 (deg)'
      WRITE(91,20)long_arr(9)*radtodeg,'Omega 9 (deg)'
      WRITE(91,30)
   END IF
!
   WRITE(91,40) tstart
   WRITE(91,30)
   WRITE(91,20)dynqq(1),'x-coordinate, body 1 (AU)'
   WRITE(91,20)dynqq(2),'y-coordinate, body 1 (AU)'
   WRITE(91,20)dynqq(3),'z-coordinate, body 1 (AU)'
   WRITE(91,30)
   WRITE(91,20)dynqq(4),'x-coordinate, body 2 (AU)'
   WRITE(91,20)dynqq(5),'y-coordinate, body 2 (AU)'
   WRITE(91,20)dynqq(6),'z-coordinate, body 2 (AU)'
   WRITE(91,30)
   WRITE(91,20)dynqq(7),'x-coordinate, body 3 (AU)'
   WRITE(91,20)dynqq(8),'y-coordinate, body 3 (AU)'
   WRITE(91,20)dynqq(9),'z-coordinate, body 3 (AU)'
   WRITE(91,30)
   IF(nbody >= 4)THEN
      WRITE(91,20)dynqq(10),'x-coordinate, body 4 (AU)'
      WRITE(91,20)dynqq(11),'y-coordinate, body 4 (AU)'
      WRITE(91,20)dynqq(12),'z-coordinate, body 4 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 5)THEN
      WRITE(91,20)dynqq(13),'x-coordinate, body 5 (AU)'
      WRITE(91,20)dynqq(14),'y-coordinate, body 5 (AU)'
      WRITE(91,20)dynqq(15),'z-coordinate, body 5 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 6)THEN
      WRITE(91,20)dynqq(16),'x-coordinate, body 6 (AU)'
      WRITE(91,20)dynqq(17),'y-coordinate, body 6 (AU)'
      WRITE(91,20)dynqq(18),'z-coordinate, body 6 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 7)THEN
      WRITE(91,20)dynqq(19),'x-coordinate, body 7 (AU)'
      WRITE(91,20)dynqq(20),'y-coordinate, body 7 (AU)'
      WRITE(91,20)dynqq(21),'z-coordinate, body 7 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 8)THEN
      WRITE(91,20)dynqq(22),'x-coordinate, body 8 (AU)'
      WRITE(91,20)dynqq(23),'y-coordinate, body 8 (AU)'
      WRITE(91,20)dynqq(24),'z-coordinate, body 8 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 9)THEN
      WRITE(91,20)dynqq(25),'x-coordinate, body 9 (AU)'
      WRITE(91,20)dynqq(26),'y-coordinate, body 9 (AU)'
      WRITE(91,20)dynqq(27),'z-coordinate, body 9 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 10)THEN
      WRITE(91,20)dynqq(28),'x-coordinate, body 10 (AU)'
      WRITE(91,20)dynqq(29),'y-coordinate, body 10 (AU)'
      WRITE(91,20)dynqq(30),'z-coordinate, body 10 (AU)'
      WRITE(91,30)
   END IF
!
   WRITE(91,20)dynpp(1),'x-velocity, body 1 (AU/day)'
   WRITE(91,20)dynpp(2),'y-velocity, body 1 (AU/day)'
   WRITE(91,20)dynpp(3),'z-velocity, body 1 (AU/day)'
   WRITE(91,30)
   WRITE(91,20)dynpp(4),'x-velocity, body 2 (AU/day)'
   WRITE(91,20)dynpp(5),'y-velocity, body 2 (AU/day)'
   WRITE(91,20)dynpp(6),'z-velocity, body 2 (AU/day)'
   WRITE(91,30)
   WRITE(91,20)dynpp(7),'x-velocity, body 3 (AU/day)'
   WRITE(91,20)dynpp(8),'y-velocity, body 3 (AU/day)'
   WRITE(91,20)dynpp(9),'z-velocity, body 3 (AU/day)'
   WRITE(91,30)
   IF(nbody >= 4)THEN
      WRITE(91,20)dynpp(10),'x-velocity, body 4 (AU/day)'
      WRITE(91,20)dynpp(11),'y-velocity, body 4 (AU/day)'
      WRITE(91,20)dynpp(12),'z-velocity, body 4 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 5)THEN
      WRITE(91,20)dynpp(13),'x-velocity, body 5 (AU/day)'
      WRITE(91,20)dynpp(14),'y-velocity, body 5 (AU/day)'
      WRITE(91,20)dynpp(15),'z-velocity, body 5 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 6)THEN
      WRITE(91,20)dynpp(16),'x-velocity, body 6 (AU/day)'
      WRITE(91,20)dynpp(17),'y-velocity, body 6 (AU/day)'
      WRITE(91,20)dynpp(18),'z-velocity, body 6 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 7)THEN
      WRITE(91,20)dynpp(19),'x-velocity, body 7 (AU/day)'
      WRITE(91,20)dynpp(20),'y-velocity, body 7 (AU/day)'
      WRITE(91,20)dynpp(21),'z-velocity, body 7 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 8)THEN
      WRITE(91,20)dynpp(22),'x-velocity, body 8 (AU/day)'
      WRITE(91,20)dynpp(23),'y-velocity, body 8 (AU/day)'
      WRITE(91,20)dynpp(24),'z-velocity, body 8 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 9)THEN
      WRITE(91,20)dynpp(25),'x-velocity, body 9 (AU/day)'
      WRITE(91,20)dynpp(26),'y-velocity, body 9 (AU/day)'
      WRITE(91,20)dynpp(27),'z-velocity, body 9 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 10)THEN
      WRITE(91,20)dynpp(28),'x-velocity, body 10 (AU/day)'
      WRITE(91,20)dynpp(29),'y-velocity, body 10 (AU/day)'
      WRITE(91,20)dynpp(30),'z-velocity, body 10 (AU/day)'
      WRITE(91,30)
   END IF
!
   centerx=0.0_dp
   centery=0.0_dp
   centerz=0.0_dp
   centervx=0.0_dp
   centervy=0.0_dp
   centervz=0.0_dp
   totmas=0.0_dp
   DO jj=1,nbody
      totmas=totmas+rmass(jj)
      centerx=centerx+rmass(jj)*dynqq(1+(jj-1)*3)
      centery=centery+rmass(jj)*dynqq(2+(jj-1)*3)
      centerz=centerz+rmass(jj)*dynqq(3+(jj-1)*3)
      centervx=centervx+rmass(jj)*dynpp(1+(jj-1)*3)
      centervy=centervy+rmass(jj)*dynpp(2+(jj-1)*3)
      centervz=centervz+rmass(jj)*dynpp(3+(jj-1)*3)
   END DO
   WRITE(91,20)centerx/totmas,'x-coordinate of C.O.M.'
   WRITE(91,20)centery/totmas,'y-coordinate of C.O.M.'
   WRITE(91,20)centerz/totmas,'z-coordinate of C.O.M.'
   WRITE(91,30)
   WRITE(91,20)centervx/totmas,'x-velocity of C.O.M.'
   WRITE(91,20)centervy/totmas,'y-velocity of C.O.M.'
   WRITE(91,20)centervz/totmas,'z-velocity of C.O.M.'
   WRITE(91,30)
!
10 FORMAT('#  Keplerian elements at day ',f15.9)
20 FORMAT(1PE24.17,10X,a)
30 FORMAT('#')
40 FORMAT('#  Cartesian coordinates at day ',f15.5)
!
   RETURN
!
END SUBROUTINE inform2
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE inform3(nbody,dynqq,dynpp,rmass,tstart,tref,  &
   radtodeg,nstep,body01posx,body01posy,body01posz,  &
   body01velx,body01vely,body01velz,body02posx,body02posy,  &
   body02posz,body02velx,body02vely,body02velz,body03posx,  &
   body03posy,body03posz,body03velx,body03vely,body03velz,  &
   body04posx,body04posy,body04posz,body04velx,body04vely,  &
   body04velz,body05posx,body05posy,body05posz,body05velx,  &
   body05vely,body05velz,body06posx,body06posy,body06posz,  &
   body06velx,body06vely,body06velz,body07posx,body07posy,  &
   body07posz,body07velx,body07vely,body07velz,body08posx,  &
   body08posy,body08posz,body09velx,body09vely,body09velz,  &
   body10posx,body10posy,body10posz,body10velx,body10vely,  &
   body10velz,body08velx,body08vely,body08velz,body09posx,  &
   body09posy,body09posz,ndyn,isw80)
!
!   writes part 2 of ELCdynamics.out (ELC only)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: dynqq(30)
   REAL(KIND=dp), INTENT(IN)                :: dynpp(30)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: tstart
   REAL(KIND=dp), INTENT(IN)                :: tref
   REAL(KIND=dp), INTENT(IN)                :: radtodeg
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN)                :: body01posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09posz(ndyn)
   INTEGER, INTENT(IN)                      :: isw80
!
   REAL(KIND=dp), DIMENSION(9)  :: p_arr,ecc_arr,a_arr,ma_arr,argper_arr
   REAL(KIND=dp), DIMENSION(9)  :: inc_arr,long_arr,tconj_arr,f_arr
   REAL(KIND=dp)  :: centerx,centery,centerz,lambda
   REAL(KIND=dp)  :: totmas,centervx,centervy,centervz,fred
!
   IF((Nbody.eq.4).and.(isw80.ge.1))THEN
      CALL newcartkepbinbin(rmass,dynQQ,dynPP,Tref,p_arr, &
         ecc_arr,a_arr,MA_arr,ArgPer_arr,inc_arr,long_arr, &
         Tconj_arr,f_arr)
   ELSE
      CALL newcartkep(nbody,rmass,dynqq,dynpp,tref,p_arr,  &
         ecc_arr,a_arr,ma_arr,argper_arr,inc_arr,long_arr,  &
         tconj_arr,f_arr)
   END IF
!
   WRITE(91,10)tstart
   WRITE(91,30)
   WRITE(91,20)p_arr(1),'period 1 (days)'
   fred=ecc_arr(1)*COS(argper_arr(1))
   WRITE(91,20)fred,'e*cos(omega) 1'
   fred=ecc_arr(1)*SIN(argper_arr(1))
   WRITE(91,20)fred,'e*sin(omega) 1'
   WRITE(91,20)inc_arr(1),'inclination 1 (rad)'
   WRITE(91,20)long_arr(1),'Omega 1 (rad)'
   WRITE(91,20)tconj_arr(1),'Tconj 1'
   WRITE(91,20)a_arr(1),'semimajor axis 1 (AU)'
   WRITE(91,20)ecc_arr(1),'eccentricity 1'
   WRITE(91,20)argper_arr(1)*radtodeg,'arg. per. 1 (deg)'
   WRITE(91,20)f_arr(1)*radtodeg,'true anomaly 1 (deg)'
   WRITE(91,20)ma_arr(1)*radtodeg,'mean anomaly 1 (deg)'
   lambda=(argper_arr(1)+f_arr(1)+long_arr(1))*radtodeg
   WRITE(91,20)lambda,'mean longitude 1 (deg)'
   WRITE(91,20)inc_arr(1)*radtodeg,'inclination 1 (deg)'
   WRITE(91,20)long_arr(1)*radtodeg,'Omega 1 (deg)'
   WRITE(91,30)
!
   WRITE(91,20)p_arr(2),'period 2 (days)'
   fred=ecc_arr(2)*COS(argper_arr(2))
   WRITE(91,20)fred,'e*cos(omega) 2'
   fred=ecc_arr(2)*SIN(argper_arr(2))
   WRITE(91,20)fred,'e*sin(omega) 2'
   WRITE(91,20)inc_arr(2),'inclination 2 (rad)'
   WRITE(91,20)long_arr(2),'Omega 2 (rad)'
   WRITE(91,20)tconj_arr(2),'Tconj 2'
   WRITE(91,20)a_arr(2),'semimajor axis 2 (AU)'
   WRITE(91,20)ecc_arr(2),'eccentricity 2'
   WRITE(91,20)argper_arr(2)*radtodeg,'arg. per. 2 (deg)'
   WRITE(91,20)f_arr(2)*radtodeg,'true anomaly 2 (deg)'
   WRITE(91,20)ma_arr(2)*radtodeg,'mean anomaly 2 (deg)'
   lambda=(argper_arr(2)+f_arr(2)+long_arr(2))*radtodeg
   WRITE(91,20)lambda,'mean longitude 2 (deg)'
   WRITE(91,20)inc_arr(2)*radtodeg,'inclination 2 (deg)'
   WRITE(91,20)long_arr(2)*radtodeg,'Omega 2 (deg)'
   WRITE(91,30)
!
   IF(nbody >= 4)THEN
      WRITE(91,20)p_arr(3),'period 3 (days)'
      fred=ecc_arr(3)*COS(argper_arr(3))
      WRITE(91,20)fred,'e*cos(omega) 3'
      fred=ecc_arr(3)*SIN(argper_arr(3))
      WRITE(91,20)fred,'e*sin(omega) 3'
      WRITE(91,20)inc_arr(3),'inclination 3 (rad)'
      WRITE(91,20)long_arr(3),'Omega 3 (rad)'
      WRITE(91,20)tconj_arr(3),'Tconj 3'
      WRITE(91,20)a_arr(3),'semimajor axis 3 (AU)'
      WRITE(91,20)ecc_arr(3),'eccentricity 3'
      WRITE(91,20)argper_arr(3)*radtodeg,'arg. per. 3 (deg)'
      WRITE(91,20)f_arr(3)*radtodeg,'true anomaly 3 (deg)'
      WRITE(91,20)ma_arr(3)*radtodeg,'mean anomaly 3 (deg)'
      lambda=(argper_arr(3)+f_arr(3)+long_arr(3))*radtodeg
      WRITE(91,20)lambda,'mean longitude 3 (deg)'
      WRITE(91,20)inc_arr(3)*radtodeg,'inclination 3 (deg)'
      WRITE(91,20)long_arr(3)*radtodeg,'Omega 3 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 5)THEN
      WRITE(91,20)p_arr(4),'period 4 (days)'
      fred=ecc_arr(4)*COS(argper_arr(4))
      WRITE(91,20)fred,'e*cos(omega) 4'
      fred=ecc_arr(4)*SIN(argper_arr(4))
      WRITE(91,20)fred,'e*sin(omega) 4'
      WRITE(91,20)inc_arr(4),'inclination 4 (rad)'
      WRITE(91,20)long_arr(4),'Omega 4 (rad)'
      WRITE(91,20)tconj_arr(4),'Tconj 4'
      WRITE(91,20)a_arr(4),'semimajor axis 4 (AU)'
      WRITE(91,20)ecc_arr(4),'eccentricity 4'
      WRITE(91,20)argper_arr(4)*radtodeg,'arg. per. 4 (deg)'
      WRITE(91,20)f_arr(4)*radtodeg,'true anomaly 4 (deg)'
      WRITE(91,20)ma_arr(4)*radtodeg,'mean anomaly 4 (deg)'
      lambda=(argper_arr(4)+f_arr(4)+long_arr(4))*radtodeg
      WRITE(91,20)lambda,'mean longitude 4 (deg)'
      WRITE(91,20)inc_arr(4)*radtodeg,'inclination 4 (deg)'
      WRITE(91,20)long_arr(4)*radtodeg,'Omega 4 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 6)THEN
      WRITE(91,20)p_arr(5),'period 5 (days)'
      fred=ecc_arr(5)*COS(argper_arr(5))
      WRITE(91,20)fred,'e*cos(omega) 5'
      fred=ecc_arr(5)*SIN(argper_arr(5))
      WRITE(91,20)fred,'e*sin(omega) 5'
      WRITE(91,20)inc_arr(5),'inclination 5 (rad)'
      WRITE(91,20)long_arr(5),'Omega 5 (rad)'
      WRITE(91,20)tconj_arr(5),'Tconj 5'
      WRITE(91,20)a_arr(5),'semimajor axis 5 (AU)'
      WRITE(91,20)ecc_arr(5),'eccentricity 5'
      WRITE(91,20)argper_arr(5)*radtodeg,'arg. per. 5 (deg)'
      WRITE(91,20)f_arr(5)*radtodeg,'true anomaly 5 (deg)'
      WRITE(91,20)ma_arr(5)*radtodeg,'mean anomaly 5 (deg)'
      lambda=(argper_arr(5)+f_arr(5)+long_arr(5))*radtodeg
      WRITE(91,20)lambda,'mean longitude 5 (deg)'
      WRITE(91,20)inc_arr(5)*radtodeg,'inclination 5 (deg)'
      WRITE(91,20)long_arr(5)*radtodeg,'Omega 5 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 7)THEN
      WRITE(91,20)p_arr(6),'period 6 (days)'
      fred=ecc_arr(6)*COS(argper_arr(6))
      WRITE(91,20)fred,'e*cos(omega) 6'
      fred=ecc_arr(6)*SIN(argper_arr(6))
      WRITE(91,20)fred,'e*sin(omega) 6'
      WRITE(91,20)inc_arr(6),'inclination 6 (rad)'
      WRITE(91,20)long_arr(6),'Omega 6 (rad)'
      WRITE(91,20)tconj_arr(6),'Tconj 6'
      WRITE(91,20)a_arr(6),'semimajor axis 6 (AU)'
      WRITE(91,20)ecc_arr(6),'eccentricity 6'
      WRITE(91,20)argper_arr(6)*radtodeg,'arg. per. 6 (deg)'
      WRITE(91,20)f_arr(6)*radtodeg,'true anomaly 6 (deg)'
      WRITE(91,20)ma_arr(6)*radtodeg,'mean anomaly 6 (deg)'
      lambda=(argper_arr(6)+f_arr(6)+long_arr(6))*radtodeg
      WRITE(91,20)lambda,'mean longitude 6 (deg)'
      WRITE(91,20)inc_arr(6)*radtodeg,'inclination 6 (deg)'
      WRITE(91,20)long_arr(6)*radtodeg,'Omega 6 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 8)THEN
      WRITE(91,20)p_arr(7),'period 7 (days)'
      fred=ecc_arr(7)*COS(argper_arr(7))
      WRITE(91,20)fred,'e*cos(omega) 7'
      fred=ecc_arr(7)*SIN(argper_arr(7))
      WRITE(91,20)fred,'e*sin(omega) 7'
      WRITE(91,20)inc_arr(7),'inclination 7 (rad)'
      WRITE(91,20)long_arr(7),'Omega 7 (rad)'
      WRITE(91,20)tconj_arr(7),'Tconj 7'
      WRITE(91,20)a_arr(7),'semimajor axis 7 (AU)'
      WRITE(91,20)ecc_arr(7),'eccentricity 7'
      WRITE(91,20)argper_arr(7)*radtodeg,'arg. per. 7 (deg)'
      WRITE(91,20)f_arr(7)*radtodeg,'true anomaly 7 (deg)'
      WRITE(91,20)ma_arr(7)*radtodeg,'mean anomaly 7 (deg)'
      lambda=(argper_arr(7)+f_arr(7)+long_arr(7))*radtodeg
      WRITE(91,20)lambda,'mean longitude 7 (deg)'
      WRITE(91,20)inc_arr(7)*radtodeg,'inclination 7 (deg)'
      WRITE(91,20)long_arr(7)*radtodeg,'Omega 7 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 9)THEN
      WRITE(91,20)p_arr(8),'period 8 (days)'
      fred=ecc_arr(8)*COS(argper_arr(8))
      WRITE(91,20)fred,'e*cos(omega) 8'
      fred=ecc_arr(8)*SIN(argper_arr(8))
      WRITE(91,20)fred,'e*sin(omega) 8'
      WRITE(91,20)inc_arr(8),'inclination 8 (rad)'
      WRITE(91,20)long_arr(8),'Omega 8 (rad)'
      WRITE(91,20)tconj_arr(8),'Tconj 8'
      WRITE(91,20)a_arr(8),'semimajor axis 8 (AU)'
      WRITE(91,20)ecc_arr(8),'eccentricity 8'
      WRITE(91,20)argper_arr(8)*radtodeg,'arg. per. 8 (deg)'
      WRITE(91,20)f_arr(8)*radtodeg,'true anomaly 8 (deg)'
      WRITE(91,20)ma_arr(8)*radtodeg,'mean anomaly 8 (deg)'
      lambda=(argper_arr(8)+f_arr(8)+long_arr(8))*radtodeg
      WRITE(91,20)lambda,'mean longitude 8 (deg)'
      WRITE(91,20)inc_arr(8)*radtodeg,'inclination 8 (deg)'
      WRITE(91,20)long_arr(8)*radtodeg,'Omega 8 (deg)'
      WRITE(91,30)
   END IF
!
   IF(nbody >= 10)THEN
      WRITE(91,20)p_arr(9),'period 9 (days)'
      fred=ecc_arr(9)*COS(argper_arr(9))
      WRITE(91,20)fred,'e*cos(omega) 9'
      fred=ecc_arr(9)*SIN(argper_arr(9))
      WRITE(91,20)fred,'e*sin(omega) 9'
      WRITE(91,20)inc_arr(9),'inclination 9 (rad)'
      WRITE(91,20)long_arr(9),'Omega 9 (rad)'
      WRITE(91,20)tconj_arr(9),'Tconj 9'
      WRITE(91,20)a_arr(9),'semimajor axis 9 (AU)'
      WRITE(91,20)ecc_arr(9),'eccentricity 9'
      WRITE(91,20)argper_arr(9)*radtodeg,'arg. per. 9 (deg)'
      WRITE(91,20)f_arr(9)*radtodeg,'true anomaly 9 (deg)'
      WRITE(91,20)ma_arr(9)*radtodeg,'mean anomaly 9 (deg)'
      lambda=(argper_arr(9)+f_arr(9)+long_arr(9))*radtodeg
      WRITE(91,20)lambda,'mean longitude 9 (deg)'
      WRITE(91,20)inc_arr(9)*radtodeg,'inclination 9 (deg)'
      WRITE(91,20)long_arr(9)*radtodeg,'Omega 9 (deg)'
      WRITE(91,30)
   END IF
!
   WRITE(91,40)tstart
   WRITE(91,30)
   WRITE(91,20)body01posx(nstep),'x-coordinate, body 1 (AU)'
   WRITE(91,20)body01posy(nstep),'y-coordinate, body 1 (AU)'
   WRITE(91,20)body01posz(nstep),'z-coordinate, body 1 (AU)'
   WRITE(91,30)
   WRITE(91,20)body02posx(nstep),'x-coordinate, body 2 (AU)'
   WRITE(91,20)body02posy(nstep),'y-coordinate, body 2 (AU)'
   WRITE(91,20)body02posz(nstep),'z-coordinate, body 2 (AU)'
   WRITE(91,30)
   WRITE(91,20)body03posx(nstep),'x-coordinate, body 3 (AU)'
   WRITE(91,20)body03posy(nstep),'y-coordinate, body 3 (AU)'
   WRITE(91,20)body03posz(nstep),'z-coordinate, body 3 (AU)'
   WRITE(91,30)
   IF(nbody >= 4)THEN
      WRITE(91,20)body04posx(nstep),'x-coordinate, body 4 (AU)'
      WRITE(91,20)body04posy(nstep),'y-coordinate, body 4 (AU)'
      WRITE(91,20)body04posz(nstep),'z-coordinate, body 4 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 5)THEN
      WRITE(91,20)body05posx(nstep),'x-coordinate, body 5 (AU)'
      WRITE(91,20)body05posy(nstep),'y-coordinate, body 5 (AU)'
      WRITE(91,20)body05posz(nstep),'z-coordinate, body 5 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 6)THEN
      WRITE(91,20)body06posx(nstep),'x-coordinate, body 6 (AU)'
      WRITE(91,20)body06posy(nstep),'y-coordinate, body 6 (AU)'
      WRITE(91,20)body06posz(nstep),'z-coordinate, body 6 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 7)THEN
      WRITE(91,20)body07posx(nstep),'x-coordinate, body 7 (AU)'
      WRITE(91,20)body07posy(nstep),'y-coordinate, body 7 (AU)'
      WRITE(91,20)body07posz(nstep),'z-coordinate, body 7 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 8)THEN
      WRITE(91,20)body08posx(nstep),'x-coordinate, body 8 (AU)'
      WRITE(91,20)body08posy(nstep),'y-coordinate, body 8 (AU)'
      WRITE(91,20)body08posz(nstep),'z-coordinate, body 8 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 9)THEN
      WRITE(91,20)body09posx(nstep),'x-coordinate, body 9 (AU)'
      WRITE(91,20)body09posy(nstep),'y-coordinate, body 9 (AU)'
      WRITE(91,20)body09posz(nstep),'z-coordinate, body 9 (AU)'
      WRITE(91,30)
   END IF
   IF(nbody >= 10)THEN
      WRITE(91,20)body10posx(nstep),'x-coordinate, body 10 (AU)'
      WRITE(91,20)body10posy(nstep),'y-coordinate, body 10 (AU)'
      WRITE(91,20)body10posz(nstep),'z-coordinate, body 10 (AU)'
      WRITE(91,30)
   END IF
!
   WRITE(91,20)body01velx(nstep),'x-velocity, body 1 (AU/day)'
   WRITE(91,20)body01vely(nstep),'y-velocity, body 1 (AU/day)'
   WRITE(91,20)body01velz(nstep),'z-velocity, body 1 (AU/day)'
   WRITE(91,30)
   WRITE(91,20)body02velx(nstep),'x-velocity, body 2 (AU/day)'
   WRITE(91,20)body02vely(nstep),'y-velocity, body 2 (AU/day)'
   WRITE(91,20)body02velz(nstep),'z-velocity, body 2 (AU/day)'
   WRITE(91,30)
   WRITE(91,20)body03velx(nstep),'x-velocity, body 3 (AU/day)'
   WRITE(91,20)body03vely(nstep),'y-velocity, body 3 (AU/day)'
   WRITE(91,20)body03velz(nstep),'z-velocity, body 3 (AU/day)'
   WRITE(91,30)
   IF(nbody >= 4)THEN
      WRITE(91,20)body04velx(nstep),'x-velocity, body 4 (AU/day)'
      WRITE(91,20)body04vely(nstep),'y-velocity, body 4 (AU/day)'
      WRITE(91,20)body04velz(nstep),'z-velocity, body 4 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 5)THEN
      WRITE(91,20)body05velx(nstep),'x-velocity, body 5 (AU/day)'
      WRITE(91,20)body05vely(nstep),'y-velocity, body 5 (AU/day)'
      WRITE(91,20)body05velz(nstep),'z-velocity, body 5 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 6)THEN
      WRITE(91,20)body06velx(nstep),'x-velocity, body 6 (AU/day)'
      WRITE(91,20)body06vely(nstep),'y-velocity, body 6 (AU/day)'
      WRITE(91,20)body06velz(nstep),'z-velocity, body 6 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 7)THEN
      WRITE(91,20)body07velx(nstep),'x-velocity, body 7 (AU/day)'
      WRITE(91,20)body07vely(nstep),'y-velocity, body 7 (AU/day)'
      WRITE(91,20)body07velz(nstep),'z-velocity, body 7 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 8)THEN
      WRITE(91,20)body08velx(nstep),'x-velocity, body 8 (AU/day)'
      WRITE(91,20)body08vely(nstep),'y-velocity, body 8 (AU/day)'
      WRITE(91,20)body08velz(nstep),'z-velocity, body 8 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 9)THEN
      WRITE(91,20)body09velx(nstep),'x-velocity, body 9 (AU/day)'
      WRITE(91,20)body09vely(nstep),'y-velocity, body 9 (AU/day)'
      WRITE(91,20)body09velz(nstep),'z-velocity, body 9 (AU/day)'
      WRITE(91,30)
   END IF
   IF(nbody >= 10)THEN
      WRITE(91,20)body10velx(nstep), 'x-velocity, body 10 (AU/day)'
      WRITE(91,20)body10vely(nstep), 'y-velocity, body 10 (AU/day)'
      WRITE(91,20)body10velz(nstep), 'z-velocity, body 10 (AU/day)'
      WRITE(91,30)
   END IF
!
   centerx=0.0_dp
   centery=0.0_dp
   centerz=0.0_dp
   centervx=0.0_dp
   centervy=0.0_dp
   centervz=0.0_dp
   totmas=0.0_dp
!
   totmas=1.0_dp
   IF(nbody == 3)THEN
      totmas=rmass(1)+rmass(2)+rmass(3)
      centerx=body01posx(nstep)*rmass(1)+body02posx(nstep)*  &
         rmass(2)+body03posx(nstep)*rmass(3)
      centery=body01posy(nstep)*rmass(1)+body02posy(nstep)*  &
         rmass(2)+body03posy(nstep)*rmass(3)
      centerz=body01posz(nstep)*rmass(1)+body02posz(nstep)*  &
         rmass(2)+body03posz(nstep)*rmass(3)
      centervx=body01velx(nstep)*rmass(1)+body02velx(nstep)*  &
         rmass(2)+body03velx(nstep)*rmass(3)
      centervy=body01vely(nstep)*rmass(1)+body02vely(nstep)*  &
         rmass(2)+body03vely(nstep)*rmass(3)
      centervz=body01velz(nstep)*rmass(1)+body02velz(nstep)*  &
         rmass(2)+body03velz(nstep)*rmass(3)
   END IF
!
   IF(nbody == 4)THEN
      totmas=rmass(1)+rmass(2)+rmass(3)+rmass(4)
      centerx=body01posx(nstep)*rmass(1)+body02posx(nstep)*  &
         rmass(2)+body03posx(nstep)*rmass(3)+body04posx(nstep)*rmass(4)
      centery=body01posy(nstep)*rmass(1)+body02posy(nstep)*  &
         rmass(2)+body03posy(nstep)*rmass(3)+body04posy(nstep)*rmass(4)
      centerz=body01posz(nstep)*rmass(1)+body02posz(nstep)*  &
         rmass(2)+body03posz(nstep)*rmass(3)+body04posz(nstep)*rmass(4)
      centervx=body01velx(nstep)*rmass(1)+body02velx(nstep)*  &
         rmass(2)+body03velx(nstep)*rmass(3)+body04velx(nstep)*rmass(4)
      centervy=body01vely(nstep)*rmass(1)+body02vely(nstep)*  &
         rmass(2)+body03vely(nstep)*rmass(3)+body04vely(nstep)*rmass(4)
      centervz=body01velz(nstep)*rmass(1)+body02velz(nstep)*  &
         rmass(2)+body03velz(nstep)*rmass(3)+body04velz(nstep)*rmass(4)
   END IF
!
   IF(nbody == 5)THEN
      totmas=rmass(1)+rmass(2)+rmass(3)+rmass(4)+rmass(5)
      centerx=body01posx(nstep)*rmass(1)+body02posx(nstep)*  &
         rmass(2)+body03posx(nstep)*rmass(3)+body04posx(nstep)*  &
         rmass(4)+body05posx(nstep)*rmass(5)
      centery=body01posy(nstep)*rmass(1)+body02posy(nstep)*  &
         rmass(2)+body03posy(nstep)*rmass(3)+body04posy(nstep)*  &
         rmass(4)+body05posy(nstep)*rmass(5)
      centerz=body01posz(nstep)*rmass(1)+body02posz(nstep)*  &
         rmass(2)+body03posz(nstep)*rmass(3)+body04posz(nstep)*  &
         rmass(4)+body05posz(nstep)*rmass(5)
      centervx=body01velx(nstep)*rmass(1)+body02velx(nstep)*  &
         rmass(2)+body03velx(nstep)*rmass(3)+body04velx(nstep)*  &
         rmass(4)+body05velx(nstep)*rmass(5)
      centervy=body01vely(nstep)*rmass(1)+body02vely(nstep)*  &
         rmass(2)+body03vely(nstep)*rmass(3)+body04vely(nstep)*  &
         rmass(4)+body05vely(nstep)*rmass(5)
      centervz=body01velz(nstep)*rmass(1)+body02velz(nstep)*  &
         rmass(2)+body03velz(nstep)*rmass(3)+body04velz(nstep)*  &
         rmass(4)+body05velz(nstep)*rmass(5)

   END IF
!
   IF(nbody == 6)THEN
      totmas=rmass(1)+rmass(2)+rmass(3)+rmass(4)+rmass(5)+rmass(6)
      centerx=body01posx(nstep)*rmass(1)+body02posx(nstep)*  &
         rmass(2)+body03posx(nstep)*rmass(3)+body04posx(nstep)*  &
         rmass(4)+body05posx(nstep)*rmass(5)+body06posx(nstep)*  &
         rmass(6)
      centery=body01posy(nstep)*rmass(1)+body02posy(nstep)*  &
         rmass(2)+body03posy(nstep)*rmass(3)+body04posy(nstep)*  &
         rmass(4)+body05posy(nstep)*rmass(5)+body06posy(nstep)*  &
         rmass(6)
      centerz=body01posz(nstep)*rmass(1)+body02posz(nstep)*  &
         rmass(2)+body03posz(nstep)*rmass(3)+body04posz(nstep)*  &
         rmass(4)+body05posz(nstep)*rmass(5)+body06posz(nstep)*  &
         rmass(6)
      centervx=body01velx(nstep)*rmass(1)+body02velx(nstep)*  &
         rmass(2)+body03velx(nstep)*rmass(3)+body04velx(nstep)*  &
         rmass(4)+body05velx(nstep)*rmass(5)+body06velx(nstep)*  &
         rmass(6)
      centervy=body01vely(nstep)*rmass(1)+body02vely(nstep)*  &
         rmass(2)+body03vely(nstep)*rmass(3)+body04vely(nstep)*  &
         rmass(4)+body05vely(nstep)*rmass(5)+body06vely(nstep)*  &
         rmass(6)
      centervz=body01velz(nstep)*rmass(1)+body02velz(nstep)*  &
         rmass(2)+body03velz(nstep)*rmass(3)+body04velz(nstep)*  &
         rmass(4)+body05velz(nstep)*rmass(5)+body06velz(nstep)*  &
         rmass(6)
   END IF
!
   IF(nbody == 7)THEN
      totmas=rmass(1)+rmass(2)+rmass(3)+rmass(4)+rmass(5)+rmass(6) &
         +rmass(7)
      centerx=body01posx(nstep)*rmass(1)+body02posx(nstep)*  &
         rmass(2)+body03posx(nstep)*rmass(3)+body04posx(nstep)*  &
         rmass(4)+body05posx(nstep)*rmass(5)+body06posx(nstep)*  &
         rmass(6)+body07posx(nstep)*rmass(7)
      centery=body01posy(nstep)*rmass(1)+body02posy(nstep)*  &
         rmass(2)+body03posy(nstep)*rmass(3)+body04posy(nstep)*  &
         rmass(4)+body05posy(nstep)*rmass(5)+body06posy(nstep)*  &
         rmass(6)+body07posy(nstep)*rmass(7)
      centerz=body01posz(nstep)*rmass(1)+body02posz(nstep)*  &
         rmass(2)+body03posz(nstep)*rmass(3)+body04posz(nstep)*  &
         rmass(4)+body05posz(nstep)*rmass(5)+body06posz(nstep)*  &
         rmass(6)+body07posz(nstep)*rmass(7)
      centervx=body01velx(nstep)*rmass(1)+body02velx(nstep)*  &
         rmass(2)+body03velx(nstep)*rmass(3)+body04velx(nstep)*  &
         rmass(4)+body05velx(nstep)*rmass(5)+body06velx(nstep)*  &
         rmass(6)+body07velx(nstep)*rmass(7)
      centervy=body01vely(nstep)*rmass(1)+body02vely(nstep)*  &
         rmass(2)+body03vely(nstep)*rmass(3)+body04vely(nstep)*  &
         rmass(4)+body05vely(nstep)*rmass(5)+body06vely(nstep)*  &
         rmass(6)+body07vely(nstep)*rmass(7)
      centervz=body01velz(nstep)*rmass(1)+body02velz(nstep)*  &
         rmass(2)+body03velz(nstep)*rmass(3)+body04velz(nstep)*  &
         rmass(4)+body05velz(nstep)*rmass(5)+body06velz(nstep)*  &
         rmass(6)+body07velz(nstep)*rmass(7)
   END IF
!
   IF(nbody == 8)THEN
      totmas=rmass(1)+rmass(2)+rmass(3)+rmass(4)+rmass(5)+rmass(6)  &
         +rmass(7)+rmass(8)
      centerx=body01posx(nstep)*rmass(1)+body02posx(nstep)*  &
         rmass(2)+body03posx(nstep)*rmass(3)+body04posx(nstep)*  &
         rmass(4)+body05posx(nstep)*rmass(5)+body06posx(nstep)*  &
         rmass(6)+body07posx(nstep)*rmass(7)+body08posx(nstep)*  &
         rmass(8)
      centery=body01posy(nstep)*rmass(1)+body02posy(nstep)*  &
         rmass(2)+body03posy(nstep)*rmass(3)+body04posy(nstep)*  &
         rmass(4)+body05posy(nstep)*rmass(5)+body06posy(nstep)*  &
         rmass(6)+body07posy(nstep)*rmass(7)+body08posy(nstep)*  &
         rmass(8)
      centerz=body01posz(nstep)*rmass(1)+body02posz(nstep)*  &
         rmass(2)+body03posz(nstep)*rmass(3)+body04posz(nstep)*  &
         rmass(4)+body05posz(nstep)*rmass(5)+body06posz(nstep)*  &
         rmass(6)+body07posz(nstep)*rmass(7)+body08posz(nstep)*  &
         rmass(8)
      centervx=body01velx(nstep)*rmass(1)+body02velx(nstep)*  &
         rmass(2)+body03velx(nstep)*rmass(3)+body04velx(nstep)*  &
         rmass(4)+body05velx(nstep)*rmass(5)+body06velx(nstep)*  &
         rmass(6)+body07velx(nstep)*rmass(7)+body08velx(nstep)*  &
         rmass(8)
      centervy=body01vely(nstep)*rmass(1)+body02vely(nstep)*  &
         rmass(2)+body03vely(nstep)*rmass(3)+body04vely(nstep)*  &
         rmass(4)+body05vely(nstep)*rmass(5)+body06vely(nstep)*  &
         rmass(6)+body07vely(nstep)*rmass(7)+body08vely(nstep)*  &
         rmass(8)
      centervz=body01velz(nstep)*rmass(1)+body02velz(nstep)*  &
         rmass(2)+body03velz(nstep)*rmass(3)+body04velz(nstep)*  &
         rmass(4)+body05velz(nstep)*rmass(5)+body06velz(nstep)*  &
         rmass(6)+body07velz(nstep)*rmass(7)+body08velz(nstep)*  &
         rmass(8)
   END IF
!
   IF(nbody == 9)THEN
      totmas=rmass(1)+rmass(2)+rmass(3)+rmass(4)+rmass(5)+rmass(6)  &
         +rmass(7)+rmass(8)+rmass(9)
      centerx=body01posx(nstep)*rmass(1)+body02posx(nstep)*  &
         rmass(2)+body03posx(nstep)*rmass(3)+body04posx(nstep)*  &
         rmass(4)+body05posx(nstep)*rmass(5)+body06posx(nstep)*  &
         rmass(6)+body07posx(nstep)*rmass(7)+body08posx(nstep)*  &
         rmass(8)+body09posx(nstep)*rmass(9)
      centery=body01posy(nstep)*rmass(1)+body02posy(nstep)*  &
         rmass(2)+body03posy(nstep)*rmass(3)+body04posy(nstep)*  &
         rmass(4)+body05posy(nstep)*rmass(5)+body06posy(nstep)*  &
         rmass(6)+body07posy(nstep)*rmass(7)+body08posy(nstep)*  &
         rmass(8)+body09posy(nstep)*rmass(9)
      centerz=body01posz(nstep)*rmass(1)+body02posz(nstep)*  &
         rmass(2)+body03posz(nstep)*rmass(3)+body04posz(nstep)*  &
         rmass(4)+body05posz(nstep)*rmass(5)+body06posz(nstep)*  &
         rmass(6)+body07posz(nstep)*rmass(7)+body08posz(nstep)*  &
         rmass(8)+body09posz(nstep)*rmass(9)
      centervx=body01velx(nstep)*rmass(1)+body02velx(nstep)*  &
         rmass(2)+body03velx(nstep)*rmass(3)+body04velx(nstep)*  &
         rmass(4)+body05velx(nstep)*rmass(5)+body06velx(nstep)*  &
         rmass(6)+body07velx(nstep)*rmass(7)+body08velx(nstep)*  &
         rmass(8)+body09velx(nstep)*rmass(9)
      centervy=body01vely(nstep)*rmass(1)+body02vely(nstep)*  &
         rmass(2)+body03vely(nstep)*rmass(3)+body04vely(nstep)*  &
         rmass(4)+body05vely(nstep)*rmass(5)+body06vely(nstep)*  &
         rmass(6)+body07vely(nstep)*rmass(7)+body08vely(nstep)*  &
         rmass(8)+body09vely(nstep)*rmass(9)
      centervz=body01velz(nstep)*rmass(1)+body02velz(nstep)*  &
         rmass(2)+body03velz(nstep)*rmass(3)+body04velz(nstep)*  &
         rmass(4)+body05velz(nstep)*rmass(5)+body06velz(nstep)*  &
         rmass(6)+body07velz(nstep)*rmass(7)+body08velz(nstep)*  &
         rmass(8)+body09velz(nstep)*rmass(9)
   END IF
!
   IF(nbody == 10)THEN
      totmas=rmass(1)+rmass(2)+rmass(3)+rmass(4)+rmass(5)+rmass(6)  &
         +rmass(7)+rmass(8)+rmass(9)+rmass(10)
      centerx=body01posx(nstep)*rmass(1)+body02posx(nstep)*  &
         rmass(2)+body03posx(nstep)*rmass(3)+body04posx(nstep)*  &
         rmass(4)+body05posx(nstep)*rmass(5)+body06posx(nstep)*  &
         rmass(6)+body07posx(nstep)*rmass(7)+body08posx(nstep)*  &
         rmass(8)+body09posx(nstep)*rmass(9)+body10posx(nstep)*  &
         rmass(10)
      centery=body01posy(nstep)*rmass(1)+body02posy(nstep)*  &
         rmass(2)+body03posy(nstep)*rmass(3)+body04posy(nstep)*  &
         rmass(4)+body05posy(nstep)*rmass(5)+body06posy(nstep)*  &
         rmass(6)+body07posy(nstep)*rmass(7)+body08posy(nstep)*  &
         rmass(8)+body09posy(nstep)*rmass(9)+body10posy(nstep)*  &
         rmass(10)
      centerz=body01posz(nstep)*rmass(1)+body02posz(nstep)*  &
         rmass(2)+body03posz(nstep)*rmass(3)+body04posz(nstep)*  &
         rmass(4)+body05posz(nstep)*rmass(5)+body06posz(nstep)*  &
         rmass(6)+body07posz(nstep)*rmass(7)+body08posz(nstep)*  &
         rmass(8)+body09posz(nstep)*rmass(9)+body10posz(nstep)*  &
         rmass(10)
      centervx=body01velx(nstep)*rmass(1)+body02velx(nstep)*  &
         rmass(2)+body03velx(nstep)*rmass(3)+body04velx(nstep)*  &
         rmass(4)+body05velx(nstep)*rmass(5)+body06velx(nstep)*  &
         rmass(6)+body07velx(nstep)*rmass(7)+body08velx(nstep)*  &
         rmass(8)+body09velx(nstep)*rmass(9)+body10velx(nstep)*  &
         rmass(10)
      centervy=body01vely(nstep)*rmass(1)+body02vely(nstep)*  &
         rmass(2)+body03vely(nstep)*rmass(3)+body04vely(nstep)*  &
         rmass(4)+body05vely(nstep)*rmass(5)+body06vely(nstep)*  &
         rmass(6)+body07vely(nstep)*rmass(7)+body08vely(nstep)*  &
         rmass(8)+body09vely(nstep)*rmass(9)+body10vely(nstep)*  &
         rmass(10)
      centervz=body01velz(nstep)*rmass(1)+body02velz(nstep)*  &
         rmass(2)+body03velz(nstep)*rmass(3)+body04velz(nstep)*  &
         rmass(4)+body05velz(nstep)*rmass(5)+body06velz(nstep)*  &
         rmass(6)+body07velz(nstep)*rmass(7)+body08velz(nstep)*  &
         rmass(8)+body09velz(nstep)*rmass(9)+body10velz(nstep)*  &
         rmass(10)
   END IF
!
   WRITE(91,20)centerx/totmas,'x-coordinate of C.O.M.'
   WRITE(91,20)centery/totmas,'y-coordinate of C.O.M.'
   WRITE(91,20)centerz/totmas,'z-coordinate of C.O.M.'
   WRITE(91,30)
   WRITE(91,20)centervx/totmas,'x-velocity of C.O.M.'
   WRITE(91,20)centervy/totmas,'y-velocity of C.O.M.'
   WRITE(91,20)centervz/totmas,'z-velocity of C.O.M.'
   WRITE(91,30)
!
10 FORMAT('#  Keplerian elements at day ',f15.5)
20 FORMAT(1PE24.17,10X,a)
30 FORMAT('#')
40 FORMAT('#  Cartesian coordinates at day ',f15.5)
!
   RETURN
!
END SUBROUTINE inform3
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE inform4(p_init,p_fin,ecc_init,ecc_fin,a_init,  &
   a_fin,ma_init,ma_fin,argperinit,argper_fin,inc_init,inc_fin,  &
   omega_init,omega_fin,tconj_init,tconj_fin,rmass,nbody,  &
   odetime,nstep,ndyn,radtodeg,igr,auslrrad,sw72,sw73,  &
   omega1,omega2,reff1,reff2,f_init,f_fin)
!
!   Writes statistics about changing orbital elements
!   to ELCdynamics.out  (ELC only)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   REAL(KIND=dp), INTENT(IN)                :: p_init(9)
   REAL(KIND=dp), INTENT(IN)                :: p_fin(9)
   REAL(KIND=dp), INTENT(IN)                :: ecc_init(9)
   REAL(KIND=dp), INTENT(IN)                :: ecc_fin(9)
   REAL(KIND=dp), INTENT(IN)                :: a_init(9)
   REAL(KIND=dp), INTENT(IN)                :: a_fin(9)
   REAL(KIND=dp), INTENT(IN)                :: ma_init(9)
   REAL(KIND=dp), INTENT(IN)                :: ma_fin(9)
   REAL(KIND=dp), INTENT(IN)                :: argperinit(9)
   REAL(KIND=dp), INTENT(IN)                :: argper_fin(9)
   REAL(KIND=dp), INTENT(IN)                :: inc_init(9)
   REAL(KIND=dp), INTENT(IN)                :: inc_fin(9)
   REAL(KIND=dp), INTENT(IN)                :: omega_init(9)
   REAL(KIND=dp), INTENT(IN)                :: omega_fin(9)
   REAL(KIND=dp), INTENT(IN)                :: tconj_init(9)
   REAL(KIND=dp), INTENT(IN)                :: tconj_fin(9)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: odetime(ndyn)
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN)                :: radtodeg
   INTEGER, INTENT(IN)                      :: igr
   REAL(KIND=dp), INTENT(IN)                :: auslrrad
   REAL(KIND=dp), INTENT(IN)                :: sw72
   REAL(KIND=dp), INTENT(IN)                :: sw73
   REAL(KIND=dp), INTENT(IN)                :: omega1
   REAL(KIND=dp), INTENT(IN)                :: omega2
   REAL(KIND=dp), INTENT(IN)                :: reff1
   REAL(KIND=dp), INTENT(IN)                :: reff2
   REAL(KIND=dp), INTENT(IN)                :: f_init(9)
   REAL(KIND=dp), INTENT(IN)                :: f_fin(9)
!
   REAL(KIND=dp)  :: delta,value,omegadotgr
   REAL(KIND=dp)  :: george,apsidalrate,cyclenum,deltaomega
!
   WRITE(91,5)
   WRITE(91,20)
!
   value=odetime(nstep)-odetime(1)
   WRITE(91,10)value,'Time span of integration (days)'
   WRITE(91,20)
!
   WRITE(91,10)p_init(1),'Initial binary period (days)'
   WRITE(91,10)p_fin(1),'Final binary period (days)'
   delta=p_fin(1)-p_init(1)
   WRITE(91,10)delta,'Difference (days)'
   WRITE(91,20)
!
   WRITE(91,10)tconj_init(1),'Initial binary Tconj'
   WRITE(91,10)tconj_fin(1),'Final binary Tconj'
   delta=tconj_fin(1)-tconj_init(1)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   WRITE(91,10)ecc_init(1),'Initial binary eccentricity'
   WRITE(91,10)ecc_fin(1),'Final binary eccentricity'
   delta=ecc_fin(1)-ecc_init(1)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=argperinit(1)*radtodeg
   WRITE(91,10)value,'Initial binary arg. per. (deg)'
   value=argper_fin(1)*radtodeg
   WRITE(91,10)value,'Final binary arg. per. (deg)'
   delta=(argper_fin(1)-argperinit(1))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=inc_init(1)*radtodeg
   WRITE(91,10)value,'Initial binary inclination (deg)'
   value=inc_fin(1)*radtodeg
   WRITE(91,10)value,'Final binary inclination (deg)'
   delta=(inc_fin(1)-inc_init(1))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=omega_init(1)*radtodeg
   WRITE(91,10)value,'Initial binary Omega (deg)'
   value=omega_fin(1)*radtodeg
   WRITE(91,10)value,'Final binary Omega (deg)'
   delta=(omega_fin(1)-omega_init(1))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   WRITE(91,10)a_init(1),'Initial binary separation (AU)'
   WRITE(91,10)a_fin(1),'Final binary separation (AU)'
   delta=a_fin(1)-a_init(1)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=ma_init(1)*radtodeg
   WRITE(91,10)value,'Initial binary mean anomaly (deg)'
   value=ma_fin(1)*radtodeg
   WRITE(91,10)value,'Final binary mean anomaly (deg)'
   delta=(ma_fin(1)-ma_init(1))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=f_init(1)*radtodeg
   WRITE(91,10)value,'Initial binary true anomaly (deg)'
   value=f_fin(1)*radtodeg
   WRITE(91,10)value,'Final binary true anomaly (deg)'
   delta=(f_fin(1)-f_init(1))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   cyclenum=(odetime(nstep)-odetime(1))/p_init(1)
   deltaomega=(argper_fin(1)-argperinit(1))*radtodeg/cyclenum
!
   IF((igr == 1))THEN
      value=a_init(1)/auslrrad
      omegadotgr=2.29E-03_dp*(rmass(1)+rmass(2))
      omegadotgr=omegadotgr/((value)*(1.0_dp-ecc_init(1)*ecc_init(1)))
      WRITE(91,10)deltaomega,'Delta_omega (deg/cycle)'
      WRITE(91,10)omegadotgr,'GR Delta_omega (deg/cycle)'
      IF(deltaomega > 0.0_dp)THEN
         george=(omegadotgr-deltaomega)/deltaomega
         WRITE(91,10)george,'(analytic - observed)/observed'
      END IF
   END IF
!
   IF((igr == 2))THEN
      value=a_init(1)/auslrrad
      george=apsidalrate(sw72,sw73,rmass(1),rmass(2),omega1,  &
         omega2,reff1,reff2,ecc_init(1))
      WRITE(91,10)deltaomega,'Delta_omega (deg/cycle)'
      WRITE(91,10)george,'Tidal Delta_omega (deg/cycle)'
      IF(deltaomega > 0.0_dp)THEN
         value=(george-deltaomega)/deltaomega
         WRITE(91,10)value,'(analytic - observed)/observed'
      END IF
   END IF
!
   IF((igr >= 3))THEN
      value=a_init(1)/auslrrad
      omegadotgr=2.29E-03_dp*(rmass(1)+rmass(2))
      omegadotgr=omegadotgr/((value)*(1.0_dp-ecc_init(1)*ecc_init(1)))
      value=a_init(1)/auslrrad
      george=apsidalrate(sw72,sw73,rmass(1),rmass(2),omega1,  &
         omega2,reff1,reff2,ecc_init(1))
      WRITE(91,10)deltaomega,'Delta_omega (deg/cycle)'
      WRITE(91,10)omegadotgr,'GR Delta_omega (deg/cycle)'
      WRITE(91,10)george,'Tidal Delta_omega (deg/cycle)'
      value=george+omegadotgr
      WRITE(91,10)value,'Total analytic Delta_omega (deg/cycle)'
      IF(deltaomega > 0.0_dp)THEN
         george=(value-deltaomega)/deltaomega
         WRITE(91,10)george,'(analytic - observed)/observed'
      END IF
   END IF
   WRITE(91,20)
!
   WRITE(91,5)
   WRITE(91,20)
   WRITE(91,10)p_init(2),'Initial body 3 period (days)'
   WRITE(91,10)p_fin(2),'Final body 3 period (days)'
   delta=p_fin(2)-p_init(2)
   WRITE(91,10)delta,'Difference (days)'
   WRITE(91,20)
!
   WRITE(91,10)tconj_init(2),'Initial body 3 Tconj'
   WRITE(91,10)tconj_fin(2),'Final body 3 Tconj'
   delta=tconj_fin(2)-tconj_init(2)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   WRITE(91,10)ecc_init(2),'Initial body 3 eccentricity'
   WRITE(91,10)ecc_fin(2),'Final body 3 eccentricity'
   delta=ecc_fin(2)-ecc_init(2)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=argperinit(2)*radtodeg
   WRITE(91,10)value,'Initial body 3 arg. per. (deg)'
   value=argper_fin(2)*radtodeg
   WRITE(91,10)value,'Final body 3 arg. per. (deg)'
   delta=(argper_fin(2)-argperinit(2))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=inc_init(2)*radtodeg
   WRITE(91,10)value,'Initial body 3 inclination (deg)'
   value=inc_fin(2)*radtodeg
   WRITE(91,10)value,'Final body 3 inclination (deg)'
   delta=(inc_fin(2)-inc_init(2))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=omega_init(2)*radtodeg
   WRITE(91,10)value,'Initial body 3 Omega (deg)'
   value=omega_fin(2)*radtodeg
   WRITE(91,10)value,'Final body 3 Omega (deg)'
   delta=(omega_fin(2)-omega_init(2))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   WRITE(91,10)a_init(2),'Initial body 3 separation (AU)'
   WRITE(91,10)a_fin(2),'Final body 3 separation (AU)'
   delta=a_fin(2)-a_init(2)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=ma_init(2)*radtodeg
   WRITE(91,10)value,'Initial body 3 mean anomaly (deg)'
   value=ma_fin(2)*radtodeg
   WRITE(91,10)value,'Final body 3 mean anomaly (deg)'
   delta=(ma_fin(2)-ma_init(2))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=f_init(2)*radtodeg
   WRITE(91,10)value,'Initial body 3 true anomaly (deg)'
   value=f_fin(2)*radtodeg
   WRITE(91,10)value,'Final body 3 true anomaly (deg)'
   delta=(f_fin(2)-f_init(2))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   IF(nbody == 3)THEN
      CLOSE(91)
      RETURN
   END IF
!
   WRITE(91,5)
   WRITE(91,20)
   WRITE(91,10)p_init(3),'Initial body 4 period (days)'
   WRITE(91,10)p_fin(3),'Final body 4 period (days)'
   delta=p_fin(3)-p_init(3)
   WRITE(91,10)delta,'Difference (days)'
   WRITE(91,20)
!
   WRITE(91,10)tconj_init(3),'Initial body 4 Tconj'
   WRITE(91,10)tconj_fin(3),'Final body 4 Tconj'
   delta=tconj_fin(3)-tconj_init(3)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   WRITE(91,10)ecc_init(3),'Initial body 4 eccentricity'
   WRITE(91,10)ecc_fin(3),'Final body 4 eccentricity'
   delta=ecc_fin(3)-ecc_init(3)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=argperinit(3)*radtodeg
   WRITE(91,10)value,'Initial body 4 arg. per. (deg)'
   value=argper_fin(3)*radtodeg
   WRITE(91,10)value,'Final body 4 arg. per. (deg)'
   delta=(argper_fin(3)-argperinit(3))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=inc_init(3)*radtodeg
   WRITE(91,10)value,'Initial body 4 inclination (deg)'
   value=inc_fin(3)*radtodeg
   WRITE(91,10)value,'Final body 4 inclination (deg)'
   delta=(inc_fin(3)-inc_init(3))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=omega_init(3)*radtodeg
   WRITE(91,10)value,'Initial body 4 Omega (deg)'
   value=omega_fin(3)*radtodeg
   WRITE(91,10)value,'Final body 4 Omega (deg)'
   delta=(omega_fin(3)-omega_init(3))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   WRITE(91,10)a_init(3),'Initial body 4 separation (AU)'
   WRITE(91,10)a_fin(3),'Final body 4 separation (AU)'
   delta=a_fin(3)-a_init(3)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=ma_init(3)*radtodeg
   WRITE(91,10)value,'Initial body 4 mean anomaly (deg)'
   value=ma_fin(3)*radtodeg
   WRITE(91,10)value,'Final body 4 mean anomaly (deg)'
   delta=(ma_fin(3)-ma_init(3))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=f_init(3)*radtodeg
   WRITE(91,10)value,'Initial body 4 true anomaly (deg)'
   value=f_fin(3)*radtodeg
   WRITE(91,10)value,'Final body 4 true anomaly (deg)'
   delta=(f_fin(3)-f_init(3))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   IF(nbody == 4)THEN
      CLOSE(91)
      RETURN
   END IF
!
   WRITE(91,5)
   WRITE(91,20)
   WRITE(91,10)p_init(4),'Initial body 5 period (days)'
   WRITE(91,10)p_fin(4),'Final body 5 period (days)'
   delta=p_fin(4)-p_init(4)
   WRITE(91,10)delta,'Difference (days)'
   WRITE(91,20)
!
   WRITE(91,10)tconj_init(4),'Initial body 5 Tconj'
   WRITE(91,10)tconj_fin(4),'Final body 5 Tconj'
   delta=tconj_fin(4)-tconj_init(4)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   WRITE(91,10)ecc_init(4),'Initial body 5 eccentricity'
   WRITE(91,10)ecc_fin(4),'Final body 5 eccentricity'
   delta=ecc_fin(4)-ecc_init(4)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=argperinit(4)*radtodeg
   WRITE(91,10)value,'Initial body 5 arg. per. (deg)'
   value=argper_fin(4)*radtodeg
   WRITE(91,10)value,'Final body 5 arg. per. (deg)'
   delta=(argper_fin(4)-argperinit(4))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=inc_init(4)*radtodeg
   WRITE(91,10)value,'Initial body 5 inclination (deg)'
   value=inc_fin(4)*radtodeg
   WRITE(91,10)value,'Final body 5 inclination (deg)'
   delta=(inc_fin(4)-inc_init(4))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=omega_init(4)*radtodeg
   WRITE(91,10)value,'Initial body 5 Omega (deg)'
   value=omega_fin(4)*radtodeg
   WRITE(91,10)value,'Final body 5 Omega (deg)'
   delta=(omega_fin(4)-omega_init(4))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   WRITE(91,10)a_init(4),'Initial body 5 separation (AU)'
   WRITE(91,10)a_fin(4),'Final body 5 separation (AU)'
   delta=a_fin(4)-a_init(4)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=ma_init(4)*radtodeg
   WRITE(91,10)value,'Initial body 5 mean anomaly (deg)'
   value=ma_fin(4)*radtodeg
   WRITE(91,10)value,'Final body 5 mean anomaly (deg)'
   delta=(ma_fin(4)-ma_init(4))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=f_init(4)*radtodeg
   WRITE(91,10)value,'Initial body 5 true anomaly (deg)'
   value=f_fin(4)*radtodeg
   WRITE(91,10)value,'Final body 5 true anomaly (deg)'
   delta=(f_fin(4)-f_init(4))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   IF(nbody == 5)THEN
      CLOSE(91)
      RETURN
   END IF
!
   WRITE(91,5)
   WRITE(91,20)
   WRITE(91,10)p_init(5),'Initial body 6 period (days)'
   WRITE(91,10)p_fin(5),'Final body 6 period (days)'
   delta=p_fin(5)-p_init(5)
   WRITE(91,10)delta,'Difference (days)'
   WRITE(91,20)
!
   WRITE(91,10)tconj_init(5),'Initial body 6 Tconj'
   WRITE(91,10)tconj_fin(5),'Final body 6 Tconj'
   delta=tconj_fin(5)-tconj_init(5)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   WRITE(91,10)ecc_init(5),'Initial body 6 eccentricity'
   WRITE(91,10)ecc_fin(5),'Final body 6 eccentricity'
   delta=ecc_fin(5)-ecc_init(5)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=argperinit(5)*radtodeg
   WRITE(91,10)value,'Initial body 6 arg. per. (deg)'
   value=argper_fin(5)*radtodeg
   WRITE(91,10)value,'Final body 6 arg. per. (deg)'
   delta=(argper_fin(5)-argperinit(5))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=inc_init(5)*radtodeg
   WRITE(91,10)value,'Initial body 6 inclination (deg)'
   value=inc_fin(5)*radtodeg
   WRITE(91,10)value,'Final body 6 inclination (deg)'
   delta=(inc_fin(5)-inc_init(5))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=omega_init(5)*radtodeg
   WRITE(91,10)value,'Initial body 6 Omega (deg)'
   value=omega_fin(5)*radtodeg
   WRITE(91,10)value,'Final body 6 Omega (deg)'
   delta=(omega_fin(5)-omega_init(5))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   WRITE(91,10)a_init(5),'Initial body 6 separation (AU)'
   WRITE(91,10)a_fin(5),'Final body 6 separation (AU)'
   delta=a_fin(5)-a_init(5)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=ma_init(5)*radtodeg
   WRITE(91,10)value,'Initial body 6 mean anomaly (deg)'
   value=ma_fin(5)*radtodeg
   WRITE(91,10)value,'Final body 6 mean anomaly (deg)'
   delta=(ma_fin(5)-ma_init(5))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=f_init(5)*radtodeg
   WRITE(91,10)value,'Initial body 6 true anomaly (deg)'
   value=f_fin(5)*radtodeg
   WRITE(91,10)value,'Final body 6 true anomaly (deg)'
   delta=(f_fin(5)-f_init(5))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   IF(nbody == 6)THEN
      CLOSE(91)
      RETURN
   END IF
!
   WRITE(91,5)
   WRITE(91,20)
   WRITE(91,10)p_init(6),'Initial body 7 period (days)'
   WRITE(91,10)p_fin(6),'Final body 7 period (days)'
   delta=p_fin(6)-p_init(6)
   WRITE(91,10)delta,'Difference (days)'
   WRITE(91,20)
!
   WRITE(91,10)tconj_init(6),'Initial body 7 Tconj'
   WRITE(91,10)tconj_fin(6),'Final body 7 Tconj'
   delta=tconj_fin(6)-tconj_init(6)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   WRITE(91,10)ecc_init(6),'Initial body 7 eccentricity'
   WRITE(91,10)ecc_fin(6),'Final body 7 eccentricity'
   delta=ecc_fin(6)-ecc_init(6)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=argperinit(6)*radtodeg
   WRITE(91,10)value,'Initial body 7 arg. per. (deg)'
   value=argper_fin(6)*radtodeg
   WRITE(91,10)value,'Final body 7 arg. per. (deg)'
   delta=(argper_fin(6)-argperinit(6))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=inc_init(6)*radtodeg
   WRITE(91,10)value,'Initial body 7 inclination (deg)'
   value=inc_fin(6)*radtodeg
   WRITE(91,10)value,'Final body 7 inclination (deg)'
   delta=(inc_fin(6)-inc_init(6))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=omega_init(6)*radtodeg
   WRITE(91,10)value,'Initial body 7 Omega (deg)'
   value=omega_fin(6)*radtodeg
   WRITE(91,10)value,'Final body 7 Omega (deg)'
   delta=(omega_fin(6)-omega_init(6))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   WRITE(91,10)a_init(6),'Initial body 7 separation (AU)'
   WRITE(91,10)a_fin(6),'Final body 7 separation (AU)'
   delta=a_fin(6)-a_init(6)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=ma_init(6)*radtodeg
   WRITE(91,10)value,'Initial body 7 mean anomaly (deg)'
   value=ma_fin(6)*radtodeg
   WRITE(91,10)value,'Final body 7 mean anomaly (deg)'
   delta=(ma_fin(6)-ma_init(6))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=f_init(6)*radtodeg
   WRITE(91,10)value,'Initial body 7 true anomaly (deg)'
   value=f_fin(6)*radtodeg
   WRITE(91,10)value,'Final body 7 true anomaly (deg)'
   delta=(f_fin(6)-f_init(6))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   IF(nbody == 7)THEN
      CLOSE(91)
      RETURN
   END IF
!
   WRITE(91,5)
   WRITE(91,20)
   WRITE(91,10)p_init(7),'Initial body 8 period (days)'
   WRITE(91,10)p_fin(7),'Final body 8 period (days)'
   delta=p_fin(7)-p_init(7)
   WRITE(91,10)delta,'Difference (days)'
   WRITE(91,20)
!
   WRITE(91,10)tconj_init(7),'Initial body 8 Tconj'
   WRITE(91,10)tconj_fin(7),'Final body 8 Tconj'
   delta=tconj_fin(7)-tconj_init(7)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   WRITE(91,10)ecc_init(7),'Initial body 8 eccentricity'
   WRITE(91,10)ecc_fin(7),'Final body 8 eccentricity'
   delta=ecc_fin(7)-ecc_init(7)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=argperinit(7)*radtodeg
   WRITE(91,10)value,'Initial body 8 arg. per. (deg)'
   value=argper_fin(7)*radtodeg
   WRITE(91,10)value,'Final body 8 arg. per. (deg)'
   delta=(argper_fin(7)-argperinit(7))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=inc_init(7)*radtodeg
   WRITE(91,10)value,'Initial body 8 inclination (deg)'
   value=inc_fin(7)*radtodeg
   WRITE(91,10)value,'Final body 8 inclination (deg)'
   delta=(inc_fin(7)-inc_init(7))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=omega_init(7)*radtodeg
   WRITE(91,10)value,'Initial body 8 Omega (deg)'
   value=omega_fin(7)*radtodeg
   WRITE(91,10)value,'Final body 8 Omega (deg)'
   delta=(omega_fin(7)-omega_init(7))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   WRITE(91,10)a_init(7),'Initial body 8 separation (AU)'
   WRITE(91,10)a_fin(7),'Final body 8 separation (AU)'
   delta=a_fin(7)-a_init(7)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=ma_init(7)*radtodeg
   WRITE(91,10)value,'Initial body 8 mean anomaly (deg)'
   value=ma_fin(7)*radtodeg
   WRITE(91,10)value,'Final body 8 mean anomaly (deg)'
   delta=(ma_fin(7)-ma_init(7))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=f_init(7)*radtodeg
   WRITE(91,10)value,'Initial body 8 true anomaly (deg)'
   value=f_fin(7)*radtodeg
   WRITE(91,10)value,'Final body 8 true anomaly (deg)'
   delta=(f_fin(7)-f_init(7))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   IF(nbody == 8)THEN
      CLOSE(91)
      RETURN
   END IF
!
   WRITE(91,5)
   WRITE(91,20)
   WRITE(91,10)p_init(8),'Initial body 9 period (days)'
   WRITE(91,10)p_fin(8),'Final body 9 period (days)'
   delta=p_fin(8)-p_init(8)
   WRITE(91,10)delta,'Difference (days)'
   WRITE(91,20)
!
   WRITE(91,10)tconj_init(8),'Initial body 9 Tconj'
   WRITE(91,10)tconj_fin(8),'Final body 9 Tconj'
   delta=tconj_fin(8)-tconj_init(8)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   WRITE(91,10)ecc_init(8),'Initial body 9 eccentricity'
   WRITE(91,10)ecc_fin(8),'Final body 9 eccentricity'
   delta=ecc_fin(8)-ecc_init(8)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=argperinit(8)*radtodeg
   WRITE(91,10)value,'Initial body 9 arg. per. (deg)'
   value=argper_fin(8)*radtodeg
   WRITE(91,10)value,'Final body 9 arg. per. (deg)'
   delta=(argper_fin(8)-argperinit(8))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=inc_init(8)*radtodeg
   WRITE(91,10)value,'Initial body 9 inclination (deg)'
   value=inc_fin(8)*radtodeg
   WRITE(91,10)value,'Final body 9 inclination (deg)'
   delta=(inc_fin(8)-inc_init(8))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=omega_init(8)*radtodeg
   WRITE(91,10)value,'Initial body 9 Omega (deg)'
   value=omega_fin(8)*radtodeg
   WRITE(91,10)value,'Final body 9 Omega (deg)'
   delta=(omega_fin(8)-omega_init(8))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   WRITE(91,10)a_init(8),'Initial body 9 separation (AU)'
   WRITE(91,10)a_fin(8),'Final body 9 separation (AU)'
   delta=a_fin(8)-a_init(8)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=ma_init(8)*radtodeg
   WRITE(91,10)value,'Initial body 9 mean anomaly (deg)'
   value=ma_fin(8)*radtodeg
   WRITE(91,10)value,'Final body 9 mean anomaly (deg)'
   delta=(ma_fin(8)-ma_init(8))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=f_init(8)*radtodeg
   WRITE(91,10)value,'Initial body 9 true anomaly (deg)'
   value=f_fin(8)*radtodeg
   WRITE(91,10)value,'Final body 9 true anomaly (deg)'
   delta=(f_fin(8)-f_init(8))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   IF(nbody == 9)THEN
      CLOSE(91)
      RETURN
   END IF
!
   WRITE(91,5)
   WRITE(91,20)
   WRITE(91,10)p_init(8),'Initial body 10 period (days)'
   WRITE(91,10)p_fin(8),'Final body 10 period (days)'
   delta=p_fin(8)-p_init(8)
   WRITE(91,10)delta,'Difference (days)'
   WRITE(91,20)
!
   WRITE(91,10)tconj_init(8),'Initial body 10 Tconj'
   WRITE(91,10)tconj_fin(8),'Final body 10 Tconj'
   delta=tconj_fin(8)-tconj_init(8)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   WRITE(91,10)ecc_init(8),'Initial body 10 eccentricity'
   WRITE(91,10)ecc_fin(8),'Final body 10 eccentricity'
   delta=ecc_fin(8)-ecc_init(8)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=argperinit(8)*radtodeg
   WRITE(91,10)value,'Initial body 10 arg. per. (deg)'
   value=argper_fin(8)*radtodeg
   WRITE(91,10)value,'Final body 10 arg. per. (deg)'
   delta=(argper_fin(8)-argperinit(8))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=inc_init(8)*radtodeg
   WRITE(91,10)value,'Initial body 10 inclination (deg)'
   value=inc_fin(8)*radtodeg
   WRITE(91,10)value,'Final body 10 inclination (deg)'
   delta=(inc_fin(8)-inc_init(8))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=omega_init(8)*radtodeg
   WRITE(91,10)value,'Initial body 10 Omega (deg)'
   value=omega_fin(8)*radtodeg
   WRITE(91,10)value,'Final body 10 Omega (deg)'
   delta=(omega_fin(8)-omega_init(8))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   WRITE(91,10)a_init(8),'Initial body 10 separation (AU)'
   WRITE(91,10)a_fin(8),'Final body 10 separation (AU)'
   delta=a_fin(8)-a_init(8)
   WRITE(91,10)delta,'Difference'
   WRITE(91,20)
!
   value=ma_init(8)*radtodeg
   WRITE(91,10)value,'Initial body 10 mean anomaly (deg)'
   value=ma_fin(8)*radtodeg
   WRITE(91,10)value,'Final body 10 mean anomaly (deg)'
   delta=(ma_fin(8)-ma_init(8))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   value=f_init(8)*radtodeg
   WRITE(91,10)value,'Initial body 10 true anomaly (deg)'
   value=f_fin(8)*radtodeg
   WRITE(91,10)value,'Final body 10 true anomaly (deg)'
   delta=(f_fin(8)-f_init(8))*radtodeg
   WRITE(91,10)delta,'Difference (deg)'
   WRITE(91,20)
!
   CLOSE(91)
!
5  FORMAT(70('#'))
10 FORMAT('#',2X,f24.15,7X,a)
20 FORMAT('#')
!
   RETURN
!
END SUBROUTINE inform4
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE initeclipse(nmaxeclipse,ncycle,ttimes,tseps,tdur1,  &
   tdur2,obsttimes,obsterr)
!
!   sets initial values to zero
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxeclipse
   INTEGER, INTENT(OUT)                     :: ncycle(40)
   REAL(KIND=dp), INTENT(OUT)               :: ttimes(40,nmaxeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: tseps(40,nmaxeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: tdur1(40,nmaxeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: tdur2(40,nmaxeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: obsttimes(40,nmaxeclipse)
   REAL(KIND=dp), INTENT(OUT)               :: obsterr(40,nmaxeclipse)
!
   INTEGER :: i,j
!
   DO i=1,40
      ncycle(i)=0
      DO j=1,nmaxeclipse
         ttimes(i,j)=0.0_dp
         tseps(i,j)=0.0_dp
         tdur1(i,j)=0.0_dp
         tdur2(i,j)=0.0_dp
         obsttimes(i,j)=0.0_dp
         obsterr(i,j)=0.0_dp
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE initeclipse
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE initmod(nmaxphase,ymodu,ymodb,ymodv,ymodr,ymodi,  &
   ymodj,ymodk,ymods1,ymods2,ymods3,ymodd,rv1,rv2,drv1,drv2)
!
!   initializes model arrays to zero
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxphase
   REAL(KIND=dp), INTENT(OUT)               :: ymodu(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodb(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodv(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodr(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodi(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodj(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodk(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods2(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymods3(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: ymodd(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: rv1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: rv2(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv1(nmaxphase)
   REAL(KIND=dp), INTENT(OUT)               :: drv2(nmaxphase)
!
   ymodu=0.0_dp
   ymodb=0.0_dp
   ymodv=0.0_dp
   ymodr=0.0_dp
   ymodi=0.0_dp
   ymodj=0.0_dp
   ymodk=0.0_dp
   ymods1=0.0_dp
   ymods2=0.0_dp
   ymods3=0.0_dp
   ymodd=0.0_dp
   rv1=0.0_dp
   rv2=0.0_dp
   drv1=0.0_dp
   drv2=0.0_dp
!
   RETURN
!
END SUBROUTINE initmod
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE initratio(ialphmax1,ibetmax1,nalph1,nbet1,nalph2,  &
   nbet2,ratio1,ratio2,coprat1,coprat2,ialphmax2,ibetmax2)
!
!   October 15, 1999
!
!   Initialize the ratio arrays to 1.0.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax1
   INTEGER, INTENT(IN)                      :: ibetmax1
   INTEGER, INTENT(IN)                      :: ialphmax2
   INTEGER, INTENT(IN)                      :: ibetmax2
   INTEGER, INTENT(IN)                      :: nalph1
   INTEGER, INTENT(IN)                      :: nbet1
   INTEGER, INTENT(IN)                      :: nalph2
   INTEGER, INTENT(IN)                      :: nbet2
   REAL(KIND=dp), INTENT(OUT)               :: ratio1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(OUT)               :: ratio2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(OUT)               :: coprat1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(OUT)               :: coprat2(ialphmax2*ibetmax2)
!
   INTEGER :: ialf,iidx, ibet
!
   DO  ialf=1,nalph1
      DO  ibet=1,4*nbet1
         iidx=(ialf-1)*4*nbet1+ibet
         ratio1(iidx)=1.0_dp
         coprat1(iidx)=1.0_dp
      END DO
   END DO
!
   DO  ialf=1,nalph2
      DO  ibet=1,4*nbet2
         iidx=(ialf-1)*4*nbet2+ibet
         ratio2(iidx)=1.0_dp
         coprat2(iidx)=1.0_dp
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE initratio
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE insgridbody3(kkk,nalph3,nbet3,tertperiod,tertt0,  &
   tertecos,tertesin,tertincl,tertomega,tertq,dwavex,dwavey,  &
   itconj,it1,it2,it3,it4,tertconj,tertratrad,hh,sw72,sw73,  &
   p2tconj,p2period,p2t0,p2ecos,p2esin,p2incl,p2omega,p2q,  &
   p2ratrad,p3tconj,p3period,p3t0,p3ecos,p3esin,p3incl,p3omega,  &
   p3q,p3ratrad,p4tconj,p4period,p4t0,p4ecos,p4esin,p4incl,  &
   p4omega,p4q,p4ratrad,p5tconj,p5period,p5t0,p5ecos,p5esin,  &
   p5incl,p5omega,p5q,p5ratrad,p6tconj,p6period,p6t0,p6ecos,  &
   p6esin,p6incl,p6omega,p6q,p6ratrad,p7tconj,p7period,p7t0,  &
   p7ecos,p7esin,p7incl,p7omega,p7q,p7ratrad,p8tconj,p8period,  &
   p8t0,p8ecos,p8esin,p8incl,p8omega,p8q,p8ratrad)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(OUT)                     :: kkk
   INTEGER, INTENT(OUT)                     :: nalph3
   INTEGER, INTENT(OUT)                     :: nbet3
   REAL(KIND=dp), INTENT(OUT)               :: tertperiod
   REAL(KIND=dp), INTENT(OUT)               :: tertt0
   REAL(KIND=dp), INTENT(OUT)               :: tertecos
   REAL(KIND=dp), INTENT(OUT)               :: tertesin
   REAL(KIND=dp), INTENT(OUT)               :: tertincl
   REAL(KIND=dp), INTENT(OUT)               :: tertomega
   REAL(KIND=dp), INTENT(OUT)               :: tertq
   REAL(KIND=dp), INTENT(OUT)               :: dwavex(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: dwavey(8,10)
   INTEGER, INTENT(OUT)                     :: itconj
   INTEGER, INTENT(OUT)                     :: it1
   INTEGER, INTENT(OUT)                     :: it2
   INTEGER, INTENT(OUT)                     :: it3
   INTEGER, INTENT(OUT)                     :: it4
   REAL(KIND=dp), INTENT(OUT)               :: tertconj
   REAL(KIND=dp), INTENT(OUT)               :: tertratrad
   REAL(KIND=dp), INTENT(OUT)               :: hh
   REAL(KIND=dp), INTENT(OUT)               :: sw72
   REAL(KIND=dp), INTENT(OUT)               :: sw73
   REAL(KIND=dp), INTENT(OUT)               :: p2tconj
   REAL(KIND=dp), INTENT(OUT)               :: p2period
   REAL(KIND=dp), INTENT(OUT)               :: p2t0
   REAL(KIND=dp), INTENT(OUT)               :: p2ecos
   REAL(KIND=dp), INTENT(OUT)               :: p2esin
   REAL(KIND=dp), INTENT(OUT)               :: p2incl
   REAL(KIND=dp), INTENT(OUT)               :: p2omega
   REAL(KIND=dp), INTENT(OUT)               :: p2q
   REAL(KIND=dp), INTENT(OUT)               :: p2ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p3tconj
   REAL(KIND=dp), INTENT(OUT)               :: p3period
   REAL(KIND=dp), INTENT(OUT)               :: p3t0
   REAL(KIND=dp), INTENT(OUT)               :: p3ecos
   REAL(KIND=dp), INTENT(OUT)               :: p3esin
   REAL(KIND=dp), INTENT(OUT)               :: p3incl
   REAL(KIND=dp), INTENT(OUT)               :: p3omega
   REAL(KIND=dp), INTENT(OUT)               :: p3q
   REAL(KIND=dp), INTENT(OUT)               :: p3ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p4tconj
   REAL(KIND=dp), INTENT(OUT)               :: p4period
   REAL(KIND=dp), INTENT(OUT)               :: p4t0
   REAL(KIND=dp), INTENT(OUT)               :: p4ecos
   REAL(KIND=dp), INTENT(OUT)               :: p4esin
   REAL(KIND=dp), INTENT(OUT)               :: p4incl
   REAL(KIND=dp), INTENT(OUT)               :: p4omega
   REAL(KIND=dp), INTENT(OUT)               :: p4q
   REAL(KIND=dp), INTENT(OUT)               :: p4ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p5tconj
   REAL(KIND=dp), INTENT(OUT)               :: p5period
   REAL(KIND=dp), INTENT(OUT)               :: p5t0
   REAL(KIND=dp), INTENT(OUT)               :: p5ecos
   REAL(KIND=dp), INTENT(OUT)               :: p5esin
   REAL(KIND=dp), INTENT(OUT)               :: p5incl
   REAL(KIND=dp), INTENT(OUT)               :: p5omega
   REAL(KIND=dp), INTENT(OUT)               :: p5q
   REAL(KIND=dp), INTENT(OUT)               :: p5ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p6tconj
   REAL(KIND=dp), INTENT(OUT)               :: p6period
   REAL(KIND=dp), INTENT(OUT)               :: p6t0
   REAL(KIND=dp), INTENT(OUT)               :: p6ecos
   REAL(KIND=dp), INTENT(OUT)               :: p6esin
   REAL(KIND=dp), INTENT(OUT)               :: p6incl
   REAL(KIND=dp), INTENT(OUT)               :: p6omega
   REAL(KIND=dp), INTENT(OUT)               :: p6q
   REAL(KIND=dp), INTENT(OUT)               :: p6ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p7tconj
   REAL(KIND=dp), INTENT(OUT)               :: p7period
   REAL(KIND=dp), INTENT(OUT)               :: p7t0
   REAL(KIND=dp), INTENT(OUT)               :: p7ecos
   REAL(KIND=dp), INTENT(OUT)               :: p7esin
   REAL(KIND=dp), INTENT(OUT)               :: p7incl
   REAL(KIND=dp), INTENT(OUT)               :: p7omega
   REAL(KIND=dp), INTENT(OUT)               :: p7q
   REAL(KIND=dp), INTENT(OUT)               :: p7ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p8tconj
   REAL(KIND=dp), INTENT(OUT)               :: p8period
   REAL(KIND=dp), INTENT(OUT)               :: p8t0
   REAL(KIND=dp), INTENT(OUT)               :: p8ecos
   REAL(KIND=dp), INTENT(OUT)               :: p8esin
   REAL(KIND=dp), INTENT(OUT)               :: p8incl
   REAL(KIND=dp), INTENT(OUT)               :: p8omega
   REAL(KIND=dp), INTENT(OUT)               :: p8q
   REAL(KIND=dp), INTENT(OUT)               :: p8ratrad
!
   INTEGER :: ios,i
!
   ios=0
   OPEN(UNIT=1,FILE='ELCbody3.insert',STATUS='old',ERR=10,IOSTAT= ios)
!
   READ(1,*,END=20,ERR=20)nalph3
   READ(1,*,END=20,ERR=20)nbet3
   READ(1,*,END=20,ERR=20)itconj
   READ(1,*,END=20,ERR=20)it1
   READ(1,*,END=20,ERR=20)it2
   READ(1,*,END=20,ERR=20)it3
   READ(1,*,END=20,ERR=20)it4
   READ(1,*,END=20,ERR=20)tertconj
   READ(1,*,END=20,ERR=20)tertperiod
   READ(1,*,END=20,ERR=20)tertt0
   READ(1,*,END=20,ERR=20)tertecos
   READ(1,*,END=20,ERR=20)tertesin
   READ(1,*,END=20,ERR=20)tertincl
   READ(1,*,END=20,ERR=20)tertomega
   READ(1,*,END=20,ERR=20)tertq
!
!  Load the limb darkening parameters for body 3
!
   DO i=1,8
      READ(1,*,END=20,ERR=20)dwavex(i,3),dwavey(i,3)
   END DO
!
   READ(1,*,END=20,ERR=20)tertratrad
   READ(1,*,END=20,ERR=20)hh
   READ(1,*,END=20,ERR=20)sw72
   READ(1,*,END=20,ERR=20)sw73
   READ(1,*)p2tconj
   READ(1,*)p2period
   READ(1,*)p2t0
   READ(1,*)p2ecos
   READ(1,*)p2esin
   READ(1,*)p2incl
   READ(1,*)p2omega
   READ(1,*)p2q
   READ(1,*)p2ratrad
!
   READ(1,*)p3tconj
   READ(1,*)p3period
   READ(1,*)p3t0
   READ(1,*)p3ecos
   READ(1,*)p3esin
   READ(1,*)p3incl
   READ(1,*)p3omega
   READ(1,*)p3q
   READ(1,*)p3ratrad
!
   READ(1,*)p4tconj
   READ(1,*)p4period
   READ(1,*)p4t0
   READ(1,*)p4ecos
   READ(1,*)p4esin
   READ(1,*)p4incl
   READ(1,*)p4omega
   READ(1,*)p4q
   READ(1,*)p4ratrad
!
   READ(1,*)p5tconj
   READ(1,*)p5period
   READ(1,*)p5t0
   READ(1,*)p5ecos
   READ(1,*)p5esin
   READ(1,*)p5incl
   READ(1,*)p5omega
   READ(1,*)p5q
   READ(1,*)p5ratrad
!
   READ(1,*)p6tconj
   READ(1,*)p6period
   READ(1,*)p6t0
   READ(1,*)p6ecos
   READ(1,*)p6esin
   READ(1,*)p6incl
   READ(1,*)p6omega
   READ(1,*)p6q
   READ(1,*)p6ratrad
!
   READ(1,*)p7tconj
   READ(1,*)p7period
   READ(1,*)p7t0
   READ(1,*)p7ecos
   READ(1,*)p7esin
   READ(1,*)p7incl
   READ(1,*)p7omega
   READ(1,*)p7q
   READ(1,*)p7ratrad
!
   READ(1,*)p8tconj
   READ(1,*)p8period
   READ(1,*)p8t0
   READ(1,*)p8ecos
   READ(1,*)p8esin
   READ(1,*)p8incl
   READ(1,*)p8omega
   READ(1,*)p8q
   READ(1,*)p8ratrad
!
!  Load the limb darkening parameters for body 4
!
   DO i=1,8
      READ(1,*,END=20,ERR=20)dwavex(i,4),dwavey(i,4)
   END DO
!
!  Load the limb darkening parameters for body 5
!
   DO i=1,8
      READ(1,*,END=20,ERR=20)dwavex(i,5),dwavey(i,5)
   END DO
!
   IF(ios == 0)THEN
      CLOSE(1)
      kkk=99
      CALL EXECUTE_COMMAND_LINE('rm ELCbody3.insert')
      RETURN
   END IF
!
!   Come here if the input file ELCbody3.insert does not exist.
!
10 IF(ios > 0)THEN
      kkk=0
      RETURN
   END IF
!
!   Come here if there is an error reading the file
!
20 kkk=0
   CALL EXECUTE_COMMAND_LINE('rm ELCbody3.insert')
!
   RETURN
!
END SUBROUTINE insgridbody3
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE insgridinput(kkk,nalph1,nbet1,nalph2,nbet2,fill1,  &
   fill2,omega1,omega2,dphase,q,finc,teff1,teff2,tgrav1,tgrav2,  &
   betarim,rinner,router,tdisk,xi,ntheta,nradius,alb1,alb2,nref,  &
   rlx,period,fm,separ,gamma,t3,g3,sa3,density,sw1,sw2,sw3,t0,  &
   idraw,iecheck,iidint,iatm,ism1,icnu,icnb,icnv,icnr,icni,icnj,  &
   icnh,icnk,irvfilt,isw1,isw2,isw3,isw4,ilaw,wave,dbolx,dboly,  &
   dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,sw8,sw9,ikeep,  &
   isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,spot2parm,  &
   spotdparm,primmass,primk,primrad,ratrad,frac1,frac2,ecosw,  &
   temprat,idark1,idark2,isw12,isw13,isw21,isw22,isw23,isw24,  &
   bigi,bigbeta,sw23,sw24,powercoeff,sw25,sw26,sw27,sw28,sw29,  &
   sw30,contam,tconj,beam1,beam2,isw25,isw26,isw27,isw28,isw29,  &
   isw30,isw31,isw32,isw33,isw34,ocose,osine,omegadot,contams0,  &
   contams1,contams2,contams3,sw47,sw48,sw49,sw80,sw81,sw82,  &
   sw83,sw84,sw85,sw86,sw87,sw88,sw89,isw80,isw81,isw82,isw83,  &
   isw84,isw85,isw86,isw87,isw88,isw89)
!
!   UPDATE August, 2014
!
!   This routine used by demcmcELC and geneticELC.
!   If the file ELC.insert exists, read it in and distroy it.  Set kkk=99
!   on exit.  If the file does not exist, set kkk=0 and exit.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(OUT)                     :: kkk
   INTEGER, INTENT(OUT)                     :: nalph1
   INTEGER, INTENT(OUT)                     :: nbet1
   INTEGER, INTENT(OUT)                     :: nalph2
   INTEGER, INTENT(OUT)                     :: nbet2
   REAL(KIND=dp), INTENT(OUT)               :: fill1
   REAL(KIND=dp), INTENT(OUT)               :: fill2
   REAL(KIND=dp), INTENT(OUT)               :: omega1
   REAL(KIND=dp), INTENT(OUT)               :: omega2
   REAL(KIND=dp), INTENT(OUT)               :: dphase
   REAL(KIND=dp), INTENT(OUT)               :: q
   REAL(KIND=dp), INTENT(OUT)               :: finc
   REAL(KIND=dp), INTENT(OUT)               :: teff1
   REAL(KIND=dp), INTENT(OUT)               :: teff2
   REAL(KIND=dp), INTENT(OUT)               :: tgrav1
   REAL(KIND=dp), INTENT(OUT)               :: tgrav2
   REAL(KIND=dp), INTENT(OUT)               :: betarim
   REAL(KIND=dp), INTENT(OUT)               :: rinner
   REAL(KIND=dp), INTENT(OUT)               :: router
   REAL(KIND=dp), INTENT(OUT)               :: tdisk
   REAL(KIND=dp), INTENT(OUT)               :: xi
   INTEGER, INTENT(OUT)                     :: ntheta
   INTEGER, INTENT(OUT)                     :: nradius
   REAL(KIND=dp), INTENT(OUT)               :: alb1
   REAL(KIND=dp), INTENT(OUT)               :: alb2
   INTEGER, INTENT(OUT)                     :: nref
   REAL(KIND=dp), INTENT(OUT)               :: rlx
   REAL(KIND=dp), INTENT(OUT)               :: period
   REAL(KIND=dp), INTENT(OUT)               :: fm
   REAL(KIND=dp), INTENT(OUT)               :: separ
   REAL(KIND=dp), INTENT(OUT)               :: gamma
   REAL(KIND=dp), INTENT(OUT)               :: t3
   REAL(KIND=dp), INTENT(OUT)               :: g3
   REAL(KIND=dp), INTENT(OUT)               :: sa3
   REAL(KIND=dp), INTENT(OUT)               :: density
   REAL(KIND=dp), INTENT(OUT)               :: sw1
   REAL(KIND=dp), INTENT(OUT)               :: sw2
   REAL(KIND=dp), INTENT(OUT)               :: sw3
   REAL(KIND=dp), INTENT(OUT)               :: t0
   INTEGER, INTENT(OUT)                     :: idraw
   INTEGER, INTENT(OUT)                     :: iecheck
   INTEGER, INTENT(OUT)                     :: iidint
   INTEGER, INTENT(OUT)                     :: iatm
   INTEGER, INTENT(OUT)                     :: ism1
   INTEGER, INTENT(OUT)                     :: icnu
   INTEGER, INTENT(OUT)                     :: icnb
   INTEGER, INTENT(OUT)                     :: icnv
   INTEGER, INTENT(OUT)                     :: icnr
   INTEGER, INTENT(OUT)                     :: icni
   INTEGER, INTENT(OUT)                     :: icnj
   INTEGER, INTENT(OUT)                     :: icnh
   INTEGER, INTENT(OUT)                     :: icnk
   INTEGER, INTENT(OUT)                     :: irvfilt
   INTEGER, INTENT(OUT)                     :: isw1
   INTEGER, INTENT(OUT)                     :: isw2
   INTEGER, INTENT(OUT)                     :: isw3
   INTEGER, INTENT(OUT)                     :: isw4
   INTEGER, INTENT(OUT)                     :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: wave(8)
   REAL(KIND=dp), INTENT(OUT)               :: dbolx(8,2)
   REAL(KIND=dp), INTENT(OUT)               :: dboly(8,2)
   REAL(KIND=dp), INTENT(OUT)               :: dwavex(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: dwavey(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: ecc
   REAL(KIND=dp), INTENT(OUT)               :: argper
   REAL(KIND=dp), INTENT(OUT)               :: pshift
   REAL(KIND=dp), INTENT(OUT)               :: sw5
   REAL(KIND=dp), INTENT(OUT)               :: sw6
   REAL(KIND=dp), INTENT(OUT)               :: sw7
   REAL(KIND=dp), INTENT(OUT)               :: sw8
   REAL(KIND=dp), INTENT(OUT)               :: sw9
   INTEGER, INTENT(OUT)                     :: ikeep
   INTEGER, INTENT(OUT)                     :: isynch
   INTEGER, INTENT(OUT)                     :: isw5
   INTEGER, INTENT(OUT)                     :: isw6
   INTEGER, INTENT(OUT)                     :: isw7
   INTEGER, INTENT(OUT)                     :: isw8
   INTEGER, INTENT(OUT)                     :: isw9
   REAL(KIND=dp), INTENT(OUT)               :: spot1parm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: spot2parm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: spotdparm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: primmass
   REAL(KIND=dp), INTENT(OUT)               :: primk
   REAL(KIND=dp), INTENT(OUT)               :: primrad
   REAL(KIND=dp), INTENT(OUT)               :: ratrad
   REAL(KIND=dp), INTENT(OUT)               :: frac1
   REAL(KIND=dp), INTENT(OUT)               :: frac2
   REAL(KIND=dp), INTENT(OUT)               :: ecosw
   REAL(KIND=dp), INTENT(OUT)               :: temprat
   INTEGER, INTENT(OUT)                     :: idark1
   INTEGER, INTENT(OUT)                     :: idark2
   INTEGER, INTENT(OUT)                     :: isw12
   INTEGER, INTENT(OUT)                     :: isw13
   INTEGER, INTENT(OUT)                     :: isw21
   INTEGER, INTENT(OUT)                     :: isw22
   INTEGER, INTENT(OUT)                     :: isw23
   INTEGER, INTENT(OUT)                     :: isw24
   REAL(KIND=dp), INTENT(OUT)               :: bigi
   REAL(KIND=dp), INTENT(OUT)               :: bigbeta
   REAL(KIND=dp), INTENT(OUT)               :: sw23
   REAL(KIND=dp), INTENT(OUT)               :: sw24
   REAL(KIND=dp), INTENT(OUT)               :: powercoeff(8,9)
   REAL(KIND=dp), INTENT(OUT)               :: sw25
   REAL(KIND=dp), INTENT(OUT)               :: sw26
   REAL(KIND=dp), INTENT(OUT)               :: sw27
   REAL(KIND=dp), INTENT(OUT)               :: sw28
   REAL(KIND=dp), INTENT(OUT)               :: sw29
   REAL(KIND=dp), INTENT(OUT)               :: sw30
   REAL(KIND=dp), INTENT(OUT)               :: contam
   REAL(KIND=dp), INTENT(OUT)               :: tconj
   REAL(KIND=dp), INTENT(OUT)               :: beam1
   REAL(KIND=dp), INTENT(OUT)               :: beam2
   INTEGER, INTENT(OUT)                     :: isw25
   INTEGER, INTENT(OUT)                     :: isw26
   INTEGER, INTENT(OUT)                     :: isw27
   INTEGER, INTENT(OUT)                     :: isw28
   INTEGER, INTENT(OUT)                     :: isw29
   INTEGER, INTENT(OUT)                     :: isw30
   INTEGER, INTENT(OUT)                     :: isw31
   INTEGER, INTENT(OUT)                     :: isw32
   INTEGER, INTENT(OUT)                     :: isw33
   INTEGER, INTENT(OUT)                     :: isw34
   REAL(KIND=dp), INTENT(OUT)               :: ocose
   REAL(KIND=dp), INTENT(OUT)               :: osine
   REAL(KIND=dp), INTENT(OUT)               :: omegadot
   REAL(KIND=dp), INTENT(OUT)               :: contams0
   REAL(KIND=dp), INTENT(OUT)               :: contams1
   REAL(KIND=dp), INTENT(OUT)               :: contams2
   REAL(KIND=dp), INTENT(OUT)               :: contams3
   REAL(KIND=dp), INTENT(OUT)               :: sw47
   REAL(KIND=dp), INTENT(OUT)               :: sw48
   REAL(KIND=dp), INTENT(OUT)               :: sw49
   REAL(KIND=dp), INTENT(OUT)               :: sw80
   REAL(KIND=dp), INTENT(OUT)               :: sw81
   REAL(KIND=dp), INTENT(OUT)               :: sw82
   REAL(KIND=dp), INTENT(OUT)               :: sw83
   REAL(KIND=dp), INTENT(OUT)               :: sw84
   REAL(KIND=dp), INTENT(OUT)               :: sw85
   REAL(KIND=dp), INTENT(OUT)               :: sw86
   REAL(KIND=dp), INTENT(OUT)               :: sw87
   REAL(KIND=dp), INTENT(OUT)               :: sw88
   REAL(KIND=dp), INTENT(OUT)               :: sw89
   INTEGER, INTENT(OUT)                     :: isw80
   INTEGER, INTENT(OUT)                     :: isw81
   INTEGER, INTENT(OUT)                     :: isw82
   INTEGER, INTENT(OUT)                     :: isw83
   INTEGER, INTENT(OUT)                     :: isw84
   INTEGER, INTENT(OUT)                     :: isw85
   INTEGER, INTENT(OUT)                     :: isw86
   INTEGER, INTENT(OUT)                     :: isw87
   INTEGER, INTENT(OUT)                     :: isw88
   INTEGER, INTENT(OUT)                     :: isw89
!
   INTEGER :: ios,i, k
   ios=0
   OPEN(UNIT=1,FILE='ELC.insert',STATUS='old',ERR=20,IOSTAT=ios)
!
   READ(1,*,END=30,ERR=30)nalph1
   READ(1,*,END=30,ERR=30)nbet1
   READ(1,*,END=30,ERR=30)nalph2
   READ(1,*,END=30,ERR=30)nbet2
   READ(1,*,END=30,ERR=30)fill1
   READ(1,*,END=30,ERR=30)fill2
   READ(1,*,END=30,ERR=30)omega1
   READ(1,*,END=30,ERR=30)omega2
   READ(1,*,END=30,ERR=30)dphase
   READ(1,*,END=30,ERR=30)q
   READ(1,*,END=30,ERR=30)finc
   READ(1,*,END=30,ERR=30)teff1
   READ(1,*,END=30,ERR=30)teff2
   READ(1,*,END=30,ERR=30)tgrav1
   READ(1,*,END=30,ERR=30)tgrav2
   READ(1,*,END=30,ERR=30)betarim
   READ(1,*,END=30,ERR=30)rinner
   READ(1,*,END=30,ERR=30)router
   READ(1,*,END=30,ERR=30)tdisk
   READ(1,*,END=30,ERR=30)xi
   READ(1,*,END=30,ERR=30)ntheta
   READ(1,*,END=30,ERR=30)nradius
   READ(1,*,END=30,ERR=30)alb1
   READ(1,*,END=30,ERR=30)alb2
   READ(1,*,END=30,ERR=30)nref
   READ(1,*,END=30,ERR=30)rlx
   READ(1,*,END=30,ERR=30)period
   READ(1,*,END=30,ERR=30)fm
   READ(1,*,END=30,ERR=30)separ
   READ(1,*,END=30,ERR=30)gamma
   READ(1,*,END=30,ERR=30)t3
   READ(1,*,END=30,ERR=30)g3
   READ(1,*,END=30,ERR=30)sa3
   READ(1,*,END=30,ERR=30)density
   READ(1,*,END=30,ERR=30)sw1
   READ(1,*,END=30,ERR=30)sw2
   READ(1,*,END=30,ERR=30)sw3
   READ(1,*,END=30,ERR=30)t0
   READ(1,*,END=30,ERR=30)idraw
   READ(1,*,END=30,ERR=30)iecheck
   READ(1,*,END=30,ERR=30)iidint
   READ(1,*,END=30,ERR=30)iatm
   READ(1,*,END=30,ERR=30)ism1
   READ(1,*,END=30,ERR=30)icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk
   READ(1,*,END=30,ERR=30)irvfilt
   READ(1,*,END=30,ERR=30)isw1
   READ(1,*,END=30,ERR=30)isw2
   READ(1,*,END=30,ERR=30)isw3
   READ(1,*,END=30,ERR=30)isw4
   READ(1,*,END=30,ERR=30)ilaw
   DO  i=1,8
      READ(1,*,END=30,ERR=30)wave(i),dbolx(i,1),dboly(i,1),  &
         dbolx(i,2),dboly(i,2),dwavex(i,1),dwavey(i,1),dwavex(i,2), &
         dwavey(i,2)
   END DO
   READ(1,*,END=30,ERR=30)ecc
   READ(1,*,END=30,ERR=30)argper
   READ(1,*,END=30,ERR=30)pshift
   READ(1,*,END=30,ERR=30)sw5
   READ(1,*,END=30,ERR=30)sw6
   READ(1,*,END=30,ERR=30)sw7
   READ(1,*,END=30,ERR=30)sw8
   READ(1,*,END=30,ERR=30)sw9
   READ(1,*,END=30,ERR=30)ikeep
   READ(1,*,END=30,ERR=30)isynch
   READ(1,*,END=30,ERR=30)isw5
   READ(1,*,END=30,ERR=30)isw6
   READ(1,*,END=30,ERR=30)isw7
   READ(1,*,END=30,ERR=30)isw8
   READ(1,*,END=30,ERR=30)isw9
   ios=0
   READ(1,*,END=30,ERR=30)spot1parm(1,1)
   READ(1,*,END=30,ERR=30)spot1parm(1,2)
   READ(1,*,END=30,ERR=30)spot1parm(1,3)
   READ(1,*,END=30,ERR=30)spot1parm(1,4)
   READ(1,*,END=30,ERR=30)spot1parm(2,1)
   READ(1,*,END=30,ERR=30)spot1parm(2,2)
   READ(1,*,END=30,ERR=30)spot1parm(2,3)
   READ(1,*,END=30,ERR=30)spot1parm(2,4)
   READ(1,*,END=30,ERR=30)spot2parm(1,1)
   READ(1,*,END=30,ERR=30)spot2parm(1,2)
   READ(1,*,END=30,ERR=30)spot2parm(1,3)
   READ(1,*,END=30,ERR=30)spot2parm(1,4)
   READ(1,*,END=30,ERR=30)spot2parm(2,1)
   READ(1,*,END=30,ERR=30)spot2parm(2,2)
   READ(1,*,END=30,ERR=30)spot2parm(2,3)
   READ(1,*,END=30,ERR=30)spot2parm(2,4)
   READ(1,*,END=30,ERR=30)spotdparm(1,1)
   READ(1,*,END=30,ERR=30)spotdparm(1,2)
   READ(1,*,END=30,ERR=30)spotdparm(1,3)
   READ(1,*,END=30,ERR=30)spotdparm(1,4)
   READ(1,*,END=30,ERR=30)spotdparm(2,1)
   READ(1,*,END=30,ERR=30)spotdparm(2,2)
   READ(1,*,END=30,ERR=30)spotdparm(2,3)
   READ(1,*,END=30,ERR=30)spotdparm(2,4)
   READ(1,*,END=30,ERR=30)primmass
   READ(1,*,END=30,ERR=30)primk
   READ(1,*,END=30,ERR=30)primrad
   READ(1,*,END=30,ERR=30)ratrad
   READ(1,*,END=30,ERR=30)frac1
   READ(1,*,END=30,ERR=30)frac2
   READ(1,*,END=30,ERR=30)ecosw
   READ(1,*,END=30,ERR=30)temprat
   READ(1,*,END=30,ERR=30)idark1
   READ(1,*,END=30,ERR=30)idark2
   READ(1,*,END=30,ERR=30)isw12
   READ(1,*,END=30,ERR=30)isw13
   READ(1,*,END=30,ERR=30)isw21
   READ(1,*,END=30,ERR=30)isw22
   READ(1,*,END=30,ERR=30)isw23
   READ(1,*,END=30,ERR=30)isw24
   READ(1,*,END=30,ERR=30)(powercoeff(1,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(2,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(3,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(4,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(5,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(6,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(7,k),k=1,9)
   READ(1,*,END=30,ERR=30)(powercoeff(8,k),k=1,9)
   READ(1,*,END=30,ERR=30)bigi
   READ(1,*,END=30,ERR=30)bigbeta
   READ(1,*,END=30,ERR=30)sw23
   READ(1,*,END=30,ERR=30)sw24
   READ(1,*,END=30,ERR=30)sw25
   READ(1,*,END=30,ERR=30)sw26
   READ(1,*,END=30,ERR=30)sw27
   READ(1,*,END=30,ERR=30)sw28
   READ(1,*,END=30,ERR=30)sw29
   READ(1,*,END=30,ERR=30)sw30
   READ(1,*,END=30,ERR=30)contam
   READ(1,*,END=30,ERR=30)tconj
   READ(1,*,END=30,ERR=30)beam1
   READ(1,*,END=30,ERR=30)beam2
   READ(1,*,END=30,ERR=30)isw25
   READ(1,*,END=30,ERR=30)isw26
   READ(1,*,END=30,ERR=30)isw27
   READ(1,*,END=30,ERR=30)isw28
   READ(1,*,END=30,ERR=30)isw29
   READ(1,*,END=30,ERR=30)isw30
   READ(1,*,END=30,ERR=30)isw31
   READ(1,*,END=30,ERR=30)isw32
   READ(1,*,END=30,ERR=30)isw33
   READ(1,*,END=30,ERR=30)isw34
   READ(1,*,END=30,ERR=30)ocose
   READ(1,*,END=30,ERR=30)osine
   READ(1,*,END=30,ERR=30)omegadot
   READ(1,*,END=30,ERR=30)contams0
   READ(1,*,END=30,ERR=30)contams1
   READ(1,*,END=30,ERR=30)contams2
   READ(1,*,END=30,ERR=30)contams3
   READ(1,*,END=30,ERR=30)sw47
   READ(1,*,END=30,ERR=30)sw48
   READ(1,*,END=30,ERR=30)sw49
   READ(1,*,END=30,ERR=30)sw80
   READ(1,*,END=30,ERR=30)sw81
   READ(1,*,END=30,ERR=30)sw82
   READ(1,*,END=30,ERR=30)sw83
   READ(1,*,END=30,ERR=30)sw84
   READ(1,*,END=30,ERR=30)sw85
   READ(1,*,END=30,ERR=30)sw86
   READ(1,*,END=30,ERR=30)sw87
   READ(1,*,END=30,ERR=30)sw88
   READ(1,*,END=30,ERR=30)sw89
   READ(1,*,END=30,ERR=30)isw80
   READ(1,*,END=30,ERR=30)isw81
   READ(1,*,END=30,ERR=30)isw82
   READ(1,*,END=30,ERR=30)isw83
   READ(1,*,END=30,ERR=30)isw84
   READ(1,*,END=30,ERR=30)isw85
   READ(1,*,END=30,ERR=30)isw86
   READ(1,*,END=30,ERR=30)isw87
   READ(1,*,END=30,ERR=30)isw88
   READ(1,*,END=30,ERR=30)isw89
!
   IF(ios == 0)THEN
      CLOSE(1)
      kkk=99
      CALL EXECUTE_COMMAND_LINE('rm ELC.insert')
      RETURN
   END IF
!
!   Come here if the input file ELC.???? does not exist.
!
20 IF(ios > 0)THEN
      kkk=0
      RETURN
   END IF
!
!   Come here if there is an error reading the file
!
30 kkk=0
   CALL EXECUTE_COMMAND_LINE('rm ELC.insert')
!
   RETURN
!
END SUBROUTINE insgridinput
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE insidecircle(n,xcir,ycir,xp,yp,iyes,icut)
!
!   UPDATE May 8, 2006
!
!   Get rid of the call to checkbetween since that takes up lots of CPU time.
!   Use a simple if-then statement.
!
!    given a polygon with N points (they need to be in order), this
!    routine will check to see if the point (xp,yp) is inside the polygon
!
!    iyes=0 means that the point is outside
!    iyes=100 means that the point is inside
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: xcir(n)
   REAL(KIND=dp), INTENT(IN)                :: ycir(n)
   REAL(KIND=dp), INTENT(IN)                :: xp
   REAL(KIND=dp), INTENT(IN)                :: yp
   INTEGER, INTENT(OUT)                     :: iyes
   INTEGER, INTENT(OUT)                     :: icut
!
   REAL(KIND=dp)  ::  yline,slope
!
   INTEGER :: i
!
   iyes=0
   icut=0
!
   DO  i=1,n-1
      IF(((xcir(i) <= xp).AND.(xp <= xcir(i+1))).OR.((xcir(i+1)  &
         <= xp).AND.(xp <= xcir(i))))THEN
         IF(ABS(xcir(i)-xcir(i+1)) <= EPSILON(xcir(i)))THEN
            yline=ycir(i)
         ELSE
            slope=(ycir(i)-ycir(i+1))/(xcir(i)-xcir(i+1))
            yline=slope*(xp-xcir(i))+ycir(i)
         END IF
         IF((yp <= yline))icut=icut+1
      END IF
   END DO
!
   IF(((xcir(1) <= xp).AND.(xp <= xcir(n))).OR.((xcir(n) <= xp)  &
      .AND.(xp <= xcir(1))))THEN
      IF(ABS(xcir(1)-xcir(n)) <= EPSILON(xcir(1)))THEN
         yline=ycir(1)
      ELSE
         slope=(ycir(1)-ycir(n))/(xcir(1)-xcir(n))
         yline=slope*(xp-xcir(1))+ycir(1)
      END IF
      IF((yp <= yline))icut=icut+1
   END IF
!
   IF((icut == 1).OR.(icut == 3).OR.(icut == 5))THEN
!
!   inside
!
      iyes=100
!
   END IF
   IF((icut == 0).OR.(icut == 2).OR.(icut == 4))THEN
!
!   outside
!
      iyes=0
!
   END IF
!
   RETURN
!
END SUBROUTINE insidecircle
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE integrationpaths(nbody,ctm,rd,path,bdr,indexpath,  &
   indexbdr)
!
! Path is a cell array the ith cell contains the bounding paths
! for the visible portion of the ith body
! Bdr is a cell array the ith cell contains the shadow boundary of the
! first i bodies
! Each path is given by an array of 5 numbers which contains
! pathI=[#of the Ith body under consideration, # of the body whose bdr
! contains the path, initial angle, final angle - initial angle, final
! angle]
! CTM is plane of the sky positions of the centers (Front to Back)
! RD is a vector of radii in the order of Front to Back bodies
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: ctm(10,2)
   REAL(KIND=dp), INTENT(IN)                :: rd(10)
   REAL(KIND=dp), INTENT(OUT)               :: path(10,27,5)
   REAL(KIND=dp), INTENT(OUT)               :: bdr(10,27,5)
   INTEGER, INTENT(OUT)                     :: indexpath(10)
   INTEGER, INTENT(OUT)                     :: indexbdr(10)
!
   REAL(KIND=dp), DIMENSION(27,5)  :: bd,pathi,pathn,pathb,pathm,path0
   REAL(KIND=dp), DIMENSION(27,5)  :: pathmn,bdnew,pathbi,paths,list,list1,path2i
   REAL(KIND=dp), DIMENSION(5)     :: arcn,arci
   REAL(KIND=dp), DIMENSION(2)     :: ct1,ct2,arc
!
   INTEGER :: i,n,j,k
   INTEGER :: indexpathn,indexlist,indexlist1,indexpathbi,indexbd
   INTEGER :: indexpathb,indexpathmn,indexpathm,indexpaths
   INTEGER :: indexpathi,indexbdnew,indexpath2i,indexpath0
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   DO i=1,10
      indexpath(i)=0
      indexbdr(i)=0
   END DO
   indexpathn=0
   indexlist=0
   indexlist1=0
   indexpathbi=0
   indexbd=0
   indexpathb=0
   indexpathmn=0
   indexpathm=0
   indexpaths=0
   indexpathi=0
   indexbdnew=0
   indexpath2i=0
   indexpath0=0
!
!   Fill arc and path arrays with -999.0
!
   DO i=1,27
      DO j=1,5
         path(1,i,j)=-999.0_dp
         path(2,i,j)=-999.0_dp
         path(3,i,j)=-999.0_dp
         path(4,i,j)=-999.0_dp
         path(5,i,j)=-999.0_dp
         path(6,i,j)=-999.0_dp
         path(7,i,j)=-999.0_dp
         path(8,i,j)=-999.0_dp
         path(9,i,j)=-999.0_dp
         path(10,i,j)=-999.0_dp
         bdr(1,i,j)=-999.0_dp
         bdr(2,i,j)=-999.0_dp
         bdr(3,i,j)=-999.0_dp
         bdr(4,i,j)=-999.0_dp
         bdr(5,i,j)=-999.0_dp
         bdr(6,i,j)=-999.0_dp
         bdr(7,i,j)=-999.0_dp
         bdr(8,i,j)=-999.0_dp
         bdr(9,i,j)=-999.0_dp
         bdr(10,i,j)=-999.0_dp
         bd(i,j)=-999.0_dp
         bdnew(i,j)=-999.0_dp
         pathn(i,j)=-999.0_dp
         pathi(i,j)=-999.0_dp
         paths(i,j)=-999.0_dp
         pathb(i,j)=-999.0_dp
         pathbi(i,j)=-999.0_dp
         pathm(i,j)=-999.0_dp
         pathmn(i,j)=-999.0_dp
         path0(i,j)=-999.0_dp
      END DO
   END DO
!
   DO i=1,10
      indexpath(i)=0
      indexbdr(i)=0
   END DO
   indexpathn=0
!
!   Initialize Paths and Bdr array with the front body
!
   path(1,1,1)=1.0_dp
   path(1,1,2)=1.0_dp
   path(1,1,3)=0.0_dp
   path(1,1,4)=twopie
   path(1,1,5)=twopie
   indexpath(1)=1
!
   DO i=1,5
      bd(1,i)=path(1,1,i)
      bdr(1,1,i)=path(1,1,i)
   END DO
   indexbdr(1)=1
   indexbd=1
!
!   Generate path for the second body.
!   The variable Path will contain the integration
!   arcs.
!
   n=2
   pathn(1,1)=REAL(n,KIND=dp)
   pathn(1,2)=REAL(n,KIND=dp)
   pathn(1,3)=0.0_dp
   pathn(1,4)=twopie
   pathn(1,5)=twopie
   indexpathn=1
!
   ct1(1)=ctm(1,1)
   ct1(2)=ctm(1,2)
   ct2(1)=ctm(n,1)
   ct2(2)=ctm(n,2)
   CALL xcircle(1,ct1,rd(1),n,ct2,rd(n),arcn,arci)
!
   IF(ABS(arcn(3)+999.0_dp) <= 10.0_dp*EPSILON(arcn(3)))THEN
!
!  disjoint
!
      path(2,1,1)=pathn(1,1)
      path(2,1,2)=pathn(1,2)
      path(2,1,3)=pathn(1,3)
      path(2,1,4)=pathn(1,4)
      path(2,1,5)=pathn(1,5)
      indexpath(2)=indexpath(2)+1
!
      DO i=1,5
         bd(indexbd+1,i)=pathn(indexpathn,i)
      END DO
      indexbd=indexbd+1
   ELSE IF(ABS(arcn(3)+998.0_dp) <= 10.0_dp*EPSILON(arcn(3)))THEN
!
! inside border
!
      path(2,1,1)=-999.0_dp
      path(2,1,2)=-999.0_dp
      path(2,1,3)=-999.0_dp
      path(2,1,4)=-999.0_dp
      path(2,1,5)=-999.0_dp
      bd(1,1)=1.0_dp
      bd(1,2)=1.0_dp
      bd(1,3)=0.0_dp
      bd(1,4)=twopie
      bd(1,5)=twopie
      bd(2,1)=2.0_dp
      bd(2,2)=2.0_dp
      bd(2,3)=0.0_dp
      bd(2,4)=0.0_dp
      bd(2,5)=0.0_dp
      indexbd=2
      indexbdr(2)=0
!
   ELSE IF(ABS(arcn(3)+997.0_dp) <= 10.0_dp*EPSILON(arcn(3)))THEN
!
! contains Bdr(i,1)
!
      path(2,1,1)=REAL(n,KIND=dp)
      path(2,1,2)=1.0_dp
      path(2,1,3)=0.0_dp
      path(2,1,4)=twopie
      path(2,1,5)=twopie
      path(2,2,1)=pathn(1,1)
      path(2,2,2)=pathn(1,2)
      path(2,2,3)=pathn(1,3)
      path(2,2,4)=pathn(1,4)
      path(2,2,5)=pathn(1,5)
      indexpath(2)=2
      bd(1,1)=REAL(n,KIND=dp)
      bd(1,2)=2.0_dp
      bd(1,3)=0.0_dp
      bd(1,4)=twopie
      bd(1,5)=twopie
      indexbd=1
   ELSE
      path(2,1,1)=arci(1)
      path(2,1,2)=arci(2)
      path(2,1,3)=arci(3)
      path(2,1,4)=arci(4)
      path(2,1,5)=arci(5)
      path(2,2,1)=arcn(1)
      path(2,2,2)=arcn(2)
      path(2,2,3)=arcn(3)
      path(2,2,4)=arcn(4)
      path(2,2,5)=arcn(5)
      indexpath(2)=2
      CALL xcomp(arci(3),arci(5),arc)
      bd(1,1)=1.0_dp
      bd(1,2)=1.0_dp
      bd(1,3)=arc(1)
      bd(1,4)=arc(2)-arc(1)
      bd(1,5)=arc(2)
      bd(2,1)=arcn(1)
      bd(2,2)=arcn(2)
      bd(2,3)=arcn(3)
      bd(2,4)=arcn(4)
      bd(2,5)=arcn(5)
      indexbd=2
   END IF
!
!   Now do the general case, which is
!   computed by iteration on the bodies form
!   Front to Back
!
!   Bd contains the visible hull at the current
!   step
!
   DO i=1,indexbd    !27
      DO j=1,5
         pathb(i,j)=bd(i,j)
         bdr(2,i,j)=bd(i,j)
      END DO
   END DO
   indexpathb=indexbd
   indexbdr(2)=indexbd
!
!   start the iteration with body 3
!
   DO WHILE(n < nbody)
      n=n+1
      DO i=1,27
         path(n,i,1)=-999.0_dp
         path(n,i,2)=-999.0_dp
         path(n,i,3)=-999.0_dp
         path(n,i,4)=-999.0_dp
         path(n,i,5)=-999.0_dp
         pathm(i,1)=-999.0_dp
         pathm(i,2)=-999.0_dp
         pathm(i,3)=-999.0_dp
         pathm(i,4)=-999.0_dp
         pathm(i,5)=-999.0_dp
         pathn(i,1)=-999.0_dp
         pathn(i,2)=-999.0_dp
         pathn(i,3)=-999.0_dp
         pathn(i,4)=-999.0_dp
         pathn(i,5)=-999.0_dp
      END DO
      pathn(1,1)=REAL(n,KIND=dp)
      pathn(1,2)=REAL(n,KIND=dp)
      pathn(1,3)=0.0_dp
      pathn(1,4)=twopie
      pathn(1,5)=twopie
      indexpathn=1
!
!   compute the intersection arcs
!
      DO  i=1,n-1
         ct1(1)=ctm(i,1)
         ct1(2)=ctm(i,2)
         ct2(1)=ctm(n,1)
         ct2(2)=ctm(n,2)
         CALL xcircle(i,ct1,rd(i),n,ct2,rd(n),arcn,arci)
         IF(ABS(arcn(3)+999.0_dp) <= 10.0_dp*EPSILON(arcn(3)))THEN
!
! disjoint
!
            DO j=1,indexpathn
               path(n,indexpath(n)+1,1)=pathn(j,1)
               path(n,indexpath(n)+1,2)=pathn(j,2)
               path(n,indexpath(n)+1,3)=pathn(j,3)
               path(n,indexpath(n)+1,4)=pathn(j,4)
               path(n,indexpath(n)+1,5)=pathn(j,5)
            END DO
            indexpath(n)=indexpath(n)+indexpathn
!
            IF(n < nbody)THEN
               pathb(indexpathb+1,1)=REAL(n,KIND=dp)
               pathb(indexpathb+1,2)=REAL(n,KIND=dp)
               pathb(indexpathb+1,3)=0.0_dp
               pathb(indexpathb+1,4)=twopie
               pathb(indexpathb+1,5)=twopie
               indexpathb=indexpathb+1
            END IF
!
         ELSE IF(ABS(arcn(3)+998.0_dp) <= EPSILON(arcn(3)))THEN
!
! inside border
!
            path(n,1,1)=REAL(n,KIND=dp)
            path(n,1,2)=REAL(n,KIND=dp)
            path(n,1,3)=0.0_dp
            path(n,1,4)=0.0_dp
            path(n,1,5)=0.0_dp
            indexpath(n)=1
!
            IF(n < nbody)THEN
               pathb(indexpathb+1,1)=REAL(n,KIND=dp)
               pathb(indexpathb+1,2)=REAL(n,KIND=dp)
               pathb(indexpathb+1,3)=0.0_dp
               pathb(indexpathb+1,4)=0.0_dp
               pathb(indexpathb+1,5)=0.0_dp
               indexpathb=indexpathb+1
            END IF
            CYCLE
!
         ELSE IF(ABS(arcn(3)+997.0_dp) <= EPSILON(arcn(3)))THEN
!
! contains border (i,1)
!
            pathmn(1,1)=REAL(i,KIND=dp)
            pathmn(1,2)=REAL(i,KIND=dp)
            pathmn(1,3)=0.0_dp
            pathmn(1,4)=twopie
            pathmn(1,5)=twopie
            indexpathmn=1
!
            DO j=1,indexpathmn
               pathm(indexpathm+1,1)=pathmn(j,1)
               pathm(indexpathm+1,2)=pathmn(j,2)
               pathm(indexpathm+1,3)=pathmn(j,3)
               pathm(indexpathm+1,4)=pathmn(j,4)
               pathm(indexpathm+1,5)=pathmn(j,5)
            END DO
            indexpathm=indexpathm+1
!
            IF(n < nbody)THEN
               pathb(indexpathb+1,1)=REAL(i,KIND=dp)
               pathb(indexpathb+1,2)=REAL(i,KIND=dp)
               pathb(indexpathb+1,3)=0.0_dp
               pathb(indexpathb+1,4)=0.0_dp
               pathb(indexpathb+1,5)=0.0_dp
               pathb(indexpathb+2,1)=REAL(n,KIND=dp)
               pathb(indexpathb+2,2)=REAL(n,KIND=dp)
               pathb(indexpathb+2,3)=0.0_dp
               pathb(indexpathb+2,4)=twopie
               pathb(indexpathb+2,5)=twopie
               indexpathb=indexpathb+2
            END IF
!
         ELSE
            path(n,indexpath(n)+1,1)=arci(1)
            path(n,indexpath(n)+1,2)=arci(2)
            path(n,indexpath(n)+1,3)=arci(3)
            path(n,indexpath(n)+1,4)=arci(4)
            path(n,indexpath(n)+1,5)=arci(5)
            path(n,indexpath(n)+2,1)=arcn(1)
            path(n,indexpath(n)+2,2)=arcn(2)
            path(n,indexpath(n)+2,3)=arcn(3)
            path(n,indexpath(n)+2,4)=arcn(4)
            path(n,indexpath(n)+2,5)=arcn(5)
            indexpath(n)=indexpath(n)+2

            IF(n < nbody)THEN
               CALL xcomp(arci(3),arci(5),arc)
               pathb(indexpathb+1,1)=REAL(i,KIND=dp)
               pathb(indexpathb+1,2)=REAL(i,KIND=dp)
               pathb(indexpathb+1,3)=arc(1)
               pathb(indexpathb+1,4)=arc(2)-arc(1)
               pathb(indexpathb+1,5)=arc(2)
               pathb(indexpathb+2,1)=arcn(1)
               pathb(indexpathb+2,2)=arcn(2)
               pathb(indexpathb+2,3)=arcn(3)
               pathb(indexpathb+2,4)=arcn(4)
               pathb(indexpathb+2,5)=arcn(5)
               indexpathb=indexpathb+2
            END IF
!
         END IF
!
!  end do i=1,N-1
!
      END DO
!
      IF(indexpathm > 0)THEN
         DO j=1,indexpathm
            paths(j,1)=pathm(j,1)
            paths(j,2)=pathm(j,2)
            paths(j,3)=pathm(j,3)
            paths(j,4)=pathm(j,4)
            paths(j,5)=pathm(j,5)
         END DO
      END IF
      indexpaths=indexpathm
!
      DO j=1,indexpath(n)
         paths(j+indexpaths,1)=path(n,j,1)
         paths(j+indexpaths,2)=path(n,j,2)
         paths(j+indexpaths,3)=path(n,j,3)
         paths(j+indexpaths,4)=path(n,j,4)
         paths(j+indexpaths,5)=path(n,j,5)
      END DO
      indexpaths=indexpaths+indexpath(n)
!
      DO i=1,27
         DO j=1,5
            pathn(i,j)=-999.0_dp
         END DO
      END DO
      indexpathn=0
!
      DO i=1,27
         DO j=1,5
            pathi(i,j)=-999.0_dp
         END DO
      END DO
      indexpathi=0
!
      DO i=1,27
         DO j=1,5
            bdnew(i,j)=-999.0_dp
         END DO
      END DO
      indexbdnew=0

      DO  i=1,n-1
!
         DO j=1,indexpath2i
            path2i(j,1)=-999.0_dp
            path2i(j,2)=-999.0_dp
            path2i(j,3)=-999.0_dp
            path2i(j,4)=-999.0_dp
            path2i(j,5)=-999.0_dp
         END DO
         DO j=1,indexlist
            list(j,1)=-999.0_dp
            list(j,2)=-999.0_dp
            list(j,3)=-999.0_dp
            list(j,4)=-999.0_dp
            list(j,5)=-999.0_dp
         END DO
         DO j=1,indexlist1
            list1(j,1)=-999.0_dp
            list1(j,2)=-999.0_dp
            list1(j,3)=-999.0_dp
            list1(j,4)=-999.0_dp
            list1(j,5)=-999.0_dp
         END DO
         k=0
         indexpath2i=0
         DO j=1,indexpaths
            IF(nint(paths(j,2)) == i)THEN
               k=k+1
               path2i(k,1)=paths(j,1)
               path2i(k,2)=paths(j,2)
               path2i(k,3)=paths(j,3)
               path2i(k,4)=paths(j,4)
               path2i(k,5)=paths(j,5)
               indexpath2i=k
            END IF
         END DO

         IF(k == 0)CYCLE
         k=0
         indexlist=0
         DO j=1,indexbd
            IF(nint(bd(j,2)) == i)THEN
               k=k+1
               list(k,1)=bd(j,1)
               list(k,2)=bd(j,2)
               list(k,3)=bd(j,3)
               list(k,4)=bd(j,4)
               list(k,5)=bd(j,5)
               indexlist=k
            END IF
         END DO
!
         IF(k == 0)CYCLE
         CALL xsectall(list,path2i,n,pathi,indexlist,indexpath2i,indexpathi)
!
         IF(indexpathi > 0)THEN
            DO j=1,indexpathi
               pathn(j+indexpathn,1)=pathi(j,1)
               pathn(j+indexpathn,2)=pathi(j,2)
               pathn(j+indexpathn,3)=pathi(j,3)
               pathn(j+indexpathn,4)=pathi(j,4)
               pathn(j+indexpathn,5)=pathi(j,5)
            END DO
            indexpathn=indexpathn+indexpathi
         END IF
      END DO
!
      DO i=1,indexpathi
         DO j=1,5
            pathi(i,j)=-999.0_dp
         END DO
      END DO
      indexpathi=0
!
      IF(n < nbody)THEN
         DO  i=1,n
            DO j=1,indexpath0
               path0(j,1)=-999.0_dp
               path0(j,2)=-999.0_dp
               path0(j,3)=-999.0_dp
               path0(j,4)=-999.0_dp
               path0(j,5)=-999.0_dp
            END DO
            indexpath0=0
            DO j=1,indexpathbi
               pathbi(j,1)=-999.0_dp
               pathbi(j,2)=-999.0_dp
               pathbi(j,3)=-999.0_dp
               pathbi(j,4)=-999.0_dp
               pathbi(j,5)=-999.0_dp
            END DO
            indexpathbi=0
            k=0
            DO j=1,indexpathb
               IF(nint(pathb(j,2)) == i)THEN
                  k=k+1
                  pathbi(k,1)=pathb(j,1)
                  pathbi(k,2)=pathb(j,2)
                  pathbi(k,3)=pathb(j,3)
                  pathbi(k,4)=pathb(j,4)
                  pathbi(k,5)=pathb(j,5)
               END IF
               indexpathbi=k
            END DO
            IF(k == 0)CYCLE
!
            path0(1,1)=REAL(i,KIND=dp)
            path0(1,2)=REAL(i,KIND=dp)
            path0(1,3)=0.0_dp
            path0(1,4)=twopie
            path0(1,5)=twopie
            indexpath0=1
            CALL xsectall(path0,pathbi,i,pathi,indexpath0,indexpathbi,indexpathi)
!
            IF(indexpathi > 0)THEN
               DO j=1,indexpathi
                  bdnew(j+indexbdnew,1)=pathi(j,1)
                  bdnew(j+indexbdnew,2)=pathi(j,2)
                  bdnew(j+indexbdnew,3)=pathi(j,3)
                  bdnew(j+indexbdnew,4)=pathi(j,4)
                  bdnew(j+indexbdnew,5)=pathi(j,5)
               END DO
               indexbdnew=indexbdnew+indexpathi
            END IF
         END DO
!
         DO i=1,indexbdnew
            DO j=1,5
               bd(i,j)=bdnew(i,j)
            END DO
         END DO
         indexbd=indexbdnew
!
         DO i=1,indexbd
            DO j=1,5
               bdr(n,i,j)=bd(i,j)
            END DO
         END DO
         indexbdr(n)=indexbd
!
      ELSE
         indexbdr(n)=0
      END IF
      k=0
      DO i=1,indexpaths
         IF(nint(paths(i,2)) == n)THEN
            k=k+1
            list(k,1)=paths(i,1)
            list(k,2)=paths(i,2)
            list(k,3)=paths(i,3)
            list(k,4)=paths(i,4)
            list(k,5)=paths(i,5)
         END IF
         indexlist=k
      END DO
!
      IF(k == 0)THEN
         pathn(indexpathn+1,1)=REAL(n,KIND=dp)
         pathn(indexpathn+1,2)=REAL(n,KIND=dp)
         pathn(indexpathn+1,3)=0.0_dp
         pathn(indexpathn+1,4)=twopie
         pathn(indexpathn+1,5)=twopie
         indexpathn=indexpathn+1
      END IF
      IF(k == 1)THEN
!
         DO j=1,indexlist
            pathn(j+indexpathn,1)=list(j,1)
            pathn(j+indexpathn,2)=list(j,2)
            pathn(j+indexpathn,3)=list(j,3)
            pathn(j+indexpathn,4)=list(j,4)
            pathn(j+indexpathn,5)=list(j,5)
         END DO
         indexpathn=indexpathn+indexlist
      END IF
      IF(k >= 2)THEN
         DO j=2,indexlist
            list1(j-1,1)=list(j,1)
            list1(j-1,2)=list(j,2)
            list1(j-1,3)=list(j,3)
            list1(j-1,4)=list(j,4)
            list1(j-1,5)=list(j,5)
            list(j,1)=-999.0_dp
            list(j,2)=-999.0_dp
            list(j,3)=-999.0_dp
            list(j,4)=-999.0_dp
            list(j,5)=-999.0_dp
         END DO
         indexlist1=indexlist-1
         indexlist=1
!
         CALL xsectall(list,list1,n,pathi,indexlist,indexlist1,indexpathi)
!
         IF(indexpathi > 0)THEN
            DO j=1,indexpathi
               pathn(j+indexpathn,1)=pathi(j,1)
               pathn(j+indexpathn,2)=pathi(j,2)
               pathn(j+indexpathn,3)=pathi(j,3)
               pathn(j+indexpathn,4)=pathi(j,4)
               pathn(j+indexpathn,5)=pathi(j,5)
            END DO
            indexpathn=indexpathn+indexpathi
         END IF
      END IF
!
      DO i=1,indexpathn
         path(n,i,1)=pathn(i,1)
         path(n,i,2)=pathn(i,2)
         path(n,i,3)=pathn(i,3)
         path(n,i,4)=pathn(i,4)
         path(n,i,5)=pathn(i,5)
      END DO
      indexpath(n)=indexpathn
!
!  End the while clause
!
   END DO
!
   RETURN
!
END SUBROUTINE integrationpaths
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION intg2pt(pathi,tol,rmdn,cmnx,cmny,ilaw)
!
!   Uses the Gaussian 2 point rule to evaluate the integral
!   for the appropriate limb darkening law:
!
!   ilaw = 1 linear
!   ilaw = 2 log
!   ilaw = 3 sqrt
!   ilaw = 4 quad
!   ilaw = 5 Kipping quad law
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
   INTEGER, INTENT(IN)                      :: ilaw
!
   REAL(KIND=dp)  :: intg2pt, a,b,s,h,c1,c2,x,y
   REAL(KIND=dp)  :: linearintgrd,logintgrd,sqrtintgrd,quadintgrd
!
   INTEGER :: k,m
!
   a=pathi(3)
   b=pathi(5)
   m=INT(REAL(INT(pathi(4)/0.2_dp)+1,KIND=dp)*tol)
   s=0.0_dp
   h=(b-a)/REAL(m,KIND=dp)
   c1=(1.0_dp-1.0_dp/SQRT(3.0_dp))/2.0_dp
   c2=(1.0_dp+1.0_dp/SQRT(3.0_dp))/2.0_dp
   x=a+h*c1
   y=a+h*c2
   DO k=1,m
      IF(ilaw == 1)THEN
         s=s+linearintgrd(x,rmdn,cmnx,cmny)+linearintgrd(y,rmdn,cmnx,cmny)
      END IF
      IF(ilaw == 2)THEN
         s=s+logintgrd(x,rmdn,cmnx,cmny)+logintgrd(y,rmdn,cmnx,cmny)
      END IF
      IF(ilaw == 3)THEN
         s=s+sqrtintgrd(x,rmdn,cmnx,cmny)+sqrtintgrd(y,rmdn,cmnx,cmny)
      END IF
      IF(ilaw == 4)THEN
         s=s+quadintgrd(x,rmdn,cmnx,cmny)+quadintgrd(y,rmdn,cmnx,cmny)
      END IF
      IF(ilaw == 5)THEN
         s=s+quadintgrd(x,rmdn,cmnx,cmny)+quadintgrd(y,rmdn,cmnx,cmny)
      END IF
      x=x+h
      y=y+h
   END DO
   s=h*s/2
!
   intg2pt=s
!
   RETURN
!
END FUNCTION intg2pt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION intg4pt(pathi,tol,rmdn,cmnx,cmny,ilaw)
!
!   Uses the Gaussian 4 point rule to evaluate the integral
!   for the appropriate limb darkening law:
!
!   ilaw = 1 linear
!   ilaw = 2 log
!   ilaw = 3 sqrt
!   ilaw = 4 quad
!   ilaw = 5 Kipping quad law
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
   INTEGER, INTENT(IN)                      :: ilaw
!
   REAL(KIND=dp)  :: intg4pt,a,b,s,h,x,y,delta,dist,w1,w2
   REAL(KIND=dp)  :: linearintgrd,logintgrd,sqrtintgrd,quadintgrd,z,t
!
   INTEGER :: k,m
!
   w1=3.47854845137453857373063949221999E-01_dp
   w2=6.52145154862546142626936050778001E-01_dp
!
   a=pathi(3)
   b=pathi(5)
   m=nint((2.0_dp*rmdn*pathi(4)+1.0_dp))
   m=nint(REAL(m,KIND=dp)*tol)
   IF(MOD(m,2) == 0)m=m+1
   IF(rmdn < 1.0_dp)THEN
      delta=SQRT(cmnx**2+cmny**2)
      IF(delta < 1.0_dp-rmdn)THEN
         m=nint((2.0_dp*rmdn*pathi(4)+1.0_dp)*tol/3.0_dp)
         IF(m < 8)m=6
         dist=((delta-1.0_dp)**2+(rmdn-1.0_dp)**2)
         IF(dist < 1.24_dp)m=m+2
         IF(dist < 1.05_dp)m=m+2
         IF(dist < 0.95_dp)m=m+2
         IF(dist < 0.85_dp)m=m+2
         IF(dist < 0.80_dp)m=m+2
         IF(dist < 0.75_dp)m=m+2
         IF(rmdn+delta >= 0.990_dp)m=m+2
         IF(rmdn+delta >= 0.995_dp)m=m+2
         IF(rmdn+delta >= 0.997_dp)m=m+2
         IF(rmdn+delta >= 0.998_dp)m=m+2
         IF(tol >= 4.0_dp)m=nint(tol/2.0_dp)*m
      END IF
   END IF
   s=0.0_dp
   h=(b-a)/REAL(m,KIND=dp)
   x = a + h*(1.0_dp-8.61136311594052575223946488892809E-01_dp)/2.0_dp
   y = a + h*(1.0_dp-3.39981043584856264802665759103245E-01_dp)/2.0_dp
   z = a + h*(1.0_dp+3.39981043584856264802665759103245E-01_dp)/2.0_dp
   t = a + h*(1.0_dp+8.61136311594052575223946488892809E-01_dp)/2.0_dp

   DO k=1,m
      IF(ilaw == 1)THEN
         s = s + w1*(linearintgrd(x,rmdn,cmnx,cmny)  &
            +linearintgrd(t,rmdn,cmnx,cmny)) + w2*  &
            (linearintgrd(y,rmdn,cmnx,cmny) + linearintgrd(z,rmdn,cmnx,cmny))
      END IF
      IF(ilaw == 2)THEN
         s = s + w1*(logintgrd(x,rmdn,cmnx,cmny)  &
            +logintgrd(t,rmdn,cmnx,cmny)) + w2*  &
            (logintgrd(y,rmdn,cmnx,cmny) + logintgrd(z,rmdn,cmnx,cmny))
      END IF
      IF(ilaw == 3)THEN
         s = s + w1*(sqrtintgrd(x,rmdn,cmnx,cmny)  &
            +sqrtintgrd(t,rmdn,cmnx,cmny)) + w2*  &
            (sqrtintgrd(y,rmdn,cmnx,cmny) + sqrtintgrd(z,rmdn,cmnx,cmny))
      END IF
      IF(ilaw == 4)THEN
         s = s + w1*(quadintgrd(x,rmdn,cmnx,cmny)  &
            +quadintgrd(t,rmdn,cmnx,cmny)) + w2*  &
            (quadintgrd(y,rmdn,cmnx,cmny) + quadintgrd(z,rmdn,cmnx,cmny))
      END IF
      IF(ilaw == 5)THEN
         s = s + w1*(quadintgrd(x,rmdn,cmnx,cmny)  &
            +quadintgrd(t,rmdn,cmnx,cmny)) + w2*  &
            (quadintgrd(y,rmdn,cmnx,cmny) + quadintgrd(z,rmdn,cmnx,cmny))
      END IF
      x=x+h
      y=y+h
      z=z+h
      t=t+h
   END DO
   s=h*s/2.0_dp
!
   intg4pt=s
!
   RETURN
!
END FUNCTION intg4pt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION intgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
!
!   Uses Gaussian quadrature to evaluate the integral
!   for the appropriate limb darkening law:
!
!   ilaw = 1 linear
!   ilaw = 2 log
!   ilaw = 3 sqrt
!   ilaw = 4 quad
!   ilaw = 5 Kipping quad law
!
   USE accur

   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
   INTEGER, INTENT(IN)                      :: ilaw
!
   REAL(KIND=dp), DIMENSION(64)   ::  xx,ww,xxa
   REAL(KIND=dp)  :: intgnpt,a,b,s,h,delta
   REAL(KIND=dp)  :: linearintgrd,logintgrd,sqrtintgrd,quadintgrd
!
   INTEGER :: k,m,norder,muse,nopt,kk,MAX
!
   a=pathi(3)
   b=pathi(5)
!
   m=nint((3.7_dp*rmdn*pathi(4)+1.0_dp))
   m=nint(REAL(m,KIND=dp)*tol)
   IF(rmdn <= 1.0_dp)THEN
      delta=SQRT(cmnx**2+cmny**2)
      IF(delta <= 1.0_dp-rmdn)THEN
         m=8
         IF((rmdn < 0.25_dp).AND.(delta > -0.75_dp/0.25_dp*rmdn +1.0_dp))m=m+1
         IF((rmdn >= 0.25_dp).AND.(delta > -0.25_dp/0.75_dp*  &
            (rmdn-0.25_dp)+0.25_dp))m=m+1
         IF((rmdn < 0.35_dp).AND.(delta > -0.65_dp/0.35_dp*rmdn +1.0_dp))m=m+1
         IF((rmdn >= 0.35_dp).AND.(delta > -0.35_dp/0.65_dp*  &
            (rmdn-0.35_dp)+0.35_dp))m=m+1
         IF((rmdn < 0.40_dp).AND.(delta > -0.60_dp/0.40_dp*rmdn +1.0_dp))m=m+1
         IF((rmdn >= 0.40_dp).AND.(delta > -0.40_dp/0.60_dp*  &
            (rmdn-0.40_dp)+0.40_dp))m=m+1
!
         IF(rmdn+delta >= 0.997_dp)m=m+1
         IF(tol > 1.0_dp)m=nint(tol*REAL(m,KIND=dp))
      END IF
   END IF
!
   IF(m < 1)m=1
   norder=4
   muse=m
   nopt=m
   MAX=64
   IF(nopt <= MAX)THEN
      norder=nopt
      muse=1
   END IF
   DO k=1,100
      IF((nopt >= MAX*k+1).AND.(nopt <= (k+1)*MAX))THEN
         norder=nopt/(k+1)
         muse=k+1
      END IF
   END DO
!
   IF(norder <= 7)norder=8
!
   CALL gausscoeff(norder,xx,ww)
!
   s=0.0_dp
   muse=muse*2
!
   h=(b-a)/REAL(muse,KIND=dp)
   DO kk=1,norder
      xxa(kk)=a+h*(1.0_dp+xx(kk))/2.0_dp
   END DO
!
   DO k=1,muse
      IF(ilaw == 1)THEN
         DO kk=1,norder
            s=s+ww(kk)*(linearintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      IF(ilaw == 2)THEN
         DO kk=1,norder
            s=s+ww(kk)*(logintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      IF(ilaw == 3)THEN
         DO kk=1,norder
            s=s+ww(kk)*(sqrtintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      IF(ilaw == 4)THEN
         DO kk=1,norder
            s=s+ww(kk)*(quadintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      IF(ilaw == 5)THEN
         DO kk=1,norder
            s=s+ww(kk)*(quadintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      DO kk=1,norder
         xxa(kk)=xxa(kk)+h
      END DO
   END DO
!
!  In the normal routine, we divide by two.  Owing to the symmetry
!  we need to multiply the sum by 2.
!
   s=h*s*0.5_dp
!
   intgnpt=s
!
   RETURN
!
END FUNCTION intgnpt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE ispacestring(instring,ichi,outstring,ilength)
!
!  Will combine an input string and an input integer in a compact
!  way for printing on the screen.
!
   USE accur
!
   IMPLICIT NONE
!
   CHARACTER (LEN=*), INTENT(IN)            :: instring
   INTEGER, INTENT(IN)                      :: ichi
   CHARACTER (LEN=*), INTENT(OUT)           :: outstring
   INTEGER, INTENT(OUT)                     :: ilength
!
   INTEGER :: itemp
!
   ilength=0
   outstring=' '
!
!   1 digit positive
!
   IF((ichi >= 0).AND.(ichi < 10))THEN
      WRITE(outstring,10)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   2 digits positive
!
   IF((ichi >= 10).AND.(ichi < 100))THEN
      WRITE(outstring,20)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   3 digits positive
!
   IF((ichi >= 100).AND.(ichi < 1000))THEN
      WRITE(outstring,30)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   4 digits positive
!
   IF((ichi >= 1000).AND.(ichi < 10000))THEN
      WRITE(outstring,40)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   5 digits positive
!
   IF((ichi >= 10000).AND.(ichi < 100000))THEN
      WRITE(outstring,50)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   6 digits positive
!
   IF((ichi >= 100000).AND.(ichi < 1000000))THEN
      WRITE(outstring,60)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   7 digits positive
!
   IF((ichi >= 1000000).AND.(ichi < 10000000))THEN
      WRITE(outstring,70)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   8 digits positive
!
   IF((ichi >= 10000000).AND.(ichi < 100000000))THEN
      WRITE(outstring,80)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   9 digits positive
!
   IF((ichi >= 1000000000))THEN
      itemp=999999999
      WRITE(outstring,90)instring,itemp
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   1 digit negative
!
   IF((ichi > -10).AND.(ichi <= 0))THEN
      WRITE(outstring,100)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   2 digits negative
!
   IF((ichi > -100).AND.(ichi <= -10))THEN
      WRITE(outstring,110)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   3 digits negative
!
   IF((ichi > -1000).AND.(ichi <= -100))THEN
      WRITE(outstring,120)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   4 digits negative
!
   IF((ichi > -10000).AND.(ichi <= -1000))THEN
      WRITE(outstring,130)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   5 digits negative
!
   IF((ichi > -100000).AND.(ichi <= -10000))THEN
      WRITE(outstring,140)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   6 digits negative
!
   IF((ichi > -1000000).AND.(ichi <= -100000))THEN
      WRITE(outstring,150)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   7 digits negative
!
   IF((ichi > -10000000).AND.(ichi <= -1000000))THEN
      WRITE(outstring,160)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   8 digits negative
!
   IF((ichi > -100000000).AND.(ichi <= -10000000))THEN
      WRITE(outstring,170)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   9 digits negative
!
   IF((ichi <= -100000000))THEN
      itemp=-999999999
      WRITE(outstring,180)instring,itemp
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
10 FORMAT(a,' = ',i1)
20 FORMAT(a,' = ',i2)
30 FORMAT(a,' = ',i3)
40 FORMAT(a,' = ',i4)
50 FORMAT(a,' = ',i5)
60 FORMAT(a,' = ',i6)
70 FORMAT(a,' = ',i7)
80 FORMAT(a,' = ',i8)
90 FORMAT(a,' = ',i9)
100 FORMAT(a,' = ',i2)
110 FORMAT(a,' = ',i3)
120 FORMAT(a,' = ',i4)
130 FORMAT(a,' = ',i5)
140 FORMAT(a,' = ',i6)
150 FORMAT(a,' = ',i7)
160 FORMAT(a,' = ',i8)
170 FORMAT(a,' = ',i9)
180 FORMAT(a,' = ',i10)
!
   RETURN
!
END SUBROUTINE ispacestring
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE istringnoequals(instring,ichi,outstring,ilength)
!
!  Will combine an input string and an input integer in a compact
!  way for printing on the screen.
!
   USE accur
!
   IMPLICIT NONE
!
   CHARACTER (LEN=*), INTENT(IN)            :: instring
   INTEGER, INTENT(IN)                      :: ichi
   CHARACTER (LEN=*), INTENT(OUT)           :: outstring
   INTEGER, INTENT(OUT)                     :: ilength
!
   INTEGER :: itemp
!
   ilength=0
   outstring=' '
!
!   1 digit positive
!
   IF((ichi >= 0).AND.(ichi < 10))THEN
      WRITE(outstring,10)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   2 digits positive
!
   IF((ichi >= 10).AND.(ichi < 100))THEN
      WRITE(outstring,20)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   3 digits positive
!
   IF((ichi >= 100).AND.(ichi < 1000))THEN
      WRITE(outstring,30)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   4 digits positive
!
   IF((ichi >= 1000).AND.(ichi < 10000))THEN
      WRITE(outstring,40)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   5 digits positive
!
   IF((ichi >= 10000).AND.(ichi < 100000))THEN
      WRITE(outstring,50)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   6 digits positive
!
   IF((ichi >= 100000).AND.(ichi < 1000000))THEN
      WRITE(outstring,60)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   7 digits positive
!
   IF((ichi >= 1000000).AND.(ichi < 10000000))THEN
      WRITE(outstring,70)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   8 digits positive
!
   IF((ichi >= 10000000).AND.(ichi < 100000000))THEN
      WRITE(outstring,80)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   9 digits positive
!
   IF((ichi >= 1000000000))THEN
      itemp=999999999
      WRITE(outstring,90)instring,itemp
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   1 digit negative
!
   IF((ichi > -10).AND.(ichi <= 0))THEN
      WRITE(outstring,100)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   2 digits negative
!
   IF((ichi > -100).AND.(ichi <= -10))THEN
      WRITE(outstring,110)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   3 digits negative
!
   IF((ichi > -1000).AND.(ichi <= -100))THEN
      WRITE(outstring,120)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   4 digits negative
!
   IF((ichi > -10000).AND.(ichi <= -1000))THEN
      WRITE(outstring,130)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   5 digits negative
!
   IF((ichi > -100000).AND.(ichi <= -10000))THEN
      WRITE(outstring,140)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   6 digits negative
!
   IF((ichi > -1000000).AND.(ichi <= -100000))THEN
      WRITE(outstring,150)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   7 digits negative
!
   IF((ichi > -10000000).AND.(ichi <= -1000000))THEN
      WRITE(outstring,160)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   8 digits negative
!
   IF((ichi > -100000000).AND.(ichi <= -10000000))THEN
      WRITE(outstring,170)instring,ichi
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
!   9 digits negative
!
   IF((ichi <= -100000000))THEN
      itemp=-999999999
      WRITE(outstring,180)instring,itemp
      ilength=LEN_TRIM(outstring)
      RETURN
   END IF
!
10 FORMAT(a,i1)
20 FORMAT(a,i2)
30 FORMAT(a,i3)
40 FORMAT(a,i4)
50 FORMAT(a,i5)
60 FORMAT(a,i6)
70 FORMAT(a,i7)
80 FORMAT(a,i8)
90 FORMAT(a,i9)
100 FORMAT(a,i2)
110 FORMAT(a,i3)
120 FORMAT(a,i4)
130 FORMAT(a,i5)
140 FORMAT(a,i6)
150 FORMAT(a,i7)
160 FORMAT(a,i8)
170 FORMAT(a,i9)
180 FORMAT(a,i10)
!
   RETURN
!
END SUBROUTINE istringnoequals
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE itaad(n,ns,y,nsd,a,ap,ndgl,f,z,h,  &
   dyno,igr,rmass,nbody,tideparm,isw80)
!
!   from Ernst Hairer
!
   USE accur
!
   IMPLICIT NONE

   INTEGER, INTENT(IN)                      :: n
   INTEGER, INTENT(IN)                      :: ns
   REAL(KIND=dp), INTENT(IN)                :: y(n)
   INTEGER, INTENT(IN)                      :: nsd
   REAL(KIND=dp), INTENT(IN)                :: a(nsd,ns)
   REAL(KIND=dp), INTENT(IN)                :: ap(nsd,ns)
   INTEGER, INTENT(IN)                      :: ndgl
   REAL(KIND=dp), INTENT(IN OUT)            :: f(ndgl*ns)
   REAL(KIND=dp), INTENT(IN OUT)            :: z(ndgl*ns)
   REAL(KIND=dp), INTENT(IN)                :: h
   REAL(KIND=dp), INTENT(OUT)               :: dyno
   INTEGER, INTENT(IN)                      :: igr
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: tideparm(20)
   INTEGER, INTENT(IN)                      :: isw80
!
   REAL(KIND=dp) :: ssum,sump,ff,znew
!
   INTEGER :: is,i,js,isn
!
   DO is=1,ns
      isn=1+(is-1)*n
      CALL dequa(n,z(isn),f(isn),igr,rmass,nbody,tideparm,isw80)
   END DO
! ---
   dyno=0.0_dp
   DO is=1,ns
      DO i=1,n
         ssum=0.0_dp
         sump=0.0_dp
         DO js=ns,1,-1
            ff=f(i+(js-1)*n)
            ssum=ssum+a(is,js)*ff
            sump=sump+ap(is,js)*ff
         END DO
         isn=i+(is-1)*n
         znew=y(i)+h*ssum+h*sump
         dyno=MAX(dyno,ABS(znew-z(isn)))
         z(isn)=znew
      END DO
   END DO
   RETURN
!
END SUBROUTINE itaad
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE jacobi_poly(n,alpha,beta,x,cx)
!
!   April 24, 2006
!
!   Subroutine to evaluate the Jacobi polynomials at x.  Routine
!   received from A. Gimenez.
!
!*******************************************************************
!
!  JACOBI_POLY evaluates the Jacobi polynomials at X.
!
!  Differential equation:
!
!    (1-X*X) Y'' + (BETA-ALPHA-(ALPHA+BETA+2) X) Y' +
!              N (N+ALPHA+BETA+1) Y = 0
!
!  Recursion:
!
!    P(0,ALPHA,BETA,X) = 1,
!
!    P(1,ALPHA,BETA,X) = ( (2+ALPHA+BETA)*X + (ALPHA-BETA) ) / 2
!
!    P(N,ALPHA,BETA,X)  =
!      (
!        (2*N+ALPHA+BETA-1)
!        * ((ALPHA**2-BETA**2)+(2*N+ALPHA+BETA)*(2*N+ALPHA+BETA-2)*X)
!        * P(N-1,ALPHA,BETA,X)
!        -2*(N-1+ALPHA)*(N-1+BETA)*(2*N+ALPHA+BETA) * P(N-2,ALPHA,BETA,X)
!      ) / 2*N*(N+ALPHA+BETA)*(2*N-2+ALPHA+BETA)
!
!  Restrictions:
!
!    -1 < ALPHA
!    -1 < BETA
!
!  Norm:
!
!    Integral ( -1 <= X <= 1 ) ( 1 - X )**ALPHA * ( 1 + X )**BETA
!      * P(N,ALPHA,BETA,X)**2 dX
!    = 2**(ALPHA+BETA+1) * Gamma ( N + ALPHA + 1 ) * Gamma ( N + BETA + 1 ) /
!      ( 2 * N + ALPHA + BETA ) * N! * Gamma ( N + ALPHA + BETA + 1 )
!
!  Special values:
!
!    P(N,ALPHA,BETA)(1) = (N+ALPHA)!/(N!*ALPHA!) for integer ALPHA.
!
!  Modified:
!
!    01 October 2002
!
!  Author:
!
!    John Burkardt
!
!  Reference:
!
!    Milton Abramowitz and Irene Stegun,
!    Handbook of Mathematical Functions,
!    US Department of Commerce, 1964.
!
!  Parameters:
!
!    Input, integer N, the highest order polynomial to compute.  Note
!    that polynomials 0 through N will be computed.
!
!    Input, real ( kind = 8 ) ALPHA, one of the parameters defining the Jacobi
!    polynomials, ALPHA must be greater than -1.
!
!    Input, real ( kind = 8 ) BETA, the second parameter defining the Jacobi
!    polynomials, BETA must be greater than -1.
!
!    Input, real ( kind = 8 ) X, the point at which the polynomials are
!    to be evaluated.
!
!    Output, real ( kind = 8 ) CX(0:N), the values of the first N+1 Jacobi
!    polynomials at the point X.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: alpha
   REAL(KIND=dp), INTENT(IN)                :: beta
   REAL(KIND=dp), INTENT(IN)                :: x
   REAL(KIND=dp), INTENT(OUT)               :: cx(n+1)
!
   INTEGER :: i
!
   REAL(KIND=dp) :: c1,c2,c3,c4,r_i
!
   IF(alpha <= -1.0_dp)THEN
      WRITE(*,'(a)')' '
      WRITE(*,'(a)')'JACOBI_POLY - Fatal error!'
      WRITE(*,'(a,g14.6)')'  Illegal input value of ALPHA = ',alpha
      WRITE(*,'(a)')'  But ALPHA must be greater than -1.'
      STOP
   END IF
   IF(beta <= -1.0_dp)THEN
      WRITE(*,'(a)')' '
      WRITE(*,'(a)')'JACOBI_POLY - Fatal error!'
      WRITE(*,'(a,g14.6)')'  Illegal input value of BETA = ',beta
      WRITE(*,'(a)')'  But BETA must be greater than -1.'
      STOP
   END IF
   IF(n < 0)THEN
      RETURN
   END IF
   cx(1)=1.0_dp
   IF(n == 0)THEN
      RETURN
   END IF
   cx(1+1)=(1.0E+00_dp+0.5E+00_dp*(alpha+beta))*x+0.5E+00_dp*(alpha-beta)
   DO i=2,n
      r_i=REAL(i,KIND=dp)
      c1=2.0E+00_dp*r_i*(r_i+alpha+beta)*(2.0E+00_dp*r_i-2.0E+00_dp+alpha+beta)
      c2=(2.0E+00_dp*r_i-1.0E+00_dp+alpha+beta)*(2.0E+00_dp*r_i+alpha+beta)  &
         *(2.0E+00_dp*r_i-2.0E+00_dp+alpha+beta)
      c3=(2.0E+00_dp*r_i-1.0E+00_dp+alpha+beta)*(alpha+beta)*(alpha-beta)
      c4=-2.0E+00_dp*(r_i-1.0E+00_dp+alpha)*(r_i-1.0E+00_dp+beta)*(2.0E+00_dp* &
         r_i+alpha+beta)
      cx(i+1)=((c3+c2*x)*cx(i-1+1)+c4*cx(i-2+1))/c1
   END DO
   RETURN
!
END SUBROUTINE jacobi_poly
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION kount(ialphmax,ialf,ibetlim)
!
!   June 11, 2003
!
!   this little function will keep track of the
!   index for the new 1D arrays.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ialf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
!
   INTEGER :: i,kount
!
   kount=0
   IF(ialf <= 1)THEN
      kount=0
      RETURN
   END IF
!
   kount=0
   DO  i=2,ialf
      kount=kount+ibetlim(i-1)
   END DO
!
   RETURN
!
END FUNCTION kount
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE lcnorm(n,yy,ynorm)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(OUT)                      :: yy(n)
   REAL(KIND=dp), INTENT(IN)                       :: ynorm
!
   INTEGER :: i
!
   DO  i=1,n
      yy(i)=yy(i)/ynorm
   END DO
!
   RETURN
!
END SUBROUTINE lcnorm
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE flcb50(tin,ilaw,flimbx,flimby)
!
!   UPDATE June 17, 2002
!
!   Change the variable x1array to xonarr
!   Change the variable x2array to xtwarr
!   Change the variable x3array to xtharr
!   Change the variable y3array to ytharr
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: tin
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: flimbx
   REAL(KIND=dp), INTENT(OUT)               :: flimby
!
   REAL(KIND=dp), DIMENSION(61) ::  tarray,xonarr,xtwarr,xtharr,y2array,ytharr
   REAL(KIND=dp)                ::  slope
!
   INTEGER :: n,indx
!
!DIMENSION tarray(61),xonarr(61),xtwarr(61),xtharr(61), y2array(61),ytharr(61)
!
   DATA tarray/3500.0_dp,3750.0_dp,4000.0_dp,4250.0_dp,4500.0_dp,4750.0_dp,  &
      5000.0_dp,5250.0_dp,5500.0_dp,5750.0_dp,6000.0_dp,6250.0_dp,  &
      6500.0_dp,6750.0_dp,7000.0_dp,7250.0_dp,7500.0_dp,7750.0_dp,8000.0_dp,  &
      8250.0_dp,8500.0_dp,8750.0_dp,9000.0_dp,9250.0_dp,9500.0_dp,  &
      9750.0_dp,10000.0_dp,10500.0_dp,11000.0_dp,11500.0_dp,12000.0_dp,  &
      12500.0_dp,13000.0_dp,14000.0_dp,15000.0_dp,16000.0_dp,17000.0_dp,  &
      18000.0_dp,19000.0_dp,20000.0_dp,21000.0_dp,22000.0_dp,23000.0_dp,  &
      24000.0_dp,25000.0_dp,26000.0_dp,27000.0_dp,28000.0_dp,29000.0_dp,  &
      30000.0_dp,31000.0_dp,32000.0_dp,33000.0_dp,34000.0_dp,35000.0_dp,  &
      37500.0_dp,40000.0_dp,42500.0_dp,45000.0_dp,47500.0_dp,50000.0_dp/
!
   DATA xonarr/0.630_dp,0.611_dp,0.680_dp,0.824_dp,0.912_dp,0.899_dp,  &
      0.861_dp,0.819_dp,0.778_dp,0.739_dp,0.701_dp,0.668_dp,0.637_dp,  &
      0.611_dp,0.589_dp,0.568_dp,0.549_dp,0.532_dp,0.518_dp,0.543_dp,  &
      0.526_dp,0.519_dp,0.532_dp,0.513_dp,0.496_dp,0.483_dp,0.471_dp,  &
      0.451_dp,0.434_dp,0.418_dp,0.404_dp,0.391_dp,0.379_dp,0.358_dp,  &
      0.342_dp,0.329_dp,0.318_dp,0.310_dp,0.302_dp,0.296_dp,0.290_dp,  &
      0.284_dp,0.278_dp,0.272_dp,0.266_dp,0.260_dp,0.255_dp,0.251_dp,  &
      0.247_dp,0.244_dp,0.239_dp,0.234_dp,0.228_dp,0.220_dp,0.212_dp,  &
      0.192_dp,0.179_dp,0.173_dp,0.169_dp,0.166_dp,0.164_dp/
!
   DATA xtwarr/0.857_dp,0.825_dp,0.822_dp,0.828_dp,0.835_dp,0.843_dp,  &
      0.848_dp,0.849_dp,0.846_dp,0.839_dp,0.829_dp,0.817_dp,0.804_dp,  &
      0.793_dp,0.783_dp,0.774_dp,0.766_dp,0.760_dp,0.757_dp,0.790_dp,  &
      0.778_dp,0.760_dp,0.739_dp,0.725_dp,0.712_dp,0.701_dp,0.692_dp,  &
      0.674_dp,0.658_dp,0.642_dp,0.626_dp,0.610_dp,0.594_dp,0.565_dp,  &
      0.541_dp,0.521_dp,0.505_dp,0.491_dp,0.480_dp,0.470_dp,0.461_dp,  &
      0.453_dp,0.446_dp,0.440_dp,0.433_dp,0.426_dp,0.419_dp,0.412_dp,  &
      0.407_dp,0.403_dp,0.398_dp,0.392_dp,0.385_dp,0.377_dp,0.368_dp,  &
      0.343_dp,0.323_dp,0.314_dp,0.311_dp,0.309_dp,0.307_dp/
!
   DATA y2array/0.341_dp,0.321_dp,0.213_dp,0.006_dp,-0.117_dp,  &
      -0.084_dp,-0.019_dp,0.045_dp,0.102_dp,0.149_dp,0.191_dp,0.224_dp,  &
      0.251_dp,0.272_dp,0.291_dp,0.308_dp,0.325_dp,0.342_dp,0.359_dp,  &
      0.371_dp,0.379_dp,0.362_dp,0.311_dp,0.318_dp,0.324_dp,0.328_dp,  &
      0.331_dp,0.334_dp,0.336_dp,0.335_dp,0.333_dp,0.329_dp,0.323_dp,  &
      0.311_dp,0.299_dp,0.289_dp,0.279_dp,0.272_dp,0.266_dp,0.261_dp,  &
      0.257_dp,0.254_dp,0.252_dp,0.251_dp,0.250_dp,0.248_dp,0.245_dp,  &
      0.242_dp,0.240_dp,0.239_dp,0.238_dp,0.236_dp,0.235_dp,0.234_dp,  &
      0.234_dp,0.227_dp,0.216_dp,0.212_dp,0.213_dp,0.214_dp,0.216_dp/
!
   DATA xtharr/0.118_dp,0.129_dp,0.360_dp,0.815_dp,1.088_dp,1.025_dp,  &
      0.890_dp,0.752_dp,0.625_dp,0.515_dp,0.414_dp,0.332_dp,0.260_dp,  &
      0.203_dp,0.152_dp,0.107_dp,0.061_dp,0.019_dp,-0.021_dp,-0.014_dp,  &
      -0.043_dp,-0.024_dp,0.066_dp,0.035_dp,0.010_dp,-0.009_dp,-0.025_dp,  &
      -0.050_dp,-0.069_dp,-0.085_dp,-0.095_dp,-0.102_dp,-0.106_dp,-0.109_dp,  &
      -0.107_dp,-0.104_dp,-0.101_dp,-0.098_dp,-0.096_dp,-0.095_dp,  &
      -0.095_dp,-0.097_dp,-0.100_dp,-0.104_dp,-0.108_dp,-0.111_dp,-0.113_dp,  &
      -0.113_dp,-0.113_dp,-0.114_dp,-0.117_dp,-0.120_dp,-0.125_dp,  &
      -0.131_dp,-0.138_dp,-0.148_dp,-0.146_dp,-0.146_dp,-0.150_dp,-0.154_dp, &
      -0.160_dp/
!
   DATA ytharr/0.853_dp,0.803_dp,0.532_dp,0.015_dp,-0.292_dp,-0.209_dp,  &
      -0.048_dp,0.112_dp,0.255_dp,0.373_dp,0.479_dp,0.559_dp,0.628_dp,  &
      0.681_dp,0.728_dp,0.770_dp,0.813_dp,0.856_dp,0.898_dp,0.928_dp,  &
      0.948_dp,0.905_dp,0.777_dp,0.796_dp,0.810_dp,0.819_dp,0.827_dp,  &
      0.836_dp,0.839_dp,0.838_dp,0.832_dp,0.822_dp,0.808_dp,0.778_dp,  &
      0.748_dp,0.721_dp,0.698_dp,0.680_dp,0.665_dp,0.652_dp,0.642_dp,  &
      0.635_dp,0.630_dp,0.627_dp,0.624_dp,0.619_dp,0.613_dp,0.606_dp,  &
      0.600_dp,0.597_dp,0.594_dp,0.590_dp,0.588_dp,0.586_dp,0.584_dp,  &
      0.567_dp,0.541_dp,0.531_dp,0.532_dp,0.534_dp,0.539_dp/
!
   n=61
!
   IF(tin <= tarray(1))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(1)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(1)
         flimby=y2array(1)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(1)
         flimby=ytharr(1)
         RETURN
      END IF
   END IF
!
   IF(tin >= tarray(n))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(n)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(n)
         flimby=y2array(n)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(n)
         flimby=ytharr(n)
         RETURN
      END IF
   END IF
!
!   Find out where Tin is located in the tabulated temperature array.
!
   CALL locate(tarray,n,tin,indx)
!
   IF(ilaw <= 1)THEN
      slope=(xonarr(indx)-xonarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xonarr(indx)
      flimby=0.0_dp
      RETURN
   END IF
!
   IF(ilaw == 2)THEN
      slope=(xtwarr(indx)-xtwarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtwarr(indx)
      slope=(y2array(indx)-y2array(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+y2array(indx)
      RETURN
   END IF
!
   IF(ilaw >= 3)THEN
      slope=(xtharr(indx)-xtharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtharr(indx)
      slope=(ytharr(indx)-ytharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+ytharr(indx)
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE flcb50
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE flch50(tin,ilaw,flimbx,flimby)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: tin
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: flimbx
   REAL(KIND=dp), INTENT(OUT)               :: flimby
!
   REAL(KIND=dp), DIMENSION(61) ::  tarray,xonarr,xtwarr,xtharr,y2array,ytharr
   REAL(KIND=dp)                ::  slope
!
   INTEGER :: n,indx
!
!DIMENSION tarray(61),xonarr(61),xtwarr(61),xtharr(61), y2array(61),ytharr(61)
!
   DATA tarray/3500.0_dp,3750.0_dp,4000.0_dp,4250.0_dp,4500.0_dp,4750.0_dp,  &
      5000.0_dp,5250.0_dp,5500.0_dp,5750.0_dp,6000.0_dp,6250.0_dp,  &
      6500.0_dp,6750.0_dp,7000.0_dp,7250.0_dp,7500.0_dp,7750.0_dp,8000.0_dp,  &
      8250.0_dp,8500.0_dp,8750.0_dp,9000.0_dp,9250.0_dp,9500.0_dp,  &
      9750.0_dp,10000.0_dp,10500.0_dp,11000.0_dp,11500.0_dp,12000.0_dp,  &
      12500.0_dp,13000.0_dp,14000.0_dp,15000.0_dp,16000.0_dp,17000.0_dp,  &
      18000.0_dp,19000.0_dp,20000.0_dp,21000.0_dp,22000.0_dp,23000.0_dp,  &
      24000.0_dp,25000.0_dp,26000.0_dp,27000.0_dp,28000.0_dp,29000.0_dp,  &
      30000.0_dp,31000.0_dp,32000.0_dp,33000.0_dp,34000.0_dp,35000.0_dp,  &
      37500.0_dp,40000.0_dp,42500.0_dp,45000.0_dp,47500.0_dp,50000.0_dp/
!
   DATA xonarr/0.234_dp,0.252_dp,0.301_dp,0.373_dp,0.415_dp,0.408_dp,  &
      0.388_dp,0.366_dp,0.345_dp,0.325_dp,0.306_dp,0.289_dp,0.275_dp,  &
      0.263_dp,0.252_dp,0.242_dp,0.233_dp,0.226_dp,0.221_dp,0.249_dp,  &
      0.240_dp,0.229_dp,0.216_dp,0.209_dp,0.204_dp,0.200_dp,0.197_dp,  &
      0.192_dp,0.187_dp,0.183_dp,0.178_dp,0.173_dp,0.168_dp,0.158_dp,  &
      0.150_dp,0.144_dp,0.139_dp,0.135_dp,0.131_dp,0.129_dp,0.126_dp,  &
      0.125_dp,0.124_dp,0.123_dp,0.122_dp,0.122_dp,0.121_dp,0.120_dp,  &
      0.119_dp,0.118_dp,0.117_dp,0.115_dp,0.112_dp,0.110_dp,0.106_dp,  &
      0.098_dp,0.089_dp,0.084_dp,0.082_dp,0.080_dp,0.079_dp/
!
   DATA xtwarr/0.448_dp,0.454_dp,0.488_dp,0.536_dp,0.562_dp,0.557_dp,  &
      0.545_dp,0.530_dp,0.513_dp,0.495_dp,0.477_dp,0.460_dp,0.444_dp,  &
      0.430_dp,0.419_dp,0.408_dp,0.398_dp,0.390_dp,0.383_dp,0.384_dp,  &
      0.372_dp,0.357_dp,0.339_dp,0.328_dp,0.320_dp,0.314_dp,0.309_dp,  &
      0.301_dp,0.294_dp,0.287_dp,0.279_dp,0.272_dp,0.264_dp,0.250_dp,  &
      0.238_dp,0.229_dp,0.221_dp,0.215_dp,0.210_dp,0.207_dp,0.205_dp,  &
      0.204_dp,0.205_dp,0.206_dp,0.208_dp,0.209_dp,0.209_dp,0.209_dp,  &
      0.207_dp,0.206_dp,0.203_dp,0.200_dp,0.196_dp,0.192_dp,0.187_dp,  &
      0.178_dp,0.168_dp,0.164_dp,0.163_dp,0.164_dp,0.164_dp/
!
   DATA y2array/0.320_dp,0.303_dp,0.281_dp,0.243_dp,0.221_dp,0.224_dp,  &
      0.235_dp,0.245_dp,0.252_dp,0.255_dp,0.257_dp,0.256_dp,0.254_dp,  &
      0.252_dp,0.250_dp,0.249_dp,0.247_dp,0.245_dp,0.243_dp,0.202_dp,  &
      0.198_dp,0.192_dp,0.185_dp,0.179_dp,0.174_dp,0.171_dp,0.169_dp,  &
      0.164_dp,0.160_dp,0.156_dp,0.152_dp,0.148_dp,0.144_dp,0.137_dp,  &
      0.131_dp,0.127_dp,0.123_dp,0.120_dp,0.118_dp,0.118_dp,0.118_dp,  &
      0.119_dp,0.122_dp,0.125_dp,0.129_dp,0.131_dp,0.133_dp,0.134_dp,  &
      0.133_dp,0.132_dp,0.130_dp,0.128_dp,0.125_dp,0.123_dp,0.121_dp,  &
      0.120_dp,0.120_dp,0.121_dp,0.122_dp,0.125_dp,0.127_dp/
!
   DATA xtharr/-0.245_dp,-0.203_dp,-0.120_dp,0.008_dp,0.083_dp,  &
      0.071_dp,0.036_dp,-0.001_dp,-0.033_dp,-0.057_dp,-0.080_dp,-0.095_dp,  &
      -0.107_dp,-0.115_dp,-0.124_dp,-0.130_dp,-0.138_dp,-0.142_dp,  &
      -0.143_dp,-0.054_dp,-0.057_dp,-0.059_dp,-0.061_dp,-0.059_dp,-0.057_dp,  &
      0.056_dp,-0.056_dp,-0.055_dp,-0.053_dp,-0.052_dp,-0.050_dp,  &
      -0.050_dp,-0.048_dp,-0.048_dp,-0.047_dp,-0.046_dp,-0.046_dp,-0.046_dp,  &
      0.046_dp,-0.048_dp,-0.051_dp,-0.054_dp,-0.059_dp,-0.064_dp,  &
      -0.071_dp,-0.075_dp,-0.079_dp,-0.081_dp,-0.081_dp,-0.081_dp,-0.079_dp,  &
      0.077_dp,-0.076_dp,-0.075_dp,-0.076_dp,-0.082_dp,-0.091_dp,  &
      -0.097_dp,-0.101_dp,-0.107_dp,-0.112_dp/
!
   DATA ytharr/0.799_dp,0.758_dp,0.702_dp,0.608_dp,0.553_dp,0.561_dp,  &
      0.586_dp,0.612_dp,0.630_dp,0.637_dp,0.644_dp,0.640_dp,0.636_dp,  &
      0.629_dp,0.626_dp,0.621_dp,0.618_dp,0.614_dp,0.606_dp,0.506_dp,  &
      0.495_dp,0.480_dp,0.462_dp,0.447_dp,0.435_dp,0.427_dp,0.422_dp,  &
      0.410_dp,0.400_dp,0.391_dp,0.380_dp,0.371_dp,0.360_dp,0.344_dp,  &
      0.329_dp,0.317_dp,0.309_dp,0.301_dp,0.296_dp,0.294_dp,0.295_dp,  &
      0.298_dp,0.304_dp,0.311_dp,0.322_dp,0.328_dp,0.333_dp,0.334_dp,  &
      0.333_dp,0.330_dp,0.325_dp,0.320_dp,0.313_dp,0.307_dp,0.304_dp,  &
      0.300_dp,0.299_dp,0.302_dp,0.306_dp,0.312_dp,0.319_dp/
!
   n=61
!
   IF(tin <= tarray(1))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(1)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(1)
         flimby=y2array(1)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(1)
         flimby=ytharr(1)
         RETURN
      END IF
   END IF
!
   IF(tin >= tarray(n))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(n)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(n)
         flimby=y2array(n)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(n)
         flimby=ytharr(n)
         RETURN
      END IF
   END IF
!
!   Find out where Tin is located in the tabulated temperature array.
!
   CALL locate(tarray,n,tin,indx)
!
   IF(ilaw <= 1)THEN
      slope=(xonarr(indx)-xonarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xonarr(indx)
      flimby=0.0_dp
      RETURN
   END IF
!
   IF(ilaw == 2)THEN
      slope=(xtwarr(indx)-xtwarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtwarr(indx)
      slope=(y2array(indx)-y2array(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+y2array(indx)
      RETURN
   END IF
!
   IF(ilaw >= 3)THEN
      slope=(xtharr(indx)-xtharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtharr(indx)
      slope=(ytharr(indx)-ytharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+ytharr(indx)
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE flch50
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE flci50(tin,ilaw,flimbx,flimby)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: tin
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: flimbx
   REAL(KIND=dp), INTENT(OUT)               :: flimby
!
   REAL(KIND=dp), DIMENSION(61) ::  tarray,xonarr,xtwarr,xtharr,y2array,ytharr
   REAL(KIND=dp)                ::  slope
!
   INTEGER :: n,indx
!
!DIMENSION tarray(61),xonarr(61),xtwarr(61),xtharr(61), y2array(61),ytharr(61)
!
   DATA tarray/3500.0_dp,3750.0_dp,4000.0_dp,4250.0_dp,4500.0_dp,4750.0_dp,  &
      5000.0_dp,5250.0_dp,5500.0_dp,5750.0_dp,6000.0_dp,6250.0_dp,  &
      6500.0_dp,6750.0_dp,7000.0_dp,7250.0_dp,7500.0_dp,7750.0_dp,8000.0_dp,  &
      8250.0_dp,8500.0_dp,8750.0_dp,9000.0_dp,9250.0_dp,9500.0_dp,  &
      9750.0_dp,10000.0_dp,10500.0_dp,11000.0_dp,11500.0_dp,12000.0_dp,  &
      12500.0_dp,13000.0_dp,14000.0_dp,15000.0_dp,16000.0_dp,17000.0_dp,  &
      18000.0_dp,19000.0_dp,20000.0_dp,21000.0_dp,22000.0_dp,23000.0_dp,  &
      24000.0_dp,25000.0_dp,26000.0_dp,27000.0_dp,28000.0_dp,29000.0_dp,  &
      30000.0_dp,31000.0_dp,32000.0_dp,33000.0_dp,34000.0_dp,35000.0_dp,  &
      37500.0_dp,40000.0_dp,42500.0_dp,45000.0_dp,47500.0_dp,50000.0_dp/
!
   DATA xonarr/0.453_dp,0.430_dp,0.444_dp,0.506_dp,0.555_dp,0.549_dp,  &
      0.527_dp,0.500_dp,0.473_dp,0.446_dp,0.420_dp,0.397_dp,0.377_dp,  &
      0.361_dp,0.348_dp,0.335_dp,0.323_dp,0.314_dp,0.309_dp,0.347_dp,  &
      0.335_dp,0.321_dp,0.304_dp,0.295_dp,0.287_dp,0.281_dp,0.277_dp,  &
      0.268_dp,0.261_dp,0.253_dp,0.246_dp,0.239_dp,0.232_dp,0.218_dp,  &
      0.207_dp,0.199_dp,0.192_dp,0.187_dp,0.182_dp,0.179_dp,0.176_dp,  &
      0.173_dp,0.171_dp,0.169_dp,0.167_dp,0.165_dp,0.163_dp,0.160_dp,  &
      0.159_dp,0.157_dp,0.155_dp,0.153_dp,0.150_dp,0.146_dp,0.142_dp,  &
      0.128_dp,0.115_dp,0.109_dp,0.106_dp,0.103_dp,0.102_dp/
!
   DATA xtwarr/0.689_dp,0.667_dp,0.661_dp,0.668_dp,0.666_dp,0.656_dp,  &
      0.647_dp,0.637_dp,0.625_dp,0.609_dp,0.592_dp,0.575_dp,0.558_dp,  &
      0.544_dp,0.531_dp,0.520_dp,0.509_dp,0.500_dp,0.493_dp,0.492_dp,  &
      0.480_dp,0.464_dp,0.442_dp,0.430_dp,0.421_dp,0.414_dp,0.408_dp,  &
      0.398_dp,0.389_dp,0.380_dp,0.370_dp,0.360_dp,0.350_dp,0.333_dp,  &
      0.318_dp,0.306_dp,0.296_dp,0.288_dp,0.283_dp,0.278_dp,0.275_dp,  &
      0.273_dp,0.272_dp,0.273_dp,0.273_dp,0.273_dp,0.272_dp,0.270_dp,  &
      0.268_dp,0.266_dp,0.264_dp,0.260_dp,0.255_dp,0.250_dp,0.244_dp,  &
      0.228_dp,0.212_dp,0.205_dp,0.203_dp,0.202_dp,0.202_dp/
!
   DATA y2array/0.354_dp,0.356_dp,0.326_dp,0.243_dp,0.167_dp,0.161_dp,  &
      0.181_dp,0.205_dp,0.228_dp,0.244_dp,0.259_dp,0.267_dp,0.271_dp,  &
      0.273_dp,0.275_dp,0.277_dp,0.279_dp,0.279_dp,0.277_dp,0.218_dp,  &
      0.218_dp,0.214_dp,0.207_dp,0.203_dp,0.201_dp,0.199_dp,0.197_dp,  &
      0.195_dp,0.192_dp,0.189_dp,0.186_dp,0.182_dp,0.178_dp,0.172_dp,  &
      0.166_dp,0.160_dp,0.156_dp,0.153_dp,0.150_dp,0.149_dp,0.149_dp,  &
      0.150_dp,0.152_dp,0.155_dp,0.159_dp,0.162_dp,0.164_dp,0.164_dp,  &
      0.164_dp,0.164_dp,0.163_dp,0.161_dp,0.158_dp,0.156_dp,0.154_dp,  &
      0.151_dp,0.146_dp,0.144_dp,0.145_dp,0.148_dp,0.150_dp/
!
   DATA xtharr/-0.077_dp,-0.104_dp,-0.044_dp,0.142_dp,0.305_dp,  &
      0.308_dp,0.256_dp,0.192_dp,0.131_dp,0.080_dp,0.032_dp,-0.003_dp,  &
      -0.030_dp,-0.049_dp,-0.065_dp,-0.080_dp,-0.095_dp,-0.104_dp,-0.106_dp,  &
      0.019_dp,0.008_dp,0.000_dp,-0.007_dp,-0.011_dp,-0.014_dp,-0.017_dp,  &
      0.019_dp,-0.025_dp,-0.028_dp,-0.030_dp,-0.032_dp,-0.034_dp,  &
      -0.036_dp,-0.039_dp,-0.041_dp,-0.042_dp,-0.042_dp,-0.042_dp,-0.043_dp,  &
      0.044_dp,-0.047_dp,-0.051_dp,-0.057_dp,-0.063_dp,-0.070_dp,  &
      -0.078_dp,-0.083_dp,-0.086_dp,-0.088_dp,-0.089_dp,-0.089_dp,-0.089_dp,  &
      0.088_dp,-0.088_dp,-0.090_dp,-0.099_dp,-0.105_dp,-0.108_dp,  &
      -0.112_dp,-0.118_dp,-0.123_dp/
!
   DATA ytharr/0.884_dp,0.890_dp,0.814_dp,0.607_dp,0.418_dp,0.402_dp,  &
      0.452_dp,0.514_dp,0.569_dp,0.611_dp,0.647_dp,0.667_dp,0.679_dp,  &
      0.683_dp,0.688_dp,0.692_dp,0.698_dp,0.697_dp,0.692_dp,0.546_dp,  &
      0.545_dp,0.535_dp,0.518_dp,0.509_dp,0.502_dp,0.496_dp,0.493_dp,  &
      0.488_dp,0.481_dp,0.473_dp,0.464_dp,0.455_dp,0.446_dp,0.429_dp,  &
      0.414_dp,0.401_dp,0.390_dp,0.382_dp,0.376_dp,0.372_dp,0.372_dp,  &
      0.374_dp,0.380_dp,0.387_dp,0.396_dp,0.404_dp,0.409_dp,0.411_dp,  &
      0.411_dp,0.410_dp,0.407_dp,0.402_dp,0.396_dp,0.390_dp,0.385_dp,  &
      0.378_dp,0.366_dp,0.360_dp,0.363_dp,0.370_dp,0.374_dp/
!
   n=61
!
   IF(tin <= tarray(1))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(1)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(1)
         flimby=y2array(1)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(1)
         flimby=ytharr(1)
         RETURN
      END IF
   END IF
!
   IF(tin >= tarray(n))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(n)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(n)
         flimby=y2array(n)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(n)
         flimby=ytharr(n)
         RETURN
      END IF
   END IF
!
!   Find out where Tin is located in the tabulated temperature array.
!
   CALL locate(tarray,n,tin,indx)
!
   IF(ilaw <= 1)THEN
      slope=(xonarr(indx)-xonarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xonarr(indx)
      flimby=0.0_dp
      RETURN
   END IF
!
   IF(ilaw == 2)THEN
      slope=(xtwarr(indx)-xtwarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtwarr(indx)
      slope=(y2array(indx)-y2array(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+y2array(indx)
      RETURN
   END IF
!
   IF(ilaw >= 3)THEN
      slope=(xtharr(indx)-xtharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtharr(indx)
      slope=(ytharr(indx)-ytharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+ytharr(indx)
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE flci50
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE flcj50(tin,ilaw,flimbx,flimby)
!
   USE accur

   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: tin
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: flimbx
   REAL(KIND=dp), INTENT(OUT)               :: flimby
!
   REAL(KIND=dp), DIMENSION(61) ::  tarray,xonarr,xtwarr,xtharr,y2array,ytharr
   REAL(KIND=dp)                ::  slope
!
   INTEGER :: n,indx
!
!DIMENSION tarray(61),xonarr(61),xtwarr(61),xtharr(61), y2array(61),ytharr(61)
!
   DATA tarray/3500.0_dp,3750.0_dp,4000.0_dp,4250.0_dp,4500.0_dp,4750.0_dp,  &
      5000.0_dp,5250.0_dp,5500.0_dp,5750.0_dp,6000.0_dp,6250.0_dp,  &
      6500.0_dp,6750.0_dp,7000.0_dp,7250.0_dp,7500.0_dp,7750.0_dp,8000.0_dp,  &
      8250.0_dp,8500.0_dp,8750.0_dp,9000.0_dp,9250.0_dp,9500.0_dp,  &
      9750.0_dp,10000.0_dp,10500.0_dp,11000.0_dp,11500.0_dp,12000.0_dp,  &
      12500.0_dp,13000.0_dp,14000.0_dp,15000.0_dp,16000.0_dp,17000.0_dp,  &
      18000.0_dp,19000.0_dp,20000.0_dp,21000.0_dp,22000.0_dp,23000.0_dp,  &
      24000.0_dp,25000.0_dp,26000.0_dp,27000.0_dp,28000.0_dp,29000.0_dp,  &
      30000.0_dp,31000.0_dp,32000.0_dp,33000.0_dp,34000.0_dp,35000.0_dp,  &
      37500.0_dp,40000.0_dp,42500.0_dp,45000.0_dp,47500.0_dp,50000.0_dp/
!
   DATA xonarr/0.234_dp,0.252_dp,0.301_dp,0.373_dp,0.415_dp,0.408_dp,  &
      0.388_dp,0.366_dp,0.345_dp,0.325_dp,0.306_dp,0.289_dp,0.275_dp,  &
      0.263_dp,0.252_dp,0.242_dp,0.233_dp,0.226_dp,0.221_dp,0.249_dp,  &
      0.240_dp,0.229_dp,0.216_dp,0.209_dp,0.204_dp,0.200_dp,0.197_dp,  &
      0.192_dp,0.187_dp,0.183_dp,0.178_dp,0.173_dp,0.168_dp,0.158_dp,  &
      0.150_dp,0.144_dp,0.139_dp,0.135_dp,0.131_dp,0.129_dp,0.126_dp,  &
      0.125_dp,0.124_dp,0.123_dp,0.122_dp,0.122_dp,0.121_dp,0.120_dp,  &
      0.119_dp,0.118_dp,0.117_dp,0.115_dp,0.112_dp,0.110_dp,0.106_dp,  &
      0.098_dp,0.089_dp,0.084_dp,0.082_dp,0.080_dp,0.079_dp/
!
   DATA xtwarr/0.448_dp,0.454_dp,0.488_dp,0.536_dp,0.562_dp,0.557_dp,  &
      0.545_dp,0.530_dp,0.513_dp,0.495_dp,0.477_dp,0.460_dp,0.444_dp,  &
      0.430_dp,0.419_dp,0.408_dp,0.398_dp,0.390_dp,0.383_dp,0.384_dp,  &
      0.372_dp,0.357_dp,0.339_dp,0.328_dp,0.320_dp,0.314_dp,0.309_dp,  &
      0.301_dp,0.294_dp,0.287_dp,0.279_dp,0.272_dp,0.264_dp,0.250_dp,  &
      0.238_dp,0.229_dp,0.221_dp,0.215_dp,0.210_dp,0.207_dp,0.205_dp,  &
      0.204_dp,0.205_dp,0.206_dp,0.208_dp,0.209_dp,0.209_dp,0.209_dp,  &
      0.207_dp,0.206_dp,0.203_dp,0.200_dp,0.196_dp,0.192_dp,0.187_dp,  &
      0.178_dp,0.168_dp,0.164_dp,0.163_dp,0.164_dp,0.164_dp/
!
   DATA y2array/0.320_dp,0.303_dp,0.281_dp,0.243_dp,0.221_dp,0.224_dp,  &
      0.235_dp,0.245_dp,0.252_dp,0.255_dp,0.257_dp,0.256_dp,0.254_dp,  &
      0.252_dp,0.250_dp,0.249_dp,0.247_dp,0.245_dp,0.243_dp,0.202_dp,  &
      0.198_dp,0.192_dp,0.185_dp,0.179_dp,0.174_dp,0.171_dp,0.169_dp,  &
      0.164_dp,0.160_dp,0.156_dp,0.152_dp,0.148_dp,0.144_dp,0.137_dp,  &
      0.131_dp,0.127_dp,0.123_dp,0.120_dp,0.118_dp,0.118_dp,0.118_dp,  &
      0.119_dp,0.122_dp,0.125_dp,0.129_dp,0.131_dp,0.133_dp,0.134_dp,  &
      0.133_dp,0.132_dp,0.130_dp,0.128_dp,0.125_dp,0.123_dp,0.121_dp,  &
      0.120_dp,0.120_dp,0.121_dp,0.122_dp,0.125_dp,0.127_dp/
!
   DATA xtharr/-0.245_dp,-0.203_dp,-0.120_dp,0.008_dp,0.083_dp,  &
      0.071_dp,0.036_dp,-0.001_dp,-0.033_dp,-0.057_dp,-0.080_dp,-0.095_dp,  &
      0.107_dp,-0.115_dp,-0.124_dp,-0.130_dp,-0.138_dp,-0.142_dp,  &
      -0.143_dp,-0.054_dp,-0.057_dp,-0.059_dp,-0.061_dp,-0.059_dp,-0.057_dp,  &
      0.056_dp,-0.056_dp,-0.055_dp,-0.053_dp,-0.052_dp,-0.050_dp,  &
      -0.050_dp,-0.048_dp,-0.048_dp,-0.047_dp,-0.046_dp,-0.046_dp,-0.046_dp,  &
      0.046_dp,-0.048_dp,-0.051_dp,-0.054_dp,-0.059_dp,-0.064_dp,  &
      -0.071_dp,-0.075_dp,-0.079_dp,-0.081_dp,-0.081_dp,-0.081_dp,-0.079_dp,  &
      0.077_dp,-0.076_dp,-0.075_dp,-0.076_dp,-0.082_dp,-0.091_dp,  &
      -0.097_dp,-0.101_dp,-0.107_dp,-0.112_dp/
!
   DATA ytharr/0.799_dp,0.758_dp,0.702_dp,0.608_dp,0.553_dp,0.561_dp,  &
      0.586_dp,0.612_dp,0.630_dp,0.637_dp,0.644_dp,0.640_dp,0.636_dp,  &
      0.629_dp,0.626_dp,0.621_dp,0.618_dp,0.614_dp,0.606_dp,0.506_dp,  &
      0.495_dp,0.480_dp,0.462_dp,0.447_dp,0.435_dp,0.427_dp,0.422_dp,  &
      0.410_dp,0.400_dp,0.391_dp,0.380_dp,0.371_dp,0.360_dp,0.344_dp,  &
      0.329_dp,0.317_dp,0.309_dp,0.301_dp,0.296_dp,0.294_dp,0.295_dp,  &
      0.298_dp,0.304_dp,0.311_dp,0.322_dp,0.328_dp,0.333_dp,0.334_dp,  &
      0.333_dp,0.330_dp,0.325_dp,0.320_dp,0.313_dp,0.307_dp,0.304_dp,  &
      0.300_dp,0.299_dp,0.302_dp,0.306_dp,0.312_dp,0.319_dp/
!
   n=61
!
   IF(tin <= tarray(1))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(1)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(1)
         flimby=y2array(1)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(1)
         flimby=ytharr(1)
         RETURN
      END IF
   END IF
!
   IF(tin >= tarray(n))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(n)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(n)
         flimby=y2array(n)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(n)
         flimby=ytharr(n)
         RETURN
      END IF
   END IF
!
!   Find out where Tin is located in the tabulated temperature array.
!
   CALL locate(tarray,n,tin,indx)
!
   IF(ilaw <= 1)THEN
      slope=(xonarr(indx)-xonarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xonarr(indx)
      flimby=0.0_dp
      RETURN
   END IF
!
   IF(ilaw == 2)THEN
      slope=(xtwarr(indx)-xtwarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtwarr(indx)
      slope=(y2array(indx)-y2array(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+y2array(indx)
      RETURN
   END IF
!
   IF(ilaw >= 3)THEN
      slope=(xtharr(indx)-xtharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtharr(indx)
      slope=(ytharr(indx)-ytharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+ytharr(indx)
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE flcj50
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE flck50(tin,ilaw,flimbx,flimby)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)            :: tin
   INTEGER, INTENT(IN)                  :: ilaw
   REAL(KIND=dp), INTENT(OUT)           :: flimbx
   REAL(KIND=dp), INTENT(OUT)           :: flimby
!
   REAL(KIND=dp), DIMENSION(61) ::  tarray,xonarr,xtwarr,xtharr,y2array,ytharr
   REAL(KIND=dp)                ::  slope
!
   INTEGER :: n,indx
!
!DIMENSION tarray(61),xonarr(61),xtwarr(61),xtharr(61), y2array(61),ytharr(61)
!
   DATA tarray/3500.0_dp,3750.0_dp,4000.0_dp,4250.0_dp,4500.0_dp,4750.0_dp,  &
      5000.0_dp,5250.0_dp,5500.0_dp,5750.0_dp,6000.0_dp,6250.0_dp,  &
      6500.0_dp,6750.0_dp,7000.0_dp,7250.0_dp,7500.0_dp,7750.0_dp,8000.0_dp,  &
      8250.0_dp,8500.0_dp,8750.0_dp,9000.0_dp,9250.0_dp,9500.0_dp,  &
      9750.0_dp,10000.0_dp,10500.0_dp,11000.0_dp,11500.0_dp,12000.0_dp,  &
      12500.0_dp,13000.0_dp,14000.0_dp,15000.0_dp,16000.0_dp,17000.0_dp,  &
      18000.0_dp,19000.0_dp,20000.0_dp,21000.0_dp,22000.0_dp,23000.0_dp,  &
      24000.0_dp,25000.0_dp,26000.0_dp,27000.0_dp,28000.0_dp,29000.0_dp,  &
      30000.0_dp,31000.0_dp,32000.0_dp,33000.0_dp,34000.0_dp,35000.0_dp,  &
      37500.0_dp,40000.0_dp,42500.0_dp,45000.0_dp,47500.0_dp,50000.0_dp/
!
   DATA xonarr/0.140_dp,0.158_dp,0.203_dp,0.250_dp,0.263_dp,0.257_dp,  &
      0.247_dp,0.235_dp,0.222_dp,0.210_dp,0.198_dp,0.188_dp,0.178_dp,  &
      0.170_dp,0.163_dp,0.157_dp,0.151_dp,0.148_dp,0.147_dp,0.156_dp,  &
      0.150_dp,0.142_dp,0.134_dp,0.130_dp,0.126_dp,0.124_dp,0.122_dp,  &
      0.118_dp,0.115_dp,0.113_dp,0.109_dp,0.106_dp,0.103_dp,0.097_dp,  &
      0.092_dp,0.088_dp,0.085_dp,0.082_dp,0.080_dp,0.079_dp,0.078_dp,  &
      0.078_dp,0.078_dp,0.079_dp,0.080_dp,0.081_dp,0.082_dp,0.082_dp,  &
      0.081_dp,0.081_dp,0.079_dp,0.078_dp,0.076_dp,0.073_dp,0.071_dp,  &
      0.066_dp,0.061_dp,0.059_dp,0.058_dp,0.058_dp,0.058_dp/
!
   DATA xtwarr/0.284_dp,0.307_dp,0.361_dp,0.423_dp,0.452_dp,0.445_dp,  &
      0.428_dp,0.410_dp,0.391_dp,0.373_dp,0.354_dp,0.338_dp,0.323_dp,  &
      0.310_dp,0.299_dp,0.289_dp,0.279_dp,0.272_dp,0.265_dp,0.250_dp,  &
      0.239_dp,0.228_dp,0.217_dp,0.209_dp,0.203_dp,0.198_dp,0.195_dp,  &
      0.189_dp,0.184_dp,0.179_dp,0.174_dp,0.169_dp,0.165_dp,0.157_dp,  &
      0.150_dp,0.145_dp,0.141_dp,0.138_dp,0.136_dp,0.135_dp,0.135_dp,  &
      0.137_dp,0.140_dp,0.143_dp,0.146_dp,0.148_dp,0.149_dp,0.148_dp,  &
      0.147_dp,0.145_dp,0.143_dp,0.139_dp,0.136_dp,0.133_dp,0.130_dp,  &
      0.127_dp,0.124_dp,0.123_dp,0.124_dp,0.125_dp,0.125_dp/
!
   DATA y2array/0.216_dp,0.224_dp,0.237_dp,0.260_dp,0.283_dp,0.281_dp,  &
      0.272_dp,0.263_dp,0.254_dp,0.244_dp,0.234_dp,0.226_dp,0.217_dp,  &
      0.210_dp,0.205_dp,0.198_dp,0.192_dp,0.185_dp,0.177_dp,0.140_dp,  &
      0.135_dp,0.129_dp,0.125_dp,0.119_dp,0.115_dp,0.112_dp,0.109_dp,  &
      0.106_dp,0.103_dp,0.100_dp,0.097_dp,0.094_dp,0.092_dp,0.089_dp,  &
      0.087_dp,0.086_dp,0.085_dp,0.084_dp,0.084_dp,0.084_dp,0.086_dp,  &
      0.089_dp,0.093_dp,0.096_dp,0.098_dp,0.100_dp,0.100_dp,0.100_dp,  &
      0.099_dp,0.097_dp,0.095_dp,0.093_dp,0.090_dp,0.089_dp,0.089_dp,  &
      0.091_dp,0.095_dp,0.096_dp,0.098_dp,0.100_dp,0.102_dp/
!
   DATA xtharr/-0.184_dp,-0.178_dp,-0.153_dp,-0.140_dp,-0.162_dp,  &
      -0.165_dp,-0.161_dp,-0.159_dp,-0.158_dp,-0.156_dp,-0.154_dp,-0.151_dp,  &
      0.148_dp,-0.145_dp,-0.144_dp,-0.141_dp,-0.137_dp,-0.130_dp,  &
      -0.118_dp,-0.053_dp,-0.052_dp,-0.051_dp,-0.053_dp,-0.049_dp,-0.046_dp,  &
      0.044_dp,-0.043_dp,-0.041_dp,-0.039_dp,-0.037_dp,-0.036_dp,  &
      -0.035_dp,-0.035_dp,-0.036_dp,-0.039_dp,-0.041_dp,-0.042_dp,-0.044_dp,  &
      0.045_dp,-0.048_dp,-0.051_dp,-0.056_dp,-0.061_dp,-0.065_dp,  &
      -0.067_dp,-0.069_dp,-0.069_dp,-0.068_dp,-0.067_dp,-0.065_dp,-0.063_dp,  &
      0.062_dp,-0.060_dp,-0.061_dp,-0.063_dp,-0.071_dp,-0.080_dp,  &
      -0.085_dp,-0.089_dp,-0.092_dp,-0.095_dp/
!
   DATA ytharr/0.541_dp,0.560_dp,0.592_dp,0.649_dp,0.709_dp,0.704_dp,  &
      0.680_dp,0.657_dp,0.634_dp,0.611_dp,0.586_dp,0.564_dp,0.543_dp,  &
      0.525_dp,0.512_dp,0.496_dp,0.480_dp,0.464_dp,0.442_dp,0.349_dp,  &
      0.337_dp,0.323_dp,0.311_dp,0.297_dp,0.287_dp,0.280_dp,0.274_dp,  &
      0.265_dp,0.257_dp,0.249_dp,0.243_dp,0.236_dp,0.230_dp,0.222_dp,  &
      0.219_dp,0.215_dp,0.212_dp,0.210_dp,0.210_dp,0.211_dp,0.215_dp,  &
      0.223_dp,0.231_dp,0.240_dp,0.246_dp,0.250_dp,0.251_dp,0.250_dp,  &
      0.247_dp,0.242_dp,0.237_dp,0.232_dp,0.226_dp,0.223_dp,0.222_dp,  &
      0.229_dp,0.236_dp,0.240_dp,0.246_dp,0.250_dp,0.254_dp/
!
   n=61
!
   IF(tin <= tarray(1))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(1)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(1)
         flimby=y2array(1)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(1)
         flimby=ytharr(1)
         RETURN
      END IF
   END IF
!
   IF(tin >= tarray(n))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(n)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(n)
         flimby=y2array(n)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(n)
         flimby=ytharr(n)
         RETURN
      END IF
   END IF
!
!   Find out where Tin is located in the tabulated temperature array.
!
   CALL locate(tarray,n,tin,indx)
!
   IF(ilaw <= 1)THEN
      slope=(xonarr(indx)-xonarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xonarr(indx)
      flimby=0.0_dp
      RETURN
   END IF
!
   IF(ilaw == 2)THEN
      slope=(xtwarr(indx)-xtwarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtwarr(indx)
      slope=(y2array(indx)-y2array(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+y2array(indx)
      RETURN
   END IF
!
   IF(ilaw >= 3)THEN
      slope=(xtharr(indx)-xtharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtharr(indx)
      slope=(ytharr(indx)-ytharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+ytharr(indx)
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE flck50
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE flcr50(tin,ilaw,flimbx,flimby)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)            :: tin
   INTEGER, INTENT(IN)                  :: ilaw
   REAL(KIND=dp), INTENT(OUT)           :: flimbx
   REAL(KIND=dp), INTENT(OUT)           :: flimby
!
   REAL(KIND=dp), DIMENSION(61) ::  tarray,xonarr,xtwarr,xtharr,y2array,ytharr
   REAL(KIND=dp)                ::  slope
!
   INTEGER :: n,indx
!
!DIMENSION tarray(61),xonarr(61),xtwarr(61),xtharr(61), y2array(61),ytharr(61)
!
   DATA tarray/3500.0_dp,3750.0_dp,4000.0_dp,4250.0_dp,4500.0_dp,4750.0_dp,  &
      5000.0_dp,5250.0_dp,5500.0_dp,5750.0_dp,6000.0_dp,6250.0_dp,  &
      6500.0_dp,6750.0_dp,7000.0_dp,7250.0_dp,7500.0_dp,7750.0_dp,8000.0_dp,  &
      8250.0_dp,8500.0_dp,8750.0_dp,9000.0_dp,9250.0_dp,9500.0_dp,  &
      9750.0_dp,10000.0_dp,10500.0_dp,11000.0_dp,11500.0_dp,12000.0_dp,  &
      12500.0_dp,13000.0_dp,14000.0_dp,15000.0_dp,16000.0_dp,17000.0_dp,  &
      18000.0_dp,19000.0_dp,20000.0_dp,21000.0_dp,22000.0_dp,23000.0_dp,  &
      24000.0_dp,25000.0_dp,26000.0_dp,27000.0_dp,28000.0_dp,29000.0_dp,  &
      30000.0_dp,31000.0_dp,32000.0_dp,33000.0_dp,34000.0_dp,35000.0_dp,  &
      37500.0_dp,40000.0_dp,42500.0_dp,45000.0_dp,47500.0_dp,50000.0_dp/
!
   DATA xonarr/0.553_dp,0.517_dp,0.533_dp,0.611_dp,0.668_dp,0.657_dp,  &
      0.627_dp,0.593_dp,0.558_dp,0.527_dp,0.496_dp,0.470_dp,0.448_dp,  &
      0.432_dp,0.418_dp,0.406_dp,0.394_dp,0.384_dp,0.378_dp,0.420_dp,  &
      0.407_dp,0.394_dp,0.383_dp,0.371_dp,0.360_dp,0.352_dp,0.345_dp,  &
      0.332_dp,0.322_dp,0.313_dp,0.303_dp,0.294_dp,0.285_dp,0.269_dp,  &
      0.256_dp,0.245_dp,0.237_dp,0.231_dp,0.225_dp,0.220_dp,0.216_dp,  &
      0.213_dp,0.210_dp,0.206_dp,0.203_dp,0.199_dp,0.195_dp,0.192_dp,  &
      0.190_dp,0.187_dp,0.185_dp,0.182_dp,0.178_dp,0.174_dp,0.168_dp,  &
      0.152_dp,0.139_dp,0.133_dp,0.130_dp,0.127_dp,0.125_dp/
!
   DATA xtwarr/0.778_dp,0.756_dp,0.746_dp,0.750_dp,0.751_dp,0.744_dp,  &
      0.735_dp,0.725_dp,0.711_dp,0.694_dp,0.676_dp,0.657_dp,0.640_dp,  &
      0.625_dp,0.613_dp,0.603_dp,0.594_dp,0.587_dp,0.583_dp,0.599_dp,  &
      0.588_dp,0.572_dp,0.548_dp,0.535_dp,0.525_dp,0.516_dp,0.509_dp,  &
      0.496_dp,0.484_dp,0.473_dp,0.461_dp,0.449_dp,0.437_dp,0.415_dp,  &
      0.395_dp,0.380_dp,0.368_dp,0.358_dp,0.349_dp,0.343_dp,0.337_dp,  &
      0.334_dp,0.331_dp,0.329_dp,0.327_dp,0.324_dp,0.321_dp,0.318_dp,  &
      0.315_dp,0.312_dp,0.309_dp,0.305_dp,0.300_dp,0.294_dp,0.288_dp,  &
      0.270_dp,0.252_dp,0.244_dp,0.242_dp,0.240_dp,0.240_dp/
!
   DATA y2array/0.336_dp,0.358_dp,0.320_dp,0.209_dp,0.124_dp,0.130_dp,  &
      0.163_dp,0.198_dp,0.229_dp,0.251_dp,0.270_dp,0.280_dp,0.287_dp,  &
      0.290_dp,0.293_dp,0.296_dp,0.300_dp,0.304_dp,0.307_dp,0.269_dp,  &
      0.272_dp,0.267_dp,0.247_dp,0.247_dp,0.246_dp,0.246_dp,0.246_dp,  &
      0.246_dp,0.243_dp,0.240_dp,0.236_dp,0.232_dp,0.228_dp,0.219_dp,  &
      0.210_dp,0.202_dp,0.196_dp,0.191_dp,0.187_dp,0.184_dp,0.182_dp,  &
      0.181_dp,0.182_dp,0.184_dp,0.186_dp,0.188_dp,0.189_dp,0.189_dp,  &
      0.188_dp,0.188_dp,0.187_dp,0.185_dp,0.183_dp,0.181_dp,0.179_dp,  &
      0.176_dp,0.170_dp,0.167_dp,0.168_dp,0.170_dp,0.172_dp/
!
   DATA xtharr/0.049_dp,-0.020_dp,0.053_dp,0.298_dp,0.481_dp,0.463_dp,  &
      0.383_dp,0.295_dp,0.215_dp,0.150_dp,0.091_dp,0.050_dp,0.018_dp,  &
      -0.003_dp,-0.022_dp,-0.038_dp,-0.057_dp,-0.072_dp,-0.083_dp,0.017_dp,  &
      -0.001_dp,-0.006_dp,0.013_dp,0.000_dp,-0.009_dp,-0.018_dp,-0.025_dp,  &
      -0.036_dp,-0.042_dp,-0.047_dp,-0.051_dp,-0.054_dp,-0.057_dp,  &
      -0.059_dp,-0.059_dp,-0.057_dp,-0.056_dp,-0.055_dp,-0.055_dp,-0.055_dp,  &
      0.056_dp,-0.059_dp,-0.063_dp,-0.069_dp,-0.076_dp,-0.082_dp,  &
      -0.087_dp,-0.091_dp,-0.093_dp,-0.094_dp,-0.095_dp,-0.096_dp,-0.096_dp,  &
      00.097_dp,-0.100_dp,-0.112_dp,-0.116_dp,-0.118_dp,-0.122_dp,-0.128_dp, &
      -0.134_dp/
!
   DATA ytharr/0.841_dp,0.896_dp,0.800_dp,0.522_dp,0.311_dp,0.324_dp,  &
      0.406_dp,0.496_dp,0.572_dp,0.628_dp,0.676_dp,0.701_dp,0.718_dp,  &
      0.725_dp,0.733_dp,0.740_dp,0.751_dp,0.761_dp,0.768_dp,0.672_dp,  &
      0.679_dp,0.667_dp,0.617_dp,0.617_dp,0.616_dp,0.616_dp,0.616_dp,  &
      0.614_dp,0.607_dp,0.600_dp,0.591_dp,0.580_dp,0.570_dp,0.546_dp,  &
      0.524_dp,0.504_dp,0.489_dp,0.476_dp,0.467_dp,0.459_dp,0.454_dp,  &
      0.453_dp,0.455_dp,0.459_dp,0.465_dp,0.469_dp,0.471_dp,0.471_dp,  &
      0.471_dp,0.470_dp,0.467_dp,0.463_dp,0.457_dp,0.451_dp,0.448_dp,  &
      0.440_dp,0.424_dp,0.418_dp,0.420_dp,0.425_dp,0.431_dp/
!
   n=61
!
   IF(tin <= tarray(1))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(1)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(1)
         flimby=y2array(1)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(1)
         flimby=ytharr(1)
         RETURN
      END IF
   END IF
!
   IF(tin >= tarray(n))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(n)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(n)
         flimby=y2array(n)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(n)
         flimby=ytharr(n)
         RETURN
      END IF
   END IF
!
!   Find out where Tin is located in the tabulated temperature array.
!
   CALL locate(tarray,n,tin,indx)
!
   IF(ilaw <= 1)THEN
      slope=(xonarr(indx)-xonarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xonarr(indx)
      flimby=0.0_dp
      RETURN
   END IF
!
   IF(ilaw == 2)THEN
      slope=(xtwarr(indx)-xtwarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtwarr(indx)
      slope=(y2array(indx)-y2array(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+y2array(indx)
      RETURN
   END IF
!
   IF(ilaw >= 3)THEN
      slope=(xtharr(indx)-xtharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtharr(indx)
      slope=(ytharr(indx)-ytharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+ytharr(indx)
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE flcr50
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE flcu00(tin,ilaw,flimbx,flimby)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)            :: tin
   INTEGER, INTENT(IN)                  :: ilaw
   REAL(KIND=dp), INTENT(OUT)           :: flimbx
   REAL(KIND=dp), INTENT(OUT)           :: flimby
!
   REAL(KIND=dp), DIMENSION(11) ::  tarray,xonarr,xtwarr,xtharr,y2array,ytharr
   REAL(KIND=dp)                ::  slope
!
   INTEGER :: n,indx
!
!DIMENSION tarray(11),xonarr(11),xtwarr(11),xtharr(11), y2array(11),ytharr(11)
!
   DATA tarray/3500.0_dp,3750.0_dp,4000.0_dp,4250.0_dp,4500.0_dp,4750.0_dp,  &
      5000.0_dp,5250.0_dp,5500.0_dp,5750.0_dp,6000.0_dp/
!
   DATA xonarr/0.745_dp,0.934_dp,1.078_dp,1.076_dp,1.025_dp,0.973_dp,  &
      0.931_dp,0.893_dp,0.922_dp,0.896_dp,0.884_dp/
!
   DATA xtwarr/0.782_dp,0.761_dp,0.776_dp,0.795_dp,0.798_dp,0.782_dp,  &
      0.762_dp,0.750_dp,0.737_dp,0.750_dp,0.757_dp/
!
   DATA y2array/0.056_dp,-0.260_dp,-0.453_dp,-0.421_dp,-0.341_dp,  &
      -0.287_dp,-0.253_dp,-0.215_dp,-0.278_dp,-0.219_dp,-0.189_dp/
!
   DATA xtharr/0.660_dp,1.324_dp,1.758_dp,1.708_dp,1.537_dp,1.404_dp,  &
      1.311_dp,1.215_dp,1.338_dp,1.223_dp,1.168_dp/
!
   DATA ytharr/0.141_dp,-0.650_dp,-1.132_dp,-1.053_dp,-0.853_dp,  &
      -0.717_dp,-0.633_dp,-0.537_dp,-0.694_dp,-0.546_dp,-0.474_dp/
!
   n=11
!
   IF(tin <= tarray(1))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(1)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(1)
         flimby=y2array(1)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(1)
         flimby=ytharr(1)
         RETURN
      END IF
   END IF
!
   IF(tin >= tarray(n))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(n)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(n)
         flimby=y2array(n)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(n)
         flimby=ytharr(n)
         RETURN
      END IF
   END IF
!
!   Find out where Tin is located in the tabulated temperature array.
!
   CALL locate(tarray,n,tin,indx)
!
   IF(ilaw <= 1)THEN
      slope=(xonarr(indx)-xonarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xonarr(indx)
      flimby=0.0_dp
      RETURN
   END IF
!
   IF(ilaw == 2)THEN
      slope=(xtwarr(indx)-xtwarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtwarr(indx)
      slope=(y2array(indx)-y2array(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+y2array(indx)
      RETURN
   END IF
!
   IF(ilaw >= 3)THEN
      slope=(xtharr(indx)-xtharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtharr(indx)
      slope=(ytharr(indx)-ytharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+ytharr(indx)
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE flcu00
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE flcu50(tin,ilaw,flimbx,flimby)
!
   USE accur
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: tin
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: flimbx
   REAL(KIND=dp), INTENT(OUT)               :: flimby
!
   REAL(KIND=dp), DIMENSION(61) ::  tarray,xonarr,xtwarr,xtharr,y2array,ytharr
   REAL(KIND=dp)                ::  slope
!
   INTEGER :: n,indx
!
!DIMENSION tarray(61),xonarr(61),xtwarr(61),xtharr(61), y2array(61),ytharr(61)
!
   DATA tarray/3500.0_dp,3750.0_dp,4000.0_dp,4250.0_dp,4500.0_dp,4750.0_dp,  &
      5000.0_dp,5250.0_dp,5500.0_dp,5750.0_dp,6000.0_dp,6250.0_dp,  &
      6500.0_dp,6750.0_dp,7000.0_dp,7250.0_dp,7500.0_dp,7750.0_dp,8000.0_dp,  &
      8250.0_dp,8500.0_dp,8750.0_dp,9000.0_dp,9250.0_dp,9500.0_dp,  &
      9750.0_dp,10000.0_dp,10500.0_dp,11000.0_dp,11500.0_dp,12000.0_dp,  &
      12500.0_dp,13000.0_dp,14000.0_dp,15000.0_dp,16000.0_dp,17000.0_dp,  &
      18000.0_dp,19000.0_dp,20000.0_dp,21000.0_dp,22000.0_dp,23000.0_dp,  &
      24000.0_dp,25000.0_dp,26000.0_dp,27000.0_dp,28000.0_dp,29000.0_dp,  &
      30000.0_dp,31000.0_dp,32000.0_dp,33000.0_dp,34000.0_dp,35000.0_dp,  &
      37500.0_dp,40000.0_dp,42500.0_dp,45000.0_dp,47500.0_dp,50000.0_dp/
!
   DATA xonarr/0.723_dp,0.688_dp,0.760_dp,0.919_dp,1.025_dp,1.018_dp,  &
      0.985_dp,0.945_dp,0.896_dp,0.843_dp,0.786_dp,0.732_dp,0.679_dp,  &
      0.634_dp,0.595_dp,0.562_dp,0.534_dp,0.515_dp,0.504_dp,0.537_dp,  &
      0.515_dp,0.492_dp,0.471_dp,0.457_dp,0.447_dp,0.440_dp,0.436_dp,  &
      0.429_dp,0.421_dp,0.413_dp,0.402_dp,0.392_dp,0.381_dp,0.362_dp,  &
      0.346_dp,0.334_dp,0.324_dp,0.317_dp,0.311_dp,0.306_dp,0.302_dp,  &
      0.297_dp,0.293_dp,0.289_dp,0.284_dp,0.279_dp,0.274_dp,0.269_dp,  &
      0.265_dp,0.262_dp,0.258_dp,0.253_dp,0.246_dp,0.239_dp,0.231_dp,  &
      0.208_dp,0.192_dp,0.185_dp,0.181_dp,0.178_dp,0.175_dp/
!
   DATA xtwarr/0.843_dp,0.834_dp,0.831_dp,0.821_dp,0.818_dp,0.832_dp,  &
      0.847_dp,0.862_dp,0.872_dp,0.875_dp,0.871_dp,0.861_dp,0.845_dp,  &
      0.825_dp,0.805_dp,0.784_dp,0.763_dp,0.744_dp,0.726_dp,0.700_dp,  &
      0.679_dp,0.655_dp,0.629_dp,0.611_dp,0.598_dp,0.590_dp,0.584_dp,  &
      0.576_dp,0.570_dp,0.562_dp,0.553_dp,0.543_dp,0.532_dp,0.512_dp,  &
      0.494_dp,0.479_dp,0.468_dp,0.459_dp,0.452_dp,0.446_dp,0.442_dp,  &
      0.440_dp,0.438_dp,0.436_dp,0.434_dp,0.430_dp,0.426_dp,0.421_dp,  &
      0.417_dp,0.413_dp,0.409_dp,0.403_dp,0.396_dp,0.389_dp,0.380_dp,  &
      0.355_dp,0.334_dp,0.325_dp,0.322_dp,0.320_dp,0.318_dp/
!
   DATA y2array/0.181_dp,0.220_dp,0.107_dp,-0.147_dp,-0.312_dp,  &
      -0.279_dp,-0.207_dp,-0.125_dp,-0.037_dp,0.047_dp,0.128_dp,0.193_dp,  &
      0.248_dp,0.287_dp,0.316_dp,0.333_dp,0.343_dp,0.343_dp,0.333_dp,  &
      0.245_dp,0.246_dp,0.245_dp,0.237_dp,0.231_dp,0.227_dp,0.224_dp,  &
      0.222_dp,0.220_dp,0.222_dp,0.225_dp,0.226_dp,0.227_dp,0.226_dp,  &
      0.224_dp,0.221_dp,0.218_dp,0.215_dp,0.212_dp,0.211_dp,0.210_dp,  &
      0.211_dp,0.213_dp,0.216_dp,0.220_dp,0.224_dp,0.227_dp,0.228_dp,  &
      0.228_dp,0.228_dp,0.227_dp,0.227_dp,0.225_dp,0.225_dp,0.224_dp,  &
      0.224_dp,0.221_dp,0.213_dp,0.210_dp,0.211_dp,0.213_dp,0.216_dp/
!
   DATA xtharr/0.452_dp,0.358_dp,0.600_dp,1.139_dp,1.493_dp,1.438_dp,  &
      1.296_dp,1.132_dp,0.952_dp,0.773_dp,0.594_dp,0.441_dp,0.307_dp,  &
      0.203_dp,0.121_dp,0.062_dp,0.019_dp,0.000_dp,0.005_dp,0.170_dp,  &
      0.145_dp,0.125_dp,0.115_dp,0.110_dp,0.106_dp,0.105_dp,0.103_dp,  &
      0.099_dp,0.088_dp,0.075_dp,0.063_dp,0.051_dp,0.042_dp,0.027_dp,  &
      0.014_dp,0.007_dp,0.003_dp,-0.001_dp,-0.005_dp,-0.009_dp,-0.015_dp,  &
      -0.022_dp,-0.031_dp,-0.040_dp,-0.051_dp,-0.062_dp,-0.069_dp,-0.073_dp,  &
      0.077_dp,-0.079_dp,-0.082_dp,-0.085_dp,-0.091_dp,-0.097_dp,  &
      -0.106_dp,-0.124_dp,-0.127_dp,-0.130_dp,-0.136_dp,-0.142_dp,-0.149_dp/
!
   DATA ytharr/0.452_dp,0.550_dp,0.266_dp,-0.366_dp,-0.780_dp,  &
      -0.699_dp,-0.518_dp,-0.312_dp,-0.092_dp,0.117_dp,0.319_dp,0.484_dp,  &
      0.620_dp,0.719_dp,0.789_dp,0.833_dp,0.859_dp,0.859_dp,0.832_dp,  &
      0.611_dp,0.616_dp,0.612_dp,0.593_dp,0.578_dp,0.568_dp,0.560_dp,  &
      0.554_dp,0.551_dp,0.556_dp,0.562_dp,0.566_dp,0.567_dp,0.565_dp,  &
      0.560_dp,0.554_dp,0.545_dp,0.537_dp,0.531_dp,0.527_dp,0.525_dp,  &
      0.528_dp,0.533_dp,0.541_dp,0.550_dp,0.559_dp,0.568_dp,0.571_dp,  &
      0.571_dp,0.570_dp,0.568_dp,0.567_dp,0.563_dp,0.562_dp,0.561_dp,  &
      0.561_dp,0.553_dp,0.532_dp,0.524_dp,0.528_dp,0.533_dp,0.539_dp/
!
   n=61
!
   IF(tin <= tarray(1))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(1)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(1)
         flimby=y2array(1)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(1)
         flimby=ytharr(1)
         RETURN
      END IF
   END IF
!
   IF(tin >= tarray(n))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(n)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(n)
         flimby=y2array(n)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(n)
         flimby=ytharr(n)
         RETURN
      END IF
   END IF
!
!   Find out where Tin is located in the tabulated temperature array.
!
   CALL locate(tarray,n,tin,indx)
!
   IF(ilaw <= 1)THEN
      slope=(xonarr(indx)-xonarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xonarr(indx)
      flimby=0.0_dp
      RETURN
   END IF
!
   IF(ilaw == 2)THEN
      slope=(xtwarr(indx)-xtwarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtwarr(indx)
      slope=(y2array(indx)-y2array(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+y2array(indx)
      RETURN
   END IF
!
   IF(ilaw >= 3)THEN
      slope=(xtharr(indx)-xtharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtharr(indx)
      slope=(ytharr(indx)-ytharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+ytharr(indx)
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE flcu50
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE flcv50(tin,ilaw,flimbx,flimby)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)            :: tin
   INTEGER, INTENT(IN)                  :: ilaw
   REAL(KIND=dp), INTENT(OUT)           :: flimbx
   REAL(KIND=dp), INTENT(OUT)           :: flimby
!
   REAL(KIND=dp), DIMENSION(61) ::  tarray,xonarr,xtwarr,xtharr,y2array,ytharr
   REAL(KIND=dp)                ::  slope
!
   INTEGER :: n,indx
!
!DIMENSION tarray(61),xonarr(61),xtwarr(61),xtharr(61), y2array(61),ytharr(61)
!
   DATA tarray/3500.0_dp,3750.0_dp,4000.0_dp,4250.0_dp,4500.0_dp,4750.0_dp,  &
      5000.0_dp,5250.0_dp,5500.0_dp,5750.0_dp,6000.0_dp,6250.0_dp,  &
      6500.0_dp,6750.0_dp,7000.0_dp,7250.0_dp,7500.0_dp,7750.0_dp,8000.0_dp,  &
      8250.0_dp,8500.0_dp,8750.0_dp,9000.0_dp,9250.0_dp,9500.0_dp,  &
      9750.0_dp,10000.0_dp,10500.0_dp,11000.0_dp,11500.0_dp,12000.0_dp,  &
      12500.0_dp,13000.0_dp,14000.0_dp,15000.0_dp,16000.0_dp,17000.0_dp,  &
      18000.0_dp,19000.0_dp,20000.0_dp,21000.0_dp,22000.0_dp,23000.0_dp,  &
      24000.0_dp,25000.0_dp,26000.0_dp,27000.0_dp,28000.0_dp,29000.0_dp,  &
      30000.0_dp,31000.0_dp,32000.0_dp,33000.0_dp,34000.0_dp,35000.0_dp,  &
      37500.0_dp,40000.0_dp,42500.0_dp,45000.0_dp,47500.0_dp,50000.0_dp/
!
   DATA xonarr/0.582_dp,0.549_dp,0.586_dp,0.694_dp,0.767_dp,0.759_dp,  &
      0.726_dp,0.686_dp,0.646_dp,0.610_dp,0.575_dp,0.547_dp,0.523_dp,  &
      0.506_dp,0.491_dp,0.479_dp,0.468_dp,0.457_dp,0.450_dp,0.488_dp,  &
      0.474_dp,0.464_dp,0.465_dp,0.448_dp,0.433_dp,0.421_dp,0.411_dp,  &
      0.393_dp,0.379_dp,0.366_dp,0.354_dp,0.343_dp,0.333_dp,0.314_dp,  &
      0.300_dp,0.288_dp,0.279_dp,0.271_dp,0.265_dp,0.259_dp,0.254_dp,  &
      0.250_dp,0.245_dp,0.241_dp,0.236_dp,0.231_dp,0.226_dp,0.222_dp,  &
      0.219_dp,0.216_dp,0.212_dp,0.208_dp,0.204_dp,0.198_dp,0.191_dp,  &
      0.172_dp,0.158_dp,0.151_dp,0.148_dp,0.145_dp,0.142_dp/
!
   DATA xtwarr/0.824_dp,0.790_dp,0.778_dp,0.786_dp,0.793_dp,0.795_dp,  &
      0.794_dp,0.789_dp,0.779_dp,0.764_dp,0.747_dp,0.730_dp,0.712_dp,  &
      0.698_dp,0.687_dp,0.679_dp,0.672_dp,0.668_dp,0.666_dp,0.696_dp,  &
      0.686_dp,0.671_dp,0.647_dp,0.634_dp,0.622_dp,0.612_dp,0.603_dp,  &
      0.586_dp,0.571_dp,0.556_dp,0.542_dp,0.527_dp,0.514_dp,0.488_dp,  &
      0.466_dp,0.448_dp,0.433_dp,0.421_dp,0.411_dp,0.403_dp,0.396_dp,  &
      0.390_dp,0.386_dp,0.382_dp,0.377_dp,0.372_dp,0.368_dp,0.363_dp,  &
      0.359_dp,0.355_dp,0.351_dp,0.347_dp,0.340_dp,0.333_dp,0.326_dp,  &
      0.304_dp,0.283_dp,0.274_dp,0.271_dp,0.269_dp,0.268_dp/
!
   DATA y2array/0.362_dp,0.361_dp,0.289_dp,0.139_dp,0.038_dp,0.053_dp,  &
      0.102_dp,0.154_dp,0.199_dp,0.232_dp,0.259_dp,0.274_dp,0.284_dp,  &
      0.289_dp,0.294_dp,0.299_dp,0.306_dp,0.315_dp,0.324_dp,0.312_dp,  &
      0.319_dp,0.311_dp,0.274_dp,0.279_dp,0.283_dp,0.286_dp,0.288_dp,  &
      0.290_dp,0.288_dp,0.285_dp,0.281_dp,0.276_dp,0.271_dp,0.260_dp,  &
      0.249_dp,0.239_dp,0.232_dp,0.225_dp,0.220_dp,0.216_dp,0.213_dp,  &
      0.211_dp,0.211_dp,0.211_dp,0.212_dp,0.212_dp,0.212_dp,0.211_dp,  &
      0.210_dp,0.209_dp,0.209_dp,0.207_dp,0.205_dp,0.203_dp,0.203_dp,  &
      0.198_dp,0.189_dp,0.185_dp,0.185_dp,0.186_dp,0.189_dp/
!
   DATA xtharr/0.039_dp,0.006_dp,0.153_dp,0.485_dp,0.710_dp,0.679_dp,  &
      0.573_dp,0.455_dp,0.348_dp,0.262_dp,0.187_dp,0.135_dp,0.097_dp,  &
      0.072_dp,0.050_dp,0.031_dp,0.008_dp,-0.015_dp,-0.037_dp,0.020_dp,  &
      -0.005_dp,-0.002_dp,0.054_dp,0.029_dp,0.009_dp,-0.008_dp,-0.021_dp,  &
      -0.042_dp,-0.053_dp,-0.062_dp,-0.067_dp,-0.071_dp,-0.074_dp,-0.075_dp,  &
      0.074_dp,-0.071_dp,-0.069_dp,-0.067_dp,-0.065_dp,-0.065_dp,  &
      -0.065_dp,-0.067_dp,-0.071_dp,-0.076_dp,-0.081_dp,-0.087_dp,-0.092_dp,  &
      0.094_dp,-0.097_dp,-0.098_dp,-0.100_dp,-0.103_dp,-0.104_dp,  &
      -0.107_dp,-0.114_dp,-0.125_dp,-0.125_dp,-0.126_dp,-0.130_dp,-0.135_dp, &
      -0.142_dp/
!
   DATA ytharr/0.906_dp,0.904_dp,0.721_dp,0.347_dp,0.095_dp,0.134_dp,  &
      0.255_dp,0.386_dp,0.496_dp,0.580_dp,0.647_dp,0.685_dp,0.710_dp,  &
      0.722_dp,0.735_dp,0.748_dp,0.766_dp,0.788_dp,0.811_dp,0.780_dp,  &
      0.798_dp,0.777_dp,0.684_dp,0.697_dp,0.707_dp,0.715_dp,0.719_dp,  &
      0.724_dp,0.720_dp,0.713_dp,0.703_dp,0.691_dp,0.678_dp,0.650_dp,  &
      0.622_dp,0.599_dp,0.579_dp,0.563_dp,0.550_dp,0.540_dp,0.532_dp,  &
      0.528_dp,0.527_dp,0.527_dp,0.529_dp,0.530_dp,0.530_dp,0.527_dp,  &
      0.526_dp,0.523_dp,0.521_dp,0.518_dp,0.512_dp,0.508_dp,0.508_dp,  &
      0.495_dp,0.472_dp,0.462_dp,0.463_dp,0.466_dp,0.473_dp/
!
   n=61
!
   IF(tin <= tarray(1))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(1)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(1)
         flimby=y2array(1)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(1)
         flimby=ytharr(1)
         RETURN
      END IF
   END IF
!
   IF(tin >= tarray(n))THEN
      IF(ilaw <= 1)THEN
         flimbx=xonarr(n)
         flimby=0.0_dp
         RETURN
      END IF
      IF(ilaw == 2)THEN
         flimbx=xtwarr(n)
         flimby=y2array(n)
         RETURN
      END IF
      IF(ilaw >= 3)THEN
         flimbx=xtharr(n)
         flimby=ytharr(n)
         RETURN
      END IF
   END IF
!
!   Find out where Tin is located in the tabulated temperature array.
!
   CALL locate(tarray,n,tin,indx)
!
   IF(ilaw <= 1)THEN
      slope=(xonarr(indx)-xonarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xonarr(indx)
      flimby=0.0_dp
      RETURN
   END IF
!
   IF(ilaw == 2)THEN
      slope=(xtwarr(indx)-xtwarr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtwarr(indx)
      slope=(y2array(indx)-y2array(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+y2array(indx)
      RETURN
   END IF
!
   IF(ilaw >= 3)THEN
      slope=(xtharr(indx)-xtharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimbx=slope*(tin-tarray(indx))+xtharr(indx)
      slope=(ytharr(indx)-ytharr(indx+1))/(tarray(indx)-tarray(indx+1))
      flimby=slope*(tin-tarray(indx))+ytharr(indx)
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE flcv50
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION linearintgrd(phi,rmdn,cmnx,cmny)
!
!   Computes the integrand for the log law case.
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: phi
   REAL(KIND=dp), INTENT(IN)                       :: rmdn
   REAL(KIND=dp), INTENT(IN)                       :: cmnx
   REAL(KIND=dp), INTENT(IN)                       :: cmny
!
   REAL(KIND=dp)  :: linearintgrd, xi,yi,rsq,xip,yip,bb,f
   REAL(KIND=dp)  :: sphi,cphi
!
   sphi=SIN(phi)
   cphi=COS(phi)
   xi=rmdn*cphi+cmnx
   yi=rmdn*sphi+cmny
   rsq=xi*xi+yi*yi
   xip=-rmdn*sphi
   yip=rmdn*cphi
   bb=xi*yip-yi*xip
   f=((-1.0_dp+rsq*(1.0_dp-rsq/3.0_dp))/((1.0_dp-rsq)**(1.5_dp)+1.0_dp)+0.5_dp)
   linearintgrd=f*bb
!
   RETURN
!
END FUNCTION linearintgrd
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE lineparms1(teff2,q,finc,separ,period,reff1,reff2,  &
   vrot1,vrot2,omega1,omega2,bdist,ecc,sa3,ave11,ave12,ave21,  &
   ave22,ave1,ave2,parmstring,pot1,pot2,rdepth,tertq,argper)
!
!   July 13, 2001
!
!   This subroutine is similar to parms1, except that it writes the
!   computed physical quantities on a single line.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: teff2
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: reff1
   REAL(KIND=dp), INTENT(IN)                :: reff2
   REAL(KIND=dp), INTENT(OUT)               :: vrot1
   REAL(KIND=dp), INTENT(OUT)               :: vrot2
   REAL(KIND=dp), INTENT(IN)                :: omega1
   REAL(KIND=dp), INTENT(IN)                :: omega2
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: sa3
   REAL(KIND=dp), INTENT(IN)                :: ave11
   REAL(KIND=dp), INTENT(IN)                :: ave12
   REAL(KIND=dp), INTENT(IN)                :: ave21
   REAL(KIND=dp), INTENT(IN)                :: ave22
   REAL(KIND=dp), INTENT(IN)                :: ave1
   REAL(KIND=dp), INTENT(IN)                :: ave2
   CHARACTER (LEN=1000), INTENT(OUT)        :: parmstring
   REAL(KIND=dp), INTENT(IN)                :: pot1
   REAL(KIND=dp), INTENT(IN)                :: pot2
   REAL(KIND=dp), INTENT(IN)                :: rdepth
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: argper
!
   REAL(KIND=dp) :: p,rm1,rm2,velk2,fincr,r3,duration1,overq,rm3
   REAL(KIND=dp) :: sifinc,r1,r2,gpole1,gpole2,fact,a2,a1,efact,velk1,ttt
   REAL(KIND=dp) :: hutfac,rimpact1,term1,pppp,term2,term3,duration
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   fincr=finc*degtorad
   sifinc=SIN(fincr)
!
!   Use the formula separ = coef*(perid*period*total_mass)**(1/3) to
!   solve for the total mass in solar masses.  The separation is
!   entered in solar masses, so (R_sun/coef)**3=7.737294491.
!
!           total_mass=(separ)**(3)*7.737294491d0/(ppp*ppp)
!
!   Use the value of GM_sun found from the solar system.
!
   p=period*secinday
   rm1=(separ*solarrad)**(3)*4.0_dp*pie*pie
   rm1=rm1/(gmsun*p*p*(1.0_dp+q))
   rm2=q*rm1
!
   r1=reff1*separ
   IF(teff2 > 0.0_dp)THEN
      r2=reff2*separ
   ELSE
      r2=0.00_dp
   END IF
!
   gpole1=gsun*rm1/(r1*r1)
   IF(teff2 > 0.0_dp)THEN
      gpole2=gsun*rm2/(r2*r2)
   ELSE
      gpole2=1.0_dp
   END IF
!
   fact=solarrad*twopie/secinday/1.0E+03_dp
!
   vrot1=fact*r1/period*sifinc
   vrot2=fact*r2/period*sifinc
!
   a2=separ/(1.0_dp+q)*bdist
   a1=separ*(1.0_dp-bdist/(1.0_dp+q))
!
!   UPDATE MARCH 4, 2005
!
!   Change a2 and a1 below.
!
   a2=separ/(1.0_dp+q)
   a1=separ-a2
   efact=1.0_dp/SQRT(1.0_dp-ecc*ecc)
   velk1=fact*a1/period*sifinc*efact
   velk2=fact*a2/period*sifinc*efact
!
   ttt=sa3
   IF(ttt < 0.0_dp)ttt=0.0_dp
   r3=r1*SQRT(ttt)
!
!   Add a correction factor to the rotational velocities in the
!   case of eccentric orbits.
!
   hutfac=(1.0_dp+7.5_dp*ecc*ecc+5.625_dp*ecc**4+0.3125_dp*ecc**6)/  &
      ((1.0_dp+3.0_dp*ecc*ecc+3.0_dp/8.0_dp*ecc**4)*SQRT((1.0_dp-ecc*ecc)**3))
!
   rimpact1=COS(fincr)*separ/r1
   IF(rimpact1 < 1.0_dp)THEN
      IF((1.0_dp+r2/r1)**2-rimpact1**2 >= 0.0_dp)THEN
         term1=SQRT((1.0_dp+r2/r1)**2-rimpact1**2)
      ELSE
         term1=0.0_dp
      END IF
   ELSE
      term1=0.0_dp
   END IF
   term2=period*r1/(pie*separ*SQRT(1.0_dp-ecc*ecc))
   term3=(1.0_dp-ecc*ecc)/(1.0_dp-ecc*COS(argper*degtorad))
   duration=term1*term2*term3*24.0_dp
!
   term1=1.0_dp-rimpact1**2
   term2=1.0_dp-(COS(fincr))**2
   IF(term1 >= 0.0_dp)THEN
      term3=SQRT(term1/term2)*r1/separ
   ELSE
      term3=0.0_dp
   END IF
!
   IF(ABS(term3) <= 1.0_dp)THEN
      duration1=period/pie*ASIN(term3)
   ELSE
      duration1=0.0_dp
   END IF
!
   overq=1.0_dp/q
   pppp=pot2/overq+0.5_dp*(overq-1.0_dp)/overq
!
   IF(ABS(tertq) > EPSILON(tertq))THEN
      rm3=(rm1+rm2)/tertq
   ELSE
      rm3=0.0_dp
   END IF
!
   WRITE(parmstring,10)rm1,rm2,r1,r2,r3,LOG10(gpole1),  &
      LOG10(gpole2),a1,a2,separ,velk1,velk2,vrot1,vrot2,vrot1*  &
      omega1*hutfac,vrot2*omega2*hutfac,ave11,ave12,ave21,ave22,  &
      ave1,ave2,pot1,pppp,rimpact1,duration,rdepth,duration1,rm3
!
   RETURN
!
10 FORMAT(2(f14.8,1X),3(f12.6,1X),2(f7.3,1X),3(f11.6,1X),2(f10.5,  &
      1X),4(f7.3,1X),6(f7.1,1X),2(f12.6,1X),(f9.6,1X),f9.6,1X,f9.7,  &
      1X,f9.6,2X,f14.8)
!
END SUBROUTINE lineparms1
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE loadtable(maxlines,maxmu,nlines,atmt,atmg,atmmu,  &
   nmu,atmint1,atmint2,atmint3,atmint4,atmint5,atmint6,atmint7,  &
   atmint8,tmax,tmin,gmax,gmin)
!
!   November 25, 1999
!
!   This routine will read the file with the model atmosphere data.  The
!   name is assumed to be 'ELC.atm', the the form is assumed to be the
!   following:
!
!   Teff   g
!   N_mu
!   mu1    intyU intyB intyV intyR intyI intyJ intyH intyK
!   mu2    intyU intyB intyV intyR intyI intyJ intyH intyK
!   ...
!
!   UPDATE January 9, 2009
!
!   make the variable atmint two dimensional, and have 8 copies called
!   atmint1, atmint2, ...
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: maxlines
   INTEGER, INTENT(IN)                      :: maxmu
   INTEGER, INTENT(OUT)                     :: nlines
   REAL(KIND=dp), INTENT(OUT)               :: atmt(maxlines)
   REAL(KIND=dp), INTENT(OUT)               :: atmg(maxlines)
   REAL(KIND=dp), INTENT(OUT)               :: atmmu(maxlines,maxmu)
   INTEGER, INTENT(OUT)                     :: nmu(maxlines)
   REAL(KIND=dp), INTENT(OUT)               :: atmint1(maxlines,maxmu)
   REAL(KIND=dp), INTENT(OUT)               :: atmint2(maxlines,maxmu)
   REAL(KIND=dp), INTENT(OUT)               :: atmint3(maxlines,maxmu)
   REAL(KIND=dp), INTENT(OUT)               :: atmint4(maxlines,maxmu)
   REAL(KIND=dp), INTENT(OUT)               :: atmint5(maxlines,maxmu)
   REAL(KIND=dp), INTENT(OUT)               :: atmint6(maxlines,maxmu)
   REAL(KIND=dp), INTENT(OUT)               :: atmint7(maxlines,maxmu)
   REAL(KIND=dp), INTENT(OUT)               :: atmint8(maxlines,maxmu)
   REAL(KIND=dp), INTENT(OUT)               :: tmax
   REAL(KIND=dp), INTENT(OUT)               :: tmin
   REAL(KIND=dp), INTENT(OUT)               :: gmax
   REAL(KIND=dp), INTENT(OUT)               :: gmin
!
   INTEGER :: ios,i,nskip,j
!
   CHARACTER (LEN=60) :: BLANK
   CHARACTER (LEN=1) :: bell
!
   DO i=1,maxlines
      atmt(i)=0.0_dp
      atmg(i)=0.0_dp
      DO j=1,maxmu
         atmmu(i,j)=0.0_dp
         atmint1(i,j)=0.0_dp
         atmint2(i,j)=0.0_dp
         atmint3(i,j)=0.0_dp
         atmint4(i,j)=0.0_dp
         atmint5(i,j)=0.0_dp
         atmint6(i,j)=0.0_dp
         atmint7(i,j)=0.0_dp
         atmint8(i,j)=0.0_dp
      END DO
   END DO
   ios=0
   OPEN(UNIT=19,FILE='ELC.atm',STATUS='old',ERR=70,IOSTAT=ios)
!
!   Read the header(s).
!
   nskip=0
   DO  i=1,100
      READ(19,80)BLANK
      IF(BLANK(1:2) == '#'.OR.BLANK(1:2) == '!'.OR.BLANK(1:2) ==  &
         '%')nskip=nskip+1
   END DO
!
   REWIND (19)
!
   IF(nskip <= 0)GO TO 30
   DO  i=1,nskip
      READ(19,80)BLANK
   END DO
!
!   Attempt to read in the intensity values.
!
30 tmax=-1000.0_dp
   tmin=10000000.0_dp
   gmax=-10000.0_dp
   gmin=11111.0_dp
   DO  i=1,maxlines
      READ(19,*,END=60)atmt(i),atmg(i)
      READ(19,*,END=60)nmu(i)
      IF(atmt(i) > tmax)tmax=atmt(i)
      IF(atmt(i) < tmin)tmin=atmt(i)
      IF(atmg(i) > gmax)gmax=atmg(i)
      IF(atmg(i) < gmin)gmin=atmg(i)
      DO  j=1,nmu(i)
         READ(19,*,END=60)atmmu(i,j),atmint1(i,j),atmint2(i,j),  &
            atmint3(i,j),atmint4(i,j),atmint5(i,j),atmint6(i,j),  &
            atmint7(i,j),atmint8(i,j)
!
!   Add this line to check for repeated mu values.  If there
!   is a repeat, then add 0.0001 (February 9, 2000).
!
         IF(j > 1)THEN
            IF(ABS(atmmu(i,j)-atmmu(i,j-1)) <= EPSILON(atmmu(i,j)))THEN
               atmmu(i,j-1)=atmmu(i,j-1)-0.00005_dp
            END IF
         END IF
      END DO
   END DO
60 CLOSE(19)
!
   nlines=i-1
!
70 IF(ios /= 0)THEN
      bell=CHAR(7)
      WRITE(*,90) bell
      STOP
   END IF
!
   RETURN
!
80 FORMAT(a60)
90 FORMAT(a1,'Error:  I can''t find the file ''ELC.atm''!')
!
END SUBROUTINE loadtable
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE locate(xx,n,x,j)
!
!   November 19, 1999
!
!   This routine was taken from Numerical Recipes, second edition.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: xx(n)
   REAL(KIND=dp), INTENT(IN)                :: x
   INTEGER, INTENT(OUT)                     :: j
!
   INTEGER :: jl,ju,jm
!
   jl=0
   ju=n+1
10 IF(ju-jl > 1)THEN
      jm=(ju+jl)/2
      IF((xx(n) > xx(1)).EQV.(x > xx(jm)))THEN
         jl=jm
      ELSE
         ju=jm
      END IF
      GO TO 10
   END IF
   j=jl
   RETURN
!
END SUBROUTINE locate
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION logintgrd(phi,rmdn,cmnx,cmny)
!
!   Computes the integrand for the log law case.
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: phi
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
!
   REAL(KIND=dp)  :: logintgrd, xi,yi,rsq,xip,yip,bb,f
!
   xi=rmdn*COS(phi)+cmnx
   yi=rmdn*SIN(phi)+cmny
   rsq=xi*xi+yi*yi
   xip=-rmdn*SIN(phi)
   yip=rmdn*COS(phi)
   bb=xi*yip-yi*xip
   f=-((1.0_dp-rsq)**(1.5_dp)*(LOG(1.0_dp-rsq)-2.0_dp/3.0_dp)/3.0_dp+  &
      2.0_dp/9.0_dp)/(2.0_dp*rsq)
   logintgrd=f*bb
!
   RETURN
!
END FUNCTION logintgrd
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE lpn(n,x,pn,pd)
!
!       ===============================================
!       Purpose: Compute Legendre polynomials Pn(x)
!                and their derivatives Pn'(x)
!       Input :  x --- Argument of Pn(x)
!                n --- Degree of Pn(x) ( n = 0,1,...)
!       Output:  PN(n) --- Pn(x)
!                PD(n) --- Pn'(x)
!       ===============================================
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: x
   REAL(KIND=dp), INTENT(OUT)               :: pn(0:n)
   REAL(KIND=dp), INTENT(OUT)               :: pd(0:n)
!
   REAL(KIND=dp)  :: p0,p1,pf
!
   INTEGER :: k
!
   pn(0)=1.0_dp
   pn(1)=x
   pd(0)=0.0_dp
   pd(1)=1.0_dp
   p0=1.0_dp
   p1=x
   DO  k=2,n
      pf=(2.0_dp*REAL(k,KIND=dp)-1.0_dp)/REAL(k,KIND=dp)*x*p1-REAL(k-1,KIND=dp)/REAL(k,KIND=dp)*p0
      pn(k)=pf
      IF(ABS(ABS(x)-1.0_dp) <= EPSILON(x))THEN
         pd(k)=0.5_dp*x**REAL(k+1,KIND=dp)*REAL(k,KIND=dp)*(REAL(k+1,KIND=dp))
      ELSE
         pd(k)=REAL(k,KIND=dp)*(p1-x*pf)/(1.0_dp-x*x)
      END IF
      p0=p1
      p1=pf
   END DO
   RETURN
!
END SUBROUTINE lpn
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE lttsky(odetime,nstep,timein,xout,yout,ndyn,pos_x,  &
   pos_y,pos_z,vel_x,vel_y,vel_z,ii)
!
!   will find x,y sky coordinates from the solution to the
!   differential equations
!
   USE accur
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   REAL(KIND=dp), INTENT(IN)                :: odetime(ndyn)
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN)                :: timein
   REAL(KIND=dp), INTENT(OUT)               :: xout
   REAL(KIND=dp), INTENT(OUT)               :: yout
   REAL(KIND=dp), INTENT(IN)                :: pos_x(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: pos_y(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: pos_z(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: vel_x(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: vel_y(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: vel_z(ndyn)
   INTEGER, INTENT(IN OUT)                  :: ii
!
   REAL(KIND=dp)  ::  zout1,velout,tr,deltat,xout1,yout1
!
   INTEGER :: kk
!
!   old dimensions
!
!          DIMENSION zzq(6,60,Ndyn)
!
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   CALL hunt(odetime,nstep,timein,ii)
   CALL hermskycoord(ndyn,nstep,odetime,timein,zout1,ii,pos_z,vel_z)
!
!   trap a potential error of unknown origin whereby the
!   output z-coordinate is unusually large or small
!
   IF(ABS(zout1) > 1.0E05_dp)THEN
      xout=pos_x(ii)
      yout=pos_y(ii)
      velout=vel_z(ii)
      xout=xout/auinsolarrad
      yout=yout/auinsolarrad
      velout=velout*auperdaytompersec/1000.0_dp
      RETURN
   END IF
!
   tr=zout1/speedauperday
!          xx(1)=-Tr
   DO kk=1,2
      CALL hunt(odetime,nstep,timein+tr,ii)
      CALL hermskycoord(ndyn,nstep,odetime,timein+tr,zout1,ii,pos_z,vel_z)
      CALL hermskyvel(ndyn,nstep,odetime,timein+tr,velout,ii,vel_z)
      tr=tr-(zout1/speedauperday-tr)/(velout/speedauperday-1.0_dp)
   END DO
!
   deltat=tr   !xx(kk-1)
!
   CALL hunt(odetime,nstep,timein+deltat,ii)
   CALL hermskycoord(ndyn,nstep,odetime,timein+deltat,xout1,ii,pos_x,vel_x)
   CALL hermskycoord(ndyn,nstep,odetime,timein+deltat,yout1,ii,pos_y,vel_y)
   xout=xout1
   yout=yout1
   xout=xout/auinsolarrad
   yout=yout/auinsolarrad
!
   RETURN
!
END SUBROUTINE lttsky
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!

SUBROUTINE lttskyvel(odetime,nstep,timein,xout,yout,velout,  &
   ndyn,pos_x,pos_y,pos_z,vel_x,vel_y,vel_z,ii)
!
!   will find x,y sky coordinates from the solution to the
!   differential equations, also returns the radial velocity
!
   USE accur
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   REAL(KIND=dp), INTENT(IN)                :: odetime(ndyn)
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN)                :: timein
   REAL(KIND=dp), INTENT(OUT)               :: xout
   REAL(KIND=dp), INTENT(OUT)               :: yout
   REAL(KIND=dp), INTENT(OUT)               :: velout
   REAL(KIND=dp), INTENT(IN)                :: pos_x(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: pos_y(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: pos_z(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: vel_x(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: vel_y(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: vel_z(ndyn)
   INTEGER, INTENT(IN OUT)                  :: ii
!
   REAL(KIND=dp) :: zout1,tr,deltat,xout1,yout1
!
   INTEGER :: kk
!
!   old dimensions
!
!          DIMENSION zzq(6,60,Ndyn)
!
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   CALL hunt(odetime,nstep,timein,ii)
   CALL hermskycoord(ndyn,nstep,odetime,timein,zout1,ii,pos_z,vel_z)
!
!   trap a potential error of unknown origin whereby the
!   output z-coordinate is unusually large or small
!
   IF(ABS(zout1) > 1.0E+05_dp)THEN
      xout=pos_x(ii)
      yout=pos_y(ii)
      velout=vel_z(ii)
      xout=xout/auinsolarrad
      yout=yout/auinsolarrad
      velout=velout*auperdaytompersec/1000.0_dp
      RETURN
   END IF
!
   tr=zout1/speedauperday
!          xx(1)=-Tr
   DO kk=1,2
      CALL hunt(odetime,nstep,timein+tr,ii)
      CALL hermskycoord(ndyn,nstep,odetime,timein+tr,zout1,ii,pos_z,vel_z)
      CALL hermskyvel(ndyn,nstep,odetime,timein+tr,velout,ii,vel_z)
      tr=tr-(zout1/speedauperday-tr)/(velout/speedauperday-1.0_dp)
   END DO
!
   deltat=tr
!
   CALL hunt(odetime,nstep,timein+deltat,ii)
   CALL hermskycoord(ndyn,nstep,odetime,timein+deltat,xout1,ii,pos_x,vel_x)
   CALL hermskycoord(ndyn,nstep,odetime,timein+deltat,yout1,ii,pos_y,vel_y)
   CALL hermskyvel(ndyn,nstep,odetime,timein+deltat,velout,ii,vel_z)
   xout=xout1
   yout=yout1
   xout=xout/auinsolarrad
   yout=yout/auinsolarrad
!
   velout=velout*auperdaytompersec/1000.0_dp
!
   RETURN
!
END SUBROUTINE lttskyvel
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE m2tom1centric(rm1,rm2,period,ecc,rmeananom,argper,  &
   finc,omega,qqm2,ppm2)
!
!   this routine will compute the xyz M1-centric coordinates and velocity
!   of M2 given these orbital parameters.
!
!   rM1 and rM2 are in solar masses, period is in days.  The angles
!   argper, finc, and Omega are in degrees
!
!   The mean anomaly is a phase, and will be in radians
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: rm1
   REAL(KIND=dp), INTENT(IN)                       :: rm2
   REAL(KIND=dp), INTENT(IN)                       :: period
   REAL(KIND=dp), INTENT(IN)                       :: ecc
   REAL(KIND=dp), INTENT(IN)                       :: rmeananom
   REAL(KIND=dp), INTENT(IN)                       :: argper
   REAL(KIND=dp), INTENT(IN)                       :: finc
   REAL(KIND=dp), INTENT(IN)                       :: omega
   REAL(KIND=dp), INTENT(OUT)                      :: qqm2(3)
   REAL(KIND=dp), INTENT(OUT)                      :: ppm2(3)
!
   REAL(KIND=dp) :: omegarad,a,p,h,cc,bige,f,r,fincr,argperrad
   REAL(KIND=dp) :: omcos,omsin,finccos,fincsin,argcos,argsin,t1,t2,t3
!
   INTEGER :: i
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
!   Find the separation
!
   a=(g*(rm1+rm2)*period*period/(4.0_dp*pie*pie))**(1.0_dp/3.0_dp)
   p=a*(1.0_dp-ecc**2)
   h=SQRT(g*(rm1+rm2)*p)
!
!   Find the true anomaly f
!
   cc=rmeananom
   cc=MOD(cc,twopie)
   cc=cc-twopie
   bige=cc
   IF(bige < twopie)bige=bige+twopie
!
   DO i=1,10
      bige=bige-(bige-ecc*SIN(bige)-cc)/(1.0_dp-ecc*COS(bige))
   END DO
!
   f=2.0_dp*ATAN(SQRT((1.0_dp+ecc)/(1.0_dp-ecc))*TAN(bige/2.0_dp))
   r=a*(1.0_dp-ecc*COS(bige))
!
!     position in orbital plane
!
   qqm2(1)=r*COS(f)
   qqm2(2)=r*SIN(f)
   qqm2(3)=0.0_dp
!
!          PeriX(1)=a*(1.0d0-ecc)
!          PeriX(2)=0.0d0
!          PeriX(3)=0.0d0
!
!     velocity in orbital plane
!
   ppm2(1)=h*(-SIN(f)/r+ecc/p*SIN(f)*COS(f))
   ppm2(2)=h*(COS(f)/r+ecc/p*SIN(f)*SIN(f))
   ppm2(3)=0.0_dp
!
!   rotate through the longitude angle, then the inclination angle, and then
!   through argper angle
!
   fincr=finc
   argperrad=argper
   omegarad=omega
   omcos=COS(omegarad)
   omsin=SIN(omegarad)
   finccos=COS(fincr)
   fincsin=SIN(fincr)
   argcos=COS(argperrad)
   argsin=SIN(argperrad)
!
!   rotate velocity vector by -argper
!
   t1=qqm2(1)*argcos-qqm2(2)*argsin
   t2=qqm2(1)*argsin+qqm2(2)*argcos
   t3=qqm2(3)
   qqm2(1)=t1
   qqm2(2)=t2
   qqm2(3)=t3
!
!   rotate the result by finc
!
   t1=qqm2(1)
   t2=qqm2(2)*finccos-qqm2(3)*fincsin
   t3=qqm2(2)*fincsin+qqm2(3)*finccos
   qqm2(1)=t1
   qqm2(2)=t2
   qqm2(3)=t3
!
!   rotate by -Omega
!
   t1=qqm2(1)*omcos-qqm2(2)*omsin
   t2=qqm2(1)*omsin+qqm2(2)*omcos
   t3=qqm2(3)
   qqm2(1)=t1
   qqm2(2)=t2
   qqm2(3)=t3
!
!   rotate velocity vector by -argper
!
   t1=ppm2(1)*argcos-ppm2(2)*argsin
   t2=ppm2(1)*argsin+ppm2(2)*argcos
   t3=ppm2(3)
   ppm2(1)=t1
   ppm2(2)=t2
   ppm2(3)=t3
!
!   rotate the result by finc
!
   t1=ppm2(1)
   t2=ppm2(2)*finccos-ppm2(3)*fincsin
   t3=ppm2(2)*fincsin+ppm2(3)*finccos
   ppm2(1)=t1
   ppm2(2)=t2
   ppm2(3)=t3
!
!   rotate by -Omega
!
   t1=ppm2(1)*omcos-ppm2(2)*omsin
   t2=ppm2(1)*omsin+ppm2(2)*omcos
   t3=ppm2(3)
   ppm2(1)=t1
   ppm2(2)=t2
   ppm2(3)=t3
!
   RETURN
!
END SUBROUTINE m2tom1centric
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE modellength(ngap,gaplow,gaphigh,ntime,  &
   tstart,tstop,tstep,itime,dphase)
!
!   Will determine the length of the arrays needed for the models
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ngap
   REAL(KIND=dp), INTENT(IN)                :: gaplow(9999)
   REAL(KIND=dp), INTENT(IN)                :: gaphigh(9999)
   INTEGER, INTENT(OUT)                     :: ntime
   REAL(KIND=dp), INTENT(IN)                :: tstart
   REAL(KIND=dp), INTENT(IN)                :: tstop
   REAL(KIND=dp), INTENT(IN)                :: tstep
   INTEGER, INTENT(IN)                      :: itime
   REAL(KIND=dp), INTENT(IN)                :: dphase
!
   REAL(KIND=dp)  :: tt
   REAL(KIND=dp), ALLOCATABLE  :: timearray(:)
!
   INTEGER :: icount,ijk,icounttime,i,nlength
!
   IF(itime <= 1)THEN
      ntime=INT(720.0_dp/dphase)
      ntime=ntime+10
      RETURN
   END IF
!
   nlength=INT((tstop-tstart)/tstep)+10
   ALLOCATE(timearray(nlength))
!
   ntime=0
   DO i=1,nlength
      tt=tstart+REAL(i-1,KIND=dp)*tstep
      IF(tt > tstop)EXIT
      ntime=ntime+1
      timearray(ntime)=tt
   END DO
   timearray(ntime+1)=timearray(ntime)+tstep
   ntime=ntime+1
!
   icount=0
!
   loop10: DO  icounttime=1,ntime
      DO ijk=1,ngap
         IF((timearray(icounttime) > gaplow(ijk)).AND.  &
            (timearray(icounttime) < gaphigh(ijk)))THEN
            CYCLE loop10
         END IF
      END DO
      icount=icount+1
   END DO loop10
!
   ntime=icount+10
!
   DEALLOCATE(timearray)
!
   RETURN
!
END SUBROUTINE modellength
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE movetoastrocentric(nbody,rmass,qq,pp,qqbc,ppbc)
!
!   inverts newmovetobarycenter
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: qq(30)
   REAL(KIND=dp), INTENT(IN)                :: pp(30)
   REAL(KIND=dp), INTENT(OUT)               :: qqbc(30)
   REAL(KIND=dp), INTENT(OUT)               :: ppbc(30)
!
   REAL(KIND=dp) :: eta,tempmass,shiftvy,shiftz,shiftvz
   REAL(KIND=dp) :: totalmass,summ,shiftx,shiftvx,shifty
!
   INTEGER :: i,j
!
   DIMENSION eta(0:9),tempmass(0:9)
!
   totalmass=0.0_dp
   DO i=1,nbody
      totalmass=totalmass+rmass(i)
   END DO
!
   DO i=0,nbody-1
      tempmass(i)=rmass(i+1)
   END DO
!
   DO i=0,nbody-1
      summ=0.0_dp
      DO j=0,i
         summ=summ+tempmass(j)
      END DO
      eta(i)=summ
   END DO
!
   DO i=nbody-1,nbody-1
      qqbc(3*i+1)=eta(nbody-1)/eta(nbody-2)*qq(3*i+1)
      qqbc(3*i+2)=eta(nbody-1)/eta(nbody-2)*qq(3*i+2)
      qqbc(3*i+3)=eta(nbody-1)/eta(nbody-2)*qq(3*i+3)
      ppbc(3*i+1)=pp(3*i+1)*tempmass(i)
      ppbc(3*i+2)=pp(3*i+2)*tempmass(i)
      ppbc(3*i+3)=pp(3*i+3)*tempmass(i)
   END DO
!
   shiftx=qq(1)
   shiftvx=pp(1)
   qqbc(1)=qq(1)-shiftx
   qqbc(4)=qq(4)-shiftx
   ppbc(1)=pp(1)-shiftvx
   ppbc(4)=pp(4)-shiftvx
!
   shifty=qq(2)
   shiftvy=pp(2)
   qqbc(2)=qq(2)-shifty
   qqbc(5)=qq(5)-shifty
   ppbc(2)=pp(2)-shiftvy
   ppbc(5)=pp(5)-shiftvy
!
   shiftz=qq(3)
   shiftvz=pp(3)
   qqbc(3)=qq(3)-shiftz
   qqbc(6)=qq(6)-shiftz
   ppbc(3)=pp(3)-shiftvz
   ppbc(6)=pp(6)-shiftvz
!
   RETURN
!
END SUBROUTINE movetoastrocentric
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE movetobarycenter(nbody,rmass,qq,pp,qqbc,ppbc)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: qq(30)
   REAL(KIND=dp), INTENT(IN)                :: pp(30)
   REAL(KIND=dp), INTENT(OUT)               :: qqbc(30)
   REAL(KIND=dp), INTENT(OUT)               :: ppbc(30)
!
   REAL(KIND=dp) ::  totalmass,cmx,cmy,cmz,vx,vy,vz
!
   INTEGER :: i
!
   totalmass=0.0_dp
   DO i=1,nbody
      totalmass=totalmass+rmass(i)
   END DO
!
   cmx=0.0_dp
   cmy=0.0_dp
   cmz=0.0_dp
   vx=0.0_dp
   vy=0.0_dp
   vz=0.0_dp
   DO i=0,nbody-1
      cmx=cmx+qq(3*i+1)*rmass(i+1)
      cmy=cmy+qq(3*i+2)*rmass(i+1)
      cmz=cmz+qq(3*i+3)*rmass(i+1)
      vx=vx+pp(3*i+1)*rmass(i+1)
      vy=vy+pp(3*i+2)*rmass(i+1)
      vz=vz+pp(3*i+3)*rmass(i+1)
   END DO
   cmx=cmx/totalmass
   cmy=cmy/totalmass
   cmz=cmz/totalmass
   vx=vx/totalmass
   vy=vy/totalmass
   vz=vz/totalmass
!
   DO i=0,nbody-1
      qqbc(3*i+1)=qq(3*i+1)-cmx
      qqbc(3*i+2)=qq(3*i+2)-cmy
      qqbc(3*i+3)=qq(3*i+3)-cmz
      ppbc(3*i+1)=pp(3*i+1)-vx
      ppbc(3*i+2)=pp(3*i+2)-vy
      ppbc(3*i+3)=pp(3*i+3)-vz
   END DO
!
   IF(nbody <= 2)RETURN
!
   RETURN
!
END SUBROUTINE movetobarycenter
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE newcartkep(nbody,rmass,qq,pp,tref,p_arr,ecc_arr,  &
   a_arr,ma_arr,argper_arr,inc_arr,long_arr,tconj_arr,f_arr)
!
!    Converts Cartesian x,y,z to Keplerian
!
!    p_arr = array of periods (index 1 for binary,
!        2 for third star, ...)
!    ecc_arr = array of eccentricities
!    a_arr = array of semimajor axes
!    MA_arr = array of mean anonalies
!    ArgPer_arr = array of argument of periastrons
!    inc_arr = array of inclinations
!    long_arr = array of mean longitudes
!    Tconj_arr = array of Tconj times
!    f_arr = array of true anomalies
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: qq(30)
   REAL(KIND=dp), INTENT(IN)                :: pp(30)
   REAL(KIND=dp), INTENT(IN)                :: tref
   REAL(KIND=dp), INTENT(OUT)               :: p_arr(9)
   REAL(KIND=dp), INTENT(OUT)               :: ecc_arr(9)
   REAL(KIND=dp), INTENT(OUT)               :: a_arr(9)
   REAL(KIND=dp), INTENT(OUT)               :: ma_arr(9)
   REAL(KIND=dp), INTENT(OUT)               :: argper_arr(9)
   REAL(KIND=dp), INTENT(OUT)               :: inc_arr(9)
   REAL(KIND=dp), INTENT(OUT)               :: long_arr(9)
   REAL(KIND=dp), INTENT(OUT)               :: tconj_arr(9)
   REAL(KIND=dp), INTENT(OUT)               :: f_arr(9)
!
   REAL(KIND=dp)  :: posx,posy,posz,w,m,trueatomeana,fmod
   REAL(KIND=dp)  :: velx,vely,velz,m1,m2,angmx,angmy,angmz,lenam,lenpos
   REAL(KIND=dp)  :: lenvel,mu,p,c,cwf,swf,wf,f,e,aa,bb,posbbcx
   REAL(KIND=dp)  :: posbbcy,posbbcz,velbbcx,velbbcy,velbbcz,totmass
!
   INTEGER :: ibody,jndx,i
!
   DIMENSION  w(9)
!
!  Initalize
!
   DO i=1,9
      p_arr(i)=0.0_dp
      ecc_arr(i)=0.0_dp
      a_arr(i)=0.0_dp
      ma_arr(i)=0.0_dp
      argper_arr(i)=0.0_dp
      inc_arr(i)=0.0_dp
      long_arr(i)=0.0_dp
      tconj_arr(i)=0.0_dp
   END DO
!
!  Get the constants.
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
!  Start with the binary
!
   jndx=1
   ibody=3
   posx=qq(1+ibody)-qq(1)
   posy=qq(2+ibody)-qq(2)
   posz=qq(3+ibody)-qq(3)
   velx=pp(1+ibody)-pp(1)
   vely=pp(2+ibody)-pp(2)
   velz=pp(3+ibody)-pp(3)
   m1=rmass(1)
   m2=rmass(2)
   mu=g*(m1+m2)
!
!   Find the direction of the angular momentum
!   vector.
!
   angmx=posy*velz-posz*vely
   angmy=posz*velx-posx*velz
   angmz=posx*vely-posy*velx
   lenam=SQRT(angmx**2+angmy**2+angmz**2)
   lenpos=SQRT(posx**2+posy**2+posz**2)
   lenvel=SQRT(velx**2+vely**2+velz**2)
   p=lenam**2/mu
   c=lenvel**2/2.0_dp-mu/lenpos
!
!   Semimajor axis in AU.
!
   a_arr(jndx)=-mu/(2.0_dp*c)
!
!   Period in days from Kepler's Third Law
!
   p_arr(jndx)=SQRT(4.0_dp*pie*pie*a_arr(jndx)**3/mu)
!
!   eccentricity.
!
   IF(1.0_dp-p/a_arr(jndx) < 0.0_dp)THEN
      ecc_arr(jndx)=0.0_dp
   ELSE
      ecc_arr(jndx)=SQRT(1.0_dp-p/a_arr(jndx))
   END IF
!
!   inclination.
!
   inc_arr(jndx)=ACOS(angmz/lenam)
!
!   Omega
!
   IF(ABS(angmy) > EPSILON(angmy))THEN
      long_arr(jndx)=ATAN(-angmx/angmy)
   ELSE
      IF(angmx < 0.0_dp)THEN
         long_arr(jndx)=halfpie
      ELSE
         long_arr(jndx)=-halfpie
      END IF
   END IF
!
   cwf=(posx*COS(long_arr(jndx))+posy*SIN(long_arr(jndx)))/lenpos
   swf=(posz/SIN(inc_arr(jndx)))/lenpos
   wf=ATAN2(swf,cwf)
   aa=lenam**2/(mu*lenpos)-1.0_dp
   bb=(lenam*(posx*velx+posy*vely+posz*velz))/(mu*lenpos)
!
!    true anomaly
!
   f=ATAN2(bb,aa)
   f_arr(jndx)=f
   argper_arr(jndx)=wf-f
   fmod=MOD(f,twopie)
   IF(fmod < 0.0_dp)fmod=fmod+twopie
   IF(fmod > pie)THEN
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=twopie
      ELSE
        e=-ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   ELSE
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=halfpie
      ELSE
        e=ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   END IF
!
!    mean anomaly
!
   ma_arr(jndx)=e-ecc_arr(jndx)*SIN(e)
!
!    get Tconj
!
   m=trueatomeana(halfpie-argper_arr(jndx),ecc_arr(jndx))
   tconj_arr(jndx)=tref+(m-ma_arr(jndx))*p_arr(jndx)/twopie
!
   IF(ma_arr(jndx) < 0.0_dp)ma_arr(jndx)=ma_arr(jndx)+twopie
   IF(f_arr(jndx) < 0.0_dp)f_arr(jndx)=f_arr(jndx)+twopie
   IF(argper_arr(jndx) < 0.0_dp)argper_arr(jndx)=argper_arr(jndx)+twopie
!
!   Now move on to the third body, assuming Jacobi coordinates
!
   jndx=2
   totmass=rmass(1)+rmass(2)
   w(1)=rmass(1)/totmass
   w(2)=rmass(2)/totmass
   posbbcx=0.0_dp
   posbbcy=0.0_dp
   posbbcz=0.0_dp
   velbbcx=0.0_dp
   velbbcy=0.0_dp
   velbbcz=0.0_dp
!
   ibody=3
   DO i=1,2
      posbbcx=posbbcx+w(i)*qq(1+(i-1)*ibody)
      posbbcy=posbbcy+w(i)*qq(2+(i-1)*ibody)
      posbbcz=posbbcz+w(i)*qq(3+(i-1)*ibody)
      velbbcx=velbbcx+w(i)*pp(1+(i-1)*ibody)
      velbbcy=velbbcy+w(i)*pp(2+(i-1)*ibody)
      velbbcz=velbbcz+w(i)*pp(3+(i-1)*ibody)
   END DO
   ibody=6
   posx=qq(1+ibody)-posbbcx
   posy=qq(2+ibody)-posbbcy
   posz=qq(3+ibody)-posbbcz
   velx=pp(1+ibody)-velbbcx
   vely=pp(2+ibody)-velbbcy
   velz=pp(3+ibody)-velbbcz
   m1=rmass(1)+rmass(2)
   m2=rmass(3)
   mu=g*(m1+m2)
!
!   Find the direction of the angular momentum
!   vector.
!
   angmx=posy*velz-posz*vely
   angmy=posz*velx-posx*velz
   angmz=posx*vely-posy*velx
   lenam=SQRT(angmx**2+angmy**2+angmz**2)
   lenpos=SQRT(posx**2+posy**2+posz**2)
   lenvel=SQRT(velx**2+vely**2+velz**2)
   p=lenam**2/mu
   c=lenvel**2/2.0_dp-mu/lenpos
!
!   Semimajor axis in AU.
!
   a_arr(jndx)=-mu/(2.0_dp*c)
!
!   Period in days from Kepler's Third Law
!
   p_arr(jndx)=SQRT(4.0_dp*pie*pie*a_arr(jndx)**3/mu)
!
!   eccentricity.
!
   IF(1.0_dp-p/a_arr(jndx) < 0.0_dp)THEN
      ecc_arr(jndx)=0.0_dp
   ELSE
      ecc_arr(jndx)=SQRT(1.0_dp-p/a_arr(jndx))
   END IF
!
!   inclination.
!
   inc_arr(jndx)=ACOS(angmz/lenam)
!
!   mean longitude
!
   IF(ABS(angmy) > EPSILON(angmy))THEN
      long_arr(jndx)=ATAN(-angmx/angmy)
   ELSE
      IF(angmx < 0.0_dp)THEN
         long_arr(jndx)=halfpie
      ELSE
         long_arr(jndx)=-halfpie
      END IF
   END IF
!
   cwf=(posx*COS(long_arr(jndx))+posy*SIN(long_arr(jndx)))/lenpos
   swf=(posz/SIN(inc_arr(jndx)))/lenpos
   wf=ATAN2(swf,cwf)
   aa=lenam**2/(mu*lenpos)-1.0_dp
   bb=(lenam*(posx*velx+posy*vely+posz*velz))/(mu*lenpos)
!
!    true anomaly
!
   f=ATAN2(bb,aa)
   f_arr(jndx)=f
   argper_arr(jndx)=wf-f
   fmod=MOD(f,twopie)
   IF(fmod < 0.0_dp)fmod=fmod+twopie
   IF(fmod > pie)THEN
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=twopie
      ELSE
        e=-ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   ELSE
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=halfpie
      ELSE
        e=ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   END IF
!
!    mean anomaly
!
   ma_arr(jndx)=e-ecc_arr(jndx)*SIN(e)
!
!    get Tconj
!
   m=trueatomeana(halfpie-argper_arr(jndx),ecc_arr(jndx))
   tconj_arr(jndx)=tref+(m-ma_arr(jndx))*p_arr(jndx)/twopie
!
   IF(ma_arr(jndx) < 0.0_dp)ma_arr(jndx)=ma_arr(jndx)+twopie
   IF(f_arr(jndx) < 0.0_dp)f_arr(jndx)=f_arr(jndx)+twopie
   IF(argper_arr(jndx) < 0.0_dp)argper_arr(jndx)=argper_arr(jndx)+twopie
!
!    Return if Nbody = 3
!
   IF(nbody == 3)RETURN
!
!   Body 4
!
   jndx=3
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   DO i=1,jndx
      w(i)=rmass(i)/totmass
   END DO
!
   posbbcx=0.0_dp
   posbbcy=0.0_dp
   posbbcz=0.0_dp
   velbbcx=0.0_dp
   velbbcy=0.0_dp
   velbbcz=0.0_dp
   ibody=3
   DO i=1,jndx
      posbbcx=posbbcx+w(i)*qq(1+(i-1)*ibody)
      posbbcy=posbbcy+w(i)*qq(2+(i-1)*ibody)
      posbbcz=posbbcz+w(i)*qq(3+(i-1)*ibody)
      velbbcx=velbbcx+w(i)*pp(1+(i-1)*ibody)
      velbbcy=velbbcy+w(i)*pp(2+(i-1)*ibody)
      velbbcz=velbbcz+w(i)*pp(3+(i-1)*ibody)
   END DO
!
   ibody=9
   posx=qq(1+ibody)-posbbcx
   posy=qq(2+ibody)-posbbcy
   posz=qq(3+ibody)-posbbcz
   velx=pp(1+ibody)-velbbcx
   vely=pp(2+ibody)-velbbcy
   velz=pp(3+ibody)-velbbcz
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   m1=totmass
   m2=rmass(jndx+1)
   mu=g*(m1+m2)
!
!   Find the direction of the angular momentum
!   vector.
!
   angmx=posy*velz-posz*vely
   angmy=posz*velx-posx*velz
   angmz=posx*vely-posy*velx
   lenam=SQRT(angmx**2+angmy**2+angmz**2)
   lenpos=SQRT(posx**2+posy**2+posz**2)
   lenvel=SQRT(velx**2+vely**2+velz**2)
   p=lenam**2/mu
   c=lenvel**2/2.0_dp-mu/lenpos
!
!   Semimajor axis in AU.
!
   a_arr(jndx)=-mu/(2.0_dp*c)
!
!   Period in days from Kepler's Third Law
!
   p_arr(jndx)=SQRT(4.0_dp*pie*pie*a_arr(jndx)**3/mu)
!
!   eccentricity.
!
   IF(1.0_dp-p/a_arr(jndx) < 0.0_dp)THEN
      ecc_arr(jndx)=0.0_dp
   ELSE
      ecc_arr(jndx)=SQRT(1.0_dp-p/a_arr(jndx))
   END IF
!
!   inclination.
!
   inc_arr(jndx)=ACOS(angmz/lenam)
!
!   mean longitude
!
   IF(ABS(angmy) > EPSILON(angmy))THEN
      long_arr(jndx)=ATAN(-angmx/angmy)
   ELSE
      IF(angmx < 0.0_dp)THEN
         long_arr(jndx)=halfpie
      ELSE
         long_arr(jndx)=-halfpie
      END IF
   END IF
!
   cwf=(posx*COS(long_arr(jndx))+posy*SIN(long_arr(jndx)))/lenpos
   swf=(posz/SIN(inc_arr(jndx)))/lenpos
   wf=ATAN2(swf,cwf)
   aa=lenam**2/(mu*lenpos)-1.0_dp
   bb=(lenam*(posx*velx+posy*vely+posz*velz))/(mu*lenpos)
!
!    true anomaly
!
   f=ATAN2(bb,aa)
   f_arr(jndx)=f
   argper_arr(jndx)=wf-f
   fmod=MOD(f,twopie)
   IF(fmod < 0.0_dp)fmod=fmod+twopie
   IF(fmod > pie)THEN
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=twopie
      ELSE
        e=-ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   ELSE
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=halfpie
      ELSE
        e=ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   END IF
!
!    mean anomaly
!
   ma_arr(jndx)=e-ecc_arr(jndx)*SIN(e)
!
!    get Tconj
!
   m=trueatomeana(halfpie-argper_arr(jndx),ecc_arr(jndx))
   tconj_arr(jndx)=tref+(m-ma_arr(jndx))*p_arr(jndx)/twopie
!
   IF(ma_arr(jndx) < 0.0_dp)ma_arr(jndx)=ma_arr(jndx)+twopie
   IF(f_arr(jndx) < 0.0_dp)f_arr(jndx)=f_arr(jndx)+twopie
   IF(argper_arr(jndx) < 0.0_dp)argper_arr(jndx)=argper_arr(jndx)+twopie
!
!    Return if Nbody = 4.
!
   IF(nbody == 4)RETURN
!
!    body 5 orbit
!
   jndx=4
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   DO i=1,jndx
      w(i)=rmass(i)/totmass
   END DO
!
   posbbcx=0.0_dp
   posbbcy=0.0_dp
   posbbcz=0.0_dp
   velbbcx=0.0_dp
   velbbcy=0.0_dp
   velbbcz=0.0_dp
   ibody=3
   DO i=1,jndx
      posbbcx=posbbcx+w(i)*qq(1+(i-1)*ibody)
      posbbcy=posbbcy+w(i)*qq(2+(i-1)*ibody)
      posbbcz=posbbcz+w(i)*qq(3+(i-1)*ibody)
      velbbcx=velbbcx+w(i)*pp(1+(i-1)*ibody)
      velbbcy=velbbcy+w(i)*pp(2+(i-1)*ibody)
      velbbcz=velbbcz+w(i)*pp(3+(i-1)*ibody)
   END DO
!
   ibody=12
   posx=qq(1+ibody)-posbbcx
   posy=qq(2+ibody)-posbbcy
   posz=qq(3+ibody)-posbbcz
   velx=pp(1+ibody)-velbbcx
   vely=pp(2+ibody)-velbbcy
   velz=pp(3+ibody)-velbbcz
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   m1=totmass
   m2=rmass(jndx+1)
   mu=g*(m1+m2)
!
!   Find the direction of the angular momentum
!   vector.
!
   angmx=posy*velz-posz*vely
   angmy=posz*velx-posx*velz
   angmz=posx*vely-posy*velx
   lenam=SQRT(angmx**2+angmy**2+angmz**2)
   lenpos=SQRT(posx**2+posy**2+posz**2)
   lenvel=SQRT(velx**2+vely**2+velz**2)
   p=lenam**2/mu
   c=lenvel**2/2.0_dp-mu/lenpos
!
!   Semimajor axis in AU.
!
   a_arr(jndx)=-mu/(2.0_dp*c)
!
!   Period in days from Kepler's Third Law
!
   p_arr(jndx)=SQRT(4.0_dp*pie*pie*a_arr(jndx)**3/mu)
!
!   eccentricity.
!
   IF(1.0_dp-p/a_arr(jndx) < 0.0_dp)THEN
      ecc_arr(jndx)=0.0_dp
   ELSE
      ecc_arr(jndx)=SQRT(1.0_dp-p/a_arr(jndx))
   END IF
!
!   inclination.
!
   inc_arr(jndx)=ACOS(angmz/lenam)
!
!   mean longitude
!
   IF(ABS(angmy) > EPSILON(angmy))THEN
      long_arr(jndx)=ATAN(-angmx/angmy)
   ELSE
      IF(angmx < 0.0_dp)THEN
         long_arr(jndx)=halfpie
      ELSE
         long_arr(jndx)=-halfpie
      END IF
   END IF
!
   cwf=(posx*COS(long_arr(jndx))+posy*SIN(long_arr(jndx)))/lenpos
   swf=(posz/SIN(inc_arr(jndx)))/lenpos
   wf=ATAN2(swf,cwf)
   aa=lenam**2/(mu*lenpos)-1.0_dp
   bb=(lenam*(posx*velx+posy*vely+posz*velz))/(mu*lenpos)
!
!    true anomaly
!
   f=ATAN2(bb,aa)
   f_arr(jndx)=f
   argper_arr(jndx)=wf-f
   fmod=MOD(f,twopie)
   IF(fmod < 0.0_dp)fmod=fmod+twopie
   IF(fmod > pie)THEN
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=twopie
      ELSE
        e=-ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   ELSE
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=halfpie
      ELSE
        e=ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   END IF
!
!    mean anomaly
!
   ma_arr(jndx)=e-ecc_arr(jndx)*SIN(e)
!
!    get Tconj
!
   m=trueatomeana(halfpie-argper_arr(jndx),ecc_arr(jndx))
   tconj_arr(jndx)=tref+(m-ma_arr(jndx))*p_arr(jndx)/twopie
!
   IF(ma_arr(jndx) < 0.0_dp)ma_arr(jndx)=ma_arr(jndx)+twopie
   IF(f_arr(jndx) < 0.0_dp)f_arr(jndx)=f_arr(jndx)+twopie
   IF(argper_arr(jndx) < 0.0_dp)argper_arr(jndx)=argper_arr(jndx)+twopie
!
!    Return if Nbody = 5.
!
   IF(nbody == 5)RETURN
!
!    body 6 orbit
!
   jndx=5
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   DO i=1,jndx
      w(i)=rmass(i)/totmass
   END DO
!
   posbbcx=0.0_dp
   posbbcy=0.0_dp
   posbbcz=0.0_dp
   velbbcx=0.0_dp
   velbbcy=0.0_dp
   velbbcz=0.0_dp
   ibody=3
   DO i=1,jndx
      posbbcx=posbbcx+w(i)*qq(1+(i-1)*ibody)
      posbbcy=posbbcy+w(i)*qq(2+(i-1)*ibody)
      posbbcz=posbbcz+w(i)*qq(3+(i-1)*ibody)
      velbbcx=velbbcx+w(i)*pp(1+(i-1)*ibody)
      velbbcy=velbbcy+w(i)*pp(2+(i-1)*ibody)
      velbbcz=velbbcz+w(i)*pp(3+(i-1)*ibody)
   END DO
!
   ibody=jndx*3
   posx=qq(1+ibody)-posbbcx
   posy=qq(2+ibody)-posbbcy
   posz=qq(3+ibody)-posbbcz
   velx=pp(1+ibody)-velbbcx
   vely=pp(2+ibody)-velbbcy
   velz=pp(3+ibody)-velbbcz
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   m1=totmass
   m2=rmass(jndx+1)
   mu=g*(m1+m2)
!
!   Find the direction of the angular momentum
!   vector.
!
   angmx=posy*velz-posz*vely
   angmy=posz*velx-posx*velz
   angmz=posx*vely-posy*velx
   lenam=SQRT(angmx**2+angmy**2+angmz**2)
   lenpos=SQRT(posx**2+posy**2+posz**2)
   lenvel=SQRT(velx**2+vely**2+velz**2)
   p=lenam**2/mu
   c=lenvel**2/2.0_dp-mu/lenpos
!
!   Semimajor axis in AU.
!
   a_arr(jndx)=-mu/(2.0_dp*c)
!
!   Period in days from Kepler's Third Law
!
   p_arr(jndx)=SQRT(4.0_dp*pie*pie*a_arr(jndx)**3/mu)
!
!   eccentricity.
!
   IF(1.0_dp-p/a_arr(jndx) < 0.0_dp)THEN
      ecc_arr(jndx)=0.0_dp
   ELSE
      ecc_arr(jndx)=SQRT(1.0_dp-p/a_arr(jndx))
   END IF
!
!   inclination.
!
   inc_arr(jndx)=ACOS(angmz/lenam)
!
!   mean longitude
!
   IF(ABS(angmy) > EPSILON(angmy))THEN
      long_arr(jndx)=ATAN(-angmx/angmy)
   ELSE
      IF(angmx < 0.0_dp)THEN
         long_arr(jndx)=halfpie
      ELSE
         long_arr(jndx)=-halfpie
      END IF
   END IF
!
   cwf=(posx*COS(long_arr(jndx))+posy*SIN(long_arr(jndx)))/lenpos
   swf=(posz/SIN(inc_arr(jndx)))/lenpos
   wf=ATAN2(swf,cwf)
   aa=lenam**2/(mu*lenpos)-1.0_dp
   bb=(lenam*(posx*velx+posy*vely+posz*velz))/(mu*lenpos)
!
!    true anomaly
!
   f=ATAN2(bb,aa)
   f_arr(jndx)=f
   argper_arr(jndx)=wf-f
   fmod=MOD(f,twopie)
   IF(fmod < 0.0_dp)fmod=fmod+twopie
   IF(fmod > pie)THEN
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=twopie
      ELSE
        e=-ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   ELSE
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=halfpie
      ELSE
        e=ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   END IF
!
!    mean anomaly
!
   ma_arr(jndx)=e-ecc_arr(jndx)*SIN(e)
!
!    get Tconj
!
   m=trueatomeana(halfpie-argper_arr(jndx),ecc_arr(jndx))
   tconj_arr(jndx)=tref+(m-ma_arr(jndx))*p_arr(jndx)/twopie
!
   IF(ma_arr(jndx) < 0.0_dp)ma_arr(jndx)=ma_arr(jndx)+twopie
   IF(f_arr(jndx) < 0.0_dp)f_arr(jndx)=f_arr(jndx)+twopie
   IF(argper_arr(jndx) < 0.0_dp)argper_arr(jndx)=argper_arr(jndx)+twopie
!
!    Return if Nbody = 6.
!
   IF(nbody == 6)RETURN
!
!    body 7 orbit
!
   jndx=6
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   DO i=1,jndx
      w(i)=rmass(i)/totmass
   END DO
!
   posbbcx=0.0_dp
   posbbcy=0.0_dp
   posbbcz=0.0_dp
   velbbcx=0.0_dp
   velbbcy=0.0_dp
   velbbcz=0.0_dp
   ibody=3
   DO i=1,jndx
      posbbcx=posbbcx+w(i)*qq(1+(i-1)*ibody)
      posbbcy=posbbcy+w(i)*qq(2+(i-1)*ibody)
      posbbcz=posbbcz+w(i)*qq(3+(i-1)*ibody)
      velbbcx=velbbcx+w(i)*pp(1+(i-1)*ibody)
      velbbcy=velbbcy+w(i)*pp(2+(i-1)*ibody)
      velbbcz=velbbcz+w(i)*pp(3+(i-1)*ibody)
   END DO
!
   ibody=jndx*3
   posx=qq(1+ibody)-posbbcx
   posy=qq(2+ibody)-posbbcy
   posz=qq(3+ibody)-posbbcz
   velx=pp(1+ibody)-velbbcx
   vely=pp(2+ibody)-velbbcy
   velz=pp(3+ibody)-velbbcz
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   m1=totmass
   m2=rmass(jndx+1)
   mu=g*(m1+m2)
!
!   Find the direction of the angular momentum
!   vector.
!
   angmx=posy*velz-posz*vely
   angmy=posz*velx-posx*velz
   angmz=posx*vely-posy*velx
   lenam=SQRT(angmx**2+angmy**2+angmz**2)
   lenpos=SQRT(posx**2+posy**2+posz**2)
   lenvel=SQRT(velx**2+vely**2+velz**2)
   p=lenam**2/mu
   c=lenvel**2/2.0_dp-mu/lenpos
!
!   Semimajor axis in AU.
!
   a_arr(jndx)=-mu/(2.0_dp*c)
!
!   Period in days from Kepler's Third Law
!
   p_arr(jndx)=SQRT(4.0_dp*pie*pie*a_arr(jndx)**3/mu)
!
!   eccentricity.
!
   IF(1.0_dp-p/a_arr(jndx) < 0.0_dp)THEN
      ecc_arr(jndx)=0.0_dp
   ELSE
      ecc_arr(jndx)=SQRT(1.0_dp-p/a_arr(jndx))
   END IF
!
!   inclination.
!
   inc_arr(jndx)=ACOS(angmz/lenam)
!
!   mean longitude
!
   IF(ABS(angmy) > EPSILON(angmy))THEN
      long_arr(jndx)=ATAN(-angmx/angmy)
   ELSE
      IF(angmx < 0.0_dp)THEN
         long_arr(jndx)=halfpie
      ELSE
         long_arr(jndx)=-halfpie
      END IF
   END IF
!
   cwf=(posx*COS(long_arr(jndx))+posy*SIN(long_arr(jndx)))/lenpos
   swf=(posz/SIN(inc_arr(jndx)))/lenpos
   wf=ATAN2(swf,cwf)
   aa=lenam**2/(mu*lenpos)-1.0_dp
   bb=(lenam*(posx*velx+posy*vely+posz*velz))/(mu*lenpos)
!
!    true anomaly
!
   f=ATAN2(bb,aa)
   f_arr(jndx)=f
   argper_arr(jndx)=wf-f
   fmod=MOD(f,twopie)
   IF(fmod < 0.0_dp)fmod=fmod+twopie
   IF(fmod > pie)THEN
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=twopie
      ELSE
        e=-ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   ELSE
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=halfpie
      ELSE
        e=ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   END IF
!
!    mean anomaly
!
   ma_arr(jndx)=e-ecc_arr(jndx)*SIN(e)
!
!    get Tconj
!
   m=trueatomeana(halfpie-argper_arr(jndx),ecc_arr(jndx))
   tconj_arr(jndx)=tref+(m-ma_arr(jndx))*p_arr(jndx)/twopie
!
   IF(ma_arr(jndx) < 0.0_dp)ma_arr(jndx)=ma_arr(jndx)+twopie
   IF(f_arr(jndx) < 0.0_dp)f_arr(jndx)=f_arr(jndx)+twopie
   IF(argper_arr(jndx) < 0.0_dp)argper_arr(jndx)=argper_arr(jndx)+twopie
!
!    Return if Nbody = 7.
!
   IF(nbody == 7)RETURN
!
!    body 8 orbit
!
   jndx=7
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   DO i=1,jndx
      w(i)=rmass(i)/totmass
   END DO
!
   posbbcx=0.0_dp
   posbbcy=0.0_dp
   posbbcz=0.0_dp
   velbbcx=0.0_dp
   velbbcy=0.0_dp
   velbbcz=0.0_dp
   ibody=3
   DO i=1,jndx
      posbbcx=posbbcx+w(i)*qq(1+(i-1)*ibody)
      posbbcy=posbbcy+w(i)*qq(2+(i-1)*ibody)
      posbbcz=posbbcz+w(i)*qq(3+(i-1)*ibody)
      velbbcx=velbbcx+w(i)*pp(1+(i-1)*ibody)
      velbbcy=velbbcy+w(i)*pp(2+(i-1)*ibody)
      velbbcz=velbbcz+w(i)*pp(3+(i-1)*ibody)
   END DO
!
   ibody=jndx*3
   posx=qq(1+ibody)-posbbcx
   posy=qq(2+ibody)-posbbcy
   posz=qq(3+ibody)-posbbcz
   velx=pp(1+ibody)-velbbcx
   vely=pp(2+ibody)-velbbcy
   velz=pp(3+ibody)-velbbcz
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   m1=totmass
   m2=rmass(jndx+1)
   mu=g*(m1+m2)
!
!   Find the direction of the angular momentum
!   vector.
!
   angmx=posy*velz-posz*vely
   angmy=posz*velx-posx*velz
   angmz=posx*vely-posy*velx
   lenam=SQRT(angmx**2+angmy**2+angmz**2)
   lenpos=SQRT(posx**2+posy**2+posz**2)
   lenvel=SQRT(velx**2+vely**2+velz**2)
   p=lenam**2/mu
   c=lenvel**2/2.0_dp-mu/lenpos
!
!   Semimajor axis in AU.
!
   a_arr(jndx)=-mu/(2.0_dp*c)
!
!   Period in days from Kepler's Third Law
!
   p_arr(jndx)=SQRT(4.0_dp*pie*pie*a_arr(jndx)**3/mu)
!
!   eccentricity.
!
   IF(1.0_dp-p/a_arr(jndx) < 0.0_dp)THEN
      ecc_arr(jndx)=0.0_dp
   ELSE
      ecc_arr(jndx)=SQRT(1.0_dp-p/a_arr(jndx))
   END IF
!
!   inclination.
!
   inc_arr(jndx)=ACOS(angmz/lenam)
!
!   mean longitude
!
   IF(ABS(angmy) > EPSILON(angmy))THEN
      long_arr(jndx)=ATAN(-angmx/angmy)
   ELSE
      IF(angmx < 0.0_dp)THEN
         long_arr(jndx)=halfpie
      ELSE
         long_arr(jndx)=-halfpie
      END IF
   END IF
!
   cwf=(posx*COS(long_arr(jndx))+posy*SIN(long_arr(jndx)))/lenpos
   swf=(posz/SIN(inc_arr(jndx)))/lenpos
   wf=ATAN2(swf,cwf)
   aa=lenam**2/(mu*lenpos)-1.0_dp
   bb=(lenam*(posx*velx+posy*vely+posz*velz))/(mu*lenpos)
!
!    true anomaly
!
   f=ATAN2(bb,aa)
   f_arr(jndx)=f
   argper_arr(jndx)=wf-f
   fmod=MOD(f,twopie)
   IF(fmod < 0.0_dp)fmod=fmod+twopie
   IF(fmod > pie)THEN
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=twopie
      ELSE
        e=-ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   ELSE
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=halfpie
      ELSE
        e=ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   END IF
!
!    mean anomaly
!
   ma_arr(jndx)=e-ecc_arr(jndx)*SIN(e)
!
!    get Tconj
!
   m=trueatomeana(halfpie-argper_arr(jndx),ecc_arr(jndx))
   tconj_arr(jndx)=tref+(m-ma_arr(jndx))*p_arr(jndx)/twopie
!
   IF(ma_arr(jndx) < 0.0_dp)ma_arr(jndx)=ma_arr(jndx)+twopie
   IF(f_arr(jndx) < 0.0_dp)f_arr(jndx)=f_arr(jndx)+twopie
   IF(argper_arr(jndx) < 0.0_dp)argper_arr(jndx)=argper_arr(jndx)+twopie
!
!    Return if Nbody = 8.
!
   IF(nbody == 8)RETURN
!
!    body 9 orbit
!
   jndx=8
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   DO i=1,jndx
      w(i)=rmass(i)/totmass
   END DO
!
   posbbcx=0.0_dp
   posbbcy=0.0_dp
   posbbcz=0.0_dp
   velbbcx=0.0_dp
   velbbcy=0.0_dp
   velbbcz=0.0_dp
   ibody=3
   DO i=1,jndx
      posbbcx=posbbcx+w(i)*qq(1+(i-1)*ibody)
      posbbcy=posbbcy+w(i)*qq(2+(i-1)*ibody)
      posbbcz=posbbcz+w(i)*qq(3+(i-1)*ibody)
      velbbcx=velbbcx+w(i)*pp(1+(i-1)*ibody)
      velbbcy=velbbcy+w(i)*pp(2+(i-1)*ibody)
      velbbcz=velbbcz+w(i)*pp(3+(i-1)*ibody)
   END DO
!
   ibody=jndx*3
   posx=qq(1+ibody)-posbbcx
   posy=qq(2+ibody)-posbbcy
   posz=qq(3+ibody)-posbbcz
   velx=pp(1+ibody)-velbbcx
   vely=pp(2+ibody)-velbbcy
   velz=pp(3+ibody)-velbbcz
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   m1=totmass
   m2=rmass(jndx+1)
   mu=g*(m1+m2)
!
!   Find the direction of the angular momentum
!   vector.
!
   angmx=posy*velz-posz*vely
   angmy=posz*velx-posx*velz
   angmz=posx*vely-posy*velx
   lenam=SQRT(angmx**2+angmy**2+angmz**2)
   lenpos=SQRT(posx**2+posy**2+posz**2)
   lenvel=SQRT(velx**2+vely**2+velz**2)
   p=lenam**2/mu
   c=lenvel**2/2.0_dp-mu/lenpos
!
!   Semimajor axis in AU.
!
   a_arr(jndx)=-mu/(2.0_dp*c)
!
!   Period in days from Kepler's Third Law
!
   p_arr(jndx)=SQRT(4.0_dp*pie*pie*a_arr(jndx)**3/mu)
!
!   eccentricity.
!
   IF(1.0_dp-p/a_arr(jndx) < 0.0_dp)THEN
      ecc_arr(jndx)=0.0_dp
   ELSE
      ecc_arr(jndx)=SQRT(1.0_dp-p/a_arr(jndx))
   END IF
!
!   inclination.
!
   inc_arr(jndx)=ACOS(angmz/lenam)
!
!   mean longitude
!
   IF(ABS(angmy) > EPSILON(angmy))THEN
      long_arr(jndx)=ATAN(-angmx/angmy)
   ELSE
      IF(angmx < 0.0_dp)THEN
         long_arr(jndx)=halfpie
      ELSE
         long_arr(jndx)=-halfpie
      END IF
   END IF
!
   cwf=(posx*COS(long_arr(jndx))+posy*SIN(long_arr(jndx)))/lenpos
   swf=(posz/SIN(inc_arr(jndx)))/lenpos
   wf=ATAN2(swf,cwf)
   aa=lenam**2/(mu*lenpos)-1.0_dp
   bb=(lenam*(posx*velx+posy*vely+posz*velz))/(mu*lenpos)
!
!    true anomaly
!
   f=ATAN2(bb,aa)
   f_arr(jndx)=f
   argper_arr(jndx)=wf-f
   fmod=MOD(f,twopie)
   IF(fmod < 0.0_dp)fmod=fmod+twopie
   IF(fmod > pie)THEN
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=twopie
      ELSE
        e=-ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   ELSE
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=halfpie
      ELSE
        e=ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   END IF
!
!    mean anomaly
!
   ma_arr(jndx)=e-ecc_arr(jndx)*SIN(e)
!
!    get Tconj
!
   m=trueatomeana(halfpie-argper_arr(jndx),ecc_arr(jndx))
   tconj_arr(jndx)=tref+(m-ma_arr(jndx))*p_arr(jndx)/twopie
!
   IF(ma_arr(jndx) < 0.0_dp)ma_arr(jndx)=ma_arr(jndx)+twopie
   IF(f_arr(jndx) < 0.0_dp)f_arr(jndx)=f_arr(jndx)+twopie
   IF(argper_arr(jndx) < 0.0_dp)argper_arr(jndx)=argper_arr(jndx)+twopie
!
!    Return if Nbody = 9.
!
   IF(nbody == 9)RETURN
!
!    body 10 orbit
!
   jndx=9
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   DO i=1,jndx
      w(i)=rmass(i)/totmass
   END DO
!
   posbbcx=0.0_dp
   posbbcy=0.0_dp
   posbbcz=0.0_dp
   velbbcx=0.0_dp
   velbbcy=0.0_dp
   velbbcz=0.0_dp
   ibody=3
   DO i=1,jndx
      posbbcx=posbbcx+w(i)*qq(1+(i-1)*ibody)
      posbbcy=posbbcy+w(i)*qq(2+(i-1)*ibody)
      posbbcz=posbbcz+w(i)*qq(3+(i-1)*ibody)
      velbbcx=velbbcx+w(i)*pp(1+(i-1)*ibody)
      velbbcy=velbbcy+w(i)*pp(2+(i-1)*ibody)
      velbbcz=velbbcz+w(i)*pp(3+(i-1)*ibody)
   END DO
!
   ibody=jndx*3
   posx=qq(1+ibody)-posbbcx
   posy=qq(2+ibody)-posbbcy
   posz=qq(3+ibody)-posbbcz
   velx=pp(1+ibody)-velbbcx
   vely=pp(2+ibody)-velbbcy
   velz=pp(3+ibody)-velbbcz
   totmass=0.0_dp
   DO i=1,jndx
      totmass=totmass+rmass(i)
   END DO
   m1=totmass
   m2=rmass(jndx+1)
   mu=g*(m1+m2)
!
!   Find the direction of the angular momentum
!   vector.
!
   angmx=posy*velz-posz*vely
   angmy=posz*velx-posx*velz
   angmz=posx*vely-posy*velx
   lenam=SQRT(angmx**2+angmy**2+angmz**2)
   lenpos=SQRT(posx**2+posy**2+posz**2)
   lenvel=SQRT(velx**2+vely**2+velz**2)
   p=lenam**2/mu
   c=lenvel**2/2.0_dp-mu/lenpos
!
!   Semimajor axis in AU.
!
   a_arr(jndx)=-mu/(2.0_dp*c)
!
!   Period in days from Kepler's Third Law
!
   p_arr(jndx)=SQRT(4.0_dp*pie*pie*a_arr(jndx)**3/mu)
!
!   eccentricity.
!
   IF(1.0_dp-p/a_arr(jndx) < 0.0_dp)THEN
      ecc_arr(jndx)=0.0_dp
   ELSE
      ecc_arr(jndx)=SQRT(1.0_dp-p/a_arr(jndx))
   END IF
!
!   inclination.
!
   inc_arr(jndx)=ACOS(angmz/lenam)
!
!   mean longitude
!
   IF(ABS(angmy) > EPSILON(angmy))THEN
      long_arr(jndx)=ATAN(-angmx/angmy)
   ELSE
      IF(angmx < 0.0_dp)THEN
         long_arr(jndx)=halfpie
      ELSE
         long_arr(jndx)=-halfpie
      END IF
   END IF
!
   cwf=(posx*COS(long_arr(jndx))+posy*SIN(long_arr(jndx)))/lenpos
   swf=(posz/SIN(inc_arr(jndx)))/lenpos
   wf=ATAN2(swf,cwf)
   aa=lenam**2/(mu*lenpos)-1.0_dp
   bb=(lenam*(posx*velx+posy*vely+posz*velz))/(mu*lenpos)
!
!    true anomaly
!
   f=ATAN2(bb,aa)
   f_arr(jndx)=f
   argper_arr(jndx)=wf-f
   fmod=MOD(f,twopie)
   IF(fmod < 0.0_dp)fmod=fmod+twopie
   IF(fmod > pie)THEN
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=twopie
      ELSE
        e=-ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   ELSE
      IF(ABS(ecc_arr(jndx)) < EPSILON(fmod))THEN
        e=halfpie
      ELSE
        e=ACOS((1.0_dp-lenpos/a_arr(jndx))/ecc_arr(jndx))
      END IF
   END IF
!
!    mean anomaly
!
   ma_arr(jndx)=e-ecc_arr(jndx)*SIN(e)
!
!    get Tconj
!
   m=trueatomeana(halfpie-argper_arr(jndx),ecc_arr(jndx))
   tconj_arr(jndx)=tref+(m-ma_arr(jndx))*p_arr(jndx)/twopie
!
   IF(ma_arr(jndx) < 0.0_dp)ma_arr(jndx)=ma_arr(jndx)+twopie
   IF(f_arr(jndx) < 0.0_dp)f_arr(jndx)=f_arr(jndx)+twopie
   IF(argper_arr(jndx) < 0.0_dp)argper_arr(jndx)=argper_arr(jndx)+twopie
!
!    Return if Nbody = 10.
!
   IF(nbody == 9)RETURN
!
   RETURN
!
END SUBROUTINE newcartkep
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE newcartkepbinbin(rmass,qq,pp,tref,p_arr,ecc_arr,  &
   a_arr,ma_arr,argper_arr,inc_arr,long_arr,tconj_arr,f_arr)
!
!    Converts Cartesian x,y,z to Keplerian for the double binary
!
!    p_arr = array of periods (index 1 for binary,
!        2 for third star, ...)
!    ecc_arr = array of eccentricities
!    a_arr = array of semimajor axes
!    MA_arr = array of mean anonalies
!    ArgPer_arr = array of argument of periastrons
!    inc_arr = array of inclinations
!    long_arr = array of mean longitudes
!    Tconj_arr = array of Tconj times
!    f_arr = array of true anomalies
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                       :: qq(30)
   REAL(KIND=dp), INTENT(IN)                       :: pp(30)
   REAL(KIND=dp), INTENT(IN)                       :: tref
   REAL(KIND=dp), INTENT(OUT)                      :: p_arr(9)
   REAL(KIND=dp), INTENT(OUT)                      :: ecc_arr(9)
   REAL(KIND=dp), INTENT(OUT)                      :: a_arr(9)
   REAL(KIND=dp), INTENT(OUT)                      :: ma_arr(9)
   REAL(KIND=dp), INTENT(OUT)                      :: argper_arr(9)
   REAL(KIND=dp), INTENT(OUT)                      :: inc_arr(9)
   REAL(KIND=dp), INTENT(OUT)                      :: long_arr(9)
   REAL(KIND=dp), INTENT(OUT)                      :: tconj_arr(9)
   REAL(KIND=dp), INTENT(OUT)                      :: f_arr(9)
!
   REAL(KIND=dp)  :: velx,vely,velz,m1,m2,tconjout,trueout,longout,posy,posz
   REAL(KIND=dp)  :: periodout,eccout,aout,meananomout,argperout,inclout,posx
   REAL(KIND=dp)  :: posbc1x,posbc1y,posbc1z,velbc1x,velbc1y,velbc1z
   REAL(KIND=dp)  :: posbc2x,posbc2y,posbc2z,velbc2x,velbc2y,velbc2z
!
   INTEGER :: ibody,jndx,i
!
!  Initalize
!
   DO i=1,9
      p_arr(i)=0.0_dp
      ecc_arr(i)=0.0_dp
      a_arr(i)=0.0_dp
      ma_arr(i)=0.0_dp
      argper_arr(i)=0.0_dp
      inc_arr(i)=0.0_dp
      long_arr(i)=0.0_dp
      tconj_arr(i)=0.0_dp
   END DO
!
!  Get the constants.
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
!  Start with the orbit of the second star with respect
!  to the first star
!
   jndx=1
   ibody=3
   posx=qq(1+ibody)-qq(1)
   posy=qq(2+ibody)-qq(2)
   posz=qq(3+ibody)-qq(3)
   velx=pp(1+ibody)-pp(1)
   vely=pp(2+ibody)-pp(2)
   velz=pp(3+ibody)-pp(3)
   m1=rmass(1)
   m2=rmass(2)
!
   CALL xyztokep(tref,m1,m2,posx,posy,posz,velx,vely,velz,  &
      periodout,eccout,aout,meananomout,argperout,inclout, &
      longout,trueout,tconjout)
!
   p_arr(1)=periodout
   ecc_arr(1)=eccout
   a_arr(1)=aout
   ma_arr(1)=meananomout
   argper_arr(1)=argperout
   inc_arr(1)=inclout
   long_arr(1)=longout
   f_arr(1)=trueout
   tconj_arr(1)=tconjout
!
!   Now move on to the second binary (star 3 and star 4)
!
   m1=rmass(3)
   m2=rmass(4)
   jndx=6
   ibody=9
   posx=qq(1+ibody)-qq(1+jndx)
   posy=qq(2+ibody)-qq(2+jndx)
   posz=qq(3+ibody)-qq(3+jndx)
   velx=pp(1+ibody)-pp(1+jndx)
   vely=pp(2+ibody)-pp(2+jndx)
   velz=pp(3+ibody)-pp(3+jndx)
!
   CALL xyztokep(tref,m1,m2,posx,posy,posz,velx,vely,velz,  &
      periodout,eccout,aout,meananomout,argperout,inclout, &
      longout,trueout,tconjout)
!
   p_arr(3)=periodout
   ecc_arr(3)=eccout
   a_arr(3)=aout
   ma_arr(3)=meananomout
   argper_arr(3)=argperout
   inc_arr(3)=inclout
   long_arr(3)=longout
   f_arr(3)=trueout
   tconj_arr(3)=tconjout
!
!   Now work on the outer orbit with respect to the barycenter
!   of the first binary
!
   posbc1x=rmass(1)/(rmass(1)+rmass(2))*qq(1)
   posbc1x=posbc1x+rmass(2)/(rmass(1)+rmass(2))*qq(4)
!
   posbc1y=rmass(1)/(rmass(1)+rmass(2))*qq(2)
   posbc1y=posbc1y+rmass(2)/(rmass(1)+rmass(2))*qq(5)
!
   posbc1z=rmass(1)/(rmass(1)+rmass(2))*qq(3)
   posbc1z=posbc1z+rmass(2)/(rmass(1)+rmass(2))*qq(6)
!
   velbc1x=rmass(1)/(rmass(1)+rmass(2))*pp(1)
   velbc1x=velbc1x+rmass(2)/(rmass(1)+rmass(2))*pp(4)
!
   velbc1y=rmass(1)/(rmass(1)+rmass(2))*pp(2)
   velbc1y=velbc1y+rmass(2)/(rmass(1)+rmass(2))*pp(5)
!
   velbc1z=rmass(1)/(rmass(1)+rmass(2))*pp(3)
   velbc1z=velbc1z+rmass(2)/(rmass(1)+rmass(2))*pp(6)
!
   posbc2x=rmass(3)/(rmass(3)+rmass(4))*qq(7)
   posbc2x=posbc2x+rmass(4)/(rmass(3)+rmass(4))*qq(10)
!
   posbc2y=rmass(3)/(rmass(3)+rmass(4))*qq(8)
   posbc2y=posbc2y+rmass(4)/(rmass(3)+rmass(4))*qq(11)
!
   posbc2z=rmass(3)/(rmass(3)+rmass(4))*qq(9)
   posbc2z=posbc2z+rmass(4)/(rmass(3)+rmass(4))*qq(12)
!
   velbc2x=rmass(3)/(rmass(3)+rmass(4))*pp(7)
   velbc2x=velbc2x+rmass(4)/(rmass(3)+rmass(4))*pp(10)
!
   velbc2y=rmass(3)/(rmass(3)+rmass(4))*pp(8)
   velbc2y=velbc2y+rmass(4)/(rmass(3)+rmass(4))*pp(11)
!
   velbc2z=rmass(3)/(rmass(3)+rmass(4))*pp(9)
   velbc2z=velbc2z+rmass(4)/(rmass(3)+rmass(4))*pp(12)
!
!   Move the origin to binary 1 barycenter
!
   posx=posbc2x-posbc1x
   posy=posbc2y-posbc1y
   posz=posbc2z-posbc1z
!
   velx=velbc2x-velbc1x
   vely=velbc2y-velbc1y
   velz=velbc2z-velbc1z
!
   m1=rmass(1)+rmass(2)
   m2=rmass(3)+rmass(4)
   CALL xyztokep(tref,m1,m2,posx,posy,posz,velx,vely,velz,  &
      periodout,eccout,aout,meananomout,argperout,inclout, &
      longout,trueout,tconjout)
!
   p_arr(2)=periodout
   ecc_arr(2)=eccout
   a_arr(2)=aout
   ma_arr(2)=meananomout
   argper_arr(2)=argperout
   inc_arr(2)=inclout
   long_arr(2)=longout
   f_arr(2)=trueout
   tconj_arr(2)=tconjout
!
   RETURN
!
END SUBROUTINE newcartkepbinbin
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE newgetinput(kkkk,nalph1,nalph2,nalph3,nbet1,nbet2,  &
   nbet3,nradius,nref,nseg,ntheta,irvfilt,iatm,icnb,icnh,icni,  &
   icnj,icnk,icnr,icnu,icnv,idark1,idark2,idraw,iecheck,iidint,  &
   ikeep,ilaw,ism1,isw1,isw12,isw13,isw2,isw21,isw22,isw23,  &
   isw24,isw25,isw26,isw27,isw28,isw29,isw3,isw30,isw31,isw32,  &
   isw33,isw34,isw4,isw5,isw6,isw7,isw8,isw80,isw81,isw82,isw83,  &
   isw84,isw85,isw86,isw87,isw88,isw89,isw9,isw100,isynch,it1,  &
   it2,it3,it4,itconj,p1mtc,p1ptc,p2omega,p2q,p2t0,p2ecos,  &
   p2esin,p2incl,p2mtc,p2ptc,p2period,p2ratrad,p2tconj,p3omega,  &
   p3q,p3t0,p3ecos,p3esin,p3incl,p3mtc,p3ptc,p3period,p3ratrad,  &
   p3tconj,p4omega,p4q,p4t0,p4ecos,p4esin,p4incl,p4mtc,p4ptc,  &
   p4period,p4ratrad,p4tconj,p5omega,p5q,p5t0,p5ecos,p5esin,  &
   p5incl,p5mtc,p5ptc,p5period,p5ratrad,p5tconj,p6omega,p6q,  &
   p6t0,p6ecos,p6esin,p6incl,p6mtc,p6ptc,p6period,p6ratrad,  &
   p6tconj,p7omega,p7q,p7t0,p7ecos,p7esin,p7incl,p7mtc,p7ptc,  &
   p7period,p7ratrad,p7tconj,p8omega,p8q,p8t0,p8ecos,p8esin,  &
   p8incl,p8mtc,p8ptc,p8period,p8ratrad,p8tconj,pbmtc,pbptc,  &
   period,q,sa3,t0,tconj,teff1,teff2,tgrav1,tgrav2,alb1,alb2,  &
   argper,beam1,beam2,betarim,bigi,bigi2,bigi3,bigi4,bigbeta,  &
   bigbeta2,bigbeta3,bigbeta4,bin2q,b2massdiff,b2masssum,  &
   b2raddiff,b2radsum,bin2ratrad,contam,contams0,contams1,  &
   contams2,contams3,dbolx,dboly,density,dphase,dwavex,dwavey,  &
   ecc,ecosw,fill1,fill2,finc,fm,frac1,frac2,g10,g3,g6,g7,g8,g9,  &
   gamma,hh,massdiff,masssum,ocose,omega1,omega2,omega3,omega4,  &
   omega5,omega6,omega7,omega8,omega9,omega10,omegadot,osine,  &
   powercoeff,primk,primmass,primrad,pshift,rlx,raddiff,radsum,  &
   ratrad,rinner,rk3,rk4,rk5,rk6,rk7,rk8,rk9,rk10,router,  &
   sdarkint1,sdarkint2,sdarkint3,sdarkint4,sdarkint5,sdarkint6,  &
   sdarkint7,sdarkint8,sdarkint9,sdarkint10,secmass,secrad,  &
   separ,spot1parm,spot2parm,spotdparm,sw1,sw2,sw23,sw24,sw25,  &
   sw26,sw27,sw28,sw29,sw3,sw30,sw47,sw48,sw49,sw5,sw6,sw7,sw72,  &
   sw73,sw8,sw80,sw81,sw82,sw83,sw84,sw85,sw86,sw87,sw88,sw89,  &
   sw9,t10,t3,t6,t7,t8,t9,tdisk,temprat,tertomega,tertq,  &
   tertconj,tertecos,tertesin,tertincl,tertperiod,tertratrad,  &
   tertt0,wave,xi,iunit,fracsum,fracdiff,bin2m3,bin2m4,bin2r3,  &
   bin2r4,sqecos,sqesin,sqtertecos,sqtertesin,sqp2ecos,sqp2esin,  &
   sqp3ecos,sqp3esin,sqp4ecos,sqp4esin,sqp5ecos,sqp5esin,  &
   sqp6ecos,sqp6esin,sqp7ecos,sqp7esin,sqp8ecos,sqp8esin,  &
   angsum1,angdiff1,angsum2,angdiff2,angsum3,angdiff3,angsum4,  &
   angdiff4,angsum5,angdiff5,angsum6,angdiff6,angsum7,angdiff7,  &
   angsum8,angdiff8,imag,fillsum,filldiff,binqtc,p1qtc,p2qtc,  &
   p3qtc,p4qtc,p5qtc,p6qtc,p7qtc,p8qtc,tbinoff,t1off,t2off,  &
   t3off,t4off,t5off,t6off,t7off,t8off,iversion,tesscontam,  &
   tessfilt,tessbin)
!
!   Reads version 6 input files.  If the first line is not
!   #1, then the program will attempt to read the old-style
!   input.
!
!   If KKKK is zero, then ELC.inp is opened.  Otherwise,
!   ELC.???? will be opened, where ???? = KKKK + 1000
!
!   November 1, 2019
!
!   Add the option for some TESS features.  If the header is
!   #2, then set version = 1, and read three lines before Nbody
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: kkkk
   INTEGER, INTENT(OUT)                     :: nalph1
   INTEGER, INTENT(OUT)                     :: nalph2
   INTEGER, INTENT(OUT)                     :: nalph3
   INTEGER, INTENT(OUT)                     :: nbet1
   INTEGER, INTENT(OUT)                     :: nbet2
   INTEGER, INTENT(OUT)                     :: nbet3
   INTEGER, INTENT(OUT)                     :: nradius
   INTEGER, INTENT(OUT)                     :: nref
   INTEGER, INTENT(OUT)                     :: nseg
   INTEGER, INTENT(OUT)                     :: ntheta
   INTEGER, INTENT(OUT)                     :: irvfilt
   INTEGER, INTENT(OUT)                     :: iatm
   INTEGER, INTENT(OUT)                     :: icnb
   INTEGER, INTENT(OUT)                     :: icnh
   INTEGER, INTENT(OUT)                     :: icni
   INTEGER, INTENT(OUT)                     :: icnj
   INTEGER, INTENT(OUT)                     :: icnk
   INTEGER, INTENT(OUT)                     :: icnr
   INTEGER, INTENT(OUT)                     :: icnu
   INTEGER, INTENT(OUT)                     :: icnv
   INTEGER, INTENT(OUT)                     :: idark1
   INTEGER, INTENT(OUT)                     :: idark2
   INTEGER, INTENT(OUT)                     :: idraw
   INTEGER, INTENT(OUT)                     :: iecheck
   INTEGER, INTENT(OUT)                     :: iidint
   INTEGER, INTENT(OUT)                     :: ikeep
   INTEGER, INTENT(OUT)                     :: ilaw
   INTEGER, INTENT(OUT)                     :: ism1
   INTEGER, INTENT(OUT)                     :: isw1
   INTEGER, INTENT(OUT)                     :: isw12
   INTEGER, INTENT(OUT)                     :: isw13
   INTEGER, INTENT(OUT)                     :: isw2
   INTEGER, INTENT(OUT)                     :: isw21
   INTEGER, INTENT(OUT)                     :: isw22
   INTEGER, INTENT(OUT)                     :: isw23
   INTEGER, INTENT(OUT)                     :: isw24
   INTEGER, INTENT(OUT)                     :: isw25
   INTEGER, INTENT(OUT)                     :: isw26
   INTEGER, INTENT(OUT)                     :: isw27
   INTEGER, INTENT(OUT)                     :: isw28
   INTEGER, INTENT(OUT)                     :: isw29
   INTEGER, INTENT(OUT)                     :: isw3
   INTEGER, INTENT(OUT)                     :: isw30
   INTEGER, INTENT(OUT)                     :: isw31
   INTEGER, INTENT(OUT)                     :: isw32
   INTEGER, INTENT(OUT)                     :: isw33
   INTEGER, INTENT(OUT)                     :: isw34
   INTEGER, INTENT(OUT)                     :: isw4
   INTEGER, INTENT(OUT)                     :: isw5
   INTEGER, INTENT(OUT)                     :: isw6
   INTEGER, INTENT(OUT)                     :: isw7
   INTEGER, INTENT(OUT)                     :: isw8
   INTEGER, INTENT(OUT)                     :: isw80
   INTEGER, INTENT(OUT)                     :: isw81
   INTEGER, INTENT(OUT)                     :: isw82
   INTEGER, INTENT(OUT)                     :: isw83
   INTEGER, INTENT(OUT)                     :: isw84
   INTEGER, INTENT(OUT)                     :: isw85
   INTEGER, INTENT(OUT)                     :: isw86
   INTEGER, INTENT(OUT)                     :: isw87
   INTEGER, INTENT(OUT)                     :: isw88
   INTEGER, INTENT(OUT)                     :: isw89
   INTEGER, INTENT(OUT)                     :: isw9
   INTEGER, INTENT(OUT)                     :: isw100
   INTEGER, INTENT(OUT)                     :: isynch
   INTEGER, INTENT(OUT)                     :: it1
   INTEGER, INTENT(OUT)                     :: it2
   INTEGER, INTENT(OUT)                     :: it3
   INTEGER, INTENT(OUT)                     :: it4
   INTEGER, INTENT(OUT)                     :: itconj
   REAL(KIND=dp), INTENT(OUT)               :: p1mtc
   REAL(KIND=dp), INTENT(OUT)               :: p1ptc
   REAL(KIND=dp), INTENT(OUT)               :: p2omega
   REAL(KIND=dp), INTENT(OUT)               :: p2q
   REAL(KIND=dp), INTENT(OUT)               :: p2t0
   REAL(KIND=dp), INTENT(OUT)               :: p2ecos
   REAL(KIND=dp), INTENT(OUT)               :: p2esin
   REAL(KIND=dp), INTENT(OUT)               :: p2incl
   REAL(KIND=dp), INTENT(OUT)               :: p2mtc
   REAL(KIND=dp), INTENT(OUT)               :: p2ptc
   REAL(KIND=dp), INTENT(OUT)               :: p2period
   REAL(KIND=dp), INTENT(OUT)               :: p2ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p2tconj
   REAL(KIND=dp), INTENT(OUT)               :: p3omega
   REAL(KIND=dp), INTENT(OUT)               :: p3q
   REAL(KIND=dp), INTENT(OUT)               :: p3t0
   REAL(KIND=dp), INTENT(OUT)               :: p3ecos
   REAL(KIND=dp), INTENT(OUT)               :: p3esin
   REAL(KIND=dp), INTENT(OUT)               :: p3incl
   REAL(KIND=dp), INTENT(OUT)               :: p3mtc
   REAL(KIND=dp), INTENT(OUT)               :: p3ptc
   REAL(KIND=dp), INTENT(OUT)               :: p3period
   REAL(KIND=dp), INTENT(OUT)               :: p3ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p3tconj
   REAL(KIND=dp), INTENT(OUT)               :: p4omega
   REAL(KIND=dp), INTENT(OUT)               :: p4q
   REAL(KIND=dp), INTENT(OUT)               :: p4t0
   REAL(KIND=dp), INTENT(OUT)               :: p4ecos
   REAL(KIND=dp), INTENT(OUT)               :: p4esin
   REAL(KIND=dp), INTENT(OUT)               :: p4incl
   REAL(KIND=dp), INTENT(OUT)               :: p4mtc
   REAL(KIND=dp), INTENT(OUT)               :: p4ptc
   REAL(KIND=dp), INTENT(OUT)               :: p4period
   REAL(KIND=dp), INTENT(OUT)               :: p4ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p4tconj
   REAL(KIND=dp), INTENT(OUT)               :: p5omega
   REAL(KIND=dp), INTENT(OUT)               :: p5q
   REAL(KIND=dp), INTENT(OUT)               :: p5t0
   REAL(KIND=dp), INTENT(OUT)               :: p5ecos
   REAL(KIND=dp), INTENT(OUT)               :: p5esin
   REAL(KIND=dp), INTENT(OUT)               :: p5incl
   REAL(KIND=dp), INTENT(OUT)               :: p5mtc
   REAL(KIND=dp), INTENT(OUT)               :: p5ptc
   REAL(KIND=dp), INTENT(OUT)               :: p5period
   REAL(KIND=dp), INTENT(OUT)               :: p5ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p5tconj
   REAL(KIND=dp), INTENT(OUT)               :: p6omega
   REAL(KIND=dp), INTENT(OUT)               :: p6q
   REAL(KIND=dp), INTENT(OUT)               :: p6t0
   REAL(KIND=dp), INTENT(OUT)               :: p6ecos
   REAL(KIND=dp), INTENT(OUT)               :: p6esin
   REAL(KIND=dp), INTENT(OUT)               :: p6incl
   REAL(KIND=dp), INTENT(OUT)               :: p6mtc
   REAL(KIND=dp), INTENT(OUT)               :: p6ptc
   REAL(KIND=dp), INTENT(OUT)               :: p6period
   REAL(KIND=dp), INTENT(OUT)               :: p6ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p6tconj
   REAL(KIND=dp), INTENT(OUT)               :: p7omega
   REAL(KIND=dp), INTENT(OUT)               :: p7q
   REAL(KIND=dp), INTENT(OUT)               :: p7t0
   REAL(KIND=dp), INTENT(OUT)               :: p7ecos
   REAL(KIND=dp), INTENT(OUT)               :: p7esin
   REAL(KIND=dp), INTENT(OUT)               :: p7incl
   REAL(KIND=dp), INTENT(OUT)               :: p7mtc
   REAL(KIND=dp), INTENT(OUT)               :: p7ptc
   REAL(KIND=dp), INTENT(OUT)               :: p7period
   REAL(KIND=dp), INTENT(OUT)               :: p7ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p7tconj
   REAL(KIND=dp), INTENT(OUT)               :: p8omega
   REAL(KIND=dp), INTENT(OUT)               :: p8q
   REAL(KIND=dp), INTENT(OUT)               :: p8t0
   REAL(KIND=dp), INTENT(OUT)               :: p8ecos
   REAL(KIND=dp), INTENT(OUT)               :: p8esin
   REAL(KIND=dp), INTENT(OUT)               :: p8incl
   REAL(KIND=dp), INTENT(OUT)               :: p8mtc
   REAL(KIND=dp), INTENT(OUT)               :: p8ptc
   REAL(KIND=dp), INTENT(OUT)               :: p8period
   REAL(KIND=dp), INTENT(OUT)               :: p8ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p8tconj
   REAL(KIND=dp), INTENT(OUT)               :: pbmtc
   REAL(KIND=dp), INTENT(OUT)               :: pbptc
   REAL(KIND=dp), INTENT(OUT)               :: period
   REAL(KIND=dp), INTENT(OUT)               :: q
   REAL(KIND=dp), INTENT(OUT)               :: sa3
   REAL(KIND=dp), INTENT(OUT)               :: t0
   REAL(KIND=dp), INTENT(OUT)               :: tconj
   REAL(KIND=dp), INTENT(OUT)               :: teff1
   REAL(KIND=dp), INTENT(OUT)               :: teff2
   REAL(KIND=dp), INTENT(OUT)               :: tgrav1
   REAL(KIND=dp), INTENT(OUT)               :: tgrav2
   REAL(KIND=dp), INTENT(OUT)               :: alb1
   REAL(KIND=dp), INTENT(OUT)               :: alb2
   REAL(KIND=dp), INTENT(OUT)               :: argper
   REAL(KIND=dp), INTENT(OUT)               :: beam1
   REAL(KIND=dp), INTENT(OUT)               :: beam2
   REAL(KIND=dp), INTENT(OUT)               :: betarim
   REAL(KIND=dp), INTENT(OUT)               :: bigi
   REAL(KIND=dp), INTENT(OUT)               :: bigi2
   REAL(KIND=dp), INTENT(OUT)               :: bigi3
   REAL(KIND=dp), INTENT(OUT)               :: bigi4
   REAL(KIND=dp), INTENT(OUT)               :: bigbeta
   REAL(KIND=dp), INTENT(OUT)               :: bigbeta2
   REAL(KIND=dp), INTENT(OUT)               :: bigbeta3
   REAL(KIND=dp), INTENT(OUT)               :: bigbeta4
   REAL(KIND=dp), INTENT(OUT)               :: bin2q
   REAL(KIND=dp), INTENT(OUT)               :: b2massdiff
   REAL(KIND=dp), INTENT(OUT)               :: b2masssum
   REAL(KIND=dp), INTENT(OUT)               :: b2raddiff
   REAL(KIND=dp), INTENT(OUT)               :: b2radsum
   REAL(KIND=dp), INTENT(OUT)               :: bin2ratrad
   REAL(KIND=dp), INTENT(OUT)               :: contam
   REAL(KIND=dp), INTENT(OUT)               :: contams0
   REAL(KIND=dp), INTENT(OUT)               :: contams1
   REAL(KIND=dp), INTENT(OUT)               :: contams2
   REAL(KIND=dp), INTENT(OUT)               :: contams3
   REAL(KIND=dp), INTENT(OUT)               :: dbolx(8,2)
   REAL(KIND=dp), INTENT(OUT)               :: dboly(8,2)
   REAL(KIND=dp), INTENT(OUT)               :: density
   REAL(KIND=dp), INTENT(OUT)               :: dphase
   REAL(KIND=dp), INTENT(OUT)               :: dwavex(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: dwavey(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: ecc
   REAL(KIND=dp), INTENT(OUT)               :: ecosw
   REAL(KIND=dp), INTENT(OUT)               :: fill1
   REAL(KIND=dp), INTENT(OUT)               :: fill2
   REAL(KIND=dp), INTENT(OUT)               :: finc
   REAL(KIND=dp), INTENT(OUT)               :: fm
   REAL(KIND=dp), INTENT(OUT)               :: frac1
   REAL(KIND=dp), INTENT(OUT)               :: frac2
   REAL(KIND=dp), INTENT(OUT)               :: g10
   REAL(KIND=dp), INTENT(OUT)               :: g3
   REAL(KIND=dp), INTENT(OUT)               :: g6
   REAL(KIND=dp), INTENT(OUT)               :: g7
   REAL(KIND=dp), INTENT(OUT)               :: g8
   REAL(KIND=dp), INTENT(OUT)               :: g9
   REAL(KIND=dp), INTENT(OUT)               :: gamma
   REAL(KIND=dp), INTENT(OUT)               :: hh
   REAL(KIND=dp), INTENT(OUT)               :: massdiff
   REAL(KIND=dp), INTENT(OUT)               :: masssum
   REAL(KIND=dp), INTENT(OUT)               :: ocose
   REAL(KIND=dp), INTENT(OUT)               :: omega1
   REAL(KIND=dp), INTENT(OUT)               :: omega2
   REAL(KIND=dp), INTENT(OUT)               :: omega3
   REAL(KIND=dp), INTENT(OUT)               :: omega4
   REAL(KIND=dp), INTENT(OUT)               :: omega5
   REAL(KIND=dp), INTENT(OUT)               :: omega6
   REAL(KIND=dp), INTENT(OUT)               :: omega7
   REAL(KIND=dp), INTENT(OUT)               :: omega8
   REAL(KIND=dp), INTENT(OUT)               :: omega9
   REAL(KIND=dp), INTENT(OUT)               :: omega10
   REAL(KIND=dp), INTENT(OUT)               :: omegadot
   REAL(KIND=dp), INTENT(OUT)               :: osine
   REAL(KIND=dp), INTENT(OUT)               :: powercoeff(8,9)
   REAL(KIND=dp), INTENT(OUT)               :: primk
   REAL(KIND=dp), INTENT(OUT)               :: primmass
   REAL(KIND=dp), INTENT(OUT)               :: primrad
   REAL(KIND=dp), INTENT(OUT)               :: pshift
   REAL(KIND=dp), INTENT(OUT)               :: rlx
   REAL(KIND=dp), INTENT(OUT)               :: raddiff
   REAL(KIND=dp), INTENT(OUT)               :: radsum
   REAL(KIND=dp), INTENT(OUT)               :: ratrad
   REAL(KIND=dp), INTENT(OUT)               :: rinner
   REAL(KIND=dp), INTENT(OUT)               :: rk3
   REAL(KIND=dp), INTENT(OUT)               :: rk4
   REAL(KIND=dp), INTENT(OUT)               :: rk5
   REAL(KIND=dp), INTENT(OUT)               :: rk6
   REAL(KIND=dp), INTENT(OUT)               :: rk7
   REAL(KIND=dp), INTENT(OUT)               :: rk8
   REAL(KIND=dp), INTENT(OUT)               :: rk9
   REAL(KIND=dp), INTENT(OUT)               :: rk10
   REAL(KIND=dp), INTENT(OUT)               :: router
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint1(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint2(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint3(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint4(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint5(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint6(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint7(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint8(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint9(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint10(8)
   REAL(KIND=dp), INTENT(OUT)               :: secmass
   REAL(KIND=dp), INTENT(OUT)               :: secrad
   REAL(KIND=dp), INTENT(OUT)               :: separ
   REAL(KIND=dp), INTENT(OUT)               :: spot1parm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: spot2parm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: spotdparm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: sw1
   REAL(KIND=dp), INTENT(OUT)               :: sw2
   REAL(KIND=dp), INTENT(OUT)               :: sw23
   REAL(KIND=dp), INTENT(OUT)               :: sw24
   REAL(KIND=dp), INTENT(OUT)               :: sw25
   REAL(KIND=dp), INTENT(OUT)               :: sw26
   REAL(KIND=dp), INTENT(OUT)               :: sw27
   REAL(KIND=dp), INTENT(OUT)               :: sw28
   REAL(KIND=dp), INTENT(OUT)               :: sw29
   REAL(KIND=dp), INTENT(OUT)               :: sw3
   REAL(KIND=dp), INTENT(OUT)               :: sw30
   REAL(KIND=dp), INTENT(OUT)               :: sw47
   REAL(KIND=dp), INTENT(OUT)               :: sw48
   REAL(KIND=dp), INTENT(OUT)               :: sw49
   REAL(KIND=dp), INTENT(OUT)               :: sw5
   REAL(KIND=dp), INTENT(OUT)               :: sw6
   REAL(KIND=dp), INTENT(OUT)               :: sw7
   REAL(KIND=dp), INTENT(OUT)               :: sw72
   REAL(KIND=dp), INTENT(OUT)               :: sw73
   REAL(KIND=dp), INTENT(OUT)               :: sw8
   REAL(KIND=dp), INTENT(OUT)               :: sw80
   REAL(KIND=dp), INTENT(OUT)               :: sw81
   REAL(KIND=dp), INTENT(OUT)               :: sw82
   REAL(KIND=dp), INTENT(OUT)               :: sw83
   REAL(KIND=dp), INTENT(OUT)               :: sw84
   REAL(KIND=dp), INTENT(OUT)               :: sw85
   REAL(KIND=dp), INTENT(OUT)               :: sw86
   REAL(KIND=dp), INTENT(OUT)               :: sw87
   REAL(KIND=dp), INTENT(OUT)               :: sw88
   REAL(KIND=dp), INTENT(OUT)               :: sw89
   REAL(KIND=dp), INTENT(OUT)               :: sw9
   REAL(KIND=dp), INTENT(OUT)               :: t10
   REAL(KIND=dp), INTENT(OUT)               :: t3
   REAL(KIND=dp), INTENT(OUT)               :: t6
   REAL(KIND=dp), INTENT(OUT)               :: t7
   REAL(KIND=dp), INTENT(OUT)               :: t8
   REAL(KIND=dp), INTENT(OUT)               :: t9
   REAL(KIND=dp), INTENT(OUT)               :: tdisk
   REAL(KIND=dp), INTENT(OUT)               :: temprat
   REAL(KIND=dp), INTENT(OUT)               :: tertomega
   REAL(KIND=dp), INTENT(OUT)               :: tertq
   REAL(KIND=dp), INTENT(OUT)               :: tertconj
   REAL(KIND=dp), INTENT(OUT)               :: tertecos
   REAL(KIND=dp), INTENT(OUT)               :: tertesin
   REAL(KIND=dp), INTENT(OUT)               :: tertincl
   REAL(KIND=dp), INTENT(OUT)               :: tertperiod
   REAL(KIND=dp), INTENT(OUT)               :: tertratrad
   REAL(KIND=dp), INTENT(OUT)               :: tertt0
   REAL(KIND=dp), INTENT(OUT)               :: wave(8)
   REAL(KIND=dp), INTENT(OUT)               :: xi
   INTEGER, INTENT(OUT)                     :: iunit
   REAL(KIND=dp), INTENT(OUT)               :: fracsum
   REAL(KIND=dp), INTENT(OUT)               :: fracdiff
   REAL(KIND=dp), INTENT(OUT)               :: bin2m3
   REAL(KIND=dp), INTENT(OUT)               :: bin2m4
   REAL(KIND=dp), INTENT(OUT)               :: bin2r3
   REAL(KIND=dp), INTENT(OUT)               :: bin2r4
   REAL(KIND=dp), INTENT(OUT)               :: sqecos
   REAL(KIND=dp), INTENT(OUT)               :: sqesin
   REAL(KIND=dp), INTENT(OUT)               :: sqtertecos
   REAL(KIND=dp), INTENT(OUT)               :: sqtertesin
   REAL(KIND=dp), INTENT(OUT)               :: sqp2ecos
   REAL(KIND=dp), INTENT(OUT)               :: sqp2esin
   REAL(KIND=dp), INTENT(OUT)               :: sqp3ecos
   REAL(KIND=dp), INTENT(OUT)               :: sqp3esin
   REAL(KIND=dp), INTENT(OUT)               :: sqp4ecos
   REAL(KIND=dp), INTENT(OUT)               :: sqp4esin
   REAL(KIND=dp), INTENT(OUT)               :: sqp5ecos
   REAL(KIND=dp), INTENT(OUT)               :: sqp5esin
   REAL(KIND=dp), INTENT(OUT)               :: sqp6ecos
   REAL(KIND=dp), INTENT(OUT)               :: sqp6esin
   REAL(KIND=dp), INTENT(OUT)               :: sqp7ecos
   REAL(KIND=dp), INTENT(OUT)               :: sqp7esin
   REAL(KIND=dp), INTENT(OUT)               :: sqp8ecos
   REAL(KIND=dp), INTENT(OUT)               :: sqp8esin
   REAL(KIND=dp), INTENT(OUT)               :: angsum1
   REAL(KIND=dp), INTENT(OUT)               :: angdiff1
   REAL(KIND=dp), INTENT(OUT)               :: angsum2
   REAL(KIND=dp), INTENT(OUT)               :: angdiff2
   REAL(KIND=dp), INTENT(OUT)               :: angsum3
   REAL(KIND=dp), INTENT(OUT)               :: angdiff3
   REAL(KIND=dp), INTENT(OUT)               :: angsum4
   REAL(KIND=dp), INTENT(OUT)               :: angdiff4
   REAL(KIND=dp), INTENT(OUT)               :: angsum5
   REAL(KIND=dp), INTENT(OUT)               :: angdiff5
   REAL(KIND=dp), INTENT(OUT)               :: angsum6
   REAL(KIND=dp), INTENT(OUT)               :: angdiff6
   REAL(KIND=dp), INTENT(OUT)               :: angsum7
   REAL(KIND=dp), INTENT(OUT)               :: angdiff7
   REAL(KIND=dp), INTENT(OUT)               :: angsum8
   REAL(KIND=dp), INTENT(OUT)               :: angdiff8
   INTEGER, INTENT(OUT)                     :: imag
   REAL(KIND=dp), INTENT(OUT)               :: fillsum
   REAL(KIND=dp), INTENT(OUT)               :: filldiff
   REAL(KIND=dp), INTENT(OUT)               :: binqtc
   REAL(KIND=dp), INTENT(OUT)               :: p1qtc
   REAL(KIND=dp), INTENT(OUT)               :: p2qtc
   REAL(KIND=dp), INTENT(OUT)               :: p3qtc
   REAL(KIND=dp), INTENT(OUT)               :: p4qtc
   REAL(KIND=dp), INTENT(OUT)               :: p5qtc
   REAL(KIND=dp), INTENT(OUT)               :: p6qtc
   REAL(KIND=dp), INTENT(OUT)               :: p7qtc
   REAL(KIND=dp), INTENT(OUT)               :: p8qtc
   REAL(KIND=dp), INTENT(OUT)               :: tbinoff
   REAL(KIND=dp), INTENT(OUT)               :: t1off
   REAL(KIND=dp), INTENT(OUT)               :: t2off
   REAL(KIND=dp), INTENT(OUT)               :: t3off
   REAL(KIND=dp), INTENT(OUT)               :: t4off
   REAL(KIND=dp), INTENT(OUT)               :: t5off
   REAL(KIND=dp), INTENT(OUT)               :: t6off
   REAL(KIND=dp), INTENT(OUT)               :: t7off
   REAL(KIND=dp), INTENT(OUT)               :: t8off
   INTEGER, INTENT(OUT)                     :: iversion
   REAL(KIND=dp), INTENT(OUT)               :: tesscontam
   INTEGER, INTENT(OUT)                     :: tessfilt
   REAL(KIND=dp), INTENT(OUT)               :: tessbin
!
   INTEGER           :: i,ios
!
   REAL(KIND=dp)     :: fake
!
   CHARACTER (LEN=1) :: bell
   CHARACTER (LEN=4) :: extension
   CHARACTER (LEN=8) :: ff
   CHARACTER (LEN=40) :: blank
!
   bell=CHAR(7)
!
   IF(kkkk > 8999)THEN
      WRITE(*,20)bell
      STOP
   END IF
!
   IF(kkkk < 8999)WRITE(extension,30)kkkk+1000
!
   IF(kkkk == 0)extension='inp'
   ff='ELC.'//extension
!
!   Set all of the integers to zero.
!
   iversion=0
   tessfilt=8
   nalph1=0
   nbet1=0
   nalph2=0
   nbet2=0
   ntheta=0
   nradius=0
   nref=0
   idraw=0
   iecheck=0
   iidint=0
   iatm=0
   ism1=0
   icnu=0
   icnb=0
   icnv=0
   icnr=0
   icni=0
   icnj=0
   icnh=0
   icnk=0
   irvfilt=0
   isw1=0
   isw2=0
   isw3=0
   isw4=0
   ilaw=0
   ikeep=0
   isynch=0
   isw5=0
   isw6=0
   isw7=0
   isw8=0
   isw9=0
   imag=0
   idark1=0
   idark2=0
   isw12=0
   isw13=0
   isw21=0
   isw22=0
   isw23=0
   isw24=0
   isw25=0
   isw26=0
   isw27=0
   isw28=0
   isw29=0
   isw30=0
   isw31=0
   isw32=0
   isw33=0
   isw34=0
   isw80=0
   isw81=0
   isw82=0
   isw83=0
   isw84=0
   isw85=0
   isw86=0
   isw87=0
   isw88=0
   isw89=0
   nalph3=0
   nbet3=0
   itconj=0
   it1=0
   it2=0
   it3=0
   it4=0
   isw100=0
   nseg=0
   i=0
   iunit=0
!
!  Set the reals to zero
!
   tessbin=0.0_dp
   tesscontam=0.0_dp
   fill1=0.0_dp
   fill2=0.0_dp
   omega1=0.0_dp
   omega2=0.0_dp
   dphase=0.0_dp
   q=1.0_dp
   finc=0.0_dp
   teff1=0.0_dp
   teff2=0.0_dp
   tgrav1=0.0_dp
   tgrav2=0.0_dp
   betarim=0.0_dp
   rinner=0.0_dp
   router=0.0_dp
   tdisk=0.0_dp
   xi=0.0_dp
   alb1=0.0_dp
   alb2=0.0_dp
   rlx=0.0_dp
   period=0.0_dp
   fm=0.0_dp
   separ=0.0_dp
   gamma=0.0_dp
   t3=0.0_dp
   g3=0.0_dp
   sa3=0.0_dp
   density=0.0_dp
   sw1=0.0_dp
   sw2=0.0_dp
   sw3=0.0_dp
   t0=0.0_dp
   ecc=0.0_dp
   argper=0.0_dp
   pshift=0.0_dp
   sw5=0.0_dp
   sw6=0.0_dp
   sw7=0.0_dp
   sw8=0.0_dp
   sw9=0.0_dp
   omega9=0.0_dp
   primmass=0.0_dp
   primk=0.0_dp
   primrad=0.0_dp
   ratrad=0.0_dp
   frac1=0.0_dp
   frac2=0.0_dp
   fillsum=0.0_dp
   filldiff=0.0_dp
   ecosw=0.0_dp
   temprat=0.0_dp
   bigi=0.0_dp
   bigbeta=0.0_dp
   sw23=0.0_dp
   sw24=0.0_dp
   sw25=0.0_dp
   sw26=0.0_dp
   sw27=0.0_dp
   sw28=0.0_dp
   sw29=0.0_dp
   sw30=0.0_dp
   contam=0.0_dp
   tconj=0.0_dp
   beam1=0.0_dp
   beam2=0.0_dp
   ocose=0.0_dp
   osine=0.0_dp
   omegadot=0.0_dp
   contams0=0.0_dp
   contams1=0.0_dp
   contams2=0.0_dp
   contams3=0.0_dp
   sw47=0.0_dp
   sw48=0.0_dp
   sw49=0.0_dp
   sw80=0.0_dp
   sw81=0.0_dp
   sw82=0.0_dp
   sw83=0.0_dp
   sw84=0.0_dp
   sw85=0.0_dp
   sw86=0.0_dp
   sw87=0.0_dp
   sw88=0.0_dp
   sw89=0.0_dp
   tertperiod=0.0_dp
   tertt0=0.0_dp
   tertecos=0.0_dp
   omega8=0.0_dp
   tertesin=0.0_dp
   tertincl=0.0_dp
   tertomega=0.0_dp
   tertq=0.0_dp
   tertconj=0.0_dp
   tertratrad=0.0_dp
   hh=0.0_dp
   sw72=0.0_dp
   sw73=0.0_dp
   p2tconj=0.0_dp
   p2period=0.0_dp
   p2t0=0.0_dp
   p2ecos=0.0_dp
   p2esin=0.0_dp
   p2incl=0.0_dp
   p2omega=0.0_dp
   p2q=0.0_dp
   p2ratrad=0.0_dp
   p3tconj=0.0_dp
   p3period=0.0_dp
   p3t0=0.0_dp
   p3ecos=0.0_dp
   p3esin=0.0_dp
   p3incl=0.0_dp
   p3omega=0.0_dp
   p3q=0.0_dp
   p3ratrad=0.0_dp
   p4tconj=0.0_dp
   p4period=0.0_dp
   p4t0=0.0_dp
   p4ecos=0.0_dp
   p4esin=0.0_dp
   p4incl=0.0_dp
   p4omega=0.0_dp
   p4q=0.0_dp
   omega7=0.0_dp
   p4ratrad=0.0_dp
   p5tconj=0.0_dp
   p5period=0.0_dp
   p5t0=0.0_dp
   p5ecos=0.0_dp
   p5esin=0.0_dp
   p5incl=0.0_dp
   p5omega=0.0_dp
   p5q=0.0_dp
   p5ratrad=0.0_dp
   p6tconj=0.0_dp
   p6period=0.0_dp
   p6t0=0.0_dp
   p6ecos=0.0_dp
   p6esin=0.0_dp
   p6incl=0.0_dp
   p6omega=0.0_dp
   p6q=0.0_dp
   p6ratrad=0.0_dp
   p7tconj=0.0_dp
   p7period=0.0_dp
   p7t0=0.0_dp
   p7ecos=0.0_dp
   p7esin=0.0_dp
   p7incl=0.0_dp
   p7omega=0.0_dp
   p7q=0.0_dp
   p7ratrad=0.0_dp
   p8tconj=0.0_dp
   p8period=0.0_dp
   p8t0=0.0_dp
   p8ecos=0.0_dp
   p8esin=0.0_dp
   p8incl=0.0_dp
   p8omega=0.0_dp
   p8q=0.0_dp
   p8ratrad=0.0_dp
   secmass=0.0_dp
   rk3=0.0_dp
   rk4=0.0_dp
   rk5=0.0_dp
   rk6=0.0_dp
   rk7=0.0_dp
   rk8=0.0_dp
   rk9=0.0_dp
   rk10=0.0_dp
   t6=0.0_dp
   g6=0.0_dp
   omega5=0.0_dp
   g7=0.0_dp
   t7=0.0_dp
   t8=0.0_dp
   g8=0.0_dp
   omega3=0.0_dp
   t9=0.0_dp
   g9=0.0_dp
   t10=0.0_dp
   g10=0.0_dp
   secrad=0.0_dp
   omega4=0.0_dp
   radsum=0.0_dp
   raddiff=0.0_dp
   masssum=0.0_dp
   massdiff=0.0_dp
   p1ptc=0.0_dp
   p1mtc=0.0_dp
   p2ptc=0.0_dp
   p2mtc=0.0_dp
   p5ptc=0.0_dp
   p5mtc=0.0_dp
   p6ptc=0.0_dp
   p6mtc=0.0_dp
   p7ptc=0.0_dp
   p7mtc=0.0_dp
   p8ptc=0.0_dp
   p8mtc=0.0_dp
   p3ptc=0.0_dp
   p3mtc=0.0_dp
   pbptc=0.0_dp
   pbmtc=0.0_dp
   p4ptc=0.0_dp
   p4mtc=0.0_dp
   bigi4=0.0_dp
   bigbeta4=0.0_dp
   b2masssum=0.0_dp
   b2massdiff=0.0_dp
   bin2q=0.0_dp
   b2radsum=0.0_dp
   b2raddiff=0.0_dp
   bin2ratrad=0.0_dp
   bigi2=0.0_dp
   bigbeta2=0.0_dp
   bigi3=0.0_dp
   bigbeta3=0.0_dp
   fake=0.0_dp
   omega6=0.0_dp
   omega10=0.0_dp
   fracsum=0.0_dp
   fracdiff=0.0_dp
   bin2m3=0.0_dp
   bin2m4=0.0_dp
   bin2r3=0.0_dp
   bin2r4=0.0_dp
   sqecos=0.0_dp
   sqesin=0.0_dp
   sqtertecos=0.0_dp
   sqtertesin=0.0_dp
   sqp2ecos=0.0_dp
   sqp2esin=0.0_dp
   sqp3ecos=0.0_dp
   sqp3esin=0.0_dp
   sqp4ecos=0.0_dp
   sqp4esin=0.0_dp
   sqp5ecos=0.0_dp
   sqp5esin=0.0_dp
   sqp6ecos=0.0_dp
   sqp6esin=0.0_dp
   sqp7ecos=0.0_dp
   sqp7esin=0.0_dp
   sqp8ecos=0.0_dp
   sqp8esin=0.0_dp
   angsum1=0.0_dp
   angdiff1=0.0_dp
   angsum2=0.0_dp
   angdiff2=0.0_dp
   angsum3=0.0_dp
   angdiff3=0.0_dp
   angsum4=0.0_dp
   angdiff4=0.0_dp
   angsum5=0.0_dp
   angdiff5=0.0_dp
   angsum6=0.0_dp
   angdiff6=0.0_dp
   angsum7=0.0_dp
   angdiff7=0.0_dp
   angsum8=0.0_dp
   angdiff8=0.0_dp
   binqtc=-99.0_dp
   p1qtc=-99.0_dp
   p2qtc=-99.0_dp
   p3qtc=-99.0_dp
   p4qtc=-99.0_dp
   p5qtc=-99.0_dp
   p6qtc=-99.0_dp
   p7qtc=-99.0_dp
   p8qtc=-99.0_dp
   tbinoff=0.0_dp
   t1off=0.0_dp
   t2off=0.0_dp
   t3off=0.0_dp
   t4off=0.0_dp
   t5off=0.0_dp
   t6off=0.0_dp
   t7off=0.0_dp
   t8off=0.0_dp
!
   DO i=1,8
      dbolx(i,1)=0.6_dp
      dbolx(i,2)=0.4_dp
      wave(i)=0.0_dp
      sdarkint1(i)=0.0_dp
      sdarkint2(i)=0.0_dp
      sdarkint3(i)=0.0_dp
      sdarkint4(i)=0.0_dp
      sdarkint5(i)=0.0_dp
      sdarkint6(i)=0.0_dp
      sdarkint7(i)=0.0_dp
      sdarkint8(i)=0.0_dp
      sdarkint9(i)=0.0_dp
      sdarkint10(i)=0.0_dp
      dwavex(i,1)=0.64_dp
      dwavey(i,1)=0.46_dp
      dwavex(i,2)=0.64_dp
      dwavey(i,2)=0.46_dp
      dwavex(i,3)=0.64_dp
      dwavey(i,3)=0.46_dp
      dwavex(i,4)=0.64_dp
      dwavey(i,4)=0.46_dp
      dwavex(i,5)=0.64_dp
      dwavey(i,5)=0.46_dp
      dwavex(i,6)=0.64_dp
      dwavey(i,6)=0.46_dp
      dwavex(i,7)=0.342_dp
      dwavey(i,7)=0.721_dp
      dwavex(i,8)=0.123_dp
      dwavey(i,8)=0.456_dp
      dwavex(i,9)=0.456_dp
      dwavey(i,9)=0.789_dp
      dwavex(i,10)=0.987_dp
      dwavey(i,10)=0.654_dp
      powercoeff(i,1)=0.0_dp
      powercoeff(i,2)=0.0_dp
      powercoeff(i,3)=0.0_dp
      powercoeff(i,4)=0.0_dp
      powercoeff(i,5)=0.0_dp
      powercoeff(i,6)=0.0_dp
      powercoeff(i,7)=0.0_dp
      powercoeff(i,8)=0.0_dp
      powercoeff(i,9)=0.0_dp
   END DO
!
   DO i=1,4
      spot1parm(1,i)=0.0_dp
      spot1parm(2,i)=0.0_dp
      spot2parm(1,i)=0.0_dp
      spot2parm(2,i)=0.0_dp
      spotdparm(1,i)=0.0_dp
      spotdparm(2,i)=0.0_dp
   END DO

!
   ios=0
   OPEN(UNIT=1,FILE=ff,STATUS='old',ERR=10,IOSTAT=ios)
!
   READ(1,40)blank
   blank=TRIM(blank)
!
!  Determine if we read a version 6 style input, or if we
!  attempt to read the old style files.
!
   IF(blank(1:3) == '#1')iversion=0
   IF(blank(1:3) == '#2')iversion=1
   IF((blank(1:3) /= '#1').AND.(blank(1:3) /= '#2'))THEN
      CLOSE(1)
!
!   if KKKK = 0, then read ELC.inp and ELCbody3.inp
!
      IF(kkkk == 0)THEN
         CALL getinput(nalph1,nbet1,nalph2,nbet2,fill1,fill2,  &
            omega1,omega2,dphase,q,finc,teff1,teff2,tgrav1,tgrav2,  &
            betarim,rinner,router,tdisk,xi,ntheta,nradius,alb1,alb2,  &
            nref,rlx,period,fm,separ,gamma,t3,g3,sa3,density,sw1,sw2,  &
            sw3,t0,idraw,iecheck,iidint,iatm,ism1,icnu,icnb,icnv,  &
            icnr,icni,icnj,icnh,icnk,irvfilt,isw1,isw2,isw3,isw4,  &
            ilaw,wave,dbolx,dboly,dwavex,dwavey,ecc,argper,pshift,  &
            sw5,sw6,sw7,sw8,sw9,ikeep,isynch,isw5,isw6,isw7,isw8,  &
            isw9,spot1parm,spot2parm,spotdparm,primmass,primk,  &
            primrad,ratrad,frac1,frac2,ecosw,temprat,idark1,idark2,  &
            isw12,isw13,isw21,isw22,isw23,isw24,bigi,bigbeta,sw23,  &
            sw24,powercoeff,sw25,sw26,sw27,sw28,sw29,sw30,contam,  &
            tconj,beam1,beam2,isw25,isw26,isw27,isw28,isw29,isw30,  &
            isw31,isw32,isw33,isw34,ocose,osine,omegadot,contams0,  &
            contams1,contams2,contams3,sw47,sw48,sw49,sw80,sw81,sw82,  &
            sw83,sw84,sw85,sw86,sw87,sw88,sw89,isw80,isw81,isw82,  &
            isw83,isw84,isw85,isw86,isw87,isw88,isw89,sdarkint1,  &
            sdarkint2,sdarkint3,sdarkint4,sdarkint5)
!
!   If isw30 >= 1, then load the third body parameters
!
         IF((isw30 >= 1).AND.(isw7 < 2))THEN
            WRITE(*,*)'Error:  set itime=2 if body 3 switch', ' is used'
            STOP
         END IF
         IF((isw30 >= 1).AND.(isw7 >= 2))THEN
            CALL getbody3(nalph3,nbet3,tertperiod,tertt0,tertecos,  &
               tertesin,tertincl,tertomega,tertq,dwavex,dwavey,itconj,  &
               it1,it2,it3,it4,tertconj,tertratrad,hh,sw72,sw73,  &
               p2tconj,p2period,p2t0,p2ecos,p2esin,p2incl,p2omega,p2q,  &
               p2ratrad,p3tconj,p3period,p3t0,p3ecos,p3esin,p3incl,  &
               p3omega,p3q,p3ratrad,p4tconj,p4period,p4t0,p4ecos,  &
               p4esin,p4incl,p4omega,p4q,p4ratrad,p5tconj,p5period,  &
               p5t0,p5ecos,p5esin,p5incl,p5omega,p5q,p5ratrad,p6tconj,  &
               p6period,p6t0,p6ecos,p6esin,p6incl,p6omega,p6q,  &
               p6ratrad,p7tconj,p7period,p7t0,p7ecos,p7esin,p7incl,  &
               p7omega,p7q,p7ratrad,p8tconj,p8period,p8t0,p8ecos,  &
               p8esin,p8incl,p8omega,p8q,p8ratrad,isw30)
!
         END IF
      END IF
!
!   if KKKK > 0, then read ELC.1??? and ELCbody3.1???
!
      IF(kkkk > 0)THEN
         CALL getgridinput(kkkk,nalph1,nbet1,nalph2,nbet2,fill1,  &
            fill2,omega1,omega2,dphase,q,finc,teff1,teff2,tgrav1,  &
            tgrav2,betarim,rinner,router,tdisk,xi,ntheta,nradius,  &
            alb1,alb2,nref,rlx,period,fm,separ,gamma,t3,g3,sa3,  &
            density,sw1,sw2,sw3,t0,idraw,iecheck,iidint,iatm,ism1,  &
            icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,irvfilt,isw1,  &
            isw2,isw3,isw4,ilaw,wave,dbolx,dboly,dwavex,dwavey,ecc,  &
            argper,pshift,sw5,sw6,sw7,sw8,sw9,ikeep,isynch,isw5,isw6,  &
            isw7,isw8,isw9,spot1parm,spot2parm,spotdparm,primmass,  &
            primk,primrad,ratrad,frac1,frac2,ecosw,temprat,idark1,  &
            idark2,isw12,isw13,isw21,isw22,isw23,isw24,bigi,bigbeta,  &
            sw23,sw24,powercoeff,sw25,sw26,sw27,sw28,sw29,sw30,  &
            contam,tconj,beam1,beam2,isw25,isw26,isw27,isw28,isw29,  &
            isw30,isw31,isw32,isw33,isw34,ocose,osine,omegadot,  &
            contams0,contams1,contams2,contams3,sw47,sw48,sw49,sw80,  &
            sw81,sw82,sw83,sw84,sw85,sw86,sw87,sw88,sw89,isw80,isw81,  &
            isw82,isw83,isw84,isw85,isw86,isw87,isw88,isw89,  &
            sdarkint1,sdarkint2,sdarkint3,sdarkint4,sdarkint5)
!
!   If isw30 >= 1, then load the third body parameters
!
         IF((isw30 >= 1).AND.(isw7 < 2))THEN
            WRITE(*,*) 'Error:  set itime=2 if body 3 switch', ' is used'
            STOP
         END IF
         IF((isw30 >= 1).AND.(isw7 >= 2))THEN
            CALL getgridbody3(kkkk,nalph3,nbet3,tertperiod,tertt0,  &
               tertecos,tertesin,tertincl,tertomega,tertq,dwavex,  &
               dwavey,itconj,it1,it2,it3,it4,tertconj,tertratrad,hh,  &
               sw72,sw73,p2tconj,p2period,p2t0,p2ecos,p2esin,p2incl,  &
               p2omega,p2q,p2ratrad,p3tconj,p3period,p3t0,p3ecos,  &
               p3esin,p3incl,p3omega,p3q,p3ratrad,p4tconj,p4period,  &
               p4t0,p4ecos,p4esin,p4incl,p4omega,p4q,p4ratrad,p5tconj,  &
               p5period,p5t0,p5ecos,p5esin,p5incl,p5omega,p5q,  &
               p5ratrad,p6tconj,p6period,p6t0,p6ecos,p6esin,p6incl,  &
               p6omega,p6q,p6ratrad,p7tconj,p7period,p7t0,p7ecos,  &
               p7esin,p7incl,p7omega,p7q,p7ratrad,p8tconj,p8period,  &
               p8t0,p8ecos,p8esin,p8incl,p8omega,p8q,p8ratrad,isw30)
!
         END IF
      END IF
      RETURN
   END IF
!
!  We have a version 6 style input file, so start reading.
!  The various subroutines will scan for comment lines and
!  report errors for the specific variable if needed.
!
   CALL rdint(1,iunit,'iunit',ff)
   CALL rdint(1,isw7,'itime',ff)
   CALL rdreal(1,sw23,'t_start',ff)
   CALL rdreal(1,sw24,'t_end',ff)
   CALL rdreal(1,sw9,'time step',ff)
   IF((sw9 <= 0.0_dp).and.(isw7 >= 2))THEN
      WRITE(*,25)bell
   END IF
   CALL rdreal(1,dphase,'dphase',ff)
   CALL rdint(1,iatm,'iatm',ff)
   CALL rdint8(1,icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk,'icn',ff)
   CALL rdint(1,irvfilt,'iRVfilt',ff)
   CALL rdint(1,ilaw,'ilaw',ff)
   CALL rdreal(1,wave(1),'wavelength filter 1',ff)
   CALL rdreal(1,wave(2),'wavelength filter 2',ff)
   CALL rdreal(1,wave(3),'wavelength filter 3',ff)
   CALL rdreal(1,wave(4),'wavelength filter 4',ff)
   CALL rdreal(1,wave(5),'wavelength filter 5',ff)
   CALL rdreal(1,wave(6),'wavelength filter 6',ff)
   CALL rdreal(1,wave(7),'wavelength filter 7',ff)
   CALL rdreal(1,wave(8),'wavelength filter 8',ff)
   CALL rdint(1,nref,'Nref',ff)
   CALL rdreal(1,rlx,'log10(Lx)',ff)
   CALL rdint(1,isw25,'X-ray foreshortening switch',ff)
   CALL rdint(1,idark1,'idark1',ff)
   CALL rdint(1,idark2,'idark2',ff)
   CALL rdint(1,isw5,'ispotprof',ff)
   CALL rdint(1,isw6,'igrav',ff)
   CALL rdint(1,isw86,'flux switch',ff)
   CALL rdreal(1,t3,'T3',ff)
   CALL rdreal(1,g3,'g3',ff)
   CALL rdreal(1,sa3,'SA3',ff)
   CALL rdint(1,isw27,'Nterms',ff)
   CALL rdint(1,isw33,'Mandel',ff)
   CALL rdint(1,isw31,'Ngap',ff)
   CALL rdint(1,iecheck,'iecheck',ff)
   CALL rdint(1,ism1,'ism1',ff)
   CALL rdint(1,isw13,'ifasttrans',ff)
   CALL rdint(1,isw8,'MonteCarlo',ff)
   CALL rdreal(1,sw7,'phaselow',ff)
   CALL rdreal(1,sw8,'phasehigh',ff)
   CALL rdint(1,isw2,'isquare',ff)
   CALL rdint(1,isw3,'iusepot',ff)
   CALL rdreal(1,sw2,'usepot1',ff)
   CALL rdreal(1,sw3,'iusepot2',ff)
   CALL rdint(1,idraw,'idraw',ff)
   CALL rdint(1,isw1,'ionephase',ff)
   CALL rdreal(1,sw1,'onephase',ff)
   CALL rdreal(1,pshift,'pshift',ff)
   CALL rdint(1,ikeep,'ikeep',ff)
   CALL rdint(1,isynch,'isynch',ff)
   CALL rdint(1,isw21,'ialign',ff)
   CALL rdint(1,isw28,'Tconj switch',ff)
   CALL rdint(1,isw29,'e*cos(omega), e*sin(omega) switch',ff)
   CALL rdint(1,imag,'imag',ff)
   CALL rdint(1,isw9,'ieliete',ff)
   CALL rdint(1,isw4,'ifixgamma',ff)
   CALL rdint(1,isw23,'iwriteeclipse',ff)
   CALL rdint(1,isw24,'frac switch',ff)
   CALL rdint(1,isw22,'screen output supress switch',ff)
   CALL rdint(1,it4,'output files supress switch',ff)
   CALL rdreal(1,sw48,'chi^2 threshold',ff)
   CALL rdreal(1,sw6,'median fit',ff)
   CALL rdint(1,isw32,'jdum',ff)
   CALL rdint(1,isw88,'Ndynwin',ff)
   CALL rdreal(1,sw47,'Tref',ff)
   CALL rdreal(1,hh,'hh',ff)
   CALL rdint(1,isw26,'iGR',ff)
   CALL rdint(1,isw80,'binary+binary switch',ff)
   CALL rdint(1,itconj,'itconj',ff)
   CALL rdint(1,it1,'logarithmic mass ratios switch',ff)
   CALL rdint(1,isw100,'planet radii switch',ff)
   CALL rdint(1,it3,'transit treatment switch',ff)
   CALL rdint(1,isw81,'transit penalty switch',ff)
   CALL rdint(1,isw85,'secondary eclipse penalty switch',ff)
   CALL rdreal(1,sw84,'chi^2 penalty',ff)
   CALL rdint(1,it2,'informational output switch',ff)
   CALL rdreal(1,contam,'contam',ff)
   CALL rdint(1,isw34,'Iseason',ff)
   CALL rdreal(1,contams0,'contamS0',ff)
   CALL rdreal(1,contams1,'contamS1',ff)
   CALL rdreal(1,contams2,'contamS2',ff)
   CALL rdreal(1,contams3,'contamS3',ff)
   CALL rdint(1,nseg,'Nseg',ff)
   CALL rdint(1,isw87,'fast Kepler binning switch',ff)
   CALL rdreal(1,sw29,'LC bin size',ff)
   CALL rdreal(1,sw30,'RV bin size',ff)
   CALL rdint(1,isw89,'NSC',ff)
!
!  Add the part about TESS options here, if iversion=1
!
   IF(iversion == 1)THEN
      CALL rdreal(1,tesscontam,'tesscontam',ff)
      CALL rdint(1,tessfilt,'tessfilt',ff)
      CALL rdreal(1,tessbin,'tessbin',ff)
   END IF
!
   CALL rdint(1,isw30,'Nbody',ff)
   CALL rdreal(1,period,'Period',ff)
   CALL rdreal(1,t0,'T0',ff)
   CALL rdreal(1,tconj,'Tconj',ff)
   CALL rdreal(1,pbptc,'PbpTc',ff)
   CALL rdreal(1,pbmtc,'PbmTc',ff)
   CALL rdreal(1,binqtc,'binqTc',ff)
   CALL rdreal(1,tbinoff,'Tbinoff',ff)
   CALL rdreal(1,ecc,'eccentricity',ff)
   CALL rdreal(1,argper,'argper',ff)
   CALL rdreal(1,ocose,'ocose',ff)
   CALL rdreal(1,osine,'osine',ff)
   CALL rdreal(1,sqecos,'sqrt(e)*cos(omega)',ff)
   CALL rdreal(1,sqesin,'sqrt(e)*sin(omega)',ff)
   CALL rdreal(1,finc,'finc',ff)
   CALL rdreal(1,sw49,'Omega_bin',ff)
   CALL rdreal(1,primk,'primK',ff)
   CALL rdreal(1,separ,'separ',ff)
   CALL rdreal(1,gamma,'gamma',ff)
   CALL rdreal(1,ecosw,'ecosw',ff)
   CALL rdint2(1,nalph1,nbet1,'Nalph1,Nbet1',ff)
   CALL rdreal(1,teff1,'Teff1',ff)
   CALL rdreal(1,tgrav1,'Tgrav1',ff)
   CALL rdreal(1,alb1,'alb1',ff)
   CALL rdreal(1,omega1,'omega1',ff)
   CALL rdreal(1,fill1,'fill1',ff)
   CALL rdreal(1,primrad,'primrad',ff)
   CALL rdreal(1,frac1,'frac1',ff)
   CALL rdreal(1,sw27,'radfill1',ff)
   CALL rdreal(1,primmass,'primmass',ff)
   CALL rdreal(1,bigi,'bigI',ff)
   CALL rdreal(1,bigbeta,'bigbeta',ff)
   CALL rdreal2(1,dwavex(1,1),dwavey(1,1),'l.d. 1, band 1',ff)
   CALL rdreal2(1,dwavex(2,1),dwavey(2,1),'l.d. 1, band 2',ff)
   CALL rdreal2(1,dwavex(3,1),dwavey(3,1),'l.d. 1, band 3',ff)
   CALL rdreal2(1,dwavex(4,1),dwavey(4,1),'l.d. 1, band 4',ff)
   CALL rdreal2(1,dwavex(5,1),dwavey(5,1),'l.d. 1, band 5',ff)
   CALL rdreal2(1,dwavex(6,1),dwavey(6,1),'l.d. 1, band 6',ff)
   CALL rdreal2(1,dwavex(7,1),dwavey(7,1),'l.d. 1, band 7',ff)
   CALL rdreal2(1,dwavex(8,1),dwavey(8,1),'l.d. 1, band 8',ff)
   CALL rdreal2(1,dbolx(1,1),dboly(1,1),'bolo. l.d. 1',ff)
   CALL rdreal(1,spot1parm(1,1),'spot1parm 1,1',ff)
   CALL rdreal(1,spot1parm(1,2),'spot1parm 1,2',ff)
   CALL rdreal(1,spot1parm(1,3),'spot1parm 1,3',ff)
   CALL rdreal(1,spot1parm(1,4),'spot1parm 1,4',ff)
   CALL rdreal(1,spot1parm(2,1),'spot1parm 2,1',ff)
   CALL rdreal(1,spot1parm(2,2),'spot1parm 2,2',ff)
   CALL rdreal(1,spot1parm(2,3),'spot1parm 2,3',ff)
   CALL rdreal(1,spot1parm(2,4),'spot1parm 2,4',ff)
   CALL rdreal(1,beam1,'beam1',ff)
   CALL rdreal(1,sw72,'rk1',ff)
   CALL rdreal(1,sdarkint1(1),'flux 1, band 1',ff)
   CALL rdreal(1,sdarkint1(2),'flux 1, band 2',ff)
   CALL rdreal(1,sdarkint1(3),'flux 1, band 3',ff)
   CALL rdreal(1,sdarkint1(4),'flux 1, band 4',ff)
   CALL rdreal(1,sdarkint1(5),'flux 1, band 5',ff)
   CALL rdreal(1,sdarkint1(6),'flux 1, band 6',ff)
   CALL rdreal(1,sdarkint1(7),'flux 1, band 7',ff)
   CALL rdreal(1,sdarkint1(8),'flux 1, band 8',ff)
   CALL rdint2(1,nalph2,nbet2,'Nalph2',ff)
   CALL rdreal(1,teff2,'Teff2',ff)
   CALL rdreal(1,temprat,'temprat',ff)
   CALL rdreal(1,tgrav2,'Tgrav2',ff)
   CALL rdreal(1,alb2,'alb2',ff)
   CALL rdreal(1,omega2,'omega2',ff)
   CALL rdreal(1,fill2,'fill2',ff)
   CALL rdreal(1,fillsum,'fillsum',ff)
   CALL rdreal(1,filldiff,'filldiff',ff)
   CALL rdreal(1,secrad,'secrad',ff)
   CALL rdreal(1,frac2,'frac2',ff)
   CALL rdreal(1,ratrad,'ratrad',ff)
   CALL rdreal(1,radsum,'radsum',ff)
   CALL rdreal(1,raddiff,'raddiff',ff)
   CALL rdreal(1,fracsum,'fracsum',ff)
   CALL rdreal(1,fracdiff,'fracdiff',ff)
   CALL rdreal(1,sw28,'radfill2',ff)
   CALL rdreal(1,q,'Q',ff)
   CALL rdreal(1,secmass,'secmass',ff)
   CALL rdreal(1,masssum,'masssum',ff)
   CALL rdreal(1,massdiff,'massdiff',ff)
   CALL rdreal(1,bigi2,'axis_I2',ff)
   CALL rdreal(1,bigbeta2,'axis_beta2',ff)
   CALL rdreal2(1,dwavex(1,2),dwavey(1,2),'l.d. 2 band 1',ff)
   CALL rdreal2(1,dwavex(2,2),dwavey(2,2),'l.d. 2 band 2',ff)
   CALL rdreal2(1,dwavex(3,2),dwavey(3,2),'l.d. 2 band 3',ff)
   CALL rdreal2(1,dwavex(4,2),dwavey(4,2),'l.d. 2 band 4',ff)
   CALL rdreal2(1,dwavex(5,2),dwavey(5,2),'l.d. 2 band 5',ff)
   CALL rdreal2(1,dwavex(6,2),dwavey(6,2),'l.d. 2 band 6',ff)
   CALL rdreal2(1,dwavex(7,2),dwavey(7,2),'l.d. 2 band 7',ff)
   CALL rdreal2(1,dwavex(8,2),dwavey(8,2),'l.d. 2 band 8',ff)
   CALL rdreal2(1,dbolx(1,2),dboly(1,2),'bolo. l.d. 2',ff)
   CALL rdreal(1,spot2parm(1,1),'spot2 parm 1,1 ',ff)
   CALL rdreal(1,spot2parm(1,2),'spot2 parm 1,2 ',ff)
   CALL rdreal(1,spot2parm(1,3),'spot2 parm 1,3 ',ff)
   CALL rdreal(1,spot2parm(1,4),'spot2 parm 1,4 ',ff)
   CALL rdreal(1,spot2parm(2,1),'spot2 parm 2,1 ',ff)
   CALL rdreal(1,spot2parm(2,2),'spot2 parm 2,2 ',ff)
   CALL rdreal(1,spot2parm(2,3),'spot2 parm 2,3 ',ff)
   CALL rdreal(1,spot2parm(2,4),'spot2 parm 2,4 ',ff)
   CALL rdreal(1,beam2,'beam2',ff)
   CALL rdreal(1,sw73,'rk2',ff)
   CALL rdreal(1,sdarkint2(1),'flux 2, band 1',ff)
   CALL rdreal(1,sdarkint2(2),'flux 2, band 2',ff)
   CALL rdreal(1,sdarkint2(3),'flux 2, band 3',ff)
   CALL rdreal(1,sdarkint2(4),'flux 2, band 4',ff)
   CALL rdreal(1,sdarkint2(5),'flux 2, band 5',ff)
   CALL rdreal(1,sdarkint2(6),'flux 2, band 6',ff)
   CALL rdreal(1,sdarkint2(7),'flux 2, band 7',ff)
   CALL rdreal(1,sdarkint2(8),'flux 2, band 8',ff)
   CALL rdint(1,iidint,'idint',ff)
   CALL rdint(1,ntheta,'Ntheta',ff)
   CALL rdint(1,nradius,'Nradius',ff)
   CALL rdreal(1,betarim,'betarim',ff)
   CALL rdreal(1,rinner,'rinner',ff)
   CALL rdreal(1,router,'router',ff)
   CALL rdreal(1,tdisk,'tdisk',ff)
   CALL rdreal(1,xi,'xi',ff)
   CALL rdreal(1,spotdparm(1,1),'disk spot 1,1',ff)
   CALL rdreal(1,spotdparm(1,2),'disk spot 1,2',ff)
   CALL rdreal(1,spotdparm(1,3),'disk spot 1,3',ff)
   CALL rdreal(1,spotdparm(1,4),'disk spot 1,4',ff)
   CALL rdreal(1,spotdparm(2,1),'disk spot 2,1',ff)
   CALL rdreal(1,spotdparm(2,2),'disk spot 2,2',ff)
   CALL rdreal(1,spotdparm(2,3),'disk spot 2,3',ff)
   CALL rdreal(1,spotdparm(2,4),'disk spot 2,4',ff)
   CALL rdreal(1,sw26,'reference phase disk fraction',ff)
   CALL rdreal(1,sw5,'asin(i)',ff)
   CALL rdreal(1,sw25,'asin(i) error',ff)
!
   DO i=2,8
      dbolx(i,1)=dbolx(1,1)
      dboly(i,1)=dboly(1,1)
      dbolx(i,2)=dbolx(1,2)
      dboly(i,2)=dboly(1,2)
   END DO
!
!  If Nbody < 3, then we are done.
!
   IF(isw30 < 3)THEN
      CLOSE(1)
      RETURN
   END IF
!
   CALL rdreal(1,tertconj,'P1Tconj',ff)
   CALL rdreal(1,tertperiod,'P1period',ff)
   CALL rdreal(1,p1ptc,'P1pTc',ff)
   CALL rdreal(1,p1mtc,'P1mTc',ff)
   CALL rdreal(1,p1qtc,'P1qTc',ff)
   CALL rdreal(1,t1off,'T1off',ff)
   CALL rdreal(1,tertt0,'P1T0',ff)
   CALL rdreal(1,tertecos,'P1e*cos',ff)
   CALL rdreal(1,tertesin,'P1e*sin',ff)
   CALL rdreal(1,sqtertecos,'P1sqrt(e)*cos',ff)
   CALL rdreal(1,sqtertesin,'P1sqrt(e)*sin',ff)
   CALL rdreal(1,tertincl,'P1incl',ff)
   CALL rdreal(1,tertomega,'P1Omega',ff)
   CALL rdreal(1,angsum1,'angsum1',ff)
   CALL rdreal(1,angdiff1,'angdiff1',ff)
   CALL rdint2(1,nalph3,nbet3,'Nalph3',ff)
   CALL rdreal(1,t3,'T3',ff)
   CALL rdreal(1,g3,'g3',ff)
   CALL rdreal(1,tertratrad,'P1ratrad',ff)
   CALL rdreal(1,tertq,'P1Q',ff)
   CALL rdreal(1,omega3,'omega3',ff)
   CALL rdreal(1,bigi3,'axis_I3',ff)
   CALL rdreal(1,bigbeta3,'axis_beta3',ff)
   CALL rdreal2(1,dwavex(1,3),dwavey(1,3),' l.d. 3, band 1',ff)
   CALL rdreal2(1,dwavex(2,3),dwavey(2,3),' l.d. 3, band 2',ff)
   CALL rdreal2(1,dwavex(3,3),dwavey(3,3),' l.d. 3, band 3',ff)
   CALL rdreal2(1,dwavex(4,3),dwavey(4,3),' l.d. 3, band 4',ff)
   CALL rdreal2(1,dwavex(5,3),dwavey(5,3),' l.d. 3, band 5',ff)
   CALL rdreal2(1,dwavex(6,3),dwavey(6,3),' l.d. 3, band 6',ff)
   CALL rdreal2(1,dwavex(7,3),dwavey(7,3),' l.d. 3, band 7',ff)
   CALL rdreal2(1,dwavex(8,3),dwavey(8,3),' l.d. 3, band 8',ff)
   CALL rdreal(1,rk3,'rk3',ff)
   CALL rdreal(1,sdarkint3(1),'flux 3, band 1',ff)
   CALL rdreal(1,sdarkint3(2),'flux 3, band 2',ff)
   CALL rdreal(1,sdarkint3(3),'flux 3, band 3',ff)
   CALL rdreal(1,sdarkint3(4),'flux 3, band 4',ff)
   CALL rdreal(1,sdarkint3(5),'flux 3, band 5',ff)
   CALL rdreal(1,sdarkint3(6),'flux 3, band 6',ff)
   CALL rdreal(1,sdarkint3(7),'flux 3, band 7',ff)
   CALL rdreal(1,sdarkint3(8),'flux 3, band 8',ff)
!
!  If Nbody < 4, then we are done.
!
   IF(isw30 < 4)THEN
      CLOSE(1)
      RETURN
   END IF
!
   CALL rdreal(1,p2tconj,'P2tconj',ff)
   CALL rdreal(1,p2period,'P2period',ff)
   CALL rdreal(1,p2ptc,'P2pTc',ff)
   CALL rdreal(1,p2mtc,'P2mTc',ff)
   CALL rdreal(1,p2qtc,'P2qTc',ff)
   CALL rdreal(1,t2off,'T2off',ff)
   CALL rdreal(1,p2t0,'P2T0',ff)
   CALL rdreal(1,p2ecos,'P2ecos',ff)
   CALL rdreal(1,p2esin,'P2esin',ff)
   CALL rdreal(1,sqp2ecos,'P2sqrt(e)cos',ff)
   CALL rdreal(1,sqp2esin,'P2sqrt(e)sin',ff)
   CALL rdreal(1,p2incl,'P2incl',ff)
   CALL rdreal(1,p2omega,'P2Omega',ff)
   CALL rdreal(1,angsum2,'angsum2',ff)
   CALL rdreal(1,angdiff2,'angdiff2',ff)
   CALL rdreal(1,sw80,'Teff4',ff)
   CALL rdreal(1,sw82,'g4',ff)
   CALL rdreal(1,p2ratrad,'P2ratrad',ff)
   CALL rdreal(1,p2q,'P2Q',ff)
   CALL rdreal(1,omega4,'omega4',ff)
   CALL rdreal(1,bigi4,'axis_I4',ff)
   CALL rdreal(1,bigbeta4,'axis_beta4',ff)
   CALL rdreal2(1,dwavex(1,4),dwavey(1,4),'l.d. 4, band 1',ff)
   CALL rdreal2(1,dwavex(2,4),dwavey(2,4),'l.d. 4, band 2',ff)
   CALL rdreal2(1,dwavex(3,4),dwavey(3,4),'l.d. 4, band 3',ff)
   CALL rdreal2(1,dwavex(4,4),dwavey(4,4),'l.d. 4, band 4',ff)
   CALL rdreal2(1,dwavex(5,4),dwavey(5,4),'l.d. 4, band 5',ff)
   CALL rdreal2(1,dwavex(6,4),dwavey(6,4),'l.d. 4, band 6',ff)
   CALL rdreal2(1,dwavex(7,4),dwavey(7,4),'l.d. 4, band 7',ff)
   CALL rdreal2(1,dwavex(8,4),dwavey(8,4),'l.d. 4, band 8',ff)
   CALL rdreal(1,rk4,'rk4',ff)
   CALL rdreal(1,sdarkint4(1),'flux 4, band 1',ff)
   CALL rdreal(1,sdarkint4(2),'flux 4, band 2',ff)
   CALL rdreal(1,sdarkint4(3),'flux 4, band 3',ff)
   CALL rdreal(1,sdarkint4(4),'flux 4, band 4',ff)
   CALL rdreal(1,sdarkint4(5),'flux 4, band 5',ff)
   CALL rdreal(1,sdarkint4(6),'flux 4, band 6',ff)
   CALL rdreal(1,sdarkint4(7),'flux 4, band 7',ff)
   CALL rdreal(1,sdarkint4(8),'flux 4, band 8',ff)
   CALL rdreal(1,b2masssum,'bin2masssum',ff)
   CALL rdreal(1,b2massdiff,'bin2massdiff',ff)
   CALL rdreal(1,bin2q,'bin2Q',ff)
   CALL rdreal(1,b2radsum,'bin2radsum',ff)
   CALL rdreal(1,b2raddiff,'bin2raddiff',ff)
   CALL rdreal(1,bin2ratrad,'bin2ratrad',ff)
   CALL rdreal(1,bin2m3,'bin2M3',ff)
   CALL rdreal(1,bin2m4,'bin2M4',ff)
   CALL rdreal(1,bin2r3,'bin2R3',ff)
   CALL rdreal(1,bin2r4,'bin2R4',ff)
!
!  If Nbody < 5, then we are done.
!
   IF(isw30 < 5)THEN
      CLOSE(1)
      RETURN
   END IF
!
   CALL rdreal(1,p3tconj,'P3tconj',ff)
   CALL rdreal(1,p3period,'P3period',ff)
   CALL rdreal(1,p3ptc,'P3pTc',ff)
   CALL rdreal(1,p3mtc,'P3mTc',ff)
   CALL rdreal(1,p3qtc,'P3qTc',ff)
   CALL rdreal(1,t3off,'T3off',ff)
   CALL rdreal(1,p3t0,'P3T0',ff)
   CALL rdreal(1,p3ecos,'P3ecos',ff)
   CALL rdreal(1,p3esin,'P3esin',ff)
   CALL rdreal(1,sqp3ecos,'P3sqrt(e)cos',ff)
   CALL rdreal(1,sqp3esin,'P3sqrt(e)sin',ff)
   CALL rdreal(1,p3incl,'P3incl',ff)
   CALL rdreal(1,p3omega,'P3Omega',ff)
   CALL rdreal(1,angsum3,'angsum3',ff)
   CALL rdreal(1,angdiff3,'angdiff3',ff)
   CALL rdreal(1,sw81,'Teff5',ff)
   CALL rdreal(1,sw83,'g5',ff)
   CALL rdreal(1,p3ratrad,'P3ratrad',ff)
   CALL rdreal(1,p3q,'P3Q',ff)
   CALL rdreal(1,omega5,'omega5',ff)
   CALL rdreal(1,fake,'axis_I5',ff)
   CALL rdreal(1,fake,'axis_beta5',ff)
   CALL rdreal2(1,dwavex(1,5),dwavey(1,5),'l.d. 5,band 1',ff)
   CALL rdreal2(1,dwavex(2,5),dwavey(2,5),'l.d. 5,band 2',ff)
   CALL rdreal2(1,dwavex(3,5),dwavey(3,5),'l.d. 5,band 3',ff)
   CALL rdreal2(1,dwavex(4,5),dwavey(4,5),'l.d. 5,band 4',ff)
   CALL rdreal2(1,dwavex(5,5),dwavey(5,5),'l.d. 5,band 5',ff)
   CALL rdreal2(1,dwavex(6,5),dwavey(6,5),'l.d. 5,band 6',ff)
   CALL rdreal2(1,dwavex(7,5),dwavey(7,5),'l.d. 5,band 7',ff)
   CALL rdreal2(1,dwavex(8,5),dwavey(8,5),'l.d. 5,band 8',ff)
   CALL rdreal(1,rk5,'rk5',ff)
   CALL rdreal(1,sdarkint5(1),'flux 5, band 1',ff)
   CALL rdreal(1,sdarkint5(2),'flux 5, band 2',ff)
   CALL rdreal(1,sdarkint5(3),'flux 5, band 3',ff)
   CALL rdreal(1,sdarkint5(4),'flux 5, band 4',ff)
   CALL rdreal(1,sdarkint5(5),'flux 5, band 5',ff)
   CALL rdreal(1,sdarkint5(6),'flux 5, band 6',ff)
   CALL rdreal(1,sdarkint5(7),'flux 5, band 7',ff)
   CALL rdreal(1,sdarkint5(8),'flux 5, band 8',ff)
!
!  If Nbody < 6, then we are done.
!
   IF(isw30 < 6)THEN
      CLOSE(1)
      RETURN
   END IF
!
   CALL rdreal(1,p4tconj,'P4tconj',ff)
   CALL rdreal(1,p4period,'P4period',ff)
   CALL rdreal(1,p4ptc,'P4pTc',ff)
   CALL rdreal(1,p4mtc,'P4mTc',ff)
   CALL rdreal(1,p4qtc,'P4qTc',ff)
   CALL rdreal(1,t4off,'T4off',ff)
   CALL rdreal(1,p4t0,'P4T0',ff)
   CALL rdreal(1,p4ecos,'P4ecos',ff)
   CALL rdreal(1,p4esin,'P4esin',ff)
   CALL rdreal(1,sqp4ecos,'P4sqrt(e)cos',ff)
   CALL rdreal(1,sqp4esin,'P4sqrt(e)sin',ff)
   CALL rdreal(1,p4incl,'P4incl',ff)
   CALL rdreal(1,p4omega,'P4Omega',ff)
   CALL rdreal(1,angsum4,'angsum4',ff)
   CALL rdreal(1,angdiff4,'angdiff4',ff)
   CALL rdreal(1,t6,'t6',ff)
   CALL rdreal(1,g6,'g6',ff)
   CALL rdreal(1,p4ratrad,'P4ratrad',ff)
   CALL rdreal(1,p4q,'P4Q',ff)
   CALL rdreal(1,omega6,'omega6',ff)
   CALL rdreal(1,fake,'axis_I6',ff)
   CALL rdreal(1,fake,'axis_beta6',ff)
   CALL rdreal2(1,dwavex(1,6),dwavey(1,6),'l.d. 6, band 1',ff)
   CALL rdreal2(1,dwavex(2,6),dwavey(2,6),'l.d. 6, band 2',ff)
   CALL rdreal2(1,dwavex(3,6),dwavey(3,6),'l.d. 6, band 3',ff)
   CALL rdreal2(1,dwavex(4,6),dwavey(4,6),'l.d. 6, band 4',ff)
   CALL rdreal2(1,dwavex(5,6),dwavey(5,6),'l.d. 6, band 5',ff)
   CALL rdreal2(1,dwavex(6,6),dwavey(6,6),'l.d. 6, band 6',ff)
   CALL rdreal2(1,dwavex(7,6),dwavey(7,6),'l.d. 6, band 7',ff)
   CALL rdreal2(1,dwavex(8,6),dwavey(8,6),'l.d. 6, band 8',ff)
   CALL rdreal(1,rk6,'rk6',ff)
   CALL rdreal(1,sdarkint6(1),'flux 6, band 1',ff)
   CALL rdreal(1,sdarkint6(2),'flux 6, band 2',ff)
   CALL rdreal(1,sdarkint6(3),'flux 6, band 3',ff)
   CALL rdreal(1,sdarkint6(4),'flux 6, band 4',ff)
   CALL rdreal(1,sdarkint6(5),'flux 6, band 5',ff)
   CALL rdreal(1,sdarkint6(6),'flux 6, band 6',ff)
   CALL rdreal(1,sdarkint6(7),'flux 6, band 7',ff)
   CALL rdreal(1,sdarkint6(8),'flux 6, band 8',ff)
!
!  If Nbody < 7, then we are done.
!
   IF(isw30 < 7)THEN
      CLOSE(1)
      RETURN
   END IF
!
   CALL rdreal(1,p5tconj,'P5tconj',ff)
   CALL rdreal(1,p5period,'P5period',ff)
   CALL rdreal(1,p5ptc,'P5pTc',ff)
   CALL rdreal(1,p5mtc,'P5mTc',ff)
   CALL rdreal(1,p5qtc,'P5qTc',ff)
   CALL rdreal(1,t5off,'T5off',ff)
   CALL rdreal(1,p5t0,'P5T0',ff)
   CALL rdreal(1,p5ecos,'P5ecos',ff)
   CALL rdreal(1,p5esin,'P5esin',ff)
   CALL rdreal(1,sqp5ecos,'P5sqrt(e)cos',ff)
   CALL rdreal(1,sqp5esin,'P5sqrt(e)sin',ff)
   CALL rdreal(1,p5incl,'P5incl',ff)
   CALL rdreal(1,p5omega,'P5Omega',ff)
   CALL rdreal(1,angsum5,'angsum5',ff)
   CALL rdreal(1,angdiff5,'angdiff5',ff)
   CALL rdreal(1,t7,'t7',ff)
   CALL rdreal(1,g7,'g7',ff)
   CALL rdreal(1,p5ratrad,'P5ratrad',ff)
   CALL rdreal(1,p5q,'P5Q',ff)
   CALL rdreal(1,omega7,'omega7',ff)
   CALL rdreal(1,fake,'axis_I7',ff)
   CALL rdreal(1,fake,'axis_beta7',ff)
   CALL rdreal2(1,dwavex(1,7),dwavey(1,7),'l.d. 7, band 1',ff)
   CALL rdreal2(1,dwavex(2,7),dwavey(2,7),'l.d. 7, band 2',ff)
   CALL rdreal2(1,dwavex(3,7),dwavey(3,7),'l.d. 7, band 3',ff)
   CALL rdreal2(1,dwavex(4,7),dwavey(4,7),'l.d. 7, band 4',ff)
   CALL rdreal2(1,dwavex(5,7),dwavey(5,7),'l.d. 7, band 5',ff)
   CALL rdreal2(1,dwavex(6,7),dwavey(6,7),'l.d. 7, band 6',ff)
   CALL rdreal2(1,dwavex(7,7),dwavey(7,7),'l.d. 7, band 7',ff)
   CALL rdreal2(1,dwavex(8,7),dwavey(8,7),'l.d. 7, band 8',ff)
   CALL rdreal(1,rk7,'rk7',ff)
   CALL rdreal(1,sdarkint7(1),'flux 7, band 1',ff)
   CALL rdreal(1,sdarkint7(2),'flux 7, band 2',ff)
   CALL rdreal(1,sdarkint7(3),'flux 7, band 3',ff)
   CALL rdreal(1,sdarkint7(4),'flux 7, band 4',ff)
   CALL rdreal(1,sdarkint7(5),'flux 7, band 5',ff)
   CALL rdreal(1,sdarkint7(6),'flux 7, band 6',ff)
   CALL rdreal(1,sdarkint7(7),'flux 7, band 7',ff)
   CALL rdreal(1,sdarkint7(8),'flux 7, band 8',ff)
!
!  If Nbody < 8, then we are done.
!
   IF(isw30 < 8)THEN
      CLOSE(1)
      RETURN
   END IF
!
   CALL rdreal(1,p6tconj,'P6tconj',ff)
   CALL rdreal(1,p6period,'P6period',ff)
   CALL rdreal(1,p6ptc,'P6pTc',ff)
   CALL rdreal(1,p6mtc,'P6mTc',ff)
   CALL rdreal(1,p6qtc,'P6qTc',ff)
   CALL rdreal(1,t6off,'T6off',ff)
   CALL rdreal(1,p6t0,'P6T0',ff)
   CALL rdreal(1,p6ecos,'P6ecos',ff)
   CALL rdreal(1,p6esin,'P6esin',ff)
   CALL rdreal(1,sqp6ecos,'P6sqrt(e)cos',ff)
   CALL rdreal(1,sqp6esin,'P6sqrt(e)sin',ff)
   CALL rdreal(1,p6incl,'P6incl',ff)
   CALL rdreal(1,p6omega,'P6Omega',ff)
   CALL rdreal(1,angsum6,'angsum6',ff)
   CALL rdreal(1,angdiff6,'angdiff6',ff)
   CALL rdreal(1,t8,'t8',ff)
   CALL rdreal(1,g8,'g8',ff)
   CALL rdreal(1,p6ratrad,'P6ratrad',ff)
   CALL rdreal(1,p6q,'P6Q',ff)
   CALL rdreal(1,omega8,'omega8',ff)
   CALL rdreal(1,fake,'axis_I8',ff)
   CALL rdreal(1,fake,'axis_beta8',ff)
   CALL rdreal2(1,dwavex(1,8),dwavey(1,8),'l.d. 8, band 1',ff)
   CALL rdreal2(1,dwavex(2,8),dwavey(2,8),'l.d. 8, band 2',ff)
   CALL rdreal2(1,dwavex(3,8),dwavey(3,8),'l.d. 8, band 3',ff)
   CALL rdreal2(1,dwavex(4,8),dwavey(4,8),'l.d. 8, band 4',ff)
   CALL rdreal2(1,dwavex(5,8),dwavey(5,8),'l.d. 8, band 5',ff)
   CALL rdreal2(1,dwavex(6,8),dwavey(6,8),'l.d. 8, band 6',ff)
   CALL rdreal2(1,dwavex(7,8),dwavey(7,8),'l.d. 8, band 7',ff)
   CALL rdreal2(1,dwavex(8,8),dwavey(8,8),'l.d. 8, band 8',ff)
   CALL rdreal(1,rk8,'rk8',ff)
   CALL rdreal(1,sdarkint8(1),'flux 8, band 1',ff)
   CALL rdreal(1,sdarkint8(2),'flux 8, band 2',ff)
   CALL rdreal(1,sdarkint8(3),'flux 8, band 3',ff)
   CALL rdreal(1,sdarkint8(4),'flux 8, band 4',ff)
   CALL rdreal(1,sdarkint8(5),'flux 8, band 5',ff)
   CALL rdreal(1,sdarkint8(6),'flux 8, band 6',ff)
   CALL rdreal(1,sdarkint8(7),'flux 8, band 7',ff)
   CALL rdreal(1,sdarkint8(8),'flux 8, band 8',ff)
!
!  If Nbody < 9, then we are done.
!
   IF(isw30 < 9)THEN
      CLOSE(1)
      RETURN
   END IF
!
   CALL rdreal(1,p7tconj,'P7tconj',ff)
   CALL rdreal(1,p7period,'P7period',ff)
   CALL rdreal(1,p7ptc,'P7pTc',ff)
   CALL rdreal(1,p7mtc,'P7mTc',ff)
   CALL rdreal(1,p7qtc,'P7qTc',ff)
   CALL rdreal(1,t7off,'T7off',ff)
   CALL rdreal(1,p7t0,'P7T0',ff)
   CALL rdreal(1,p7ecos,'P7ecos',ff)
   CALL rdreal(1,p7esin,'P7esin',ff)
   CALL rdreal(1,sqp7ecos,'P7sqrt(e)cos',ff)
   CALL rdreal(1,sqp7esin,'P7sqrt(e)esin',ff)
   CALL rdreal(1,p7incl,'P7incl',ff)
   CALL rdreal(1,p7omega,'P7Omega',ff)
   CALL rdreal(1,angsum7,'angsum7',ff)
   CALL rdreal(1,angdiff7,'angdiff7',ff)
   CALL rdreal(1,t9,'t9',ff)
   CALL rdreal(1,g9,'g9',ff)
   CALL rdreal(1,p7ratrad,'P7ratrad',ff)
   CALL rdreal(1,p7q,'P7Q',ff)
   CALL rdreal(1,omega9,'omega9',ff)
   CALL rdreal(1,fake,'axis_I9',ff)
   CALL rdreal(1,fake,'axis_I9',ff)
   CALL rdreal2(1,dwavex(1,9),dwavey(1,9),'l.d. 9, band 1',ff)
   CALL rdreal2(1,dwavex(2,9),dwavey(2,9),'l.d. 9, band 2',ff)
   CALL rdreal2(1,dwavex(3,9),dwavey(3,9),'l.d. 9, band 3',ff)
   CALL rdreal2(1,dwavex(4,9),dwavey(4,9),'l.d. 9, band 4',ff)
   CALL rdreal2(1,dwavex(5,9),dwavey(5,9),'l.d. 9, band 5',ff)
   CALL rdreal2(1,dwavex(6,9),dwavey(6,9),'l.d. 9, band 6',ff)
   CALL rdreal2(1,dwavex(7,9),dwavey(7,9),'l.d. 9, band 7',ff)
   CALL rdreal2(1,dwavex(8,9),dwavey(8,9),'l.d. 9, band 8',ff)
   CALL rdreal(1,rk9,'rk9',ff)
   CALL rdreal(1,sdarkint9(1),'flux 9, band 1',ff)
   CALL rdreal(1,sdarkint9(2),'flux 9, band 2',ff)
   CALL rdreal(1,sdarkint9(3),'flux 9, band 3',ff)
   CALL rdreal(1,sdarkint9(4),'flux 9, band 4',ff)
   CALL rdreal(1,sdarkint9(5),'flux 9, band 5',ff)
   CALL rdreal(1,sdarkint9(6),'flux 9, band 6',ff)
   CALL rdreal(1,sdarkint9(7),'flux 9, band 7',ff)
   CALL rdreal(1,sdarkint9(8),'flux 9, band 8',ff)
!
!  If Nbody < 10, then we are done.
!
   IF(isw30 < 10)THEN
      CLOSE(1)
      RETURN
   END IF
!
   CALL rdreal(1,p8tconj,'P8tconj',ff)
   CALL rdreal(1,p8period,'P8period',ff)
   CALL rdreal(1,p8ptc,'P8pTc',ff)
   CALL rdreal(1,p8mtc,'P8mTc',ff)
   CALL rdreal(1,p8qtc,'P8qTc',ff)
   CALL rdreal(1,t8off,'T8off',ff)
   CALL rdreal(1,p8t0,'P8T0',ff)
   CALL rdreal(1,p8ecos,'P8ecos',ff)
   CALL rdreal(1,p8esin,'P8esin',ff)
   CALL rdreal(1,sqp8ecos,'P8sqrt(e)cos',ff)
   CALL rdreal(1,sqp8esin,'P8sqrt(e)sin',ff)
   CALL rdreal(1,p8incl,'P8incl',ff)
   CALL rdreal(1,p8omega,'P8Omega',ff)
   CALL rdreal(1,angsum8,'angsum8',ff)
   CALL rdreal(1,angdiff8,'angdiff8',ff)
   CALL rdreal(1,t10,'t10',ff)
   CALL rdreal(1,g10,'g10',ff)
   CALL rdreal(1,p8ratrad,'P8ratrad',ff)
   CALL rdreal(1,p8q,'P8Q',ff)
   CALL rdreal(1,omega10,'omega10',ff)
   CALL rdreal(1,fake,'axis_I10',ff)
   CALL rdreal(1,fake,'axis_I10',ff)
   CALL rdreal2(1,dwavex(1,10),dwavey(1,10),'l.d. 10, band 1', ff)
   CALL rdreal2(1,dwavex(2,10),dwavey(2,10),'l.d. 10, band 1', ff)
   CALL rdreal2(1,dwavex(3,10),dwavey(3,10),'l.d. 10, band 1', ff)
   CALL rdreal2(1,dwavex(4,10),dwavey(4,10),'l.d. 10, band 1', ff)
   CALL rdreal2(1,dwavex(5,10),dwavey(5,10),'l.d. 10, band 1', ff)
   CALL rdreal2(1,dwavex(6,10),dwavey(6,10),'l.d. 10, band 1', ff)
   CALL rdreal2(1,dwavex(7,10),dwavey(7,10),'l.d. 10, band 1', ff)
   CALL rdreal2(1,dwavex(8,10),dwavey(8,10),'l.d. 10, band 1', ff)
   CALL rdreal(1,rk10,'rk10',ff)
   CALL rdreal(1,sdarkint10(1),'flux 10, band 1',ff)
   CALL rdreal(1,sdarkint10(2),'flux 10, band 2',ff)
   CALL rdreal(1,sdarkint10(3),'flux 10, band 3',ff)
   CALL rdreal(1,sdarkint10(4),'flux 10, band 4',ff)
   CALL rdreal(1,sdarkint10(5),'flux 10, band 5',ff)
   CALL rdreal(1,sdarkint10(6),'flux 10, band 6',ff)
   CALL rdreal(1,sdarkint10(7),'flux 10, band 7',ff)
   CALL rdreal(1,sdarkint10(8),'flux 10, band 8',ff)
!
   IF(ios == 0)THEN
      CLOSE(1)
      RETURN
   END IF
!
!   Come here if there is a problem with opening the file
!
10 IF(ios > 0)THEN
      IF(kkkk == 0)WRITE(*,50)bell
      IF(kkkk > 0)WRITE(*,60)bell,kkkk
      STOP
   END IF
!
20 FORMAT(a1,'index is too large')
25 FORMAT(a1,'Error:  Time step is zero when itime=2')
30 FORMAT(i4)
40 FORMAT(a40)
50 FORMAT(a1,'Error:  File ELC.inp does not exist')
60 FORMAT(a1,'Error:  File ELC.???? does not exist for index ', i4)
!
   RETURN
!
END SUBROUTINE newgetinput
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION newintg4pt(pathi,tol,rmdn,cmnx,cmny,ilaw)
!
!   Uses the Gaussian 4 point rule to evaluate the integral
!   for the appropriate limb darkening law:
!
!   ilaw = 1 linear
!   ilaw = 2 log
!   ilaw = 3 sqrt
!   ilaw = 4 quad
!   ilaw = 5 Kipping quad law
!
!   This version will use symmetry about the x-axis and use
!   half of the number of panels
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
   INTEGER, INTENT(IN)                      :: ilaw
!
   REAL(KIND=dp)  :: newintg4pt,a,b,s,h,x,y,delta,dist,w1,w2
   REAL(KIND=dp)  :: linearintgrd,logintgrd,sqrtintgrd,quadintgrd,z,t
!
   INTEGER :: k,m
!
   w1=3.47854845137453857373063949221999E-01_dp
   w2=6.52145154862546142626936050778001E-01_dp
!
   a=pathi(3)
!
!  Change the value of b here compared to the regular routine
!
   b=a+0.5_dp*pathi(4)
   m=nint((2.0_dp*rmdn*pathi(4)+1.0_dp))
   m=nint(REAL(m,KIND=dp)*tol)
   IF(MOD(m,2) == 0)m=m+1
   IF(rmdn <= 1.0_dp)THEN
      delta=SQRT(cmnx**2+cmny**2)
      IF(delta <= 1.0_dp-rmdn)THEN
         m=nint((2.0_dp*rmdn*pathi(4)+1.0_dp)*tol/3.0_dp)
         IF(m < 8)m=6
         dist=((delta-1.0_dp)**2+(rmdn-1.0_dp)**2)
         IF(dist < 1.24_dp)m=m+2
         IF(dist < 1.05_dp)m=m+2
         IF(dist < 0.95_dp)m=m+2
         IF(dist < 0.85_dp)m=m+2
         IF(dist < 0.80_dp)m=m+2
         IF(dist < 0.75_dp)m=m+2
         IF(rmdn+delta >= 0.990_dp)m=m+2
         IF(rmdn+delta >= 0.995_dp)m=m+2
         IF(rmdn+delta >= 0.997_dp)m=m+2
         IF(rmdn+delta >= 0.998_dp)m=m+2
         IF(tol >= 4.0_dp)m=nint(tol/2.0_dp)*m
      END IF
      IF((delta+rmdn >= 1.0_dp).AND.(delta+rmdn <= 1.0025_dp))m=m+2
   END IF
!
!   Because of the symmetry, we need half of the panels
!
   m=m/2
!
   s=0.0_dp
   h=(b-a)/REAL(m,KIND=dp)
   x = a + h*(1.0_dp-8.61136311594052575223946488892809E-01_dp)/2.0_dp
   y = a + h*(1.0_dp-3.39981043584856264802665759103245E-01_dp)/2.0_dp
   z = a + h*(1.0_dp+3.39981043584856264802665759103245E-01_dp)/2.0_dp
   t = a + h*(1.0_dp+8.61136311594052575223946488892809E-01_dp)/2.0_dp

   DO k=1,m
      IF(ilaw == 1)THEN
         s = s + w1*(linearintgrd(x,rmdn,cmnx,cmny)  &
            +linearintgrd(t,rmdn,cmnx,cmny)) + w2*  &
            (linearintgrd(y,rmdn,cmnx,cmny) + linearintgrd(z,rmdn,cmnx,cmny))
      END IF
      IF(ilaw == 2)THEN
         s = s + w1*(logintgrd(x,rmdn,cmnx,cmny)  &
            +logintgrd(t,rmdn,cmnx,cmny)) + w2*  &
            (logintgrd(y,rmdn,cmnx,cmny) + logintgrd(z,rmdn,cmnx,cmny))
      END IF
      IF(ilaw == 3)THEN
         s = s + w1*(sqrtintgrd(x,rmdn,cmnx,cmny)  &
            +sqrtintgrd(t,rmdn,cmnx,cmny)) + w2*  &
            (sqrtintgrd(y,rmdn,cmnx,cmny) + sqrtintgrd(z,rmdn,cmnx,cmny))
      END IF
      IF(ilaw == 4)THEN
         s = s + w1*(quadintgrd(x,rmdn,cmnx,cmny)  &
            +quadintgrd(t,rmdn,cmnx,cmny)) + w2*  &
            (quadintgrd(y,rmdn,cmnx,cmny) + quadintgrd(z,rmdn,cmnx,cmny))
      END IF
      IF(ilaw == 5)THEN
         s = s + w1*(quadintgrd(x,rmdn,cmnx,cmny)  &
            +quadintgrd(t,rmdn,cmnx,cmny)) + w2*  &
            (quadintgrd(y,rmdn,cmnx,cmny) + quadintgrd(z,rmdn,cmnx,cmny))
      END IF
      x=x+h
      y=y+h
      z=z+h
      t=t+h
   END DO
!
!  In the normal routine, we divide by two.  Owing to the symmetry
!  we need to multiply the sum by 2.
!
   s=h*s
!
   newintg4pt=s
!
   RETURN
!
END FUNCTION newintg4pt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION newintgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
!
!   Uses Gaussian quadrature to evaluate the integral
!   for the appropriate limb darkening law:
!
!   ilaw = 1 linear
!   ilaw = 2 log
!   ilaw = 3 sqrt
!   ilaw = 4 quad
!   ilaw = 5 Kipping quad law
!
!   This version will use symmetry about the x-axis and use
!   half of the number of panels.  The order of the method
!   is chosen to mminimize the quadrature error
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
   INTEGER, INTENT(IN)                      :: ilaw
!
   REAL(KIND=dp), DIMENSION(64)   :: xx,ww,xxa
   REAL(KIND=dp) :: newintgnpt,a,b,s,h,delta
   REAL(KIND=dp) :: linearintgrd,logintgrd,sqrtintgrd,quadintgrd
!
   INTEGER :: k,m,norder,muse,nopt,kk,MAX
!
!DIMENSION  xx(64),ww(64),xxa(64)
!
   a=pathi(3)
!
!  Change the value of b here compared to the regular routine
!
   b=a+0.5_dp*pathi(4)
!
   m=nint((3.7_dp*rmdn*pathi(4)+1.0_dp))
   m=nint(REAL(m,KIND=dp)*tol)
   IF(rmdn <= 1.0_dp)THEN
      delta=SQRT(cmnx**2+cmny**2)
      IF(delta <= 1.0_dp-rmdn)THEN
         m=8
         IF((rmdn < 0.25_dp).AND.(delta > -0.75_dp/0.25_dp*rmdn +1.0_dp))m=m+1
         IF((rmdn >= 0.25_dp).AND.(delta > -0.25_dp/0.75_dp*  &
            (rmdn-0.25_dp)+0.25_dp))m=m+1
         IF((rmdn < 0.35_dp).AND.(delta > -0.65_dp/0.35_dp*rmdn +1.0_dp))m=m+1
         IF((rmdn >= 0.35_dp).AND.(delta > -0.35_dp/0.65_dp*  &
            (rmdn-0.35_dp)+0.35_dp))m=m+1
         IF((rmdn < 0.40_dp).AND.(delta > -0.60_dp/0.40_dp*rmdn +1.0_dp))m=m+1
         IF((rmdn >= 0.40_dp).AND.(delta > -0.40_dp/0.60_dp*  &
            (rmdn-0.40_dp)+0.40_dp))m=m+1
!
         IF(rmdn+delta >= 0.997_dp)m=m+1
         IF(tol > 1.0_dp)m=nint(tol*REAL(m,KIND=dp))
      END IF
   END IF
!
   IF(m < 1)m=1
   norder=4
   muse=m
   nopt=m
   MAX=64
   IF(nopt <= MAX)THEN
      norder=nopt
      muse=1
   END IF
   DO k=1,100
      IF((nopt >= MAX*k+1).AND.(nopt <= (k+1)*MAX))THEN
         norder=nopt/(k+1)
         muse=k+1
      END IF
   END DO
!
   IF(norder <= 7)norder=8
!
   CALL gausscoeff(norder,xx,ww)
!
   s=0.0_dp
   h=(b-a)/REAL(muse,KIND=dp)
   DO kk=1,norder
      xxa(kk)=a+h*(1.0_dp+xx(kk))/2.0_dp
   END DO
!
   DO k=1,muse
      IF(ilaw == 1)THEN
         DO kk=1,norder
            s=s+ww(kk)*(linearintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      IF(ilaw == 2)THEN
         DO kk=1,norder
            s=s+ww(kk)*(logintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      IF(ilaw == 3)THEN
         DO kk=1,norder
            s=s+ww(kk)*(sqrtintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      IF(ilaw == 4)THEN
         DO kk=1,norder
            s=s+ww(kk)*(quadintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      IF(ilaw == 5)THEN
         DO kk=1,norder
            s=s+ww(kk)*(quadintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      DO kk=1,norder
         xxa(kk)=xxa(kk)+h
      END DO
   END DO
!
!  In the normal routine, we divide by two.  Owing to the symmetry
!  we need to multiply the sum by 2.
!
   s=h*s
!
   newintgnpt=s
!
   RETURN
!
END FUNCTION newintgnpt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE newm2tom1centric(rm1,rm2,period,ecc,rmeananom,  &
   argper,finc,omega,qqm2,ppm2)
!
!   this routine will compute the xyz M1-centric coordinates and velocity
!   of M2 given these orbital parameters.
!
!   rM1 and rM2 are in solar masses, period is in days.  The angles
!   argper, finc, and Omega are in degrees
!
!   The mean anomaly is a phase, and will be in radians
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: rm1
   REAL(KIND=dp), INTENT(IN)                :: rm2
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: rmeananom
   REAL(KIND=dp), INTENT(IN)                :: argper
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(OUT)               :: qqm2(3)
   REAL(KIND=dp), INTENT(OUT)               :: ppm2(3)
!
   REAL(KIND=dp) :: omegarad,a,p,h,cc,bige,f,r,fincr,argperrad,rmeanmotion
   REAL(KIND=dp) :: omcos,omsin,finccos,fincsin,argcos,argsin,t1,t2,t3
!
   INTEGER :: i
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
!   Find the separation
!
   a=(g*(rm1+rm2)*period*period/(4.0_dp*pie*pie))**(1.0_dp/3.0_dp)
   p=a*(1.0_dp-ecc**2)
   h=SQRT(g*(rm1+rm2)*p)
!
!   Find the true anomaly f
!
   cc=rmeananom
   cc=MOD(cc,twopie)
   cc=cc-twopie
   bige=cc
   IF(bige < twopie)bige=bige+twopie
!
   DO i=1,10
      bige=bige-(bige-ecc*SIN(bige)-cc)/(1.0_dp-ecc*COS(bige))
   END DO
!
   f=2.0_dp*ATAN(SQRT((1.0_dp+ecc)/(1.0_dp-ecc))*TAN(bige/2.0_dp))
   r=a*(1.0_dp-ecc*COS(bige))
!
!     position in orbital plane
!
   qqm2(1)=a*(COS(bige)-ecc)
   qqm2(2)=a*SQRT(1.0_dp-ecc*ecc)*SIN(bige)
   qqm2(3)=0.0_dp
!
!     velocity in orbital plane
!
   ppm2(1)=h*(-SIN(f)/r+ecc/p*SIN(f)*COS(f))
   ppm2(2)=h*(COS(f)/r+ecc/p*SIN(f)*SIN(f))
   ppm2(3)=0.0_dp
!
   rmeanmotion=h/(a*a*SQRT(1.0_dp-ecc*ecc))
   ppm2(1)=-a*rmeanmotion*SIN(bige)/(1.0_dp-ecc*COS(bige))
   ppm2(2)=SQRT(1.0_dp-ecc*ecc)*a*rmeanmotion*COS(bige)/(1.0_dp-ecc*COS(bige))
!
!   rotate through the longitude angle, then the inclination angle, and then
!   through argper angle
!
   fincr=finc
   argperrad=argper
   omegarad=omega
   omcos=COS(omegarad)
   omsin=SIN(omegarad)
   finccos=COS(fincr)
   fincsin=SIN(fincr)
   argcos=COS(argperrad)
   argsin=SIN(argperrad)
!
!   rotate velocity vector by -argper
!
   t1=qqm2(1)*argcos-qqm2(2)*argsin
   t2=qqm2(1)*argsin+qqm2(2)*argcos
   t3=qqm2(3)
   qqm2(1)=t1
   qqm2(2)=t2
   qqm2(3)=t3
!
!   rotate the result by finc
!
   t1=qqm2(1)
   t2=qqm2(2)*finccos-qqm2(3)*fincsin
   t3=qqm2(2)*fincsin+qqm2(3)*finccos
   qqm2(1)=t1
   qqm2(2)=t2
   qqm2(3)=t3
!
!   rotate by -Omega
!
   t1=qqm2(1)*omcos-qqm2(2)*omsin
   t2=qqm2(1)*omsin+qqm2(2)*omcos
   t3=qqm2(3)
   qqm2(1)=t1
   qqm2(2)=t2
   qqm2(3)=t3
!
!   rotate velocity vector by -argper
!
   t1=ppm2(1)*argcos-ppm2(2)*argsin
   t2=ppm2(1)*argsin+ppm2(2)*argcos
   t3=ppm2(3)
   ppm2(1)=t1
   ppm2(2)=t2
   ppm2(3)=t3
!
!   rotate the result by finc
!
   t1=ppm2(1)
   t2=ppm2(2)*finccos-ppm2(3)*fincsin
   t3=ppm2(2)*fincsin+ppm2(3)*finccos
   ppm2(1)=t1
   ppm2(2)=t2
   ppm2(3)=t3
!
!   rotate by -Omega
!
   t1=ppm2(1)*omcos-ppm2(2)*omsin
   t2=ppm2(1)*omsin+ppm2(2)*omcos
   t3=ppm2(3)
   ppm2(1)=t1
   ppm2(2)=t2
   ppm2(3)=t3
!
   RETURN
!
END SUBROUTINE newm2tom1centric
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE newmovetobarycenter(nbody,rmass,qq,pp,qqbc,ppbc)
!
!   move the x,y,z coordinates in the binary frame to barycenter
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: qq(30)
   REAL(KIND=dp), INTENT(IN)                :: pp(30)
   REAL(KIND=dp), INTENT(OUT)               :: qqbc(30)
   REAL(KIND=dp), INTENT(OUT)               :: ppbc(30)
!
   REAL(KIND=dp), DIMENSION(0:9)  :: eta(0:9),tempmass,tempx,tempy,tempz,tempvx
   REAL(KIND=dp), DIMENSION(0:9)  :: tempvy,tempvz,tempmx,tempmy,tempmz
   REAL(KIND=dp)  :: p0x,p0y,p0z,summ,vx,vy,vz,summx,summy,summz,totalmass
!
   INTEGER :: i,j
!
   totalmass=0.0_dp
   DO i=1,nbody
      totalmass=totalmass+rmass(i)
   END DO
!
   p0x=0.0_dp
   p0y=0.0_dp
   p0z=0.0_dp
   DO i=0,nbody-1
      tempmass(i)=rmass(i+1)
      tempx(i)=qq(3*i+1)
      tempy(i)=qq(3*i+2)
      tempz(i)=qq(3*i+3)
      tempvx(i)=pp(3*i+1)
      tempvy(i)=pp(3*i+2)
      tempvz(i)=pp(3*i+3)
   END DO
!
   DO i=0,nbody-1
      summ=0.0_dp
      DO j=0,i
         summ=summ+tempmass(j)
      END DO
      eta(i)=summ
   END DO
!
   tempmx(0)=totalmass*tempvx(0)
   tempmy(0)=totalmass*tempvy(0)
   tempmz(0)=totalmass*tempvz(0)
   p0x=tempmx(0)
   p0y=tempmy(0)
   p0z=tempmz(0)
!
   DO i=1,nbody-1
      tempmx(i)=eta(i-1)/eta(i)*tempmass(i)*tempvx(i)
      tempmy(i)=eta(i-1)/eta(i)*tempmass(i)*tempvy(i)
      tempmz(i)=eta(i-1)/eta(i)*tempmass(i)*tempvz(i)
   END DO

   vx=0.0_dp
   vy=0.0_dp
   vz=0.0_dp
   DO i=0,0
      summx=0.0_dp
      summy=0.0_dp
      summz=0.0_dp
      vx=0.0_dp
      vy=0.0_dp
      vz=0.0_dp
      DO j=1,nbody-1
         summx=summx+tempmass(j)/eta(j)*tempx(j)
         summy=summy+tempmass(j)/eta(j)*tempy(j)
         summz=summz+tempmass(j)/eta(j)*tempz(j)
         vx=vx+tempmass(i)/eta(j-1)*tempmx(j)
         vy=vy+tempmass(i)/eta(j-1)*tempmy(j)
         vz=vz+tempmass(i)/eta(j-1)*tempmz(j)
      END DO
      qqbc(3*i+1)=-summx
      qqbc(3*i+2)=-summy
      qqbc(3*i+3)=-summz
      ppbc(3*i+1)=(p0x*tempmass(i)/eta(nbody-1)-vx)/tempmass(i)
      ppbc(3*i+2)=(p0y*tempmass(i)/eta(nbody-1)-vy)/tempmass(i)
      ppbc(3*i+3)=(p0z*tempmass(i)/eta(nbody-1)-vz)/tempmass(i)
   END DO
   DO i=1,nbody-2
      summx=0.0_dp
      summy=0.0_dp
      summz=0.0_dp
      vx=0.0_dp
      vy=0.0_dp
      vz=0.0_dp
      DO j=i+1,nbody-1
         summx=summx+tempmass(j)/eta(j)*tempx(j)
         summy=summy+tempmass(j)/eta(j)*tempy(j)
         summz=summz+tempmass(j)/eta(j)*tempz(j)
         vx=vx+tempmass(i)/eta(j-1)*tempmx(j)
         vy=vy+tempmass(i)/eta(j-1)*tempmy(j)
         vz=vz+tempmass(i)/eta(j-1)*tempmz(j)
      END DO
      qqbc(3*i+1)=qq(3*i+1)*eta(i-1)/eta(i)-summx
      qqbc(3*i+2)=qq(3*i+2)*eta(i-1)/eta(i)-summy
      qqbc(3*i+3)=qq(3*i+3)*eta(i-1)/eta(i)-summz
      ppbc(3*i+1)=(p0x*tempmass(i)/eta(nbody-1)+tempmx(i)-vx)/tempmass(i)
      ppbc(3*i+2)=(p0y*tempmass(i)/eta(nbody-1)+tempmy(i)-vy)/tempmass(i)
      ppbc(3*i+3)=(p0z*tempmass(i)/eta(nbody-1)+tempmz(i)-vz)/tempmass(i)
   END DO
   DO i=nbody-1,nbody-1
      qqbc(3*i+1)=eta(nbody-2)/eta(nbody-1)*tempx(i)
      qqbc(3*i+2)=eta(nbody-2)/eta(nbody-1)*tempy(i)
      qqbc(3*i+3)=eta(nbody-2)/eta(nbody-1)*tempz(i)
      ppbc(3*i+1)=(p0x*tempmass(i)/eta(nbody-1)+tempmx(i))/tempmass(i)
      ppbc(3*i+2)=(p0y*tempmass(i)/eta(nbody-1)+tempmy(i))/tempmass(i)
      ppbc(3*i+3)=(p0z*tempmass(i)/eta(nbody-1)+tempmz(i))/tempmass(i)
   END DO
!
   RETURN
!
END SUBROUTINE newmovetobarycenter
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE newparm(iunit,newparmstr,rmass,rrad,rrau,  &
   teff2,q,separ,ecc,argper,period,finc,omega1,omega2,ave11,  &
   ave12,ave21,ave22,ave1,ave2,diskrad,diskthick,duras,rdepth,  &
   omegabn,tconj,t0,nbody,tref,ribcinp,itconj,tertt0,p2t0,  &
   p3t0,p4t0,p5t0,p6t0,p7t0,p8t0,fill1,fill2)
!
!   Will write the new ELCparm file.  If iunit>1, then write
!   to the file ELC.parm.  If iunit=1, then return the
!   parameters in a line in the string newparmstr
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: iunit
   CHARACTER (LEN=4000), INTENT(OUT)        :: newparmstr
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: rrad(10)
   REAL(KIND=dp), INTENT(IN)                :: rrau(10)
   REAL(KIND=dp), INTENT(IN)                :: teff2
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: argper
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: omega1
   REAL(KIND=dp), INTENT(IN)                :: omega2
   REAL(KIND=dp), INTENT(IN)                :: ave11
   REAL(KIND=dp), INTENT(IN)                :: ave12
   REAL(KIND=dp), INTENT(IN)                :: ave21
   REAL(KIND=dp), INTENT(IN)                :: ave22
   REAL(KIND=dp), INTENT(IN)                :: ave1
   REAL(KIND=dp), INTENT(IN)                :: ave2
   REAL(KIND=dp), INTENT(IN)                :: diskrad
   REAL(KIND=dp), INTENT(IN)                :: diskthick
   REAL(KIND=dp), INTENT(IN)                :: duras
   REAL(KIND=dp), INTENT(IN)                :: rdepth
   REAL(KIND=dp), INTENT(IN)                :: omegabn
   REAL(KIND=dp), INTENT(IN)                :: tconj
   REAL(KIND=dp), INTENT(IN)                :: t0
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: tref
   REAL(KIND=dp), INTENT(IN)                :: ribcinp(10,6)
   INTEGER, INTENT(IN)                      :: itconj
   REAL(KIND=dp), INTENT(IN)                :: tertt0
   REAL(KIND=dp), INTENT(IN)                :: p2t0
   REAL(KIND=dp), INTENT(IN)                :: p3t0
   REAL(KIND=dp), INTENT(IN)                :: p4t0
   REAL(KIND=dp), INTENT(IN)                :: p5t0
   REAL(KIND=dp), INTENT(IN)                :: p6t0
   REAL(KIND=dp), INTENT(IN)                :: p7t0
   REAL(KIND=dp), INTENT(IN)                :: p8t0
   REAL(KIND=dp), INTENT(IN)                :: fill1
   REAL(KIND=dp), INTENT(IN)                :: fill2
!
   REAL(KIND=dp)  :: ttt,gpole1,gpole2,t0_1,arg1
   REAL(KIND=dp)  :: fact,vrot1,vrot2,fincr,sifinc,a1,a2
   REAL(KIND=dp)  :: efact,velk1,velk2,hutfac,tertomega,rmutual1
   REAL(KIND=dp)  :: rimpact1,duration,term1,term2,term3,duration1,ecc1
   REAL(KIND=dp)  :: tperi1,tertconj,tertperiod,tconj1,tertincl,tt1,tt2
!
   INTEGER :: ilength,icount,ipl
!
   CHARACTER (LEN=70) :: outstring
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   fourthirdspie=4.0_dp/3.0_dp*pie
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   newparmstr=' '
   icount=2
   IF(iunit > 1)OPEN(UNIT=3,FILE='ELC.parm',STATUS='unknown')
!
   ttt=rmass(1)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,10)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rmass(2)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,20)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(1)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,30)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(2)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,40)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   gpole1=gsun*rmass(1)/(rrad(1)**2)
   IF(teff2 > 0.0_dp)THEN
      gpole2=gsun*rmass(2)/(rrad(2)**2)
   ELSE
      gpole2=1.0_dp
   END IF
!
   ttt=LOG10(gpole1)
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,50)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=LOG10(gpole2)
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,60)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   density of star 1
!
   ttt=(rmass(1)*solarmass*1000.0_dp)/(fourthirdspie*(rrad(1)*  &
      solarrad*100.0_dp)**3)
   IF(ttt < 0.0_dp)ttt=0.0_dp
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,70)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   density of star 2
!
   ttt=(rmass(2)*solarmass*1000.0_dp)/(fourthirdspie*(rrad(2)*  &
      solarrad*100.0_dp)**3)
   IF(ttt < 0.0_dp)ttt=0.0_dp
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,80)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!  fill1
!
   ttt=fill1
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,81)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!  fill2
!
   ttt=fill2
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,82)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!  K-velocities and rotational velocities
!
   fincr=finc*degtorad!pie/180.0d0
   sifinc=SIN(fincr)
   fact=solarrad*twopie/86400.0_dp/1.0E+03_dp
   vrot1=fact*rrad(1)/period*sifinc
   vrot2=fact*rrad(2)/period*sifinc
   a2=(separ/(1.0_dp+q))
   a1=separ-a2
   efact=1.0_dp/SQRT(1.0_dp-ecc*ecc)
   velk1=fact*a1/period*sifinc*efact
   velk2=fact*a2/period*sifinc*efact
!
   ttt=velk1
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,90)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=velk2
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,100)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   Add a correction factor to the rotational velocities in the
!   case of eccentric orbits.
!
   hutfac=(1.0_dp+7.5_dp*ecc*ecc+5.625_dp*ecc**4+0.3125_dp*ecc**6)/  &
      ((1.0_dp+3.0_dp*ecc*ecc+3.0_dp/8.0_dp*ecc**4)*SQRT((1.0_dp-ecc*ecc)**3))
!
   ttt=vrot1*hutfac
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,110)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=vrot2*hutfac
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,120)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=vrot1*hutfac*omega1
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,130)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=vrot2*hutfac*omega2
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,140)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   spot temperatures
!
   ttt=ave11
   ipl=3
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,150)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ave12
   ipl=3
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,160)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ave21
   ipl=3
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,170)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ave22
   ipl=3
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,180)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ave1
   ipl=3
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,190)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ave2
   ipl=3
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,200)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!  disk radius and thickness
!
   ttt=diskrad
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,210)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=diskthick
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,220)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!  duration of X-ray eclipse in degrees
!
   ttt=duras
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,230)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   impact parameter of primary eclipse and duration
!
   rimpact1=COS(fincr)*separ/rrad(1)
   IF(rimpact1 < 0.0_dp)rimpact1=0.0_dp
   IF(rimpact1 < 1.0_dp)THEN
      term1=SQRT((1.0_dp+rrad(2)/rrad(1))**2-rimpact1**2)
   ELSE
      term1=0.0_dp
   END IF
   term2=period*rrad(1)/(pie*separ*SQRT(1.0_dp-ecc*ecc))
   term3=(1.0_dp-ecc*ecc)/(1.0_dp-ecc*COS(argper*degtorad))
   duration=term1*term2*term3!*24.0d0
!
   ttt=rimpact1
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,240)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=duration
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,250)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rdepth
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,260)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   term1=1.0_dp-rimpact1**2
   term2=1.0_dp-(COS(fincr))**2
   IF(term1 >= 0.0_dp)THEN
      term3=SQRT(term1/term2)*rrad(1)/separ
   ELSE
      term3=0.0_dp
   END IF
   IF(ABS(term3) <= 1.0_dp)THEN
      duration1=period/pie*ASIN(term3)
   ELSE
      duration1=0.0_dp
   END IF
!
   ttt=duration1
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,270)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   secondary mass and radius in Earth units
!
   ttt=rmass(2)*earthmasstosolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,280)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(2)*earthradinsolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,290)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   orbital parameters of binary orbit
!
   ttt=period
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,300)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=separ*auinsolarrad
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,310)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ecc
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,320)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=argper
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,330)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=finc
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,340)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=omegabn
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,350)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=tconj
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,360)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=t0
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,370)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=0.0_dp
   ipl=1
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,380)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   CALL istringnoequals(' ',nbody,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,390)icount,nbody
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   If the number of bodies is 2, then close the output file
!   and leave.
!
   IF(nbody <= 2)THEN
      IF(iunit > 1)CLOSE(3)
      RETURN
   END IF
!
   ttt=tref
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,400)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!  Output information about the third body and its orbit.
!
   ttt=rmass(3)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,410)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(3)
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,420)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rmass(3)*earthmasstosolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,430)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(3)*earthradinsolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,440)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   gpole1=gsun*rmass(3)/(rrad(3)**2)
   ttt=LOG10(gpole1)
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,450)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=(rmass(3)*solarmass*1000.0_dp)/(fourthirdspie*(rrad(3)*  &
      solarrad*100.0_dp)**3)
   IF(ttt < 0.0_dp)ttt=0.0_dp
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,460)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(2,1)
   tertperiod=ttt
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,470)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrau(3)
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,480)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=SQRT(ribcinp(2,2)**2+ribcinp(2,3)**2)
   ecc1=ttt
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,490)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ATAN2(ribcinp(2,3),ribcinp(2,2))*radtodeg
   IF(ttt < 0.0_dp)ttt=ttt+360.0_dp
   arg1=ttt
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,500)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(2,4)*radtodeg
!          IF(ttt.lt.0.0d0)ttt=ttt+360.0d0
   tertincl=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,510)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(2,5)*radtodeg
   tertomega=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,520)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tertconj=ribcinp(2,6)
   t0_1=tertt0
   IF(itconj >= 2)THEN
      CALL gett0(tertincl,tertperiod,ecc1,arg1,tperi1,tertconj)
      t0_1=tertconj
   END IF
   IF(itconj == 1)THEN
      CALL gett0tran (tertincl,tertperiod,ecc1,arg1,t0_1,tertconj)
   END IF
   IF(itconj == 0)THEN
      CALL getcontimes (tertincl,tertperiod,ecc1,arg1,t0_1, tertconj,tconj1)
   END IF
!
   ttt=tertconj
   ipl=7
   CALL pnoequalstring (' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,530)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=t0_1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,540)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tt1=SIN(tertincl*degtorad)*SIN(fincr)*COS(tertomega*degtorad)
   tt2=COS(tertincl*degtorad)*COS(fincr)
   rmutual1=ACOS(tt1+tt2)*radtodeg
   ttt=rmutual1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,550)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   If the number of bodies is 3, then close the output file
!   and leave.
!
   IF(nbody <= 3)THEN
      IF(iunit > 1)CLOSE(3)
      RETURN
   END IF
!
!  Repeat the block of body 3 parameters for body 4
!
   ttt=rmass(4)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,560)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(4)
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,570)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rmass(4)*earthmasstosolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,580)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(4)*earthradinsolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,590)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   gpole1=gsun*rmass(4)/(rrad(4)**2)
   ttt=LOG10(gpole1)
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,600)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=(rmass(4)*solarmass*1000.0_dp)/(fourthirdspie*(rrad(4)*  &
      solarrad*100.0_dp)**3)
   IF(ttt < 0.0_dp)ttt=0.0_dp
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,610)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(3,1)
   tertperiod=ttt
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,620)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrau(4)
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,630)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=SQRT(ribcinp(3,2)**2+ribcinp(3,3)**2)
   ecc1=ttt
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,640)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ATAN2(ribcinp(3,3),ribcinp(3,2))*radtodeg
   IF(ttt < 0.0_dp)ttt=ttt+360.0_dp
   arg1=ttt
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,650)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(3,4)*radtodeg
!          IF(ttt.lt.0.0d0)ttt=ttt+360.0d0
   tertincl=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,660)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(3,5)*radtodeg
   tertomega=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,670)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tertconj=ribcinp(3,6)
   t0_1=p2t0
   IF(itconj >= 2)THEN
      CALL gett0(tertincl,tertperiod,ecc1,arg1,tperi1,tertconj)
      t0_1=tertconj
   END IF
   IF(itconj == 1)THEN
      CALL gett0tran(tertincl,tertperiod,ecc1,arg1,t0_1,tertconj)
   END IF
   IF(itconj == 0)THEN
      CALL getcontimes(tertincl,tertperiod,ecc1,arg1,t0_1, tertconj,tconj1)
   END IF
!
   ttt=tertconj
   ipl=7
   CALL pnoequalstring (' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,680)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=t0_1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,690)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tt1=SIN(tertincl*degtorad)*SIN(fincr)*COS(tertomega*degtorad)
   tt2=COS(tertincl*degtorad)*COS(fincr)
   rmutual1=ACOS(tt1+tt2)*radtodeg
   ttt=rmutual1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,700)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   If the number of bodies is 4, then close the output file
!   and leave.
!
   IF(nbody <= 4)THEN
      IF(iunit > 1)CLOSE(3)
      RETURN
   END IF
!
!  Repeat the block of body 4 parameters for body 5
!
   ttt=rmass(5)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,710)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(5)
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,720)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rmass(5)*earthmasstosolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,730)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(5)*earthradinsolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,740)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   gpole1=gsun*rmass(5)/(rrad(5)**2)
   ttt=LOG10(gpole1)
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,750)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=(rmass(5)*solarmass*1000.0_dp)/(fourthirdspie*(rrad(5)*  &
      solarrad*100.0_dp)**3)
   IF(ttt < 0.0_dp)ttt=0.0_dp
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,760)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(4,1)
   tertperiod=ttt
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,770)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrau(5)
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,780)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=SQRT(ribcinp(4,2)**2+ribcinp(4,3)**2)
   ecc1=ttt
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,790)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ATAN2(ribcinp(4,3),ribcinp(4,2))*radtodeg
   IF(ttt < 0.0_dp)ttt=ttt+360.0_dp
   arg1=ttt
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,800)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(4,4)*radtodeg
!          IF(ttt.lt.0.0d0)ttt=ttt+360.0d0
   tertincl=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,810)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(4,5)*radtodeg
   tertomega=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,820)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tertconj=ribcinp(4,6)
   t0_1=p3t0
   IF(itconj >= 2)THEN
      CALL gett0(tertincl,tertperiod,ecc1,arg1,tperi1,tertconj)
      t0_1=tertconj
   END IF
   IF(itconj == 1)THEN
      CALL gett0tran (tertincl,tertperiod,ecc1,arg1,t0_1,tertconj)
   END IF
   IF(itconj == 0)THEN
      CALL getcontimes (tertincl,tertperiod,ecc1,arg1,t0_1, tertconj,tconj1)
   END IF
!
   ttt=tertconj
   ipl=7
   CALL pnoequalstring (' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,830)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=t0_1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,840)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tt1=SIN(tertincl*degtorad)*SIN(fincr)*COS(tertomega*degtorad)
   tt2=COS(tertincl*degtorad)*COS(fincr)
   rmutual1=ACOS(tt1+tt2)*radtodeg
   ttt=rmutual1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,850)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   If the number of bodies is 5, then close the output file
!   and leave.
!
   IF(nbody <= 5)THEN
      IF(iunit > 1)CLOSE(3)
      RETURN
   END IF
!
!  Repeat the block of body 5 parameters for body 6
!
   ttt=rmass(6)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,860)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(6)
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,870)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rmass(6)*earthmasstosolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,880)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(6)*earthradinsolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,890)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   gpole1=gsun*rmass(6)/(rrad(6)**2)
   ttt=LOG10(gpole1)
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,900)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=(rmass(6)*solarmass*1000.0_dp)/(fourthirdspie*(rrad(6)*  &
      solarrad*100.0_dp)**3)
   IF(ttt < 0.0_dp)ttt=0.0_dp
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,910)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(5,1)
   tertperiod=ttt
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,920)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrau(6)
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,930)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=SQRT(ribcinp(5,2)**2+ribcinp(5,3)**2)
   ecc1=ttt
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,940)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ATAN2(ribcinp(5,3),ribcinp(5,2))*radtodeg
   IF(ttt < 0.0_dp)ttt=ttt+360.0_dp
   arg1=ttt
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,950)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(5,4)*radtodeg
!          IF(ttt.lt.0.0d0)ttt=ttt+360.0d0
   tertincl=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,960)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(5,5)*radtodeg
   tertomega=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,970)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tertconj=ribcinp(5,6)
   t0_1=p4t0
   IF(itconj >= 2)THEN
      CALL gett0(tertincl,tertperiod,ecc1,arg1,tperi1,tertconj)
      t0_1=tertconj
   END IF
   IF(itconj == 1)THEN
      CALL gett0tran (tertincl,tertperiod,ecc1,arg1,t0_1,tertconj)
   END IF
   IF(itconj == 0)THEN
      CALL getcontimes (tertincl,tertperiod,ecc1,arg1,t0_1, tertconj,tconj1)
   END IF
!
   ttt=tertconj
   ipl=7
   CALL pnoequalstring (' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,980)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=t0_1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,990)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tt1=SIN(tertincl*degtorad)*SIN(fincr)*COS(tertomega*degtorad)
   tt2=COS(tertincl*degtorad)*COS(fincr)
   rmutual1=ACOS(tt1+tt2)*radtodeg
   ttt=rmutual1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1000)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   If the number of bodies is 6, then close the output file
!   and leave.
!
   IF(nbody <= 6)THEN
      IF(iunit > 1)CLOSE(3)
      RETURN
   END IF
!
!  Repeat the block of body 6 parameters for body 7
!
   ttt=rmass(7)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1010)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(7)
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1020)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rmass(7)*earthmasstosolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1030)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(7)*earthradinsolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1040)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   gpole1=gsun*rmass(7)/(rrad(7)**2)
   ttt=LOG10(gpole1)
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1050)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=(rmass(7)*solarmass*1000.0_dp)/(fourthirdspie*(rrad(7)*  &
      solarrad*100.0_dp)**3)
   IF(ttt < 0.0_dp)ttt=0.0_dp
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1060)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(6,1)
   tertperiod=ttt
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1070)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrau(7)
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1080)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=SQRT(ribcinp(6,2)**2+ribcinp(6,3)**2)
   ecc1=ttt
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1090)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ATAN2(ribcinp(6,3),ribcinp(6,2))*radtodeg
   IF(ttt < 0.0_dp)ttt=ttt+360.0_dp
   arg1=ttt
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1100)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(6,4)*radtodeg
!          IF(ttt.lt.0.0d0)ttt=ttt+360.0d0
   tertincl=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1110)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(6,5)*radtodeg
   tertomega=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1120)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tertconj=ribcinp(6,6)
   t0_1=p5t0
   IF(itconj >= 2)THEN
      CALL gett0(tertincl,tertperiod,ecc1,arg1,tperi1,tertconj)
      t0_1=tertconj
   END IF
   IF(itconj == 1)THEN
      CALL gett0tran (tertincl,tertperiod,ecc1,arg1,t0_1,tertconj)
   END IF
   IF(itconj == 0)THEN
      CALL getcontimes (tertincl,tertperiod,ecc1,arg1,t0_1, tertconj,tconj1)
   END IF
!
   ttt=tertconj
   ipl=7
   CALL pnoequalstring (' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1130)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=t0_1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1140)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tt1=SIN(tertincl*degtorad)*SIN(fincr)*COS(tertomega*degtorad)
   tt2=COS(tertincl*degtorad)*COS(fincr)
   rmutual1=ACOS(tt1+tt2)*radtodeg
   ttt=rmutual1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1150)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   If the number of bodies is 7, then close the output file
!   and leave.
!
   IF(nbody <= 7)THEN
      IF(iunit > 1)CLOSE(3)
      RETURN
   END IF
!
!  Repeat the block of body 7 parameters for body 8
!
   ttt=rmass(8)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1160)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(8)
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1170)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rmass(8)*earthmasstosolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1180)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(8)*earthradinsolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1190)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   gpole1=gsun*rmass(8)/(rrad(8)**2)
   ttt=LOG10(gpole1)
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1200)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=(rmass(8)*solarmass*1000.0_dp)/(fourthirdspie*(rrad(8)*  &
      solarrad*100.0_dp)**3)
   IF(ttt < 0.0_dp)ttt=0.0_dp
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1210)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(7,1)
   tertperiod=ttt
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1220)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrau(8)
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1230)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=SQRT(ribcinp(7,2)**2+ribcinp(7,3)**2)
   ecc1=ttt
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1240)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ATAN2(ribcinp(7,3),ribcinp(7,2))*radtodeg
   IF(ttt < 0.0_dp)ttt=ttt+360.0_dp
   arg1=ttt
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1250)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(7,4)*radtodeg
!          IF(ttt.lt.0.0d0)ttt=ttt+360.0d0
   tertincl=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1260)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(7,5)*radtodeg
   tertomega=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1270)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tertconj=ribcinp(7,6)
   t0_1=p6t0
   IF(itconj >= 2)THEN
      CALL gett0(tertincl,tertperiod,ecc1,arg1,tperi1,tertconj)
      t0_1=tertconj
   END IF
   IF(itconj == 1)THEN
      CALL gett0tran (tertincl,tertperiod,ecc1,arg1,t0_1,tertconj)
   END IF
   IF(itconj == 0)THEN
      CALL getcontimes (tertincl,tertperiod,ecc1,arg1,t0_1, tertconj,tconj1)
   END IF
!
   ttt=tertconj
   ipl=7
   CALL pnoequalstring (' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1280)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=t0_1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1290)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tt1=SIN(tertincl*degtorad)*SIN(fincr)*COS(tertomega*degtorad)
   tt2=COS(tertincl*degtorad)*COS(fincr)
   rmutual1=ACOS(tt1+tt2)*radtodeg
   ttt=rmutual1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1300)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   If the number of bodies is 8, then close the output file
!   and leave.
!
   IF(nbody <= 8)THEN
      IF(iunit > 1)CLOSE(3)
      RETURN
   END IF
!
!  Repeat the block of body 8 parameters for body 9
!
   ttt=rmass(9)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1310)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(9)
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1320)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rmass(9)*earthmasstosolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1330)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(9)*earthradinsolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1340)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   gpole1=gsun*rmass(9)/(rrad(9)**2)
   ttt=LOG10(gpole1)
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1350)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=(rmass(9)*solarmass*1000.0_dp)/(fourthirdspie*(rrad(9)*  &
      solarrad*100.0_dp)**3)
   IF(ttt < 0.0_dp)ttt=0.0_dp
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1360)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(8,1)
   tertperiod=ttt
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1370)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrau(9)
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1380)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=SQRT(ribcinp(8,2)**2+ribcinp(8,3)**2)
   ecc1=ttt
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1390)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ATAN2(ribcinp(8,3),ribcinp(8,2))*radtodeg
   IF(ttt < 0.0_dp)ttt=ttt+360.0_dp
   arg1=ttt
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1400)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(8,4)*radtodeg
!          IF(ttt.lt.0.0d0)ttt=ttt+360.0d0
   tertincl=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1410)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(8,5)*radtodeg
   tertomega=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1420)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tertconj=ribcinp(8,6)
   t0_1=p7t0
   IF(itconj >= 2)THEN
      CALL gett0(tertincl,tertperiod,ecc1,arg1,tperi1,tertconj)
      t0_1=tertconj
   END IF
   IF(itconj == 1)THEN
      CALL gett0tran (tertincl,tertperiod,ecc1,arg1,t0_1,tertconj)
   END IF
   IF(itconj == 0)THEN
      CALL getcontimes (tertincl,tertperiod,ecc1,arg1,t0_1, tertconj,tconj1)
   END IF
!
   ttt=tertconj
   ipl=7
   CALL pnoequalstring (' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1430)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=t0_1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1440)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tt1=SIN(tertincl*degtorad)*SIN(fincr)*COS(tertomega*degtorad)
   tt2=COS(tertincl*degtorad)*COS(fincr)
   rmutual1=ACOS(tt1+tt2)*radtodeg
   ttt=rmutual1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1450)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   If the number of bodies is 9, then close the output file
!   and leave.
!
   IF(nbody <= 9)THEN
      IF(iunit > 1)CLOSE(3)
      RETURN
   END IF
!
!  Repeat the block of body 9 parameters for body 10
!
   ttt=rmass(10)
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1460)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(10)
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1470)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rmass(10)*earthmasstosolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1480)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrad(10)*earthradinsolar
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1490)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   gpole1=gsun*rmass(10)/(rrad(10)**2)
   ttt=LOG10(gpole1)
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1500)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=(rmass(10)*solarmass*1000.0_dp)/(fourthirdspie*(rrad(10)*  &
      solarrad*100.0_dp)**3)
   IF(ttt < 0.0_dp)ttt=0.0_dp
   ipl=4
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1510)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(9,1)
   tertperiod=ttt
   ipl=8
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1520)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=rrau(10)
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1530)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=SQRT(ribcinp(9,2)**2+ribcinp(9,3)**2)
   ecc1=ttt
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1540)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ATAN2(ribcinp(9,3),ribcinp(9,2))*radtodeg
   IF(ttt < 0.0_dp)ttt=ttt+360.0_dp
   arg1=ttt
   ipl=5
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1550)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(9,4)*radtodeg
!          IF(ttt.lt.0.0d0)ttt=ttt+360.0d0
   tertincl=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1560)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=ribcinp(9,5)*radtodeg
   tertomega=ttt
   ipl=6
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1570)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tertconj=ribcinp(9,6)
   t0_1=p8t0
   IF(itconj >= 2)THEN
      CALL gett0(tertincl,tertperiod,ecc1,arg1,tperi1,tertconj)
      t0_1=tertconj
   END IF
   IF(itconj == 1)THEN
      CALL gett0tran(tertincl,tertperiod,ecc1,arg1,t0_1,tertconj)
   END IF
   IF(itconj == 0)THEN
      CALL getcontimes(tertincl,tertperiod,ecc1,arg1,t0_1, tertconj,tconj1)
   END IF
!
   ttt=tertconj
   ipl=7
   CALL pnoequalstring (' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1580)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   ttt=t0_1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1590)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
   tt1=SIN(tertincl*degtorad)*SIN(fincr)*COS(tertomega*degtorad)
   tt2=COS(tertincl*degtorad)*COS(fincr)
   rmutual1=ACOS(tt1+tt2)*radtodeg
   ttt=rmutual1
   ipl=7
   CALL pnoequalstring(' ',ipl,ttt,outstring,ilength)
   IF(iunit > 1)THEN
      icount=icount+1
      WRITE(3,1600)icount,outstring(2:30)
   ELSE
      newparmstr=TRIM(newparmstr)//TRIM(outstring)
   END IF
!
!   If the number of bodies is 10, then close the output file
!   and leave.
!
   IF(nbody <= 10)THEN
      IF(iunit > 1)CLOSE(3)
      RETURN
   END IF
!
10 FORMAT(i3,1X,a22,1X,'mass of star 1 in solar masses')
20 FORMAT(i3,1X,a22,1X,'mass of star 2 in solar masses')
30 FORMAT(i3,1X,a22,1X,'radius of star 1 in solar radii')
40 FORMAT(i3,1X,a22,1X,'radius of star 2 in solar radii')
50 FORMAT(i3,1X,a22,1X,'log(g1) cgs')
60 FORMAT(i3,1X,a22,1X,'log(g2) cgs')
70 FORMAT(i3,1X,a22,1X,'density of star 1 in g/cc')
80 FORMAT(i3,1X,a22,1X,'density of star 2 in g/cc')
81 FORMAT(i3,1X,a22,1X,'fill1, Roche lobe filling factor of',1X,  &
      'star 1')
82 FORMAT(i3,1X,a22,1X,'fill2, Roche lobe filling factor of',1X,  &
      'star 2')
90 FORMAT(i3,1X,a22,1X,'K-velocity star 1 in km/sec')
100 FORMAT(i3,1X,a22,1X,'K-velocity star 2 in km/sec')
110 FORMAT(i3,1X,a22,1X,'V1_rot*sin(i) of star 1 in km/sec')
120 FORMAT(i3,1X,a22,1X,'V1_rot*sin(i) of star 2 in km/sec')
130 FORMAT(i3,1X,a22,1X,'V1_rot*sin(i) of star 1, scaled by',1X,''  &
      ,'omega in km/sec')
140 FORMAT(i3,1X,a22,1X,'V1_rot*sin(i) of star 2, scaled by',1X,''  &
      ,'omega in km/sec')
150 FORMAT(i3,1X,a22,1X,'temperature spot 1, star 1 (K)')
160 FORMAT(i3,1X,a22,1X,'temperature spot 2, star 1 (K)')
170 FORMAT(i3,1X,a22,1X,'temperature spot 1, star 2 (K)')
180 FORMAT(i3,1X,a22,1X,'temperature spot 2, star 2 (K)')
190 FORMAT(i3,1X,a22,1X,'temperature spot 1, disk (K)')
200 FORMAT(i3,1X,a22,1X,'temperature spot 2, disk (K)')
210 FORMAT(i3,1X,a22,1X,'disk radius in solar radii')
220 FORMAT(i3,1X,a22,1X,'disk thickness in solar radii')
230 FORMAT(i3,1X,a22,1X,'duration of X-ray eclipse in degrees')
240 FORMAT(i3,1X,a22,1X,'impact parameter of primary transit')
250 FORMAT(i3,1X,a22,1X,'duration of primary transit in days')
260 FORMAT(i3,1X,a22,1X,'depth of primary transit')
270 FORMAT(i3,1X,a22,1X,'duration of primary transit in days,',1X,  &
      'alternate formula')
280 FORMAT(i3,1X,a22,1X,'mass of star 2 in Earth masses')
290 FORMAT(i3,1X,a22,1X,'radius of star 2 in Earth radii')
300 FORMAT(i3,1X,a22,1X,'period of binary in days')
310 FORMAT(i3,1X,a22,1X,'semimajor axis of binary orbit in AU')
320 FORMAT(i3,1X,a22,1X,'eccentricity of binary orbit')
330 FORMAT(i3,1X,a22,1X,'argument of periastron of binary orbit',  &
      1X,'in degrees')
340 FORMAT(i3,1X,a22,1X,'inclination of binary orbit in degrees')
350 FORMAT(i3,1X,a22,1X,'nodal angle of binary orbit in degrees')
360 FORMAT(i3,1X,a22,1X,'T_conj of binary orbit')
370 FORMAT(i3,1X,a22,1X,'T_peri of binary orbit')
380 FORMAT(i3,1X,a22,1X,'mutual inclination of binary orbit in',  &
      1X,'degrees')
390 FORMAT(i3,1X,i2,21X,'number of bodies')
400 FORMAT(i3,1X,a22,1X,'T_ref')
410 FORMAT(i3,1X,a22,1X,'mass of body 3 in solar masses')
420 FORMAT(i3,1X,a22,1X,'radius of body 3 in solar radii')
430 FORMAT(i3,1X,a22,1X,'mass of body 3 in Earth masses')
440 FORMAT(i3,1X,a22,1X,'radius of body 3 in Earth radii')
450 FORMAT(i3,1X,a22,1X,'log(g3) cgs')
460 FORMAT(i3,1X,a22,1X,'density of body 3 in g/cc')
470 FORMAT(i3,1X,a22,1X,'period of body 3 in days')
480 FORMAT(i3,1X,a22,1X,'semimajor axis of body 3 orbit in AU')
490 FORMAT(i3,1X,a22,1X,'eccentricity of body 3 orbit')
500 FORMAT(i3,1X,a22,1X,'argument of periastron of body 3 orbit',  &
      1X,'in degrees')
510 FORMAT(i3,1X,a22,1X,'inclination of body 3 orbit in degrees')
520 FORMAT(i3,1X,a22,1X,'nodal angle of body 3 orbit in degrees')
530 FORMAT(i3,1X,a22,1X,'T_conj of body 3 orbit')
540 FORMAT(i3,1X,a22,1X,'T_peri of body 3 orbit')
550 FORMAT(i3,1X,a22,1X,'mutual inclination  of body 3 orbit in',  &
      1X,'degrees')
560 FORMAT(i3,1X,a22,1X,'mass of body 4 in solar masses')
570 FORMAT(i3,1X,a22,1X,'radius of body 4 in solar radii')
580 FORMAT(i3,1X,a22,1X,'mass of body 4 in Earth masses')
590 FORMAT(i3,1X,a22,1X,'radius of body 4 in Earth radii')
600 FORMAT(i3,1X,a22,1X,'log(g4) cgs')
610 FORMAT(i3,1X,a22,1X,'density of body 4 in g/cc')
620 FORMAT(i3,1X,a22,1X,'period of body 4 in days')
630 FORMAT(i3,1X,a22,1X,'semimajor axis of body 4 orbit in AU')
640 FORMAT(i3,1X,a22,1X,'eccentricity of body 4 orbit')
650 FORMAT(i3,1X,a22,1X,'argument of periastron of body 4 orbit',  &
      1X,'in degrees')
660 FORMAT(i3,1X,a22,1X,'inclination of body 4 orbit in degrees')
670 FORMAT(i3,1X,a22,1X,'nodal angle of body 4 orbit in degrees')
680 FORMAT(i3,1X,a22,1X,'T_conj of body 4 orbit')
690 FORMAT(i3,1X,a22,1X,'T_peri of body 4 orbit')
700 FORMAT(i3,1X,a22,1X,'mutual inclination of body 4 orbit in',  &
      1X,'degrees')
710 FORMAT(i3,1X,a22,1X,'mass of body 5 in solar masses')
720 FORMAT(i3,1X,a22,1X,'radius of body 5 in solar radii')
730 FORMAT(i3,1X,a22,1X,'mass of body 5 in Earth masses')
740 FORMAT(i3,1X,a22,1X,'radius of body 5 in Earth radii')
750 FORMAT(i3,1X,a22,1X,'log(g5) cgs')
760 FORMAT(i3,1X,a22,1X,'density of body 5 in g/cc')
770 FORMAT(i3,1X,a22,1X,'period of body 5 in days')
780 FORMAT(i3,1X,a22,1X,'semimajor axis of body 5 orbit in AU')
790 FORMAT(i3,1X,a22,1X,'eccentricity of body 5 orbit')
800 FORMAT(i3,1X,a22,1X,'argument of periastron of body 5 orbit',  &
      1X,'in degrees')
810 FORMAT(i3,1X,a22,1X,'inclination of body 5 orbit in degrees')
820 FORMAT(i3,1X,a22,1X,'nodal angle of body 5 orbit in degrees')
830 FORMAT(i3,1X,a22,1X,'T_conj of body 5 orbit')
840 FORMAT(i3,1X,a22,1X,'T_peri of body 5 orbit')
850 FORMAT(i3,1X,a22,1X,'mutual inclination of body 5 orbit in',  &
      1X,'degrees')
860 FORMAT(i3,1X,a22,1X,'mass of body 6 in solar masses')
870 FORMAT(i3,1X,a22,1X,'radius of body 6 in solar radii')
880 FORMAT(i3,1X,a22,1X,'mass of body 6 in Earth masses')
890 FORMAT(i3,1X,a22,1X,'radius of body 6 in Earth radii')
900 FORMAT(i3,1X,a22,1X,'log(g6) cgs')
910 FORMAT(i3,1X,a22,1X,'density of body 6 in g/cc')
920 FORMAT(i3,1X,a22,1X,'period of body 6 in days')
930 FORMAT(i3,1X,a22,1X,'semimajor axis of body 6 orbit in AU')
940 FORMAT(i3,1X,a22,1X,'eccentricity of body 6 orbit')
950 FORMAT(i3,1X,a22,1X,'argument of periastron of body 6 orbit',  &
      1X,'in degrees')
960 FORMAT(i3,1X,a22,1X,'inclination of body 6 orbit in degrees')
970 FORMAT(i3,1X,a22,1X,'nodal angle of body 6 orbit in degrees')
980 FORMAT(i3,1X,a22,1X,'T_conj of body 6 orbit')
990 FORMAT(i3,1X,a22,1X,'T_peri of body 6 orbit')
1000 FORMAT(i3,1X,a22,1X,'mutual inclination of body 6 orbit in',  &
      1X,'degrees')
1010 FORMAT(i3,1X,a22,1X,'mass of body 7 in solar masses')
1020 FORMAT(i3,1X,a22,1X,'radius of body 7 in solar radii')
1030 FORMAT(i3,1X,a22,1X,'mass of body 7 in Earth masses')
1040 FORMAT(i3,1X,a22,1X,'radius of body 7 in Earth radii')
1050 FORMAT(i3,1X,a22,1X,'log(g7) cgs')
1060 FORMAT(i3,1X,a22,1X,'density of body 7 in g/cc')
1070 FORMAT(i3,1X,a22,1X,'period of body 7 in days')
1080 FORMAT(i3,1X,a22,1X,'semimajor axis of body 7 orbit in AU')
1090 FORMAT(i3,1X,a22,1X,'eccentricity of body 7 orbit')
1100 FORMAT(i3,1X,a22,1X,'argument of periastron of body 7 orbit',  &
      1X,'in degrees')
1110 FORMAT(i3,1X,a22,1X,'inclination of body 7 orbit in degrees')
1120 FORMAT(i3,1X,a22,1X,'nodal angle of body 7 orbit in degrees')
1130 FORMAT(i3,1X,a22,1X,'T_conj of body 7 orbit')
1140 FORMAT(i3,1X,a22,1X,'T_peri of body 7 orbit')
1150 FORMAT(i3,1X,a22,1X,'mutual inclination of body 7 orbit in',  &
      1X,'degrees')
1160 FORMAT(i3,1X,a22,1X,'mass of body 8 in solar masses')
1170 FORMAT(i3,1X,a22,1X,'radius of body 8 in solar radii')
1180 FORMAT(i3,1X,a22,1X,'mass of body 8 in Earth masses')
1190 FORMAT(i3,1X,a22,1X,'radius of body 8 in Earth radii')
1200 FORMAT(i3,1X,a22,1X,'log(g7) cgs')
1210 FORMAT(i3,1X,a22,1X,'density of body 8 in g/cc')
1220 FORMAT(i3,1X,a22,1X,'period of body 8 in days')
1230 FORMAT(i3,1X,a22,1X,'semimajor axis of body 8 orbit in AU')
1240 FORMAT(i3,1X,a22,1X,'eccentricity of body 8 orbit')
1250 FORMAT(i3,1X,a22,1X,'argument of periastron of body 8 orbit',  &
      1X,'in degrees')
1260 FORMAT(i3,1X,a22,1X,'inclination of body 8 orbit in degrees')
1270 FORMAT(i3,1X,a22,1X,'nodal angle of body 8 orbit in degrees')
1280 FORMAT(i3,1X,a22,1X,'T_conj of body 8 orbit')
1290 FORMAT(i3,1X,a22,1X,'T_peri of body 8 orbit')
1300 FORMAT(i3,1X,a22,1X,'mutual inclination of body 8 orbit in',  &
      1X,'degrees')
1310 FORMAT(i3,1X,a22,1X,'mass of body 9 in solar masses')
1320 FORMAT(i3,1X,a22,1X,'radius of body 9 in solar radii')
1330 FORMAT(i3,1X,a22,1X,'mass of body 9 in Earth masses')
1340 FORMAT(i3,1X,a22,1X,'radius of body 9 in Earth radii')
1350 FORMAT(i3,1X,a22,1X,'log(g7) cgs')
1360 FORMAT(i3,1X,a22,1X,'density of body 9 in g/cc')
1370 FORMAT(i3,1X,a22,1X,'period of body 9 in days')
1380 FORMAT(i3,1X,a22,1X,'semimajor axis of body 9 orbit in AU')
1390 FORMAT(i3,1X,a22,1X,'eccentricity of body 9 orbit')
1400 FORMAT(i3,1X,a22,1X,'argument of periastron of body 9 orbit',  &
      1X,'in degrees')
1410 FORMAT(i3,1X,a22,1X,'inclination of body 9 orbit in degrees')
1420 FORMAT(i3,1X,a22,1X,'nodal angle of body 9 orbit in degrees')
1430 FORMAT(i3,1X,a22,1X,'T_conj of body 9 orbit')
1440 FORMAT(i3,1X,a22,1X,'T_peri of body 9 orbit')
1450 FORMAT(i3,1X,a22,1X,'mutual inclination of body 9 orbit in',  &
      1X,'degrees')
1460 FORMAT(i3,1X,a22,1X,'mass of body 10 in solar masses')
1470 FORMAT(i3,1X,a22,1X,'radius of body 10 in solar radii')
1480 FORMAT(i3,1X,a22,1X,'mass of body 10 in Earth masses')
1490 FORMAT(i3,1X,a22,1X,'radius of body 10 in Earth radii')
1500 FORMAT(i3,1X,a22,1X,'log(g7) cgs')
1510 FORMAT(i3,1X,a22,1X,'density of body 10 in g/cc')
1520 FORMAT(i3,1X,a22,1X,'period of body 10 in days')
1530 FORMAT(i3,1X,a22,1X,'semimajor axis of body 10 orbit in AU')
1540 FORMAT(i3,1X,a22,1X,'eccentricity of body 10 orbit')
1550 FORMAT(i3,1X,a22,1X,'argument of periastron of body 10 orbit',  &
      1X,'in degrees')
1560 FORMAT(i3,1X,a22,1X,'inclination of body 10 orbit in degrees')
1570 FORMAT(i3,1X,a22,1X,'nodal angle of body 10 orbit in degrees')
1580 FORMAT(i3,1X,a22,1X,'T_conj of body 10 orbit')
1590 FORMAT(i3,1X,a22,1X,'T_peri of body 10 orbit')
1600 FORMAT(i3,1X,a22,1X,'mutual inclination of body 10 orbit in',  &
      1X,'degrees')
!
   RETURN
!
END SUBROUTINE newparm
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE newrecordparm(ioutflag,nalph1,nalph2,nalph3,nbet1,  &
   nbet2,nbet3,nradius,nref,nseg,ntheta,irvfilt,iatm,icnb,icnh,  &
   icni,icnj,icnk,icnr,icnu,icnv,idark1,idark2,idraw,iecheck,  &
   iidint,ikeep,ilaw,ism1,isw1,isw13,isw2,isw21,isw22,  &
   isw23,isw24,isw25,isw26,isw27,isw28,isw29,isw3,isw30,isw31,  &
   isw32,isw33,isw34,isw4,isw5,isw6,isw7,isw8,isw80,isw81,  &
   isw85,isw86,isw87,isw88,isw89,isw9,isw100,isynch,  &
   it1,it2,it3,it4,itconj,p1mtc,p1ptc,p2omega,p2q,p2t0,p2ecos,  &
   p2esin,p2incl,p2mtc,p2ptc,p2period,p2ratrad,p2tconj,p3omega,  &
   p3q,p3t0,p3ecos,p3esin,p3incl,p3mtc,p3ptc,p3period,p3ratrad,  &
   p3tconj,p4omega,p4q,p4t0,p4ecos,p4esin,p4incl,p4mtc,p4ptc,  &
   p4period,p4ratrad,p4tconj,p5omega,p5q,p5t0,p5ecos,p5esin,  &
   p5incl,p5mtc,p5ptc,p5period,p5ratrad,p5tconj,p6omega,p6q,  &
   p6t0,p6ecos,p6esin,p6incl,p6mtc,p6ptc,p6period,p6ratrad,  &
   p6tconj,p7omega,p7q,p7t0,p7ecos,p7esin,p7incl,p7mtc,p7ptc,  &
   p7period,p7ratrad,p7tconj,p8omega,p8q,p8t0,p8ecos,p8esin,  &
   p8incl,p8mtc,p8ptc,p8period,p8ratrad,p8tconj,pbmtc,pbptc,  &
   period,q,sa3,t0,tconj,teff1,teff2,tgrav1,tgrav2,alb1,alb2,  &
   argper,beam1,beam2,betarim,bigi,bigi2,bigi3,bigi4,bigbeta,  &
   bigbeta2,bigbeta3,bigbeta4,bin2q,b2massdiff,b2masssum,  &
   b2raddiff,b2radsum,bin2ratrad,contam,contams0,contams1,  &
   contams2,contams3,dbolx,dboly,dphase,dwavex,dwavey,  &
   ecc,ecosw,fill1,fill2,finc,frac1,frac2,g10,g3,g6,g7,g8,g9,  &
   gamma,hh,massdiff,masssum,ocose,omega1,omega2,omega3,omega4,  &
   omega5,omega6,omega7,omega8,omega9,omega10,osine,  &
   primk,primmass,primrad,pshift,rlx,raddiff,radsum,  &
   ratrad,rinner,rk3,rk4,rk5,rk6,rk7,rk8,rk9,rk10,router,  &
   sdarkint1,sdarkint2,sdarkint3,sdarkint4,sdarkint5,sdarkint6,  &
   sdarkint7,sdarkint8,sdarkint9,sdarkint10,secmass,secrad,  &
   separ,spot1parm,spot2parm,spotdparm,sw1,sw2,sw23,sw24,sw25,  &
   sw26,sw27,sw28,sw29,sw3,sw30,sw47,sw48,sw49,sw5,sw6,sw7,sw72,  &
   sw73,sw8,sw80,sw81,sw82,sw83,sw84,  &
   sw9,t10,t3,t6,t7,t8,t9,tdisk,temprat,tertomega,tertq,  &
   tertconj,tertecos,tertesin,tertincl,tertperiod,tertratrad,  &
   tertt0,wave,xi,iunit,fracsum,fracdiff,bin2m3,bin2m4,bin2r3,  &
   bin2r4,sqecos,sqesin,sqtertecos,sqtertesin,sqp2ecos,sqp2esin,  &
   sqp3ecos,sqp3esin,sqp4ecos,sqp4esin,sqp5ecos,sqp5esin,  &
   sqp6ecos,sqp6esin,sqp7ecos,sqp7esin,sqp8ecos,sqp8esin,  &
   angsum1,angdiff1,angsum2,angdiff2,angsum3,angdiff3,angsum4,  &
   angdiff4,angsum5,angdiff5,angsum6,angdiff6,angsum7,angdiff7,  &
   angsum8,angdiff8,imag,fillsum,filldiff,binqtc,p1qtc,p2qtc,  &
   p3qtc,p4qtc,p5qtc,p6qtc,p7qtc,p8qtc,tbinoff,t1off,t2off,  &
   t3off,t4off,t5off,t6off,t7off,t8off,iversion,tesscontam,  &
   tessfilt,tessbin)
!
!   November 1, 2019
!
!   Modified to handle version numbers.  If iversion=0, then
!   there is no change.  If iversion=1, then add some
!   blocks about TESS features after the Kepler block.  There
!   will be 3 items:
!
!   tesscontam
!   tessfilt
!   tessbin
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ioutflag
   INTEGER, INTENT(IN)                      :: nalph1
   INTEGER, INTENT(IN)                      :: nalph2
   INTEGER, INTENT(IN)                      :: nalph3
   INTEGER, INTENT(IN)                      :: nbet1
   INTEGER, INTENT(IN)                      :: nbet2
   INTEGER, INTENT(IN)                      :: nbet3
   INTEGER, INTENT(IN)                      :: nradius
   INTEGER, INTENT(IN)                      :: nref
   INTEGER, INTENT(IN)                      :: nseg
   INTEGER, INTENT(IN)                      :: ntheta
   INTEGER, INTENT(IN)                      :: irvfilt
   INTEGER, INTENT(IN)                      :: iatm
   INTEGER, INTENT(IN)                      :: icnb
   INTEGER, INTENT(IN)                      :: icnh
   INTEGER, INTENT(IN)                      :: icni
   INTEGER, INTENT(IN)                      :: icnj
   INTEGER, INTENT(IN)                      :: icnk
   INTEGER, INTENT(IN)                      :: icnr
   INTEGER, INTENT(IN)                      :: icnu
   INTEGER, INTENT(IN)                      :: icnv
   INTEGER, INTENT(IN)                      :: idark1
   INTEGER, INTENT(IN)                      :: idark2
   INTEGER, INTENT(IN)                      :: idraw
   INTEGER, INTENT(IN)                      :: iecheck
   INTEGER, INTENT(IN)                      :: iidint
   INTEGER, INTENT(IN)                      :: ikeep
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: ism1
   INTEGER, INTENT(IN)                      :: isw1
   INTEGER, INTENT(IN)                      :: isw13
   INTEGER, INTENT(IN)                      :: isw2
   INTEGER, INTENT(IN)                      :: isw21
   INTEGER, INTENT(IN)                      :: isw22
   INTEGER, INTENT(IN)                      :: isw23
   INTEGER, INTENT(IN)                      :: isw24
   INTEGER, INTENT(IN)                      :: isw25
   INTEGER, INTENT(IN)                      :: isw26
   INTEGER, INTENT(IN)                      :: isw27
   INTEGER, INTENT(IN)                      :: isw28
   INTEGER, INTENT(IN)                      :: isw29
   INTEGER, INTENT(IN)                      :: isw3
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw31
   INTEGER, INTENT(IN)                      :: isw32
   INTEGER, INTENT(IN)                      :: isw33
   INTEGER, INTENT(IN)                      :: isw34
   INTEGER, INTENT(IN)                      :: isw4
   INTEGER, INTENT(IN)                      :: isw5
   INTEGER, INTENT(IN)                      :: isw6
   INTEGER, INTENT(IN)                      :: isw7
   INTEGER, INTENT(IN)                      :: isw8
   INTEGER, INTENT(IN)                      :: isw80
   INTEGER, INTENT(IN)                      :: isw81
   INTEGER, INTENT(IN)                      :: isw85
   INTEGER, INTENT(IN)                      :: isw86
   INTEGER, INTENT(IN)                      :: isw87
   INTEGER, INTENT(IN)                      :: isw88
   INTEGER, INTENT(IN)                      :: isw89
   INTEGER, INTENT(IN)                      :: isw9
   INTEGER, INTENT(IN)                      :: isw100
   INTEGER, INTENT(IN)                      :: isynch
   INTEGER, INTENT(IN)                      :: it1
   INTEGER, INTENT(IN)                      :: it2
   INTEGER, INTENT(IN)                      :: it3
   INTEGER, INTENT(IN)                      :: it4
   INTEGER, INTENT(IN)                      :: itconj
   REAL(KIND=dp), INTENT(IN)                :: p1mtc
   REAL(KIND=dp), INTENT(IN)                :: p1ptc
   REAL(KIND=dp), INTENT(IN)                :: p2omega
   REAL(KIND=dp), INTENT(IN)                :: p2q
   REAL(KIND=dp), INTENT(IN)                :: p2t0
   REAL(KIND=dp), INTENT(IN)                :: p2ecos
   REAL(KIND=dp), INTENT(IN)                :: p2esin
   REAL(KIND=dp), INTENT(IN)                :: p2incl
   REAL(KIND=dp), INTENT(IN)                :: p2mtc
   REAL(KIND=dp), INTENT(IN)                :: p2ptc
   REAL(KIND=dp), INTENT(IN)                :: p2period
   REAL(KIND=dp), INTENT(IN)                :: p2ratrad
   REAL(KIND=dp), INTENT(IN)                :: p2tconj
   REAL(KIND=dp), INTENT(IN)                :: p3omega
   REAL(KIND=dp), INTENT(IN)                :: p3q
   REAL(KIND=dp), INTENT(IN)                :: p3t0
   REAL(KIND=dp), INTENT(IN)                :: p3ecos
   REAL(KIND=dp), INTENT(IN)                :: p3esin
   REAL(KIND=dp), INTENT(IN)                :: p3incl
   REAL(KIND=dp), INTENT(IN)                :: p3mtc
   REAL(KIND=dp), INTENT(IN)                :: p3ptc
   REAL(KIND=dp), INTENT(IN)                :: p3period
   REAL(KIND=dp), INTENT(IN)                :: p3ratrad
   REAL(KIND=dp), INTENT(IN)                :: p3tconj
   REAL(KIND=dp), INTENT(IN)                :: p4omega
   REAL(KIND=dp), INTENT(IN)                :: p4q
   REAL(KIND=dp), INTENT(IN)                :: p4t0
   REAL(KIND=dp), INTENT(IN)                :: p4ecos
   REAL(KIND=dp), INTENT(IN)                :: p4esin
   REAL(KIND=dp), INTENT(IN)                :: p4incl
   REAL(KIND=dp), INTENT(IN)                :: p4mtc
   REAL(KIND=dp), INTENT(IN)                :: p4ptc
   REAL(KIND=dp), INTENT(IN)                :: p4period
   REAL(KIND=dp), INTENT(IN)                :: p4ratrad
   REAL(KIND=dp), INTENT(IN)                :: p4tconj
   REAL(KIND=dp), INTENT(IN)                :: p5omega
   REAL(KIND=dp), INTENT(IN)                :: p5q
   REAL(KIND=dp), INTENT(IN)                :: p5t0
   REAL(KIND=dp), INTENT(IN)                :: p5ecos
   REAL(KIND=dp), INTENT(IN)                :: p5esin
   REAL(KIND=dp), INTENT(IN)                :: p5incl
   REAL(KIND=dp), INTENT(IN)                :: p5mtc
   REAL(KIND=dp), INTENT(IN)                :: p5ptc
   REAL(KIND=dp), INTENT(IN)                :: p5period
   REAL(KIND=dp), INTENT(IN)                :: p5ratrad
   REAL(KIND=dp), INTENT(IN)                :: p5tconj
   REAL(KIND=dp), INTENT(IN)                :: p6omega
   REAL(KIND=dp), INTENT(IN)                :: p6q
   REAL(KIND=dp), INTENT(IN)                :: p6t0
   REAL(KIND=dp), INTENT(IN)                :: p6ecos
   REAL(KIND=dp), INTENT(IN)                :: p6esin
   REAL(KIND=dp), INTENT(IN)                :: p6incl
   REAL(KIND=dp), INTENT(IN)                :: p6mtc
   REAL(KIND=dp), INTENT(IN)                :: p6ptc
   REAL(KIND=dp), INTENT(IN)                :: p6period
   REAL(KIND=dp), INTENT(IN)                :: p6ratrad
   REAL(KIND=dp), INTENT(IN)                :: p6tconj
   REAL(KIND=dp), INTENT(IN)                :: p7omega
   REAL(KIND=dp), INTENT(IN)                :: p7q
   REAL(KIND=dp), INTENT(IN)                :: p7t0
   REAL(KIND=dp), INTENT(IN)                :: p7ecos
   REAL(KIND=dp), INTENT(IN)                :: p7esin
   REAL(KIND=dp), INTENT(IN)                :: p7incl
   REAL(KIND=dp), INTENT(IN)                :: p7mtc
   REAL(KIND=dp), INTENT(IN)                :: p7ptc
   REAL(KIND=dp), INTENT(IN)                :: p7period
   REAL(KIND=dp), INTENT(IN)                :: p7ratrad
   REAL(KIND=dp), INTENT(IN)                :: p7tconj
   REAL(KIND=dp), INTENT(IN)                :: p8omega
   REAL(KIND=dp), INTENT(IN)                :: p8q
   REAL(KIND=dp), INTENT(IN)                :: p8t0
   REAL(KIND=dp), INTENT(IN)                :: p8ecos
   REAL(KIND=dp), INTENT(IN)                :: p8esin
   REAL(KIND=dp), INTENT(IN)                :: p8incl
   REAL(KIND=dp), INTENT(IN)                :: p8mtc
   REAL(KIND=dp), INTENT(IN)                :: p8ptc
   REAL(KIND=dp), INTENT(IN)                :: p8period
   REAL(KIND=dp), INTENT(IN)                :: p8ratrad
   REAL(KIND=dp), INTENT(IN)                :: p8tconj
   REAL(KIND=dp), INTENT(IN)                :: pbmtc
   REAL(KIND=dp), INTENT(IN)                :: pbptc
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: sa3
   REAL(KIND=dp), INTENT(IN)                :: t0
   REAL(KIND=dp), INTENT(IN)                :: tconj
   REAL(KIND=dp), INTENT(IN)                :: teff1
   REAL(KIND=dp), INTENT(IN)                :: teff2
   REAL(KIND=dp), INTENT(IN)                :: tgrav1
   REAL(KIND=dp), INTENT(IN)                :: tgrav2
   REAL(KIND=dp), INTENT(IN)                :: alb1
   REAL(KIND=dp), INTENT(IN)                :: alb2
   REAL(KIND=dp), INTENT(IN)                :: argper
   REAL(KIND=dp), INTENT(IN)                :: beam1
   REAL(KIND=dp), INTENT(IN)                :: beam2
   REAL(KIND=dp), INTENT(IN)                :: betarim
   REAL(KIND=dp), INTENT(IN)                :: bigi
   REAL(KIND=dp), INTENT(IN)                :: bigi2
   REAL(KIND=dp), INTENT(IN)                :: bigi3
   REAL(KIND=dp), INTENT(IN)                :: bigi4
   REAL(KIND=dp), INTENT(IN)                :: bigbeta
   REAL(KIND=dp), INTENT(IN)                :: bigbeta2
   REAL(KIND=dp), INTENT(IN)                :: bigbeta3
   REAL(KIND=dp), INTENT(IN)                :: bigbeta4
   REAL(KIND=dp), INTENT(IN)                :: bin2q
   REAL(KIND=dp), INTENT(IN)                :: b2massdiff
   REAL(KIND=dp), INTENT(IN)                :: b2masssum
   REAL(KIND=dp), INTENT(IN)                :: b2raddiff
   REAL(KIND=dp), INTENT(IN)                :: b2radsum
   REAL(KIND=dp), INTENT(IN)                :: bin2ratrad
   REAL(KIND=dp), INTENT(IN)                :: contam
   REAL(KIND=dp), INTENT(IN)                :: contams0
   REAL(KIND=dp), INTENT(IN)                :: contams1
   REAL(KIND=dp), INTENT(IN)                :: contams2
   REAL(KIND=dp), INTENT(IN)                :: contams3
   REAL(KIND=dp), INTENT(IN)                :: dbolx(8,2)
   REAL(KIND=dp), INTENT(IN)                :: dboly(8,2)
   REAL(KIND=dp), INTENT(IN)                :: dphase
   REAL(KIND=dp), INTENT(IN)                :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN)                :: dwavey(8,10)
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: ecosw
   REAL(KIND=dp), INTENT(IN)                :: fill1
   REAL(KIND=dp), INTENT(IN)                :: fill2
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: frac1
   REAL(KIND=dp), INTENT(IN)                :: frac2
   REAL(KIND=dp), INTENT(IN)                :: g10
   REAL(KIND=dp), INTENT(IN)                :: g3
   REAL(KIND=dp), INTENT(IN)                :: g6
   REAL(KIND=dp), INTENT(IN)                :: g7
   REAL(KIND=dp), INTENT(IN)                :: g8
   REAL(KIND=dp), INTENT(IN)                :: g9
   REAL(KIND=dp), INTENT(IN)                :: gamma
   REAL(KIND=dp), INTENT(IN)                :: hh
   REAL(KIND=dp), INTENT(IN)                :: massdiff
   REAL(KIND=dp), INTENT(IN)                :: masssum
   REAL(KIND=dp), INTENT(IN)                :: ocose
   REAL(KIND=dp), INTENT(IN)                :: omega1
   REAL(KIND=dp), INTENT(IN)                :: omega2
   REAL(KIND=dp), INTENT(IN)                :: omega3
   REAL(KIND=dp), INTENT(IN)                :: omega4
   REAL(KIND=dp), INTENT(IN)                :: omega5
   REAL(KIND=dp), INTENT(IN)                :: omega6
   REAL(KIND=dp), INTENT(IN)                :: omega7
   REAL(KIND=dp), INTENT(IN)                :: omega8
   REAL(KIND=dp), INTENT(IN)                :: omega9
   REAL(KIND=dp), INTENT(IN)                :: omega10
   REAL(KIND=dp), INTENT(IN)                :: osine
   REAL(KIND=dp), INTENT(IN)                :: primk
   REAL(KIND=dp), INTENT(IN)                :: primmass
   REAL(KIND=dp), INTENT(IN)                :: primrad
   REAL(KIND=dp), INTENT(IN)                :: pshift
   REAL(KIND=dp), INTENT(IN)                :: rlx
   REAL(KIND=dp), INTENT(IN)                :: raddiff
   REAL(KIND=dp), INTENT(IN)                :: radsum
   REAL(KIND=dp), INTENT(IN)                :: ratrad
   REAL(KIND=dp), INTENT(IN)                :: rinner
   REAL(KIND=dp), INTENT(IN)                :: rk3
   REAL(KIND=dp), INTENT(IN)                :: rk4
   REAL(KIND=dp), INTENT(IN)                :: rk5
   REAL(KIND=dp), INTENT(IN)                :: rk6
   REAL(KIND=dp), INTENT(IN)                :: rk7
   REAL(KIND=dp), INTENT(IN)                :: rk8
   REAL(KIND=dp), INTENT(IN)                :: rk9
   REAL(KIND=dp), INTENT(IN)                :: rk10
   REAL(KIND=dp), INTENT(IN)                :: router
   REAL(KIND=dp), INTENT(IN)                :: sdarkint1(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint2(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint3(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint4(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint5(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint6(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint7(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint8(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint9(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint10(8)
   REAL(KIND=dp), INTENT(IN)                :: secmass
   REAL(KIND=dp), INTENT(IN)                :: secrad
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: spot1parm(2,4)
   REAL(KIND=dp), INTENT(IN)                :: spot2parm(2,4)
   REAL(KIND=dp), INTENT(IN)                :: spotdparm(2,4)
   REAL(KIND=dp), INTENT(IN)                :: sw1
   REAL(KIND=dp), INTENT(IN)                :: sw2
   REAL(KIND=dp), INTENT(IN)                :: sw23
   REAL(KIND=dp), INTENT(IN)                :: sw24
   REAL(KIND=dp), INTENT(IN)                :: sw25
   REAL(KIND=dp), INTENT(IN)                :: sw26
   REAL(KIND=dp), INTENT(IN)                :: sw27
   REAL(KIND=dp), INTENT(IN)                :: sw28
   REAL(KIND=dp), INTENT(IN)                :: sw29
   REAL(KIND=dp), INTENT(IN)                :: sw3
   REAL(KIND=dp), INTENT(IN)                :: sw30
   REAL(KIND=dp), INTENT(IN)                :: sw47
   REAL(KIND=dp), INTENT(IN)                :: sw48
   REAL(KIND=dp), INTENT(IN)                :: sw49
   REAL(KIND=dp), INTENT(IN)                :: sw5
   REAL(KIND=dp), INTENT(IN)                :: sw6
   REAL(KIND=dp), INTENT(IN)                :: sw7
   REAL(KIND=dp), INTENT(IN)                :: sw72
   REAL(KIND=dp), INTENT(IN)                :: sw73
   REAL(KIND=dp), INTENT(IN)                :: sw8
   REAL(KIND=dp), INTENT(IN)                :: sw80
   REAL(KIND=dp), INTENT(IN)                :: sw81
   REAL(KIND=dp), INTENT(IN)                :: sw82
   REAL(KIND=dp), INTENT(IN)                :: sw83
   REAL(KIND=dp), INTENT(IN)                :: sw84
   REAL(KIND=dp), INTENT(IN)                :: sw9
   REAL(KIND=dp), INTENT(IN)                :: t10
   REAL(KIND=dp), INTENT(IN)                :: t3
   REAL(KIND=dp), INTENT(IN)                :: t6
   REAL(KIND=dp), INTENT(IN)                :: t7
   REAL(KIND=dp), INTENT(IN)                :: t8
   REAL(KIND=dp), INTENT(IN)                :: t9
   REAL(KIND=dp), INTENT(IN)                :: tdisk
   REAL(KIND=dp), INTENT(IN)                :: temprat
   REAL(KIND=dp), INTENT(IN)                :: tertomega
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: tertconj
   REAL(KIND=dp), INTENT(IN)                :: tertecos
   REAL(KIND=dp), INTENT(IN)                :: tertesin
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertperiod
   REAL(KIND=dp), INTENT(IN)                :: tertratrad
   REAL(KIND=dp), INTENT(IN)                :: tertt0
   REAL(KIND=dp), INTENT(IN)                :: wave(8)
   REAL(KIND=dp), INTENT(IN)                :: xi
   INTEGER, INTENT(IN)                      :: iunit
   REAL(KIND=dp), INTENT(IN)                :: fracsum
   REAL(KIND=dp), INTENT(IN)                :: fracdiff
   REAL(KIND=dp), INTENT(IN)                :: bin2m3
   REAL(KIND=dp), INTENT(IN)                :: bin2m4
   REAL(KIND=dp), INTENT(IN)                :: bin2r3
   REAL(KIND=dp), INTENT(IN)                :: bin2r4
   REAL(KIND=dp), INTENT(IN)                :: sqecos
   REAL(KIND=dp), INTENT(IN)                :: sqesin
   REAL(KIND=dp), INTENT(IN)                :: sqtertecos
   REAL(KIND=dp), INTENT(IN)                :: sqtertesin
   REAL(KIND=dp), INTENT(IN)                :: sqp2ecos
   REAL(KIND=dp), INTENT(IN)                :: sqp2esin
   REAL(KIND=dp), INTENT(IN)                :: sqp3ecos
   REAL(KIND=dp), INTENT(IN)                :: sqp3esin
   REAL(KIND=dp), INTENT(IN)                :: sqp4ecos
   REAL(KIND=dp), INTENT(IN)                :: sqp4esin
   REAL(KIND=dp), INTENT(IN)                :: sqp5ecos
   REAL(KIND=dp), INTENT(IN)                :: sqp5esin
   REAL(KIND=dp), INTENT(IN)                :: sqp6ecos
   REAL(KIND=dp), INTENT(IN)                :: sqp6esin
   REAL(KIND=dp), INTENT(IN)                :: sqp7ecos
   REAL(KIND=dp), INTENT(IN)                :: sqp7esin
   REAL(KIND=dp), INTENT(IN)                :: sqp8ecos
   REAL(KIND=dp), INTENT(IN)                :: sqp8esin
   REAL(KIND=dp), INTENT(IN)                :: angsum1
   REAL(KIND=dp), INTENT(IN)                :: angdiff1
   REAL(KIND=dp), INTENT(IN)                :: angsum2
   REAL(KIND=dp), INTENT(IN)                :: angdiff2
   REAL(KIND=dp), INTENT(IN)                :: angsum3
   REAL(KIND=dp), INTENT(IN)                :: angdiff3
   REAL(KIND=dp), INTENT(IN)                :: angsum4
   REAL(KIND=dp), INTENT(IN)                :: angdiff4
   REAL(KIND=dp), INTENT(IN)                :: angsum5
   REAL(KIND=dp), INTENT(IN)                :: angdiff5
   REAL(KIND=dp), INTENT(IN)                :: angsum6
   REAL(KIND=dp), INTENT(IN)                :: angdiff6
   REAL(KIND=dp), INTENT(IN)                :: angsum7
   REAL(KIND=dp), INTENT(IN)                :: angdiff7
   REAL(KIND=dp), INTENT(IN)                :: angsum8
   REAL(KIND=dp), INTENT(IN)                :: angdiff8
   INTEGER, INTENT(IN)                      :: imag
   REAL(KIND=dp), INTENT(IN)                :: fillsum
   REAL(KIND=dp), INTENT(IN)                :: filldiff
   REAL(KIND=dp), INTENT(IN)                :: binqtc
   REAL(KIND=dp), INTENT(IN)                :: p1qtc
   REAL(KIND=dp), INTENT(IN)                :: p2qtc
   REAL(KIND=dp), INTENT(IN)                :: p3qtc
   REAL(KIND=dp), INTENT(IN)                :: p4qtc
   REAL(KIND=dp), INTENT(IN)                :: p5qtc
   REAL(KIND=dp), INTENT(IN)                :: p6qtc
   REAL(KIND=dp), INTENT(IN)                :: p7qtc
   REAL(KIND=dp), INTENT(IN)                :: p8qtc
   REAL(KIND=dp), INTENT(IN)                :: tbinoff
   REAL(KIND=dp), INTENT(IN)                :: t1off
   REAL(KIND=dp), INTENT(IN)                :: t2off
   REAL(KIND=dp), INTENT(IN)                :: t3off
   REAL(KIND=dp), INTENT(IN)                :: t4off
   REAL(KIND=dp), INTENT(IN)                :: t5off
   REAL(KIND=dp), INTENT(IN)                :: t6off
   REAL(KIND=dp), INTENT(IN)                :: t7off
   REAL(KIND=dp), INTENT(IN)                :: t8off
   INTEGER, INTENT(IN)                      :: iversion
   REAL(KIND=dp), INTENT(IN)                :: tesscontam
   INTEGER, INTENT(IN)                      :: tessfilt
   REAL(KIND=dp), INTENT(IN)                :: tessbin
!
   INTEGER :: iu,ib,iv,ir,ii,ij,ih,ik
!
   REAL(KIND=dp)  :: fake
!
   IF(ioutflag == 1)OPEN(UNIT=2,FILE='ELC.out',STATUS='unknown')
!
   fake=0.0_dp
   IF(ioutflag == 1)THEN
!
!  Modify the icn? flags so that they are either 0 or 1, which conforms
!  to the output format statement.
!
      IF(icnu == 430)THEN
         iu=0
      ELSE
         iu=1
      END IF
      IF(icnb == 430)THEN
         ib=0
      ELSE
         ib=1
      END IF
      IF(icnv == 430)THEN
         iv=0
      ELSE
         iv=1
      END IF
      IF(icnr == 430)THEN
         ir=0
      ELSE
         ir=1
      END IF
      IF(icni == 430)THEN
         ii=0
      ELSE
         ii=1
      END IF
      IF(icnj == 430)THEN
         ij=0
      ELSE
         ij=1
      END IF
      IF(icnh == 430)THEN
         ih=0
      ELSE
         ih=1
      END IF
      IF(icnk == 430)THEN
         ik=0
      ELSE
         ik=1
      END IF
!
      IF(iversion == 0)THEN
         WRITE(2,*)'This is ELC version 7.0 (November, 2019)'
      END IF
      IF(iversion == 1)THEN
         WRITE(2,*)'This is ELC version 7.1 (November 14, 2019)'
      END IF
!
!   update the header if version 1
!
      IF(iversion == 0)WRITE(2,10)
      IF(iversion == 1)WRITE(2,15)
      WRITE(2,20)
      WRITE(2,30)
      WRITE(2,20)
      WRITE(2,40)
      WRITE(2,20)
      WRITE(2,50)iunit
      WRITE(2,20)
      WRITE(2,60)
      WRITE(2,20)
      WRITE(2,70)isw7
      WRITE(2,80)sw23
      WRITE(2,90)sw24
      WRITE(2,100)sw9
      WRITE(2,110)dphase
      WRITE(2,20)
      WRITE(2,120)
      WRITE(2,20)
      WRITE(2,130)iatm
      WRITE(2,140)iu,ib,iv,ir,ii,ij,ih,ik
      WRITE(2,150)irvfilt
      WRITE(2,160)ilaw
      WRITE(2,170)wave(1),1
      WRITE(2,170)wave(2),2
      WRITE(2,170)wave(3),3
      WRITE(2,170)wave(4),4
      WRITE(2,170)wave(5),5
      WRITE(2,170)wave(6),6
      WRITE(2,170)wave(7),7
      WRITE(2,170)wave(8),8
      WRITE(2,180)nref
      WRITE(2,190)rlx
      WRITE(2,200)isw25
      WRITE(2,210)idark1
      WRITE(2,220)idark2
      WRITE(2,230)isw5
      WRITE(2,240)isw6
      WRITE(2,250)isw86
      WRITE(2,20)
      WRITE(2,260)
      WRITE(2,20)
      WRITE(2,270)t3
      WRITE(2,280)g3
      WRITE(2,290)sa3
      WRITE(2,20)
      WRITE(2,300)
      WRITE(2,20)
      WRITE(2,310)isw27
      WRITE(2,320)isw33
      WRITE(2,330)isw31
      WRITE(2,340)iecheck
      WRITE(2,350)ism1
      WRITE(2,360)isw13
      WRITE(2,370)isw8
      WRITE(2,380)sw7
      WRITE(2,390)sw8
      WRITE(2,20)
      WRITE(2,400)
      WRITE(2,20)
      WRITE(2,410)isw2
      WRITE(2,420)isw3
      WRITE(2,430)sw2
      WRITE(2,440)sw3
      WRITE(2,20)
      WRITE(2,450)
      WRITE(2,20)
      WRITE(2,460)idraw
      WRITE(2,470)isw1
      WRITE(2,480)sw1
      WRITE(2,20)
      WRITE(2,490)
      WRITE(2,20)
      WRITE(2,500)pshift
      WRITE(2,510)ikeep
      WRITE(2,520)isynch
      WRITE(2,530)isw21
      WRITE(2,540)isw28
      WRITE(2,550)isw29
      WRITE(2,20)
      WRITE(2,560)
      WRITE(2,20)
      WRITE(2,570)imag
      WRITE(2,580)isw9
      WRITE(2,590)isw4
      WRITE(2,600)isw23
      WRITE(2,610)isw24
      WRITE(2,620)isw22
      WRITE(2,630)it4
      WRITE(2,640)sw48
      WRITE(2,650)sw6
      WRITE(2,660)isw32
      WRITE(2,20)
      WRITE(2,670)
      WRITE(2,20)
      WRITE(2,680)isw88
      WRITE(2,690)sw47
      WRITE(2,700)hh
      WRITE(2,710)isw26
      WRITE(2,720)isw80
      WRITE(2,730)itconj
      WRITE(2,740)it1
      WRITE(2,750)isw100
      WRITE(2,760)it3
      WRITE(2,770)isw81
      WRITE(2,780)isw85
      WRITE(2,790)sw84
      WRITE(2,800)it2
      WRITE(2,20)
      WRITE(2,810)
      WRITE(2,20)
      WRITE(2,820)contam
      WRITE(2,830)isw34
      WRITE(2,840)contams0
      WRITE(2,850)contams1
      WRITE(2,860)contams2
      WRITE(2,870)contams3
      WRITE(2,880)nseg
      WRITE(2,890)isw87
      WRITE(2,900)sw29
      WRITE(2,910)sw30
      WRITE(2,920)isw89
!
!  If iversion=1, then add the TESS block
!
      IF(iversion == 1)THEN
         WRITE(2,921)
         WRITE(2,922)
         WRITE(2,923)
         WRITE(2,924)tesscontam
         WRITE(2,925)tessfilt
         WRITE(2,926)tessbin
      END IF
      WRITE(2,20)
      WRITE(2,930)
      WRITE(2,20)
      WRITE(2,940)isw30
      WRITE(2,20)
      WRITE(2,950)
      WRITE(2,20)
      WRITE(2,960)period
      WRITE(2,970)t0
      WRITE(2,980)tconj
      WRITE(2,990)pbptc
      WRITE(2,1000)pbmtc
      WRITE(2,1010)binqtc
      WRITE(2,1020)tbinoff
      WRITE(2,1030)ecc
      WRITE(2,1040)argper
      WRITE(2,1050)ocose
      WRITE(2,1060)osine
      WRITE(2,1070)sqecos
      WRITE(2,1080)sqesin
      WRITE(2,1090)finc
      WRITE(2,1100)sw49
      WRITE(2,1110)primk
      WRITE(2,1120)separ
      WRITE(2,1130)gamma
      WRITE(2,1140)ecosw
      WRITE(2,20)
      WRITE(2,1150)
      WRITE(2,20)
      WRITE(2,1160)nalph1,nbet1
      WRITE(2,1170)teff1
      WRITE(2,1180)tgrav1
      WRITE(2,1190)alb1
      WRITE(2,1200)omega1
      WRITE(2,1210)fill1
      WRITE(2,1220)primrad
      WRITE(2,1230)frac1
      WRITE(2,1240)sw27
      WRITE(2,1250)primmass
      WRITE(2,1260)bigi
      WRITE(2,1270)bigbeta
      WRITE(2,1280)dwavex(1,1),dwavey(1,1)
      WRITE(2,1290)dwavex(2,1),dwavey(2,1)
      WRITE(2,1300)dwavex(3,1),dwavey(3,1)
      WRITE(2,1310)dwavex(4,1),dwavey(4,1)
      WRITE(2,1320)dwavex(5,1),dwavey(5,1)
      WRITE(2,1330)dwavex(6,1),dwavey(6,1)
      WRITE(2,1340)dwavex(7,1),dwavey(7,1)
      WRITE(2,1350)dwavex(8,1),dwavey(8,1)
      WRITE(2,1360)dbolx(1,1),dboly(1,1)
      WRITE(2,1370)spot1parm(1,1)
      WRITE(2,1380)spot1parm(1,2)
      WRITE(2,1390)spot1parm(1,3)
      WRITE(2,1400)spot1parm(1,4)
      WRITE(2,1410)spot1parm(2,1)
      WRITE(2,1420)spot1parm(2,2)
      WRITE(2,1430)spot1parm(2,3)
      WRITE(2,1440)spot1parm(2,4)
      WRITE(2,1450)beam1
      WRITE(2,1460)sw72
      WRITE(2,1470)sdarkint1(1)
      WRITE(2,1480)sdarkint1(2)
      WRITE(2,1490)sdarkint1(3)
      WRITE(2,1500)sdarkint1(4)
      WRITE(2,1510)sdarkint1(5)
      WRITE(2,1520)sdarkint1(6)
      WRITE(2,1530)sdarkint1(7)
      WRITE(2,1540)sdarkint1(8)
      WRITE(2,20)
      WRITE(2,1550)
      WRITE(2,20)
      WRITE(2,1560)nalph2,nbet2
      WRITE(2,1570)teff2
      WRITE(2,1580)temprat
      WRITE(2,1590)tgrav2
      WRITE(2,1600)alb2
      WRITE(2,1610)omega2
      WRITE(2,1620)fill2
      WRITE(2,1630)fillsum
      WRITE(2,1640)filldiff
      WRITE(2,1650)secrad
      WRITE(2,1660)frac2
      WRITE(2,1670)ratrad
      WRITE(2,1680)radsum
      WRITE(2,1690)raddiff
      WRITE(2,1700)fracsum
      WRITE(2,1710)fracdiff
      WRITE(2,1720)sw28
      WRITE(2,1730)q
      WRITE(2,1740)secmass
      WRITE(2,1750)masssum
      WRITE(2,1760)massdiff
      WRITE(2,1770)bigi2
      WRITE(2,1780)bigbeta2
      WRITE(2,1790)dwavex(1,2),dwavey(1,2)
      WRITE(2,1800)dwavex(2,2),dwavey(2,2)
      WRITE(2,1810)dwavex(3,2),dwavey(3,2)
      WRITE(2,1820)dwavex(4,2),dwavey(4,2)
      WRITE(2,1830)dwavex(5,2),dwavey(5,2)
      WRITE(2,1840)dwavex(6,2),dwavey(6,2)
      WRITE(2,1850)dwavex(7,2),dwavey(7,2)
      WRITE(2,1860)dwavex(8,2),dwavey(8,2)
      WRITE(2,1870)dbolx(1,2),dboly(1,2)
      WRITE(2,1880)spot2parm(1,1)
      WRITE(2,1890)spot2parm(1,2)
      WRITE(2,1900)spot2parm(1,3)
      WRITE(2,1910)spot2parm(1,4)
      WRITE(2,1920)spot2parm(2,1)
      WRITE(2,1930)spot2parm(2,2)
      WRITE(2,1940)spot2parm(2,3)
      WRITE(2,1950)spot2parm(2,4)
      WRITE(2,1960)beam2
      WRITE(2,1970)sw73
      WRITE(2,1980)sdarkint2(1)
      WRITE(2,1990)sdarkint2(2)
      WRITE(2,2000)sdarkint2(3)
      WRITE(2,2010)sdarkint2(4)
      WRITE(2,2020)sdarkint2(5)
      WRITE(2,2030)sdarkint2(6)
      WRITE(2,2040)sdarkint2(7)
      WRITE(2,2050)sdarkint2(8)
      WRITE(2,20)
      WRITE(2,2060)
      WRITE(2,20)
      WRITE(2,2070)iidint
      WRITE(2,2080)ntheta
      WRITE(2,2090)nradius
      WRITE(2,2100)betarim
      WRITE(2,2110)rinner
      WRITE(2,2120)router
      WRITE(2,2130)tdisk
      WRITE(2,2140)xi
      WRITE(2,2150)spotdparm(1,1)
      WRITE(2,2160)spotdparm(1,2)
      WRITE(2,2170)spotdparm(1,3)
      WRITE(2,2180)spotdparm(1,4)
      WRITE(2,2190)spotdparm(2,1)
      WRITE(2,2200)spotdparm(2,2)
      WRITE(2,2210)spotdparm(2,3)
      WRITE(2,2220)spotdparm(2,4)
      WRITE(2,2230)sw26
      WRITE(2,20)
      WRITE(2,2240)
      WRITE(2,20)
      WRITE(2,2250)sw5
      WRITE(2,2260)sw25
!
!  If Nbody < 3, then we are done.
!
      IF(isw30 < 3)RETURN
!
      WRITE(2,20)
      WRITE(2,2270)
      WRITE(2,20)
      WRITE(2,2280)tertconj
      WRITE(2,2290)tertperiod
      WRITE(2,2300)p1ptc
      WRITE(2,2310)p1mtc
      WRITE(2,2320)p1qtc
      WRITE(2,2330)t1off
      WRITE(2,2340)tertt0
      WRITE(2,2350)tertecos
      WRITE(2,2360)tertesin
      WRITE(2,2370)sqtertecos
      WRITE(2,2380)sqtertesin
      WRITE(2,2390)tertincl
      WRITE(2,2400)tertomega
      WRITE(2,2410)angsum1
      WRITE(2,2420)angdiff1
      WRITE(2,20)
      WRITE(2,2430)
      WRITE(2,20)
      WRITE(2,2440)nalph3,nbet3
      WRITE(2,2450)t3
      WRITE(2,2460)g3
      WRITE(2,2470)tertratrad
      WRITE(2,2480)tertq
      WRITE(2,2490)omega3
      WRITE(2,2500)bigi3
      WRITE(2,2510)bigbeta3
      WRITE(2,2520)dwavex(1,3),dwavey(1,3)
      WRITE(2,2530)dwavex(2,3),dwavey(2,3)
      WRITE(2,2540)dwavex(3,3),dwavey(3,3)
      WRITE(2,2550)dwavex(4,3),dwavey(4,3)
      WRITE(2,2560)dwavex(5,3),dwavey(5,3)
      WRITE(2,2570)dwavex(6,3),dwavey(6,3)
      WRITE(2,2580)dwavex(7,3),dwavey(7,3)
      WRITE(2,2590)dwavex(8,3),dwavey(8,3)
      WRITE(2,2600)rk3
      WRITE(2,2610)sdarkint3(1)
      WRITE(2,2620)sdarkint3(2)
      WRITE(2,2630)sdarkint3(3)
      WRITE(2,2640)sdarkint3(4)
      WRITE(2,2650)sdarkint3(5)
      WRITE(2,2660)sdarkint3(6)
      WRITE(2,2670)sdarkint3(7)
      WRITE(2,2680)sdarkint3(8)
!
!  If Nbody < 4, then we are done.
!
      IF(isw30 < 4)RETURN
!
      WRITE(2,20)
      WRITE(2,2690)
      WRITE(2,20)
      WRITE(2,2700)p2tconj
      WRITE(2,2710)p2period
      WRITE(2,2720)p2ptc
      WRITE(2,2730)p2mtc
      WRITE(2,2740)p2qtc
      WRITE(2,2750)t2off
      WRITE(2,2760)p2t0
      WRITE(2,2770)p2ecos
      WRITE(2,2780)p2esin
      WRITE(2,2790)sqp2ecos
      WRITE(2,2800)sqp2esin
      WRITE(2,2810)p2incl
      WRITE(2,2820)p2omega
      WRITE(2,2830)angsum2
      WRITE(2,2840)angdiff2
      WRITE(2,20)
      WRITE(2,2850)
      WRITE(2,20)
      WRITE(2,2860)sw80
      WRITE(2,2870)sw82
      WRITE(2,2880)p2ratrad
      WRITE(2,2890)p2q
      WRITE(2,2900)omega4
      WRITE(2,2910)bigi4
      WRITE(2,2920)bigbeta4
      WRITE(2,2930)dwavex(1,4),dwavey(1,4)
      WRITE(2,2940)dwavex(2,4),dwavey(2,4)
      WRITE(2,2950)dwavex(3,4),dwavey(3,4)
      WRITE(2,2960)dwavex(4,4),dwavey(4,4)
      WRITE(2,2970)dwavex(5,4),dwavey(5,4)
      WRITE(2,2980)dwavex(6,4),dwavey(6,4)
      WRITE(2,2990)dwavex(7,4),dwavey(7,4)
      WRITE(2,3000)dwavex(8,4),dwavey(8,4)
      WRITE(2,3010)rk4
      WRITE(2,3020)sdarkint4(1)
      WRITE(2,3030)sdarkint4(2)
      WRITE(2,3040)sdarkint4(3)
      WRITE(2,3050)sdarkint4(4)
      WRITE(2,3060)sdarkint4(5)
      WRITE(2,3070)sdarkint4(6)
      WRITE(2,3080)sdarkint4(7)
      WRITE(2,3090)sdarkint4(8)
      WRITE(2,20)
      WRITE(2,3100)
      WRITE(2,20)
      WRITE(2,3110)b2masssum
      WRITE(2,3120)b2massdiff
      WRITE(2,3130)bin2q
      WRITE(2,3140)b2radsum
      WRITE(2,3150)b2raddiff
      WRITE(2,3160)bin2ratrad
      WRITE(2,3170)bin2m3
      WRITE(2,3180)bin2m4
      WRITE(2,3190)bin2r3
      WRITE(2,3200)bin2r4
!
!  If Nbody < 5, then we are done.
!
      IF(isw30 < 5)RETURN
!
      WRITE(2,20)
      WRITE(2,3210)
      WRITE(2,20)
      WRITE(2,3220)p3tconj
      WRITE(2,3230)p3period
      WRITE(2,3240)p3ptc
      WRITE(2,3250)p3mtc
      WRITE(2,3260)p3qtc
      WRITE(2,3270)t3off
      WRITE(2,3280)p3t0
      WRITE(2,3290)p3ecos
      WRITE(2,3300)p3esin
      WRITE(2,3310)sqp3ecos
      WRITE(2,3320)sqp3esin
      WRITE(2,3330)p3incl
      WRITE(2,3340)p3omega
      WRITE(2,3350)angsum3
      WRITE(2,3360)angdiff3
      WRITE(2,20)
      WRITE(2,3370)
      WRITE(2,20)
      WRITE(2,3380)sw81
      WRITE(2,3390)sw83
      WRITE(2,3400)p3ratrad
      WRITE(2,3410)p3q
      WRITE(2,3420)omega5
      WRITE(2,3430)fake
      WRITE(2,3440)fake
      WRITE(2,3450)dwavex(1,5),dwavey(1,5)
      WRITE(2,3460)dwavex(2,5),dwavey(2,5)
      WRITE(2,3470)dwavex(3,5),dwavey(3,5)
      WRITE(2,3480)dwavex(4,5),dwavey(4,5)
      WRITE(2,3490)dwavex(5,5),dwavey(5,5)
      WRITE(2,3500)dwavex(6,5),dwavey(6,5)
      WRITE(2,3510)dwavex(7,5),dwavey(7,5)
      WRITE(2,3520)dwavex(8,5),dwavey(8,5)
      WRITE(2,3530)rk5
      WRITE(2,3540)sdarkint5(1)
      WRITE(2,3550)sdarkint5(2)
      WRITE(2,3560)sdarkint5(3)
      WRITE(2,3570)sdarkint5(4)
      WRITE(2,3580)sdarkint5(5)
      WRITE(2,3590)sdarkint5(6)
      WRITE(2,3600)sdarkint5(7)
      WRITE(2,3610)sdarkint5(8)
!
!  If Nbody < 6, then we are done.
!
      IF(isw30 < 6)RETURN
!
      WRITE(2,20)
      WRITE(2,3620)
      WRITE(2,20)
      WRITE(2,3630)p4tconj
      WRITE(2,3640)p4period
      WRITE(2,3650)p4ptc
      WRITE(2,3660)p4mtc
      WRITE(2,3670)p4qtc
      WRITE(2,3680)t4off
      WRITE(2,3690)p4t0
      WRITE(2,3700)p4ecos
      WRITE(2,3710)p4esin
      WRITE(2,3720)sqp4ecos
      WRITE(2,3730)sqp4esin
      WRITE(2,3740)p4incl
      WRITE(2,3750)p4omega
      WRITE(2,3760)angsum4
      WRITE(2,3770)angdiff4
      WRITE(2,20)
      WRITE(2,3780)
      WRITE(2,20)
      WRITE(2,3790)t6
      WRITE(2,3800)g6
      WRITE(2,3810)p4ratrad
      WRITE(2,3820)p4q
      WRITE(2,3830)omega6
      WRITE(2,3840)fake
      WRITE(2,3850)fake
      WRITE(2,3860)dwavex(1,6),dwavey(1,6)
      WRITE(2,3870)dwavex(2,6),dwavey(2,6)
      WRITE(2,3880)dwavex(3,6),dwavey(3,6)
      WRITE(2,3890)dwavex(4,6),dwavey(4,6)
      WRITE(2,3900)dwavex(5,6),dwavey(5,6)
      WRITE(2,3910)dwavex(6,6),dwavey(6,6)
      WRITE(2,3920)dwavex(7,6),dwavey(7,6)
      WRITE(2,3930)dwavex(8,6),dwavey(8,6)
      WRITE(2,3940)rk6
      WRITE(2,3950)sdarkint6(1)
      WRITE(2,3960)sdarkint6(2)
      WRITE(2,3970)sdarkint6(3)
      WRITE(2,3980)sdarkint6(4)
      WRITE(2,3990)sdarkint6(5)
      WRITE(2,4000)sdarkint6(6)
      WRITE(2,4010)sdarkint6(7)
      WRITE(2,4020)sdarkint6(8)
!
!  If Nbody < 7, then we are done.
!
      IF(isw30 < 7)RETURN
!
      WRITE(2,20)
      WRITE(2,4030)
      WRITE(2,20)
      WRITE(2,4040)p5tconj
      WRITE(2,4050)p5period
      WRITE(2,4060)p5ptc
      WRITE(2,4070)p5mtc
      WRITE(2,4080)p5qtc
      WRITE(2,4090)t5off
      WRITE(2,4100)p5t0
      WRITE(2,4110)p5ecos
      WRITE(2,4120)p5esin
      WRITE(2,4130)sqp5ecos
      WRITE(2,4140)sqp5esin
      WRITE(2,4150)p5incl
      WRITE(2,4160)p5omega
      WRITE(2,4170)angsum5
      WRITE(2,4180)angdiff5
      WRITE(2,20)
      WRITE(2,4190)
      WRITE(2,20)
      WRITE(2,4200)t7
      WRITE(2,4210)g7
      WRITE(2,4220)p5ratrad
      WRITE(2,4230)p5q
      WRITE(2,4240)omega7
      WRITE(2,4250)fake
      WRITE(2,4260)fake
      WRITE(2,4270)dwavex(1,7),dwavey(1,7)
      WRITE(2,4280)dwavex(2,7),dwavey(2,7)
      WRITE(2,4290)dwavex(3,7),dwavey(3,7)
      WRITE(2,4300)dwavex(4,7),dwavey(4,7)
      WRITE(2,4310)dwavex(5,7),dwavey(5,7)
      WRITE(2,4320)dwavex(6,7),dwavey(6,7)
      WRITE(2,4330)dwavex(7,7),dwavey(7,7)
      WRITE(2,4340)dwavex(8,7),dwavey(8,7)
      WRITE(2,4350)rk7
      WRITE(2,4360)sdarkint7(1)
      WRITE(2,4370)sdarkint7(2)
      WRITE(2,4380)sdarkint7(3)
      WRITE(2,4390)sdarkint7(4)
      WRITE(2,4400)sdarkint7(5)
      WRITE(2,4410)sdarkint7(6)
      WRITE(2,4420)sdarkint7(7)
      WRITE(2,4430)sdarkint7(8)
!
!  If Nbody < 8, then we re done.
!
      IF(isw30 < 8)RETURN
!
      WRITE(2,20)
      WRITE(2,4440)
      WRITE(2,20)
      WRITE(2,4450)p6tconj
      WRITE(2,4460)p6period
      WRITE(2,4470)p6ptc
      WRITE(2,4480)p6mtc
      WRITE(2,4490)p6qtc
      WRITE(2,4500)t6off
      WRITE(2,4510)p6t0
      WRITE(2,4520)p6ecos
      WRITE(2,4530)p6esin
      WRITE(2,4540)sqp6ecos
      WRITE(2,4550)sqp6esin
      WRITE(2,4560)p6incl
      WRITE(2,4570)p6omega
      WRITE(2,4580)angsum6
      WRITE(2,4590)angdiff6
      WRITE(2,20)
      WRITE(2,4600)
      WRITE(2,20)
      WRITE(2,4610)t8
      WRITE(2,4620)g8
      WRITE(2,4630)p6ratrad
      WRITE(2,4640)p6q
      WRITE(2,4650)omega8
      WRITE(2,4660)fake
      WRITE(2,4670)fake
      WRITE(2,4680)dwavex(1,8),dwavey(1,8)
      WRITE(2,4690)dwavex(2,8),dwavey(2,8)
      WRITE(2,4700)dwavex(3,8),dwavey(3,8)
      WRITE(2,4710)dwavex(4,8),dwavey(4,8)
      WRITE(2,4720)dwavex(5,8),dwavey(5,8)
      WRITE(2,4730)dwavex(6,8),dwavey(6,8)
      WRITE(2,4740)dwavex(7,8),dwavey(7,8)
      WRITE(2,4750)dwavex(8,8),dwavey(8,8)
      WRITE(2,4760)rk8
      WRITE(2,4770)sdarkint8(1)
      WRITE(2,4780)sdarkint8(2)
      WRITE(2,4790)sdarkint8(3)
      WRITE(2,4800)sdarkint8(4)
      WRITE(2,4810)sdarkint8(5)
      WRITE(2,4820)sdarkint8(6)
      WRITE(2,4830)sdarkint8(7)
      WRITE(2,4840)sdarkint8(8)
!
!  If Nbody < 9, then we are done.
!
      IF(isw30 < 9)RETURN
!
      WRITE(2,20)
      WRITE(2,4850)
      WRITE(2,20)
      WRITE(2,4860)p7tconj
      WRITE(2,4870)p7period
      WRITE(2,4880)p7ptc
      WRITE(2,4890)p7mtc
      WRITE(2,4900)p7qtc
      WRITE(2,4910)t7off
      WRITE(2,4920)p7t0
      WRITE(2,4930)p7ecos
      WRITE(2,4940)p7esin
      WRITE(2,4950)sqp7ecos
      WRITE(2,4960)sqp7esin
      WRITE(2,4970)p7incl
      WRITE(2,4980)p7omega
      WRITE(2,4990)angsum7
      WRITE(2,5000)angdiff7
      WRITE(2,20)
      WRITE(2,5010)
      WRITE(2,20)
      WRITE(2,5020)t9
      WRITE(2,5030)g9
      WRITE(2,5040)p7ratrad
      WRITE(2,5050)p7q
      WRITE(2,5060)omega9
      WRITE(2,5070)fake
      WRITE(2,5080)fake
      WRITE(2,5090)dwavex(1,9),dwavey(1,9)
      WRITE(2,5100)dwavex(2,9),dwavey(2,9)
      WRITE(2,5110)dwavex(3,9),dwavey(3,9)
      WRITE(2,5120)dwavex(4,9),dwavey(4,9)
      WRITE(2,5130)dwavex(5,9),dwavey(5,9)
      WRITE(2,5140)dwavex(6,9),dwavey(6,9)
      WRITE(2,5150)dwavex(7,9),dwavey(7,9)
      WRITE(2,5160)dwavex(8,9),dwavey(8,9)
      WRITE(2,5170)rk9
      WRITE(2,5180)sdarkint9(1)
      WRITE(2,5190)sdarkint9(2)
      WRITE(2,5200)sdarkint9(3)
      WRITE(2,5210)sdarkint9(4)
      WRITE(2,5220)sdarkint9(5)
      WRITE(2,5230)sdarkint9(6)
      WRITE(2,5240)sdarkint9(7)
      WRITE(2,5250)sdarkint9(8)
!
!  If Nbody < 10, then we are done.
!
      IF(isw30 < 10)RETURN
!
      WRITE(2,20)
      WRITE(2,5260)
      WRITE(2,20)
      WRITE(2,5270)p8tconj
      WRITE(2,5280)p8period
      WRITE(2,5290)p8ptc
      WRITE(2,5300)p8mtc
      WRITE(2,5310)p8qtc
      WRITE(2,5320)t8off
      WRITE(2,5330)p8t0
      WRITE(2,5340)p8ecos
      WRITE(2,5350)p8esin
      WRITE(2,5360)sqp8ecos
      WRITE(2,5370)sqp8esin
      WRITE(2,5380)p8incl
      WRITE(2,5390)p8omega
      WRITE(2,5400)angsum8
      WRITE(2,5410)angdiff8
      WRITE(2,20)
      WRITE(2,5420)
      WRITE(2,20)
      WRITE(2,5430)t10
      WRITE(2,5440)g10
      WRITE(2,5450)p8ratrad
      WRITE(2,5460)p8q
      WRITE(2,5470)omega10
      WRITE(2,5480)fake
      WRITE(2,5490)fake
      WRITE(2,5500)dwavex(1,10),dwavey(1,10)
      WRITE(2,5510)dwavex(2,10),dwavey(2,10)
      WRITE(2,5520)dwavex(3,10),dwavey(3,10)
      WRITE(2,5530)dwavex(4,10),dwavey(4,10)
      WRITE(2,5540)dwavex(5,10),dwavey(5,10)
      WRITE(2,5550)dwavex(6,10),dwavey(6,10)
      WRITE(2,5560)dwavex(7,10),dwavey(7,10)
      WRITE(2,5570)dwavex(8,10),dwavey(8,10)
      WRITE(2,5580)rk10
      WRITE(2,5590)sdarkint10(1)
      WRITE(2,5600)sdarkint10(2)
      WRITE(2,5610)sdarkint10(3)
      WRITE(2,5620)sdarkint10(4)
      WRITE(2,5630)sdarkint10(5)
      WRITE(2,5640)sdarkint10(6)
      WRITE(2,5650)sdarkint10(7)
      WRITE(2,5660)sdarkint10(8)
   END IF
!
10 FORMAT('#1 New version 7 input, this line required')
15 FORMAT('#2 New version 7.1 input, this line required')
20 FORMAT('!')
30 FORMAT('!  Lines starting with # or ! can be inserted',' anyw'  &
      ,'here')
40 FORMAT('!  Units')
50 FORMAT(i1,24X,'iunit')
60 FORMAT('!  Parameters for light surve sampling')
70 FORMAT(i1,24X,'itime')
80 FORMAT(f15.8,10X,'t_start (if itime=2)')
90 FORMAT(f15.8,10X,'t_end   (if itime=2)')
100 FORMAT(f11.8,14X,'time step in days (if itime=2)')
110 FORMAT(f10.6,15X,'dphase in degrees (if itime=0 or 1)')
120 FORMAT('!  Control flags for filters and limb darkening')
130 FORMAT(i1,24X,'iatm (0 for black body)')
140 FORMAT(8(i1,1X),9X,'icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK')
150 FORMAT(i1,24X,'iRVfilt')
160 FORMAT(i3,22X,'ilaw (1=lin., 2=log, 3=sqrt, 4=quad,',' 5=Kipp'  &
      ,'ing quad)')
170 FORMAT(f11.4,14X,'central wavelength for filter ',i1,' when i'  &
      ,'atm=0')
180 FORMAT(i2,23X,'Nref')
190 FORMAT(f10.5,15X,'log10(Lx) in erg/sec, tag Lx')
200 FORMAT(i1,24X,'X-ray foreshortening switch (1 for',' point so'  &
      ,'urce)')
210 FORMAT(i1,24X,'idark1')
220 FORMAT(i1,24X,'idark2')
230 FORMAT(i1,24X,'ispotprof (0=constant, 1=linear, ','2=Gaussian'  &
      ,' change in temperature profile')
240 FORMAT(i1,24X,'igrav')
250 FORMAT(i1,24X,'set to 1 to use fluxes')
260 FORMAT('!  Third light parameters')
270 FORMAT(f18.10,7X,'T3 (Kelvin), tag t3')
280 FORMAT(f15.11,10X,'g3 (log(g) in c.g.s), tag g3')
290 FORMAT(f22.16,3X,'SA3 (ratio of body 1 to body 3 areas),',' t'  &
      ,'ag SA')
300 FORMAT('!  Control flags related to speed and accuracy')
310 FORMAT(i6,19X,'Nterms for fast analytic')
320 FORMAT(i1,24X,'mandel (0 for Gimenez, 1 for Mandel &',' Agol)' )
330 FORMAT(i4,21X,'Ngap')
340 FORMAT(i2,23X,'iecheck')
350 FORMAT(i1,24X,'ism1')
360 FORMAT(i1,24X,'ifasttrans (>0 for fast transit mode)')
370 FORMAT(i6,19X,'MonteCarlo (0 for interpolation, >10 ','for Mo'  &
      ,'nte Carlo integration)')
380 FORMAT(f12.6,13X,'phaselow  (phase range if phaselow>0 and',''  &
      ,' phasehigh>0')
390 FORMAT(f12.6,13X,'phasehigh  and phaselow < phasehigh)')
400 FORMAT('!  Control flags for Roche geometry')
410 FORMAT(i1,24X,'isquare')
420 FORMAT(i1,24X,'iusepot')
430 FORMAT(f12.6,13X,'usepot1')
440 FORMAT(f12.6,13X,'usepot2')
450 FORMAT('!  Drawing flags')
460 FORMAT(i1,24X,'idraw (1 to write output drawing files)')
470 FORMAT(i1,24X,'ionephase')
480 FORMAT(f12.6,13X,'onephase')
490 FORMAT('!  Control flags for orbital elements')
500 FORMAT(f12.9,13X,'pshift, tag ps')
510 FORMAT(i1,24X,'ikeep (1 to put primary eclipse at phase 0.0)')
520 FORMAT(i1,24X,'isynch (1 to keep rotation synchronous',' at p'  &
      ,'eriastron)')
530 FORMAT(i1,24X,'ialign (1 for rotation aligned with orbit)')
540 FORMAT(i1,24X,'set to 1 to fit for Tconj of binary')
550 FORMAT(i1,24X,'set to 1 to fit for e*cos(omega), ','e*sin(ome'  &
      ,'ga) of binary')
560 FORMAT('!  Control flags for use with optimizers')
570 FORMAT(i2,23X,'imag ','(0 for input data in mag, 1 for input '  &
      ,'data in flux)')
580 FORMAT(i4,21X,'ielite')
590 FORMAT(i2,23X,'ifixgamma (0, 1, 2) or (10, 11, 12)')
600 FORMAT(i1,24X,'iwriteeclipse (1 to fit for eclipse times ','w'  &
      ,'hen Nbody >=3 and itime=2)')
610 FORMAT(i1,24X,'frac switch (>1 to enable ELCratio.* files)')
620 FORMAT(i1,24X,'set to 1 to supress optimizer screen output')
630 FORMAT(i1,24X,'set to 1 to supress demcmcELC output files')
640 FORMAT(f15.5,10X,'chi^2 threshold to write to output files')
650 FORMAT(f4.1,21X,'median fit (0 for chi^2, >0 for median)')
660 FORMAT(i14,11X,'jdum (seed for markovELC, geneticELC, ','rand'  &
      ,'omELC, demcmcELC, hammerELC)')
670 FORMAT('!  Control flags and parameters for use with ','the d'  &
      ,'ynamical integrator (Nbody >=3)')
680 FORMAT(i2,23X,'Ndynwin (number of segments to integrate)')
690 FORMAT(f15.6,10X,'Tref for dynamical integrator (Nbody >=3)')
700 FORMAT(f8.5,17X,'hh (step size in days)')
710 FORMAT(i1,24X,'iGR (1 for GR, 2 for tidal, 3 for both)')
720 FORMAT(i1,24X,'set to 1 for binary+binary model (use ','Nbody'  &
      ,'=4)')
730 FORMAT(i1,24X,'itconj (0=T_peri, 1=T_tran, 2=T_occul)')
740 FORMAT(i1,24X,'set to 1 for logarithmic mass ratios')
750 FORMAT(i1,24X,'set to 1 for planet radii in Earth radii')
760 FORMAT(i1,24X,'set to 1 to treat transits and occultations ',  &
      'together')
770 FORMAT(i1,24X,'set to 1 for transit penalty')
780 FORMAT(i1,24X,'set to 1 for secondary eclipse penalty')
790 FORMAT(f15.4,10X,'chi^2 penalty for transit or secondary ',  &
       'eclipse')
800 FORMAT(i1,24X,'set to 1 for informational output (ELC only)')
810 FORMAT('! Features for Kepler data')
820 FORMAT(f16.13,9X,'Kepler contamination, tag co')
830 FORMAT(i1,24X,'Iseason (1 for seasonal Kepler contamination)')
840 FORMAT(f16.13,9X,'contamS0 (season 0 contamination, tag s0)')
850 FORMAT(f16.13,9X,'contamS1 (season 1 contamination, tag s1)')
860 FORMAT(f16.13,9X,'contamS2 (season 2 contamination, tag s2)')
870 FORMAT(f16.13,9X,'contamS3 (season 3 contamination, tag s3)')
880 FORMAT(i4,21X,'Nseg (number of segments to fit for','contamin'  &
      ,'ation)')
890 FORMAT(i1,24X,'set to 1 for fast Kepler binning')
900 FORMAT(f10.5,15X,'bin size for light curves (minutes)')
910 FORMAT(f10.5,15X,'bin size for RV curves (minutes)')
920 FORMAT(i2,23X,'NSC (number of short cadence intervals)')
!
!  If iversion=1, then add the TESS block
!
921 FORMAT('!')
922 FORMAT('! Features for TESS data')
923 FORMAT('!')
924 FORMAT(f16.13,9X,'TESS contamination, tag ct')
925 FORMAT(i1,24X,'TESS filter in ELC.atm')
926 FORMAT(f10.5,15X,'bin size for TESS light curve (minutes)')
!
930 FORMAT('!  Number of bodies (2 to 10)')
940 FORMAT(i2,23X,'Nbody')
950 FORMAT('!  Binary orbit parameters')
960 FORMAT(f22.15,3X,'Period (days), tag pe')
970 FORMAT(f22.15,3X,'T0 (time of periastron passage), tag T0')
980 FORMAT(f22.15,3X,'Tconj (time of primary eclipse), tag Tc')
990 FORMAT(f20.13,5X,'PbpTc (period + Tconj for binary), tag bp')
1000 FORMAT(f20.13,5X,'PbmTc (period - Tconj for binary), tag bm')
1010 FORMAT(f17.12,8X,'binqTc (slope in P-Tc plane for binary),',  &
      1X,'tag bq')
1020 FORMAT(f21.12,4X,'Tbinoff (offset in P-Tc plane for binary),',  &
      1X,'tag bt')
1030 FORMAT(f15.12,10X,'eccentricity, tag ec')
1040 FORMAT(f19.13,6X,'argument of periaston in degrees, tag ar')
1050 FORMAT(f20.17,5X,'e*cos(omega), tag oc')
1060 FORMAT(f20.17,5X,'e*sin(omega), tag os')
1070 FORMAT(f20.17,5X,'sqrt(e)*cos(omega), tag bc')
1080 FORMAT(f20.17,5X,'sqrt(e)*sin(omega), tag bs')
1090 FORMAT(f22.16,3X,'finc (inclination in degrees), tag in')
1100 FORMAT(f15.10,10X,'Omega_bin (nodal angle of binary ','in deg'  &
      ,'rees), tag Ob')
1110 FORMAT(f19.13,6X,'primK (K-velocity of star 1 in km/sec),',' '  &
      ,'tag pk')
1120 FORMAT(f12.6,13X,'separ (semimajor axis in solar radii), ','t'  &
      ,'ag se')
1130 FORMAT(f12.6,13X,'gamma')
1140 FORMAT(f10.7,15X,'ecosw (phase difference between eclipses)',  &
      ' tag dp')
1150 FORMAT('!  Body 1 parameters')
1160 FORMAT(2(i4,1X),15X,'Nalph1, Nbet1')
1170 FORMAT(f15.9,10X,'Teff1 (K), tag T1')
1180 FORMAT(f10.7,15X,'Tgrav1, tag g1')
1190 FORMAT(f10.7,15X,'alb1 (albedo of star 1), tag l1')
1200 FORMAT(f18.13,7X,'omega1, tag o1')
1210 FORMAT(f15.12,10X,'fill1, tag f1')
1220 FORMAT(f20.13,5X,'primrad (star 1 radius in solar radii),',' '  &
      ,'tag pr')
1230 FORMAT(f18.15,7X,'frac1 (fractional radius star 1:','  R_1/a',  &
      '), tag q1')
1240 FORMAT(f15.12,10X,'radfill1 (set to use fill1',' in terms of '  &
      ,'R_eff)')
1250 FORMAT(f22.17,3X,'primmass (star 1 mass in solar masses),',' '  &
      ,'tag pm')
1260 FORMAT(f12.7,13X,'axis_I1 (inclination of rotation axis if ',  &
      'ialign=0), tag ai')
1270 FORMAT(f12.7,13X,'axis_beta1 (angle of rotation axis wrt ','o'  &
      ,'rbit if ialign=0), tag ab')
1280 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','1, tag x1, y1')
1290 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','2, tag x2, y2')
1300 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','3, tag x3, y3')
1310 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','4, tag x4, y4')
1320 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','5, tag x5, y5')
1330 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','6, tag x6, y6')
1340 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','7, tag x7, y7')
1350 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','8, tag x8, y8')
1360 FORMAT(2(f8.5,1X),7X,'bolometric L.D. coefficients',' (used w'  &
      ,'hen Nref >= 0)')
1370 FORMAT(f10.7,15X,'Temperature factor spot 1, star 1, tag b1')
1380 FORMAT(f11.7,14X,'Latitude of spot 1, star 1 (degrees),',' ta'  &
      ,'g b2')
1390 FORMAT(f11.7,14X,'Longitude of spot 1, star 1 (degrees),',' t'  &
      ,'ag b3')
1400 FORMAT(f11.7,14X,'Angular radius of spot 1, star 1 ','(degree'  &
      ,'s), tag b4')
1410 FORMAT(f10.7,15X,'Temperature factor spot 2, star 1, tag b5')
1420 FORMAT(f11.7,14X,'Latitude of spot 2, star 1 (degrees),',' ta'  &
      ,'g b6')
1430 FORMAT(f11.7,14X,'Longitude of spot 2, star 1 (degrees),',' t'  &
      ,'ag b7')
1440 FORMAT(f11.7,14X,'Angular radius of spot 2, star 1 ','(degree'  &
      ,'s), tag b8')
1450 FORMAT(f13.10,12X,'beam1 (Doppler boosting factor,',' star 1)'  &
      ,', tag e1')
1460 FORMAT(f10.7,15X,'rk1 (apsidal constant, star 1), tag a1')
1470 FORMAT(f20.11,5X,'flux star 1, filter 1 (need Nterms > 0),',''  &
      ,' tag 11')
1480 FORMAT(f20.11,5X,'flux star 1, filter 2 (need Nterms > 0),',''  &
      ,' tag 12')
1490 FORMAT(f20.11,5X,'flux star 1, filter 3 (need Nterms > 0),',''  &
      ,' tag 13')
1500 FORMAT(f20.11,5X,'flux star 1, filter 4 (need Nterms > 0),',''  &
      ,' tag 14')
1510 FORMAT(f20.11,5X,'flux star 1, filter 5 (need Nterms > 0),',''  &
      ,' tag 15')
1520 FORMAT(f20.11,5X,'flux star 1, filter 6 (need Nterms > 0),',''  &
      ,' tag 16')
1530 FORMAT(f20.11,5X,'flux star 1, filter 7 (need Nterms > 0),',''  &
      ,' tag 17')
1540 FORMAT(f20.11,5X,'flux star 1, filter 8 (need Nterms > 0),',''  &
      ,' tag 18')
1550 FORMAT('!  Body 2 parameters')
1560 FORMAT(2(i4,1X),15X,'Nalph2, Nbet2')
1570 FORMAT(f15.9,10X,'Teff2 (K), tag T2')
1580 FORMAT(f20.16,5X,'temprat (T_2/T_1), tag te')
1590 FORMAT(f10.7,15X,'Tgrav2, tag g2')
1600 FORMAT(f10.7,15X,'alb2 (albedo of star 2), tag l2')
1610 FORMAT(f18.13,7X,'omega2, tag o2')
1620 FORMAT(f15.12,10X,'fill2, tag f2')
1630 FORMAT(f15.12,10X,'fillsum, tag sf')
1640 FORMAT(f16.13,9X,'filldiff, tag sd')
1650 FORMAT(f17.13,8X,'secrad (secondary star radius in solar ','r'  &
      ,'adii), tag sr')
1660 FORMAT(f18.15,7X,'frac2 (fractional radius star 2:','  R_2/a',  &
      '), tag q2')
1670 FORMAT(f20.13,5X,'ratrad (ratio of star 1 radius to ','star 2'  &
      ,' radius),  tag ra')
1680 FORMAT(f20.13,5X,'radsum (sum of radii in solar), ','tag rs')
1690 FORMAT(f20.13,5X,'raddiff (R_1 - R_2  in solar), ','tag rd')
1700 FORMAT(f17.14,8X,'fracsum ((R_1 + R_2)/a), tag fs')
1710 FORMAT(f17.14,8X,'fracdiff ((R_1 - R_2)/a), tag fd')
1720 FORMAT(f15.12,10X,'radfill2 (set to use fill2',' in terms of '  &
      ,'R_eff)')
1730 FORMAT(f24.17,1X,'Q (M_2/M_1), tag ma')
1740 FORMAT(f20.15,5X,'secmass (star 2 mass in solar masses),',' t'  &
      ,'ag sm')
1750 FORMAT(f20.15,5X,'masssum (sum of masses in solar), ',' tag m' ,'s')
1760 FORMAT(f20.15,5X,'massdiff (M_1 - M_2 in solar), tag md')
1770 FORMAT(f12.7,13X,'axis_I2 (inclination of rotation axis if ',  &
      'ialign=0), tag bi')
1780 FORMAT(f12.7,13X,'axis_beta2 (angle of rotation axis wrt ','o'  &
      ,'rbit if ialign=0), tag bb')
1790 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','1, tag z1, w1')
1800 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','2, tag z2, w2')
1810 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','3, tag z3, w3')
1820 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','4, tag z4, w4')
1830 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','5, tag z5, w5')
1840 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','6, tag z6, w6')
1850 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','7, tag z7, w7')
1860 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','8, tag z8, w8')
1870 FORMAT(2(f8.5,1X),7X,'bolometric L.D. coefficients',' (used w'  &
      ,'hen Nref >= 0)')
1880 FORMAT(f10.7,15X,'Temperature factor spot 1, star 2, tag c1')
1890 FORMAT(f11.7,14X,'Latitude of spot 1, star 2 (degrees),',' ta'  &
      ,'g c2')
1900 FORMAT(f11.7,14X,'Longitude of spot 1, star 2 (degrees),',' t'  &
      ,'ag c3')
1910 FORMAT(f11.7,14X,'Angular radius of spot 1, star 2 ','(degree'  &
      ,'s), tag c4')
1920 FORMAT(f10.7,15X,'Temperature factor spot 2, star 2, tag c5')
1930 FORMAT(f11.7,14X,'Latitude of spot 2, star 2 (degrees),',' ta'  &
      ,'g c6')
1940 FORMAT(f11.7,14X,'Longitude of spot 2, star 2 (degrees),',' t'  &
      ,'ag c7')
1950 FORMAT(f11.7,14X,'Angular radius of spot 2, star 2 ','(degree'  &
      ,'s), tag c8')
1960 FORMAT(f13.10,12X,'beam2 (Doppler boosting factor,',' star 2)'  &
      ,', tag e2')
1970 FORMAT(f10.7,15X,'rk2 (apsidal constant, star 2), tag a2')
1980 FORMAT(f20.11,5X,'flux star 2, filter 1 (need Nterms > 0),',''  &
      ,' tag 21')
1990 FORMAT(f20.11,5X,'flux star 2, filter 2 (need Nterms > 0),',''  &
      ,' tag 22')
2000 FORMAT(f20.11,5X,'flux star 2, filter 3 (need Nterms > 0),',''  &
      ,' tag 23')
2010 FORMAT(f20.11,5X,'flux star 2, filter 4 (need Nterms > 0),',''  &
      ,' tag 24')
2020 FORMAT(f20.11,5X,'flux star 2, filter 5 (need Nterms > 0),',''  &
      ,' tag 25')
2030 FORMAT(f20.11,5X,'flux star 2, filter 6 (need Nterms > 0),',''  &
      ,' tag 26')
2040 FORMAT(f20.11,5X,'flux star 2, filter 7 (need Nterms > 0),',''  &
      ,' tag 27')
2050 FORMAT(f20.11,5X,'flux star 2, filter 8 (need Nterms > 0),',''  &
      ,' tag 28')
2060 FORMAT('!  Accretion disk parameters')
2070 FORMAT(i1,24X,'idint (1 for accretion disk)')
2080 FORMAT(i3,22X,'Ntheta')
2090 FORMAT(i3,22X,'Nradius')
2100 FORMAT(f11.8,14X,'beta_rim (opening angle in degrees),',' tag'  &
      ,' be')
2110 FORMAT(f12.9,13X,'rinner (radius of inner hole), tag ri')
2120 FORMAT(f12.9,13X,'router (radius of outer disk), tag ro')
2130 FORMAT(f13.6,12X,'Tdisk (temperature of inner edge in K)',' t'  &
      ,'ag td')
2140 FORMAT(f12.9,13X,'xi (power-law exponent on temperature',' pr'  &
      ,'ofile), tag xi')
2150 FORMAT(f13.10,12X,'Temperature factor spot 1, disk, tag d1')
2160 FORMAT(f13.9,12X,'Azimuth of spot 1, disk (degrees), tag d2')
2170 FORMAT(f13.9,12X,'Radial cutoff of spot 1, disk (0 <= ',' r_c'  &
      ,'ut <=1), tag d3')
2180 FORMAT(f13.9,12X,'Angular size of spot 1, disk (degrees),',' '  &
      ,'tag d4')
2190 FORMAT(f13.10,12X,'Temperature factor spot 2, disk, tag d5')
2200 FORMAT(f13.9,12X,'Azimuth of spot 2, disk (degrees), tag d6')
2210 FORMAT(f13.9,12X,'Radial cutoff of spot 2, disk (0 <= r_cut',  &
      ' <=1), tag d7')
2220 FORMAT(f13.9,12X,'Angular size of spot 2, disk (degrees),',' '  &
      ,'tag d8')
2230 FORMAT(f15.9,10X,'reference phase for disk fraction')
2240 FORMAT('!  Pulsar parameters')
2250 FORMAT(f17.11,8X,'asini (projected semimajor axis in ','secon'  &
      ,'ds)')
2260 FORMAT(f13.10,12X,'asini error')
2270 FORMAT('!  Body 3 orbital parameters')
2280 FORMAT(f21.13,4X,'P1Tconj, tag tj')
2290 FORMAT(f22.14,3X,'P1period (days), tag tt')
2300 FORMAT(f21.13,4X,'P1pTc (period + Tconj for body 3), tag 1p')
2310 FORMAT(f21.13,4X,'P1mTc (period - Tconj for body 3), tag 1m')
2320 FORMAT(f17.12,8X,'P1qTc (slope in P-Tc plane for body 3),',1X,  &
      'tag 1q')
2330 FORMAT(f21.12,4X,'T1off (offset in P-Tc plane for body 3),',  &
      1X,'tag 1t')
2340 FORMAT(f21.13,4X,'P1T0, tag tu')
2350 FORMAT(f20.17,5X,'P1e*cos(omega), tag tv')
2360 FORMAT(f20.17,5X,'P1e*sin(omega), tag tw')
2370 FORMAT(f20.17,5X,'P1sqrt(e)*cos(omega), tag 1c')
2380 FORMAT(f20.17,5X,'P1sqrt(e)*sin(omega), tag 1s')
2390 FORMAT(f20.15,5X,'P1incl (degrees), tag tx')
2400 FORMAT(f20.15,5X,'P1Omega (degrees), tag ty')
2410 FORMAT(f20.14,5X,'angsum1 (P1incl + P1Omega), tag 1a')
2420 FORMAT(f20.14,5X,'angdiff1 (P1incl - P1Omega), tag 1d')
2430 FORMAT('!  Body 3 parameters')
2440 FORMAT(2(i4,1X),15X,'Nalph3, Nbet3')
2450 FORMAT(f15.9,10X,'Teff3 (K), tag T3')
2460 FORMAT(f8.5,17X,'g3, tag g3')
2470 FORMAT(f16.11,9X,'P1ratrad (radius of star 1 to ','body 3), t'  &
      ,'ag tb')
2480 FORMAT(f20.11,5X,'P1Q (mass of EB to body 3 mass), ','tag tz')
2490 FORMAT(f18.13,7X,'omega3, tag o3')
2500 FORMAT(f12.7,13X,'axis_I3 (inclination of rotation axis if ',  &
      'ialign=0), tag ci')
2510 FORMAT(f12.7,13X,'axis_beta3 (angle of rotation axis wrt ','o'  &
      ,'rbit if ialign=0), tag cb')
2520 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','1, tag m1, n1')
2530 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','2, tag m2, n2')
2540 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','3, tag m3, n3')
2550 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','4, tag m4, n4')
2560 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','5, tag m5, n5')
2570 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','6, tag m6, n6')
2580 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','7, tag m7, n7')
2590 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','8, tag m8, n8')
2600 FORMAT(f10.7,15X,'rk3 (apsidal constant, body 3), tag a3')
2610 FORMAT(f20.11,5X,'flux body 3, filter 1 (need Nterms > 0),',''  &
      ,' tag 31')
2620 FORMAT(f20.11,5X,'flux body 3, filter 2 (need Nterms > 0),',''  &
      ,' tag 32')
2630 FORMAT(f20.11,5X,'flux body 3, filter 3 (need Nterms > 0),',''  &
      ,' tag 33')
2640 FORMAT(f20.11,5X,'flux body 3, filter 4 (need Nterms > 0),',''  &
      ,' tag 34')
2650 FORMAT(f20.11,5X,'flux body 3, filter 5 (need Nterms > 0),',''  &
      ,' tag 35')
2660 FORMAT(f20.11,5X,'flux body 3, filter 6 (need Nterms > 0),',''  &
      ,' tag 36')
2670 FORMAT(f20.11,5X,'flux body 3, filter 7 (need Nterms > 0),',''  &
      ,' tag 37')
2680 FORMAT(f20.11,5X,'flux body 3, filter 8 (need Nterms > 0),',''  &
      ,' tag 38')
2690 FORMAT('!  Body 4 orbital parameters')
2700 FORMAT(f21.13,4X,'P2Tconj, tag uj')
2710 FORMAT(f22.14,3X,'P2period (days), tag ut')
2720 FORMAT(f21.13,4X,'P2pTc (period + Tconj for body 4), tag 2p')
2730 FORMAT(f21.13,4X,'P2mTc (period - Tconj for body 4), tag 2m')
2740 FORMAT(f17.12,8X,'P2qTc (slope in P-Tc plane for body 4),',1X,  &
      'tag 2q')
2750 FORMAT(f21.12,4X,'T2off (offset in P-Tc plane for body 4),',  &
      1X,'tag 2t')
2760 FORMAT(f21.13,4X,'P2T0, tag uu')
2770 FORMAT(f20.17,5X,'P2e*cos(omega), tag uv')
2780 FORMAT(f20.17,5X,'P2e*sin(omega), tag uw')
2790 FORMAT(f20.17,5X,'P2sqrt(e)*cos(omega), tag 2c')
2800 FORMAT(f20.17,5X,'P2sqrt(e)*sin(omega), tag 2s')
2810 FORMAT(f20.15,5X,'P2incl (degrees), tag ux')
2820 FORMAT(f20.15,5X,'P2Omega (degrees), tag uy')
2830 FORMAT(f20.14,5X,'angsum2 (P2incl + P2Omega), tag 2a')
2840 FORMAT(f20.14,5X,'angdiff2 (P2incl - P2Omega), tag 2d')
2850 FORMAT('!  Body 4 parameters')
2860 FORMAT(f15.9,10X,'Teff4 (K), tag T4')
2870 FORMAT(f8.5,17X,'g4, tag g4')
2880 FORMAT(f16.11,9X,'P2ratrad (radius of star 1 to ','body 4), t'  &
      ,'ag ub')
2890 FORMAT(f20.11,5X,'P2Q (mass of EB to body 4 mass), ','tag uz')
2900 FORMAT(f18.13,7X,'omega4, tag o4')
2910 FORMAT(f12.7,13X,'axis_I4 (inclination of rotation axis if ',  &
      'ialign=0), tag di')
2920 FORMAT(f12.7,13X,'axis_beta4 (angle of rotation axis wrt ','o'  &
      ,'rbit if ialign=0), tag db')
2930 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','1, tag i1, j1')
2940 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','2, tag i2, j2')
2950 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','3, tag i3, j3')
2960 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','4, tag i4, j4')
2970 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','5, tag i5, j5')
2980 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','6, tag i6, j6')
2990 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','7, tag i7, j7')
3000 FORMAT(2(f11.8,1X),1X,'limb darkening coefficients,',' filter'  &
      ,' ','8, tag i8, j8')
3010 FORMAT(f10.7,15X,'rk4 (apsidal constant, body 4), tag a4')
3020 FORMAT(f20.11,5X,'flux body 4, filter 1 (need Nterms > 0),',''  &
      ,' tag 41')
3030 FORMAT(f20.11,5X,'flux body 4, filter 2 (need Nterms > 0),',''  &
      ,' tag 42')
3040 FORMAT(f20.11,5X,'flux body 4, filter 3 (need Nterms > 0),',''  &
      ,' tag 43')
3050 FORMAT(f20.11,5X,'flux body 4, filter 4 (need Nterms > 0),',''  &
      ,' tag 44')
3060 FORMAT(f20.11,5X,'flux body 4, filter 5 (need Nterms > 0),',''  &
      ,' tag 45')
3070 FORMAT(f20.11,5X,'flux body 4, filter 6 (need Nterms > 0),',''  &
      ,' tag 46')
3080 FORMAT(f20.11,5X,'flux body 4, filter 7 (need Nterms > 0),',''  &
      ,' tag 47')
3090 FORMAT(f20.11,5X,'flux body 4, filter 8 (need Nterms > 0),',''  &
      ,' tag 48')
3100 FORMAT('!  binary+binary stellar parameters')
3110 FORMAT(f21.14,4X,'bin2masssum (M_3 + M_4 in binary+binary ',''  &
      ,'mode), tag 91')
3120 FORMAT(f21.14,4X,'bin2massdiff (M_3 - M_4 in binary+binary ',  &
      'mode), tag 92')
3130 FORMAT(f21.14,4X,'bin2Q (M_4/M_3 in binary+binary ','mode), t'  &
      ,'ag 93')
3140 FORMAT(f21.14,4X,'bin2radsum (R_3 + R_4 in binary+binary ','m'  &
      ,'ode), tag 94')
3150 FORMAT(f21.14,4X,'bin2raddiff (R_3 - R_4 in binary+binary ',''  &
      ,'mode), tag 95')
3160 FORMAT(f21.14,4X,'bin2ratrad (R_3/R_4 in binary+binary ','mod'  &
      ,'e), tag 96')
3170 FORMAT(f21.15,4X,'bin2M3 (M3 in solar masses), tag 97')
3180 FORMAT(f21.15,4X,'bin2M4 (M4 in solar masses), tag 98')
3190 FORMAT(f21.15,4X,'bin2R3 (R3 in solar masses), tag 99')
3200 FORMAT(f21.15,4X,'bin2R4 (R4 in solar masses), tag 90')
3210 FORMAT('!  Body 5 orbital parameters')
3220 FORMAT(f21.13,4X,'P3Tconj, tag vj')
3230 FORMAT(f22.14,3X,'P3period (days), tag vt')
3240 FORMAT(f21.13,4X,'P3pTc (period + Tconj for body 5), tag 3p')
3250 FORMAT(f21.13,4X,'P3mTc (period - Tconj for body 5), tag 3m')
3260 FORMAT(f17.12,8X,'P3qTc (slope in P-Tc plane for body 5),',1X,  &
      'tag 3q')
3270 FORMAT(f21.12,4X,'T3off (offset in P-Tc plane for body 5),',  &
      1X,'tag 3t')
3280 FORMAT(f21.13,4X,'P3T0, tag vu')
3290 FORMAT(f20.17,5X,'P3e*cos(omega), tag vv')
3300 FORMAT(f20.17,5X,'P3e*sin(omega), tag vw')
3310 FORMAT(f20.17,5X,'P3sqrt(e)*cos(omega), tag 3c')
3320 FORMAT(f20.17,5X,'P3sqrt(e)*sin(omega), tag 3s')
3330 FORMAT(f20.15,5X,'P3incl (degrees), tag vx')
3340 FORMAT(f20.15,5X,'P3Omega (degrees), tag vy')
3350 FORMAT(f20.14,5X,'angsum3 (P3incl + P3Omega), tag 3a')
3360 FORMAT(f20.14,5X,'angdiff3 (P3incl - P3Omega), tag 3d')
3370 FORMAT('!  Body 5 parameters')
3380 FORMAT(f15.9,10X,'Teff5 (K), tag T5')
3390 FORMAT(f8.5,17X,'g5, tag g5')
3400 FORMAT(f16.11,9X,'P3ratrad (radius of star 1 to ','body 5), t'  &
      ,'ag vb')
3410 FORMAT(f20.11,5X,'P3Q (mass of EB to body 5 mass), ','tag vz')
3420 FORMAT(f12.8,13X,'omega5, tag o5')
3430 FORMAT(f12.7,13X,'axis_I5 (inclination of rotation axis if ',  &
      'ialign=0), tag ...')
3440 FORMAT(f12.7,13X,'axis_beta5 (angle of rotation axis wrt ','o'  &
      ,'rbit if ialign=0), tag ...')
3450 FORMAT(2(f11.8,1X),7X,'limb darkening coefficients,',' filter'  &
      ,' ','1, tag k1, p1')
3460 FORMAT(2(f11.8,1X),7X,'limb darkening coefficients,',' filter'  &
      ,' ','2, tag k2, p2')
3470 FORMAT(2(f11.8,1X),7X,'limb darkening coefficients,',' filter'  &
      ,' ','3, tag k3, p3')
3480 FORMAT(2(f11.8,1X),7X,'limb darkening coefficients,',' filter'  &
      ,' ','4, tag k4, p4')
3490 FORMAT(2(f11.8,1X),7X,'limb darkening coefficients,',' filter'  &
      ,' ','5, tag k5, p5')
3500 FORMAT(2(f11.8,1X),7X,'limb darkening coefficients,',' filter'  &
      ,' ','6, tag k6, p6')
3510 FORMAT(2(f11.8,1X),7X,'limb darkening coefficients,',' filter'  &
      ,' ','7, tag k7, p7')
3520 FORMAT(2(f11.8,1X),7X,'limb darkening coefficients,',' filter'  &
      ,' ','8, tag k8, p8')
3530 FORMAT(f10.7,15X,'rk5 (apsidal constant, body 5), tag a5')
3540 FORMAT(f20.11,5X,'flux body 5, filter 1 (need Nterms > 0),',''  &
      ,' tag 51')
3550 FORMAT(f20.11,5X,'flux body 5, filter 2 (need Nterms > 0),',''  &
      ,' tag 52')
3560 FORMAT(f20.11,5X,'flux body 5, filter 3 (need Nterms > 0),',''  &
      ,' tag 53')
3570 FORMAT(f20.11,5X,'flux body 5, filter 4 (need Nterms > 0),',''  &
      ,' tag 54')
3580 FORMAT(f20.11,5X,'flux body 5, filter 5 (need Nterms > 0),',''  &
      ,' tag 55')
3590 FORMAT(f20.11,5X,'flux body 5, filter 6 (need Nterms > 0),',''  &
      ,' tag 56')
3600 FORMAT(f20.11,5X,'flux body 5, filter 7 (need Nterms > 0),',''  &
      ,' tag 57')
3610 FORMAT(f20.11,5X,'flux body 5, filter 8 (need Nterms > 0),',''  &
      ,' tag 58')
3620 FORMAT('!  Body 6 orbital parameters')
3630 FORMAT(f21.13,4X,'P4Tconj, tag wj')
3640 FORMAT(f22.14,3X,'P4period (days), tag wt')
3650 FORMAT(f21.13,4X,'P4pTc (period + Tconj for body 6), tag 4p')
3660 FORMAT(f21.13,4X,'P4mTc (period - Tconj for body 6), tag 4m')
3670 FORMAT(f17.12,8X,'P4qTc (slope in P-Tc plane for body 6),',1X,  &
      'tag 4q')
3680 FORMAT(f21.12,4X,'T4off (offset in P-Tc plane for body 6),',  &
      1X,'tag 4t')
3690 FORMAT(f21.13,4X,'P4T0, tag wu')
3700 FORMAT(f20.17,5X,'P4e*cos(omega), tag wv')
3710 FORMAT(f20.17,5X,'P4e*sin(omega), tag ww')
3720 FORMAT(f20.17,5X,'P4sqrt(e)*cos(omega), tag 4c')
3730 FORMAT(f20.17,5X,'P4sqrt(e)*sin(omega), tag 4s')
3740 FORMAT(f20.15,5X,'P4incl (degrees), tag wx')
3750 FORMAT(f20.15,5X,'P4Omega (degrees), tag wy')
3760 FORMAT(f20.14,5X,'angsum4 (P4incl + P4Omega), tag 4a')
3770 FORMAT(f20.14,5X,'angdiff4 (P4incl - P4Omega), tag 4d')
3780 FORMAT('!  Body 6 parameters')
3790 FORMAT(f15.9,10X,'Teff6 (K), tag T6')
3800 FORMAT(f8.5,17X,'g6, tag g6')
3810 FORMAT(f16.11,9X,'P4ratrad (radius of star 1 to ','body 6), t'  &
      ,'ag wb')
3820 FORMAT(f20.11,5X,'P4Q (mass of EB to body 6 mass), ','tag wz')
3830 FORMAT(f12.8,13X,'omega6, tag o6')
3840 FORMAT(f12.7,13X,'axis_I6 (inclination of rotation axis if ',  &
      'ialign=0), tag ...')
3850 FORMAT(f12.7,13X,'axis_beta6 (angle of rotation axis wrt ','o'  &
      ,'rbit if ialign=0), tag ...')
3860 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'1, tag ..., ...')
3870 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'2, tag ..., ...')
3880 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'3, tag ..., ...')
3890 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'4, tag ..., ...')
3900 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'5, tag ..., ...')
3910 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'6, tag ..., ...')
3920 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'7, tag ..., ...')
3930 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'8, tag ..., ...')
3940 FORMAT(f10.7,15X,'rk6 (apsidal constant, body 6), tag a6')
3950 FORMAT(f20.11,5X,'flux body 6, filter 1 (need Nterms > 0),',''  &
      ,' tag 61')
3960 FORMAT(f20.11,5X,'flux body 6, filter 2 (need Nterms > 0),',''  &
      ,' tag 62')
3970 FORMAT(f20.11,5X,'flux body 6, filter 3 (need Nterms > 0),',''  &
      ,' tag 63')
3980 FORMAT(f20.11,5X,'flux body 6, filter 4 (need Nterms > 0),',''  &
      ,' tag 64')
3990 FORMAT(f20.11,5X,'flux body 6, filter 5 (need Nterms > 0),',''  &
      ,' tag 65')
4000 FORMAT(f20.11,5X,'flux body 6, filter 6 (need Nterms > 0),',''  &
      ,' tag 66')
4010 FORMAT(f20.11,5X,'flux body 6, filter 7 (need Nterms > 0),',''  &
      ,' tag 67')
4020 FORMAT(f20.11,5X,'flux body 6, filter 8 (need Nterms > 0),',''  &
      ,' tag 68')
4030 FORMAT('!  Body 7 orbital parameters')
4040 FORMAT(f21.13,4X,'P5Tconj, tag xj')
4050 FORMAT(f22.14,3X,'P5period (days), tag xt')
4060 FORMAT(f21.13,4X,'P5pTc (period + Tconj for body 7), tag 5p')
4070 FORMAT(f21.13,4X,'P5mTc (period - Tconj for body 7), tag 5m')
4080 FORMAT(f17.12,8X,'P5qTc (slope in P-Tc plane for body 7),',1X,  &
      'tag 5q')
4090 FORMAT(f21.12,4X,'T5off (offset in P-Tc plane for body 7),',  &
      1X,'tag 5t')
4100 FORMAT(f21.13,4X,'P5T0, tag xu')
4110 FORMAT(f20.17,5X,'P5e*cos(omega), tag xv')
4120 FORMAT(f20.17,5X,'P5e*sin(omega), tag xw')
4130 FORMAT(f20.17,5X,'P5sqrt(e)*cos(omega), tag 5c')
4140 FORMAT(f20.17,5X,'P5sqrt(e)*sin(omega), tag 5s')
4150 FORMAT(f20.15,5X,'P5incl (degrees), tag xx')
4160 FORMAT(f20.15,5X,'P5Omega (degrees), tag xy')
4170 FORMAT(f20.14,5X,'angsum5 (P5incl + P5Omega), tag 5a')
4180 FORMAT(f20.14,5X,'angdiff5 (P5incl - P5Omega), tag 5d')
4190 FORMAT('!  Body 7 parameters')
4200 FORMAT(f15.9,10X,'Teff7 (K), tag T7')
4210 FORMAT(f8.5,17X,'g7, tag g7')
4220 FORMAT(f16.11,9X,'P5ratrad (radius of star 1 to ','body 7), t'  &
      ,'ag xb')
4230 FORMAT(f20.11,5X,'P5Q (mass of EB to body 7 mass), ','tag xz')
4240 FORMAT(f12.8,13X,'omega7, tag o7')
4250 FORMAT(f12.7,13X,'axis_I7 (inclination of rotation axis if ',  &
      'ialign=0), tag ...')
4260 FORMAT(f12.7,13X,'axis_beta7 (angle of rotation axis wrt ','o'  &
      ,'rbit if ialign=0), tag ...')
4270 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'1, tag ..., ...')
4280 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'2, tag ..., ...')
4290 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'3, tag ..., ...')
4300 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'4, tag ..., ...')
4310 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'5, tag ..., ...')
4320 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'6, tag ..., ...')
4330 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'7, tag ..., ...')
4340 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'8, tag ..., ...')
4350 FORMAT(f10.7,15X,'rk7 (apsidal constant, body 7), tag a7')
4360 FORMAT(f20.11,5X,'flux body 7, filter 1 (need Nterms > 0),',''  &
      ,' tag 71')
4370 FORMAT(f20.11,5X,'flux body 7, filter 2 (need Nterms > 0),',''  &
      ,' tag 72')
4380 FORMAT(f20.11,5X,'flux body 7, filter 3 (need Nterms > 0),',''  &
      ,' tag 73')
4390 FORMAT(f20.11,5X,'flux body 7, filter 4 (need Nterms > 0),',''  &
      ,' tag 74')
4400 FORMAT(f20.11,5X,'flux body 7, filter 5 (need Nterms > 0),',''  &
      ,' tag 75')
4410 FORMAT(f20.11,5X,'flux body 7, filter 6 (need Nterms > 0),',''  &
      ,' tag 76')
4420 FORMAT(f20.11,5X,'flux body 7, filter 7 (need Nterms > 0),',''  &
      ,' tag 77')
4430 FORMAT(f20.11,5X,'flux body 7, filter 8 (need Nterms > 0),',''  &
      ,' tag 78')
4440 FORMAT('!  Body 8 orbital parameters')
4450 FORMAT(f21.13,4X,'P6Tconj, tag sj')
4460 FORMAT(f22.14,3X,'P6period (days), tag st')
4470 FORMAT(f21.13,4X,'P6pTc (period + Tconj for body 8), tag 6p')
4480 FORMAT(f21.13,4X,'P6mTc (period - Tconj for body 8), tag 6m')
4490 FORMAT(f17.12,8X,'P6qTc (slope in P-Tc plane for body 8),',1X,  &
      'tag 6q')
4500 FORMAT(f21.12,4X,'T6off (offset in P-Tc plane for body 8),',  &
      1X,'tag 6t')
4510 FORMAT(f21.13,4X,'P6T0, tag su')
4520 FORMAT(f20.17,5X,'P6e*cos(omega), tag sv')
4530 FORMAT(f20.17,5X,'P6e*sin(omega), tag sw')
4540 FORMAT(f20.17,5X,'P6sqrt(e)*cos(omega), tag 6c')
4550 FORMAT(f20.17,5X,'P6sqrt(e)*sin(omega), tag 6s')
4560 FORMAT(f20.15,5X,'P6incl (degrees), tag sx')
4570 FORMAT(f20.15,5X,'P6Omega (degrees), tag sy')
4580 FORMAT(f20.14,5X,'angsum6 (P6incl + P6Omega), tag 6a')
4590 FORMAT(f20.14,5X,'angdiff6 (P6incl - P6Omega), tag 6d')
4600 FORMAT('!  Body 8 parameters')
4610 FORMAT(f15.9,10X,'Teff8 (K), tag T8')
4620 FORMAT(f8.5,17X,'g8, tag g8')
4630 FORMAT(f16.11,9X,'P6ratrad (radius of star 1 to ','body 8), t'  &
      ,'ag sb')
4640 FORMAT(f20.11,5X,'P6Q (mass of EB to body 8 mass), ','tag sz')
4650 FORMAT(f12.8,13X,'omega8, tag o8')
4660 FORMAT(f12.7,13X,'axis_I8 (inclination of rotation axis if ',  &
      'ialign=0), tag ...')
4670 FORMAT(f12.7,13X,'axis_beta8 (angle of rotation axis wrt ','o'  &
      ,'rbit if ialign=0), tag ...')
4680 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'1, tag ..., ...')
4690 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'2, tag ..., ...')
4700 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'3, tag ..., ...')
4710 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'4, tag ..., ...')
4720 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'5, tag ..., ...')
4730 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'6, tag ..., ...')
4740 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'7, tag ..., ...')
4750 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'8, tag ..., ...')
4760 FORMAT(f10.7,15X,'rk8 (apsidal constant, body 8), tag a8')
4770 FORMAT(f20.11,5X,'flux body 8, filter 1 (need Nterms > 0),',''  &
      ,' tag 81')
4780 FORMAT(f20.11,5X,'flux body 8, filter 2 (need Nterms > 0),',''  &
      ,' tag 82')
4790 FORMAT(f20.11,5X,'flux body 8, filter 3 (need Nterms > 0),',''  &
      ,' tag 83')
4800 FORMAT(f20.11,5X,'flux body 8, filter 4 (need Nterms > 0),',''  &
      ,' tag 84')
4810 FORMAT(f20.11,5X,'flux body 8, filter 5 (need Nterms > 0),',''  &
      ,' tag 85')
4820 FORMAT(f20.11,5X,'flux body 8, filter 6 (need Nterms > 0),',''  &
      ,' tag 86')
4830 FORMAT(f20.11,5X,'flux body 8, filter 7 (need Nterms > 0),',''  &
      ,' tag 87')
4840 FORMAT(f20.11,5X,'flux body 8, filter 8 (need Nterms > 0),',''  &
      ,' tag 88')
4850 FORMAT('!  Body 9 orbital parameters')
4860 FORMAT(f21.13,4X,'P7Tconj, tag hj')
4870 FORMAT(f22.14,3X,'P7period (days), tag ht')
4880 FORMAT(f21.13,4X,'P7pTc (period + Tconj for body 9), tag 7p')
4890 FORMAT(f21.13,4X,'P7mTc (period - Tconj for body 9), tag 7m')
4900 FORMAT(f17.12,8X,'P7qTc (slope in P-Tc plane for body 9),',1X,  &
      'tag 7q')
4910 FORMAT(f21.12,4X,'T7off (offset in P-Tc plane for body 9),',  &
      1X,'tag 7t')
4920 FORMAT(f21.13,4X,'P7T0, tag hu')
4930 FORMAT(f20.17,5X,'P7e*cos(omega), tag hv')
4940 FORMAT(f20.17,5X,'P7e*sin(omega), tag hw')
4950 FORMAT(f20.17,5X,'P7sqrt(e)*cos(omega), tag 7c')
4960 FORMAT(f20.17,5X,'P7sqrt(e)*sin(omega), tag 7s')
4970 FORMAT(f20.15,5X,'P7incl (degrees), tag hx')
4980 FORMAT(f20.15,5X,'P7Omega (degrees), tag hy')
4990 FORMAT(f20.14,5X,'angsum7 (P7incl + P7Omega), tag 7a')
5000 FORMAT(f20.14,5X,'angdiff7 (P7incl - P7Omega), tag 7d')
5010 FORMAT('!  Body 9 parameters')
5020 FORMAT(f15.9,10X,'Teff9 (K), tag T9')
5030 FORMAT(f8.5,17X,'g9, tag g9')
5040 FORMAT(f16.11,9X,'P7ratrad (radius of star 1 to ','body 9), t'  &
      ,'ag hb')
5050 FORMAT(f20.11,5X,'P7Q (mass of EB to body 9 mass), ','tag hz')
5060 FORMAT(f12.8,13X,'omega9, tag o9')
5070 FORMAT(f12.7,13X,'axis_I9 (inclination of rotation axis if ',  &
      'ialign=0), tag ...')
5080 FORMAT(f12.7,13X,'axis_beta9 (angle of rotation axis wrt ','o'  &
      ,'rbit if ialign=0), tag ...')
5090 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'1, tag ..., ...')
5100 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'2, tag ..., ...')
5110 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'3, tag ..., ...')
5120 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'4, tag ..., ...')
5130 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'5, tag ..., ...')
5140 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'6, tag ..., ...')
5150 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'7, tag ..., ...')
5160 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'8, tag ..., ...')
5170 FORMAT(f10.8,15X,'rk9 (apsidal constant, body 9), tag a9')
5180 FORMAT(f20.11,5X,'flux body 9, filter 1 (need Nterms > 0),',''  &
      ,' tag 91')
5190 FORMAT(f20.11,5X,'flux body 9, filter 2 (need Nterms > 0),',''  &
      ,' tag 92')
5200 FORMAT(f20.11,5X,'flux body 9, filter 3 (need Nterms > 0),',''  &
      ,' tag 93')
5210 FORMAT(f20.11,5X,'flux body 9, filter 4 (need Nterms > 0),',''  &
      ,' tag 94')
5220 FORMAT(f20.11,5X,'flux body 9, filter 5 (need Nterms > 0),',''  &
      ,' tag 95')
5230 FORMAT(f20.11,5X,'flux body 9, filter 6 (need Nterms > 0),',''  &
      ,' tag 96')
5240 FORMAT(f20.11,5X,'flux body 9, filter 7 (need Nterms > 0),',''  &
      ,' tag 97')
5250 FORMAT(f20.11,5X,'flux body 9, filter 8 (need Nterms > 0),',''  &
      ,' tag 98')
5260 FORMAT('!  Body 10 orbital parameters')
5270 FORMAT(f21.13,4X,'P8Tconj, tag kj')
5280 FORMAT(f22.14,3X,'P8period (days), tag kt')
5290 FORMAT(f21.13,4X,'P8pTc (period + Tconj for body 10), tag 8p')
5300 FORMAT(f21.13,4X,'P8mTc (period - Tconj for body 10), tag 8m')
5310 FORMAT(f17.12,8X,'P8qTc (slope in P-Tc plane for body 10),',  &
      1X,'tag 8q')
5320 FORMAT(f21.12,4X,'T8off (offset in P-Tc plane for body 10),',  &
      1X,'tag 8t')
5330 FORMAT(f21.13,4X,'P8T0, tag ku')
5340 FORMAT(f20.17,5X,'P8e*cos(omega), tag kv')
5350 FORMAT(f20.17,5X,'P8e*sin(omega), tag kw')
5360 FORMAT(f20.17,5X,'P8sqrt(e)*cos(omega), tag 8c')
5370 FORMAT(f20.17,5X,'P8sqrt(e)*sin(omega), tag 8s')
5380 FORMAT(f20.15,5X,'P8incl (degrees), tag kx')
5390 FORMAT(f20.15,5X,'P8Omega (degrees), tag ky')
5400 FORMAT(f20.14,5X,'angsum8 (P8incl + P8Omega), tag 8a')
5410 FORMAT(f20.14,5X,'angdiff8 (P8incl - P8Omega), tag 8d')
5420 FORMAT('!  Body 10 parameters')
5430 FORMAT(f15.9,10X,'Teff10 (K), tag ...')
5440 FORMAT(f8.5,17X,'g10, tag g0')
5450 FORMAT(f16.11,9X,'P8ratrad (radius of star 1 to ','body 10),'  &
      ,' tag kb')
5460 FORMAT(f20.11,5X,'P8Q (mass of EB to body 10 mass), ','tag k' ,'z')
5470 FORMAT(f12.8,13X,'omega10, tag o0')
5480 FORMAT(f12.7,13X,'axis_I10 (inclination of rotation axis if ',  &
      'ialign=0), tag ...')
5490 FORMAT(f12.7,13X,'axis_beta10 (angle of rotation axis wrt ',''  &
      ,'orbit if ialign=0), tag ...')
5500 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'1, tag ..., ...')
5510 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'2, tag ..., ...')
5520 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'3, tag ..., ...')
5530 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'4, tag ..., ...')
5540 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'5, tag ..., ...')
5550 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'6, tag ..., ...')
5560 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'7, tag ..., ...')
5570 FORMAT(2(f8.5,1X),7X,'limb darkening coefficients,',' filter '  &
      ,'8, tag ..., ...')
5580 FORMAT(f10.7,15X,'rk10 (apsidal constant, body 10), tag ...')
5590 FORMAT(f20.11,5X,'flux body 10, filter 1 (need Nterms > 0),',  &
      ' tag 01')
5600 FORMAT(f20.11,5X,'flux body 10, filter 2 (need Nterms > 0),',  &
      ' tag 02')
5610 FORMAT(f20.11,5X,'flux body 10, filter 3 (need Nterms > 0),',  &
      ' tag 03')
5620 FORMAT(f20.11,5X,'flux body 10, filter 4 (need Nterms > 0),',  &
      ' tag 04')
5630 FORMAT(f20.11,5X,'flux body 10, filter 5 (need Nterms > 0),',  &
      ' tag 05')
5640 FORMAT(f20.11,5X,'flux body 10, filter 6 (need Nterms > 0),',  &
      ' tag 06')
5650 FORMAT(f20.11,5X,'flux body 10, filter 7 (need Nterms > 0),',  &
      ' tag 07')
5660 FORMAT(f20.11,5X,'flux body 10, filter 8 (need Nterms > 0),',  &
      ' tag 08')
!
   RETURN
!
END SUBROUTINE newrecordparm
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE newsortcircle(n,xcir,ycir,nhoriz,xhoriz,yhoriz,  &
   ibetmax,xhmin,xhmax,yhmin,yhmax)
!
!   May 18, 2000
!
!   This routine will take the x,y points of the star's horizon, sort them
!   in polar coordinates, resample by interpolation, and return new arrays
!   xhoriz,yhoriz.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: xcir(n)
   REAL(KIND=dp), INTENT(IN OUT)            :: ycir(n)
   INTEGER, INTENT(OUT)                     :: nhoriz
   REAL(KIND=dp), INTENT(OUT)               :: xhoriz(4*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: yhoriz(4*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: xhmin
   REAL(KIND=dp), INTENT(OUT)               :: xhmax
   REAL(KIND=dp), INTENT(OUT)               :: yhmin
   REAL(KIND=dp), INTENT(OUT)               :: yhmax
!
   REAL(KIND=dp), ALLOCATABLE :: theta(:),rr(:),dumt1(:),dumr1(:),dumt2(:),dumr2(:)
   REAL(KIND=dp)  :: xcenter,ycenter,xxx,yyy,diff,angle
   REAL(KIND=dp)  :: xmin,xmax,ymin,ymax,dy,qqq
!
   INTEGER :: i,icount,ndum,index,m,k
!
   ALLOCATE(theta(45000),rr(45000),dumt1(45000),dumt2(45000),dumr1(45000), &
      dumr2(45000))
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   CALL getmaxvalues(n,xcir,ycir,xmin,xmax,ymin,ymax)
!
   xcenter=(xmax+xmin)/2.0_dp
   ycenter=(ymax+ymin)/2.0_dp
!
!   convert to polar coordinates
!
   DO  i=1,n
      xxx=xcir(i)-xcenter
      yyy=ycir(i)-ycenter
      IF(ABS(xxx) <= EPSILON(xxx))THEN
         IF(yyy < 0.0_dp)THEN
            theta(i)=3.0_dp*pie/2.0_dp
            rr(i)=SQRT(xxx*xxx+yyy*yyy)
            CYCLE
         END IF
         IF(yyy >= 0.0_dp)THEN
            theta(i)=halfpie
            rr(i)=SQRT(xxx*xxx+yyy*yyy)
            CYCLE
         END IF
      END IF
      IF((yyy >= 0.0_dp).AND.(xxx >= 0.0_dp))THEN
         theta(i)=(ATAN2(yyy,xxx))
         rr(i)=SQRT(xxx*xxx+yyy*yyy)
      END IF
      IF((yyy >= 0.0_dp).AND.(xxx < 0.0_dp))THEN
         theta(i)=(ATAN2(yyy,xxx))
         rr(i)=SQRT(xxx*xxx+yyy*yyy)
      END IF
      IF((yyy < 0.0_dp).AND.(xxx < 0.0_dp))THEN
         rr(i)=SQRT(xxx*xxx+yyy*yyy)
         theta(i)=twopie+(ATAN2(yyy,xxx))
      END IF
      IF((yyy < 0.0_dp).AND.(xxx >= 0.0_dp))THEN
         rr(i)=SQRT(xxx*xxx+yyy*yyy)
         theta(i)=twopie+ATAN2(yyy,xxx)
      END IF
   END DO
!
!  sort by theta and swap x and y also
!
   IF(n > 1)CALL sort3(n,theta,rr,ycir)
!
!   Now make a dummy array with theta going from -360 to 720 degrees.
!   This will ensure the interpolation is smooth near the boundaries.
!
   icount=0
   DO  i=1,n
      icount=icount+1
      dumt1(icount)=theta(i)-twopie
      dumr1(icount)=rr(i)
   END DO
!
   DO  i=1,n
      icount=icount+1
      dumt1(icount)=theta(i)
      dumr1(icount)=rr(i)
   END DO
!
   DO  i=1,n
      icount=icount+1
      dumt1(icount)=theta(i)+twopie
      dumr1(icount)=rr(i)
   END DO
!
   ndum=icount
!
!   Remove possible repeated points.
!
   icount=0
   DO  i=2,ndum
      diff=ABS(dumt1(i)-dumt1(i-1))
      IF(diff > 1.0E-10_dp)THEN
         icount=icount+1
         dumt2(icount)=dumt1(i-1)
         dumr2(icount)=dumr1(i-1)
      END IF
   END DO
!
   ndum=icount
!
   index=n
   m=3
   nhoriz=360
!
!   Update May 8, 2006
!
!   Find the minimum and maximum x and y values
!
   xhmin=1.0E+20_dp
   xhmax=-1.0E+20_dp
   yhmin=1.0E+20_dp
   yhmax=-1.0E+20_dp
!
   nhoriz=360
   DO  i=1,360
      angle=REAL(i,KIND=dp)*degtorad
      CALL hunt(dumt2,ndum,angle,index)
      k=MIN(MAX(index-(m-1)/2,1),ndum+1-m)
      CALL polint(dumt2(k),dumr2(k),m,angle,qqq,dy)
!
!   Now assign x,y coordinates based on the qqq (radius) and angle.
!
      xhoriz(i)=qqq*COS(angle)+xcenter
      yhoriz(i)=qqq*SIN(angle)+ycenter
      IF(xhoriz(i) < xhmin)xhmin=xhoriz(i)
      IF(yhoriz(i) < yhmin)yhmin=yhoriz(i)
      IF(xhoriz(i) > xhmax)xhmax=xhoriz(i)
      IF(yhoriz(i) > yhmax)yhmax=yhoriz(i)
   END DO
!
   DEALLOCATE(theta,rr,dumt1,dumt2,dumr1,dumr2)
!
   RETURN
!
END SUBROUTINE newsortcircle
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE newtondiff(odetime,zzq,nstep,timeinterp,nbody,  &
   ii,ndyn)
!
!   divided difference tables for finding intermediate values
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   REAL(KIND=dp), INTENT(IN)                :: odetime(ndyn)
   REAL(KIND=dp), INTENT(IN OUT)            :: zzq(6,60,2)
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN)                :: timeinterp(6)
   INTEGER, INTENT(IN)                      :: nbody
   INTEGER, INTENT(IN OUT)                  :: ii
!
   REAL(KIND=dp), DIMENSION(6)     :: xx
   REAL(KIND=dp), DIMENSION(6,6)   :: d
!
   INTEGER :: kkk,jj,j,i
!
!   old dimension
!
!          DIMENSION zzq(6,60,Ndyn)
!
   DO ii=1,nstep
      DO kkk=1,nbody*3
         DO jj=1,6
            xx(jj)=odetime(ii)+timeinterp(jj)
            d(jj,1)=zzq(jj,kkk,ii)
         END DO
!
!   Construct the divided difference table
!
         DO j=2,6
            DO i=j,6
               d(i,j)=(d(i,j-1)-d(i-1,j-1))/(xx(i)-xx(i-j+1))
            END DO
         END DO
!
         DO i=1,6
            zzq(i,kkk,ii)=d(i,i)
         END DO
!
      END DO
   END DO
   RETURN
!
END SUBROUTINE newtondiff
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE occultquad(z0,u1,u2,p,muo1,mu0,nz)
!
!  This routine computes the lightcurve for occultation
!  of a quadratically limb-darkened source without microlensing.
!  Please cite Mandel & Agol (2002) if you make use of this
!  routine
!  in your research.  Please report errors or bugs to
!  agol@tapir.caltech.edu
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: z0
   REAL(KIND=dp), INTENT(IN)                :: u1
   REAL(KIND=dp), INTENT(IN)                :: u2
   REAL(KIND=dp), INTENT(IN OUT)            :: p
   REAL(KIND=dp), INTENT(OUT)               :: muo1
   REAL(KIND=dp), INTENT(OUT)               :: mu0
   INTEGER, INTENT(IN)                      :: nz
!
   INTEGER :: i
!
   REAL(KIND=dp)  :: lambdad(nz)
   REAL(KIND=dp)  :: etad(nz),lambdae(nz),lam,pi,x1,x2,x3,z,omega,kap0
   REAL(KIND=dp)  :: kap1,q,kk,ek,pk,n,ellec,ellk,rj
!
   IF(ABS(p-0.5_dp) < 1.E-03_dp)p=0.5_dp
!
! Input:
!
! rs   radius of the source (set to unity)
! z0   impact parameter in units of rs
! p    occulting star size in units of rs
! u1   linear    limb-darkening coefficient (gamma_1 in paper)
! u2   quadratic limb-darkening coefficient (gamma_2 in paper)
!
! Output:
!
! muo1 fraction of flux at each z0 for a limb-darkened source
! mu0  fraction of flux at each z0 for a uniform source
!
! Limb darkening has the form:
!  I(r)=[1-u1*(1-sqrt(1-(r/rs)^2))-u2*(1-sqrt(1-(r/rs)^2))^2]/(1-u1/3-u2/6)/pi
!
! To use this routine
!
! Now, compute pure occultation curve:
!
   muo1=0.0_dp
   omega=1.0_dp-u1/3.0_dp-u2/6.0_dp
   pi=ACOS(-1.0_dp)
!
! Loop over each impact parameter:
!
   DO i=1,nz
!
! substitute z=z0(i) to shorten expressions
!
      z=z0  !(i)
      x1=(p-z)**2
      x2=(p+z)**2
      x3=p**2-z**2
!
! the source is unocculted:
! Table 3, I.
!
      IF(z >= 1.0_dp+p)THEN
         lambdad(i)=0.0_dp
         etad(i)=0.0_dp
         lambdae(i)=0.0_dp
         GO TO 10
      END IF
!
! the  source is completely occulted:
! Table 3, II.
!
      IF(p >= 1.0_dp.AND.z <= p-1.0_dp)THEN
         lambdad(i)=2.0_dp/3.0_dp
         etad(i)=0.5_dp
         lambdae(i)=1.0_dp
         GO TO 10
      END IF
!
! the source is partly occulted and the occulting object crosses the limb:
! Equation (26):
!
      IF(z >= ABS(1.0_dp-p).AND.z <= 1.0_dp+p)THEN
         kap1=ACOS(MIN((1.0_dp-p*p+z*z)/2.0_dp/z,1.0_dp))
         kap0=ACOS(MIN((p*p+z*z-1.0_dp)/2.0_dp/p/z,1.0_dp))
         lambdae(i)=p*p*kap0+kap1
         lambdae(i)=(lambdae(i)-0.5_dp*SQRT(MAX(4.0_dp*z*z-(1.0_dp+z*z-  &
            p*p)**2,0.0_dp)))/pi
      END IF
!
! the occulting object transits the source star (but doesn't
! completely cover it):
!
      IF(z <= 1.0_dp-p)lambdae(i)=p*p
!
! the edge of the occulting star lies at the origin- special
! expressions in this case:
!
      IF(ABS(z-p) < 1.0E-04_dp*(z+p))THEN
!
! Table 3, Case V.:
!
         IF(z >= 0.5_dp)THEN
            lam=0.5_dp*pi
            q=0.5_dp/p
            kk=ellk(q)
            ek=ellec(q)
!
! Equation 34: lambda_3
!
            lambdad(i)=1.0_dp/3.0_dp+16.0_dp*p/9.0_dp/pi*(2.0_dp*p*p-1.0_dp)*ek-  &
               (32.0_dp*p**4-20.0_dp*p*p+3.0_dp)/9.0_dp/pi/p*kk
!
! Equation 34: eta_1
!
            etad(i)=1.0_dp/2.0_dp/pi*(kap1+p*p*(p*p+2.0_dp*z*z)*kap0-(1.0_dp  &
               +5.0_dp*p*p+z*z)/4.0_dp*SQRT((1.0_dp-x1)*(x2-1.0_dp)))
            IF(ABS(p-0.5_dp) <= EPSILON(p))THEN
!
! Case VIII: p=1/2, z=1/2
!
               lambdad(i)=1.0_dp/3.0_dp-4.0_dp/pi/9.0_dp
               etad(i)=3.0_dp/32.0_dp
            END IF
            GO TO 10
         ELSE
!
! Table 3, Case VI.:
!
            lam=0.5_dp*pi
            q=2.0_dp*p
            kk=ellk(q)
            ek=ellec(q)
!
! Equation 34: lambda_4
!
            lambdad(i)=1.0_dp/3.0_dp+2.0_dp/9.0_dp/pi*(4.0_dp*(2.0_dp*p*p-1.0_dp)*  &
               ek+(1.0_dp-4.0_dp*p*p)*kk)
!
! Equation 34: eta_2
!
            etad(i)=p*p/2.0_dp*(p*p+2.0_dp*z*z)
            GO TO 10
         END IF
      END IF
!
! the occulting star partly occults the source and crosses the limb:
! Table 3, Case III:
!
!  Changed 1.0001 to 1.0000 and .gt. to .ge.
!
      IF((z > 0.5_dp+ABS(p-0.5_dp).AND.z < 1.0_dp+p).OR.(p > 0.5_dp  &
         .AND.z >= ABS(1.0_dp-p)*1.000_dp.AND.z < p))THEN
         lam=0.5_dp*pi
         q=SQRT((1.0_dp-(p-z)**2)/4.0_dp/z/p)
         kk=ellk(q)
         ek=ellec(q)
         n=1.0_dp/x1-1.0_dp
         pk=kk-n/3.0_dp*rj(0.0_dp,1.0_dp-q*q,1.0_dp,1.0_dp+n)
!
! Equation 34, lambda_1:
!
         lambdad(i)=1.0_dp/9.0_dp/pi/SQRT(p*z)*(((1.0_dp-x2)*(2.0_dp*x2+x1-  &
            3.0_dp)-3.0_dp*x3*(x2-2.0_dp))*kk+4.0_dp*p*z*(z*z+7.0_dp*p*p-4.0_dp)*  &
            ek-3.0_dp*x3/x1*pk)
         IF(z < p)lambdad(i)=lambdad(i)+2.0_dp/3.0_dp
!
! Equation 34, eta_1:
!
         etad(i)=1.0_dp/2.0_dp/pi*(kap1+p*p*(p*p+2.0_dp*z*z)*kap0-(1.0_dp+  &
            5.0_dp*p*p+z*z)/4.0_dp*SQRT((1.0_dp-x1)*(x2-1.0_dp)))
         GO TO 10
      END IF
!
! the occulting star transits the source:
! Table 3, Case IV.:
!
      IF(p <= 1.0_dp.AND.z <= (1.0_dp-p)*1.0001_dp)THEN
         lam=0.5_dp*pi
         q=SQRT((x2-x1)/(1.0_dp-x1))
         kk=ellk(q)
         ek=ellec(q)
         n=x2/x1-1.0_dp
         pk=kk-n/3.0_dp*rj(0.0_dp,1.0_dp-q*q,1.0_dp,1.0_dp+n)
!
! Equation 34, lambda_2:
!
         lambdad(i)=2.0_dp/9.0_dp/pi/SQRT(1.0_dp-x1)*((1.0_dp-5.0_dp*z*z+p*p+  &
            x3*x3)*kk+(1.0_dp-x1)*(z*z+7.0_dp*p*p-4.0_dp)*ek-3.0_dp*x3/x1*pk)
         IF(z < p)lambdad(i)=lambdad(i)+2.0_dp/3.0_dp
         IF(ABS(p+z-1.0_dp) <= 1.0E-04_dp)THEN
            lambdad(i)=2/3.0_dp/pi*ACOS(1.0_dp-2.0_dp*p)-4.0_dp/9.0_dp/pi*  &
               SQRT(p*(1.0_dp-p))*(3.0_dp+2.0_dp*p-8.0_dp*p*p)
         END IF
!
! Equation 34, eta_2:
!
         etad(i)=p*p/2.0_dp*(p*p+2.0_dp*z*z)
      END IF
10    CONTINUE
!
! Now, using equation (33):
!
      muo1=1.0_dp-((1.0_dp-u1-2.0_dp*u2)*lambdae(i)+(u1+2.0_dp*u2)*  &
         lambdad(i)+u2*etad(i))/omega
!
! Equation 25:
!
      mu0=1.0_dp-lambdae(i)
   END DO
   RETURN
!
END SUBROUTINE occultquad
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE oldgrkaad(n,nstep,x,y,meth,iout,rpar,  &
   rmass,nbody,posarray,velarray,odetime,zzq,timeinterp,ndyn,h,  &
   igr,tideparm,isw80)
!
! from Ernst Hairer
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(IN)                      :: n
   INTEGER, INTENT(IN)                      :: nstep
   REAL(KIND=dp), INTENT(IN OUT)            :: x
   REAL(KIND=dp), INTENT(IN OUT)            :: y(n)
   INTEGER, INTENT(IN)                      :: meth(10)
   INTEGER, INTENT(IN)                      :: iout
   REAL(KIND=dp), INTENT(IN)                :: rpar(10)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(OUT)               :: posarray(2,30)
   REAL(KIND=dp), INTENT(OUT)               :: velarray(2,30)
   REAL(KIND=dp), INTENT(OUT)               :: odetime(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: zzq(6,60,2)
   REAL(KIND=dp), INTENT(OUT)               :: timeinterp(6)
   REAL(KIND=dp), INTENT(IN)                :: h
   INTEGER, INTENT(IN)                      :: igr
   REAL(KIND=dp), INTENT(IN)                :: tideparm(20)
   INTEGER, INTENT(IN)                      :: isw80
!
   INTEGER, PARAMETER :: ndgl=50
   INTEGER, PARAMETER :: nsd=15
!
   REAL(KIND=dp), DIMENSION(nsd)       ::   c,b,bp
   REAL(KIND=dp), DIMENSION(nsd,nsd)   ::   a,ap
   REAL(KIND=dp), DIMENSION(ndgl)      ::   ycs
   REAL(KIND=dp), DIMENSION(ndgl*nsd)  ::   f,z

   REAL(KIND=dp)  :: dyno,dymin,ffs,yyi,eps,suma,sume,ff,temp,ycsi,yi
!
   INTEGER :: ns,nss,icos,itsw
   INTEGER :: jj,i,istep,is,ii,iter,isn,isym
!
!   old dimensions
!
!          DIMENSION zzq(6,60,Ndyn)
!
!          EXTERNAL FCN
!
   ns=meth(1)
   nss=ns*n
   icos=meth(2)
   itsw=meth(3)
   isym=meth(4)
   IF(icos /= 0)WRITE(6,*)' METH(2) = ',icos,' NOT ALLOWED'
   IF(isym /= 0)WRITE(6,*)' METH(4) = ',isym,' NOT ALLOWED'
   CALL gauspd(ns,c,b,bp,nsd,a,ap)
!
   DO jj=1,6
      timeinterp(jj)=c(jj)*h
   END DO
!
   IF(iout /= 0)CALL solfid(0,x,y,n,rmass,nbody)
   DO i=1,n
      ycs(i)=0.0_dp
   END DO
!
   DO istep=1,nstep
      CALL dequa(n,y,f,igr,rmass,nbody,tideparm,isw80)
      DO i=1,n
         ffs=h*f(i)
         yyi=y(i)
         DO is=1,6
            z(i+(is-1)*n)=yyi+c(is)*ffs
         END DO
      END DO
      odetime(istep)=x
      IF(istep < 2)THEN
         DO ii=1,n/2
            posarray(istep,ii)=y(ii)
            velarray(istep,ii)=y(ii+n/2)
         END DO
      END IF
!
      dymin=100.0_dp
      dyno=10.0_dp
      iter=0
      eps=rpar(1)
      IF(itsw == 0)THEN
         DO WHILE((dyno < dymin).AND.(ABS(dyno) > EPSILON(dyno)))
            dymin=MIN(dymin,dyno)
            CALL itaad(n,ns,y,nsd,a,ap,ndgl,f,z,h,  &
               dyno,igr,rmass,nbody,tideparm,isw80)
         END DO
      ELSE
         DO WHILE(dyno > eps.AND.iter <= 50)
            iter=iter+1
            CALL itaad(n,ns,y,nsd,a,ap,ndgl,f,z,h,  &
               dyno,igr,rmass,nbody,tideparm,isw80)
         END DO
         IF(iter >= 49)WRITE(6,*)' no convergence',iter,dyno
         DO is=1,ns
            isn=1+(is-1)*n
            CALL dequa(n,z(isn),f(isn),igr,rmass,nbody,tideparm,isw80)
         END DO
      END IF
!
      x=x+h
      DO i=1,n
         suma=0.0_dp
         sume=0.0_dp
         DO is=1,ns/2
            ff=f(i+(is-1)*n)+f(i+(ns-is)*n)
            suma=suma+b(is)*ff
            sume=sume+bp(is)*ff
         END DO
         IF(2*(ns/2) /= ns)THEN
            is=1+ns/2
            ff=f(i+(is-1)*n)
            suma=suma+b(is)*ff
            sume=sume+bp(is)*ff
         END IF
         temp=y(i)
         ycsi=ycs(i)+h*suma
         yi=temp+ycsi
         ycsi=ycsi+(temp-yi)
         ycsi=ycsi+h*sume
         y(i)=yi+ycsi
         ycs(i)=ycsi+(yi-y(i))
!
         DO is=1,6
            IF(istep <= 2)THEN
               IF(i <= n/2)zzq(is,i,istep)=z(i+(is-1)*n)
            END IF
         END DO
      END DO
      IF(iout /= 0)CALL solfid(istep,x,y,n,rmass,nbody)
   END DO
!
   RETURN
!
END SUBROUTINE oldgrkaad
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE overlaphoriz(nhoriz1,xhoriz1,yhoriz1,nhoriz2,  &
   xhoriz2,yhoriz2,ioverlap)
!
!   UPDATE May 26, 2004
!
!   This routine will take the horizons for star 1 and star 2 and
!   see if there is an overlap on the sky.  If so, then ioverlap=999
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nhoriz1
   REAL(KIND=dp), INTENT(IN)                :: xhoriz1(nhoriz1)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz1(nhoriz1)
   INTEGER, INTENT(IN)                      :: nhoriz2
   REAL(KIND=dp), INTENT(IN)                :: xhoriz2(nhoriz2)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz2(nhoriz2)
   INTEGER, INTENT(OUT)                     :: ioverlap
!
   REAL(KIND=dp)  :: xp,yp
!
   INTEGER :: i,iyes,icut
!
   DO  i=1,nhoriz1
      iyes=-1
      xp=xhoriz1(i)
      yp=yhoriz1(i)
      CALL insidecircle(nhoriz2,xhoriz2,yhoriz2,xp,yp,iyes,icut)
      IF(iyes == 100)ioverlap=999
   END DO
!
   DO  i=1,nhoriz2
      iyes=-1
      xp=xhoriz2(i)
      yp=yhoriz2(i)
      CALL insidecircle(nhoriz1,xhoriz1,yhoriz1,xp,yp,iyes,icut)
      IF(iyes == 100)ioverlap=999
   END DO
!
   RETURN
!
END SUBROUTINE overlaphoriz
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE parms(iunit,teff2,q,finc,separ,period,reff1,reff2,  &
   vrot1,vrot2,gscale1,gscale2,omega1,omega2,ecc,ioutflag,  &
   rmass,rrad,rrau,rm1,rm2,r1,r2,isw30,obsparm)
!
!   November 30, 1999
!
!   This routine will compute the component masses, radii, etc. based
!   on the mass ratio, inclination, orbital separation, and orbital period.
!   Set iunit=1 to print to the output file, or 0 to print to screen.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: iunit
   REAL(KIND=dp), INTENT(IN)                :: teff2
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: reff1
   REAL(KIND=dp), INTENT(IN)                :: reff2
   REAL(KIND=dp), INTENT(OUT)               :: vrot1
   REAL(KIND=dp), INTENT(OUT)               :: vrot2
   REAL(KIND=dp), INTENT(OUT)               :: gscale1
   REAL(KIND=dp), INTENT(OUT)               :: gscale2
   REAL(KIND=dp), INTENT(IN)                :: omega1
   REAL(KIND=dp), INTENT(IN)                :: omega2
   REAL(KIND=dp), INTENT(IN)                :: ecc
   INTEGER, INTENT(IN)                      :: ioutflag
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: rrad(10)
   REAL(KIND=dp), INTENT(IN)                :: rrau(10)
   REAL(KIND=dp), INTENT(OUT)               :: rm1
   REAL(KIND=dp), INTENT(OUT)               :: rm2
   REAL(KIND=dp), INTENT(OUT)               :: r1
   REAL(KIND=dp), INTENT(OUT)               :: r2
   INTEGER, INTENT(IN)                      :: isw30
   REAL(KIND=dp), INTENT(OUT)               :: obsparm(25)
!
   REAL(KIND=dp)  :: den,volume,fincr,ppp,sifinc,total_mass,p,fact,efact,hutfac
   REAL(KIND=dp)  :: a2,a1,gpole1,gpole2,velk1,velk2,ttt
!
   INTEGER :: ilength1,ilength2,ilength3,ilength4
!
   CHARACTER (LEN=40) :: instring1,instring2,instring3,instring4
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   fourthirdspie=4.0_dp/3.0_dp*pie
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   fincr=finc*degtorad!pie/180.0d0
   ppp=period*24.0_dp
   sifinc=SIN(fincr)
!
!   Use the formula separ = coef*(perid*period*total_mass)**(1/3) to
!   solve for the total mass in solar masses.  The separation is
!   entered in solar masses, so (R_sun/coef)**3=7.737294491.
!
   total_mass=(separ)**(3)*coeff/(ppp*ppp)
!
   rm1=total_mass/(1.0_dp+q)
   rm2=q*rm1
!
!   Use the value of GM_sun found from the solar system.
!
   p=period*secinday!86400.0d0
   rm1=(separ*solarrad)**(3)*4.0_dp*pie*pie
   rm1=rm1/(gmsun*p*p*(1.0_dp+q))
   rm2=q*rm1
!
   r1=reff1*separ
   IF(teff2 > 0.0_dp)THEN
      r2=reff2*separ
   ELSE
      r2=0.00_dp
   END IF
!
   gpole1=gsun*rm1/(r1*r1)
   IF(teff2 > 0.0_dp)THEN
      gpole2=gsun*rm2/(r2*r2)
   ELSE
      gpole2=1.0_dp
   END IF
!
   gscale1=gsun*rm1/(separ*separ)
   gscale2=gsun*rm2/(separ*separ)
!
   fact=solarrad*twopie/86400.0_dp/1.0E+03_dp
!
   vrot1=fact*r1/period*sifinc
   vrot2=fact*r2/period*sifinc
!
!   UPDATE MARCH 4, 2005
!
!   Was (separ/(1.0d0+Q))*bdist)
!
   a2=(separ/(1.0_dp+q))
   a1=separ-a2
!
!   April 20, 2001
!
!   Change efact below
!
!           efact=1.0d0/dsqrt(1.0-ecc*ecc)
!
   efact=1.0_dp/SQRT(1.0_dp-ecc*ecc)
   velk1=fact*a1/period*sifinc*efact
   velk2=fact*a2/period*sifinc*efact
!
!   August 10, 2001
!
!   Add a correction factor to the rotational velocities in the
!   case of eccentric orbits.
!
   hutfac=(1.0_dp+7.5_dp*ecc*ecc+5.625_dp*ecc**4+0.3125_dp*ecc**6)/  &
      ((1.0_dp+3.0_dp*ecc*ecc+3.0_dp/8.0_dp*ecc**4)*SQRT((1.0_dp-ecc*ecc)**3))
!
   IF(ioutflag == 1)THEN
!
      CALL pspacestring('M1',5,rm1,instring1,ilength1)
      CALL pspacestring('R1',5,r1,instring2,ilength2)
      CALL pspacestring('log(g1)',4,LOG10(gpole1),instring3,ilength3)
      IF(iunit >= 1)WRITE(2,20)TRIM(instring1),TRIM(instring2),TRIM(instring3)
!
      CALL pspacestring('M2',5,rm2,instring1,ilength1)
      CALL pspacestring('R2',5,r2,instring2,ilength2)
      CALL pspacestring('log(g2)',4,LOG10(gpole2),instring3,ilength3)
      IF(iunit >= 1)WRITE(2,30)TRIM(instring1),TRIM(instring2),TRIM(instring3)
!
      CALL pspacestring('P',6,period,instring1,ilength1)
      CALL pspacestring('a1',3,a1,instring2,ilength2)
      CALL pspacestring('a2',3,a2,instring3,ilength3)
      CALL pspacestring('a',4,separ,instring4,ilength4)
      IF(iunit >= 1)WRITE(2,40)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring4)
!
      CALL pspacestring('K1',4,velk1,instring1,ilength1)
      CALL pspacestring('K2',4,velk2,instring2,ilength2)
      IF(iunit >= 1)WRITE(2,50)TRIM(instring1),TRIM(instring2)
!
      CALL pspacestring('V1_rot*sin(i)',4,vrot1*hutfac,instring1,ilength1)
      CALL pspacestring('V2_rot*sin(i)',4,vrot2*hutfac,instring2,ilength2)
      IF(iunit >= 1)WRITE(2,50)TRIM(instring1),TRIM(instring2)
!
      CALL pspacestring('V1_rot*sin(i)',4,vrot1*hutfac*omega1,instring1,ilength1)
      CALL pspacestring('V2_rot*sin(i)',4,vrot2*hutfac*omega2,instring2,ilength2)
      IF(iunit >= 1)WRITE(2,60)TRIM(instring1),TRIM(instring2)
   END IF
!
   IF(isw30 <= 2)RETURN
!
!  output to ELC.out if ioutflag > 0.  If the mass is more than 2000 Earth
!  masses, switch to solar units.
!
   obsparm(20)=rmass(3)
   obsparm(21)=rrad(3)
   IF((ioutflag == 1).AND.(rmass(3) > 0.0_dp))THEN
      IF(rmass(3) <= 0.0050_dp)THEN
         ttt=rmass(3)*earthmasstosolar
         CALL pspacestring('M3',4,ttt,instring1,ilength1)
         ttt=rrad(3)*earthradinsolar
         CALL pspacestring('R3',4,ttt,instring2,ilength2)
         volume=(fourthirdspie)*(rrad(3)*solarrad*100.0_dp)**3
         den=rmass(3)*(solarmass*1000.0_dp)/volume
         CALL pspacestring('den3',3,den,instring3,ilength3)
         CALL pspacestring('a3',5,rrau(3),instring4,ilength4)
         WRITE(2,200)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      ELSE
         CALL pspacestring('M3',4,rmass(3),instring1,ilength1)
         CALL pspacestring('R3',4,rrad(3),instring2,ilength2)
         ttt=100.0_dp*rmass(3)*solarmass*gnewton/(rrad(3)**2*solarrad**2)
         ttt=LOG10(ttt)
         CALL pspacestring('log(g3)',4,ttt,instring3,ilength3)
         CALL pspacestring('a3',5,rrau(3),instring4,ilength4)
         WRITE(2,210)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      END IF
   END IF
!
   IF(isw30 <= 3)RETURN
!
   obsparm(22)=rmass(4)
   obsparm(23)=rrad(4)
   IF((ioutflag == 1).AND.(rmass(4) > 0.0_dp))THEN
      IF(rmass(4) <= 0.0050_dp)THEN
         ttt=rmass(4)*earthmasstosolar
         CALL pspacestring('M4',4,ttt,instring1,ilength1)
         ttt=rrad(4)*earthradinsolar
         CALL pspacestring('R4',4,ttt,instring2,ilength2)
         volume=(fourthirdspie)*(rrad(4)*solarrad*100.0_dp)**3
         den=rmass(4)*(solarmass*1000.0_dp)/volume
         CALL pspacestring('den4',3,den,instring3,ilength3)
         CALL pspacestring('a4',5,rrau(4),instring4,ilength4)
         WRITE(2,200)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      ELSE
         CALL pspacestring('M4',4,rmass(4),instring1,ilength1)
         CALL pspacestring('R4',4,rrad(4),instring2,ilength2)
         ttt=100.0_dp*rmass(4)*solarmass*gnewton/(rrad(4)**2*solarrad**2)
         ttt=LOG10(ttt)
         CALL pspacestring('log(g4)',4,ttt,instring3,ilength3)
         CALL pspacestring('a4',5,rrau(4),instring4,ilength4)
         WRITE(2,210)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      END IF
   END IF
!
   IF(isw30 <= 4)RETURN
!
   obsparm(24)=rmass(5)
   obsparm(25)=rrad(5)
   IF((ioutflag == 1).AND.(rmass(5) > 0.0_dp))THEN
      IF(rmass(5) <= 0.0050_dp)THEN
         ttt=rmass(5)*earthmasstosolar
         CALL pspacestring('M5',4,ttt,instring1,ilength1)
         ttt=rrad(5)*earthradinsolar
         CALL pspacestring('R5',4,ttt,instring2,ilength2)
         volume=(fourthirdspie)*(rrad(5)*solarrad*100.0_dp)**3
         den=rmass(5)*(solarmass*1000.0_dp)/volume
         CALL pspacestring('den5',3,den,instring3,ilength3)
         CALL pspacestring('a5',5,rrau(5),instring4,ilength4)
         WRITE(2,200)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      ELSE
         CALL pspacestring('M5',4,rmass(5),instring1,ilength1)
         CALL pspacestring('R5',4,rrad(5),instring2,ilength2)
         ttt=100.0_dp*rmass(5)*solarmass*gnewton/(rrad(5)**2*solarrad**2)
         ttt=LOG10(ttt)
         CALL pspacestring('log(g5)',4,ttt,instring3,ilength3)
         CALL pspacestring('a5',5,rrau(5),instring4,ilength4)
         WRITE(2,210)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      END IF
   END IF
!
   IF(isw30 <= 5)RETURN
!
   IF((ioutflag == 1).AND.(rmass(6) > 0.0_dp))THEN
      IF(rmass(6) <= 0.0050_dp)THEN
         ttt=rmass(6)*earthmasstosolar
         CALL pspacestring('M6',4,ttt,instring1,ilength1)
         ttt=rrad(6)*earthradinsolar
         CALL pspacestring('R6',4,ttt,instring2,ilength2)
         volume=(fourthirdspie)*(rrad(6)*solarrad*100.0_dp)**3
         den=rmass(6)*(solarmass*1000.0_dp)/volume
         CALL pspacestring('den6',3,den,instring3,ilength3)
         CALL pspacestring('a6',5,rrau(6),instring4,ilength4)
         WRITE(2,200)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      ELSE
         CALL pspacestring('M6',4,rmass(6),instring1,ilength1)
         CALL pspacestring('R6',4,rrad(6),instring2,ilength2)
         ttt=100.0_dp*rmass(6)*solarmass*gnewton/(rrad(6)**2*solarrad**2)
         ttt=LOG10(ttt)
         CALL pspacestring('log(g6)',4,ttt,instring3,ilength3)
         CALL pspacestring('a6',5,rrau(6),instring4,ilength4)
         WRITE(2,210)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      END IF
   END IF
!
   IF(isw30 <= 6)RETURN
!
   IF((ioutflag == 1).AND.(rmass(7) > 0.0_dp))THEN
      IF(rmass(7) <= 0.0050_dp)THEN
         ttt=rmass(7)*earthmasstosolar
         CALL pspacestring('M7',4,ttt,instring1,ilength1)
         ttt=rrad(7)*earthradinsolar
         CALL pspacestring('R7',4,ttt,instring2,ilength2)
         volume=(fourthirdspie)*(rrad(7)*solarrad*100.0_dp)**3
         den=rmass(7)*(solarmass*1000.0_dp)/volume
         CALL pspacestring('den7',3,den,instring3,ilength3)
         CALL pspacestring('a7',5,rrau(7),instring4,ilength4)
         WRITE(2,200)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      ELSE
         CALL pspacestring('M7',4,rmass(7),instring1,ilength1)
         CALL pspacestring('R7',4,rrad(7),instring2,ilength2)
         ttt=100.0_dp*rmass(7)*solarmass*gnewton/(rrad(7)**2*solarrad**2)
         ttt=LOG10(ttt)
         CALL pspacestring('log(g7)',4,ttt,instring3,ilength3)
         CALL pspacestring('a7',5,rrau(7),instring4,ilength4)
         WRITE(2,210)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      END IF
   END IF
!
   IF(isw30 <= 7)RETURN
!
   IF((ioutflag == 1).AND.(rmass(8) > 0.0_dp))THEN
      IF(rmass(8) <= 0.0050_dp)THEN
         ttt=rmass(8)*earthmasstosolar
         CALL pspacestring('M8',4,ttt,instring1,ilength1)
         ttt=rrad(8)*earthradinsolar
         CALL pspacestring('R8',4,ttt,instring2,ilength2)
         volume=(fourthirdspie)*(rrad(8)*solarrad*100.0_dp)**3
         den=rmass(8)*(solarmass*1000.0_dp)/volume
         CALL pspacestring('den8',3,den,instring3,ilength3)
         CALL pspacestring('a8',5,rrau(8),instring4,ilength4)
         WRITE(2,200)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      ELSE
         CALL pspacestring('M8',4,rmass(8),instring1,ilength1)
         CALL pspacestring('R8',4,rrad(8),instring2,ilength2)
         ttt=100.0_dp*rmass(8)*solarmass*gnewton/(rrad(8)**2*solarrad**2)
         ttt=LOG10(ttt)
         CALL pspacestring('log(g8)',4,ttt,instring3,ilength3)
         CALL pspacestring('a8',5,rrau(8),instring4,ilength4)
         WRITE(2,210)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      END IF
   END IF
!
   IF(isw30 <= 8)RETURN
!
   IF((ioutflag == 1).AND.(rmass(9) > 0.0_dp))THEN
      IF(rmass(9) <= 0.0050_dp)THEN
         ttt=rmass(9)*earthmasstosolar
         CALL pspacestring('M9',4,ttt,instring1,ilength1)
         ttt=rrad(9)*earthradinsolar
         CALL pspacestring('R9',4,ttt,instring2,ilength2)
         volume=(fourthirdspie)*(rrad(9)*solarrad*100.0_dp)**3
         den=rmass(9)*(solarmass*1000.0_dp)/volume
         CALL pspacestring('den9',3,den,instring3,ilength3)
         CALL pspacestring('a9',5,rrau(9),instring4,ilength4)
         WRITE(2,200)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      ELSE
         CALL pspacestring('M9',4,rmass(9),instring1,ilength1)
         CALL pspacestring('R9',4,rrad(9),instring2,ilength2)
         ttt=100.0_dp*rmass(9)*solarmass*gnewton/(rrad(9)**2*solarrad**2)
         ttt=LOG10(ttt)
         CALL pspacestring('log(g9)',4,ttt,instring3,ilength3)
         CALL pspacestring('a9',5,rrau(9),instring4,ilength4)
         WRITE(2,210)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      END IF
   END IF
!
   IF(isw30 <= 9)RETURN
!
   IF((ioutflag == 1).AND.(rmass(10) > 0.0_dp))THEN
      IF(rmass(10) <= 0.0050_dp)THEN
         ttt=rmass(10)*earthmasstosolar
         CALL pspacestring('M10',4,ttt,instring1,ilength1)
         ttt=rrad(10)*earthradinsolar
         CALL pspacestring('R10',4,ttt,instring2,ilength2)
         volume=(fourthirdspie)*(rrad(10)*solarrad*100.0_dp)**3
         den=rmass(10)*(solarmass*1000.0_dp)/volume
         CALL pspacestring('den10',3,den,instring3,ilength3)
         CALL pspacestring('a10',5,rrau(10),instring4,ilength4)
         WRITE(2,200)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      ELSE
         CALL pspacestring('M10',4,rmass(10),instring1,ilength1)
         CALL pspacestring('R10',4,rrad(10),instring2,ilength2)
         ttt=100.0_dp*rmass(10)*solarmass*gnewton/(rrad(10)**2*solarrad**2)
         ttt=LOG10(ttt)
         CALL pspacestring('log(g10)',4,ttt,instring3,ilength3)
         CALL pspacestring('a10',5,rrau(10),instring4,ilength4)
         WRITE(2,210)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3),TRIM(instring4)
      END IF
   END IF
!
   RETURN
!
20 FORMAT(/a,1X,'M_sun;',1X,a,1X,'R_sun;',1X,a,1X,'cgs')
30 FORMAT(a,1X,'M_sun;',1X,a,1X,'R_sun;',1X,a,1X,'cgs')
40 FORMAT(a,1X,'d;',1X,a,1X,'R_sun;',1X,a,1X,'R_sun;',1X, a,1X,'R_sun')
50 FORMAT(a,1X,'km/sec;',1X,a,1X,'km/sec')
60 FORMAT(a,1X,'km/sec;',1X,a,1X,'km/sec (scaled by omegas)')
200 FORMAT(a,1X,'M_Earth;',1X,a,1X,'R_earth;',1X,a,1X,'g/cc;',1X,  &
      a,1X,'AU')
210 FORMAT(a,1X,'M_sun;',1X,a,1X,'R_sun;',1X,a,1X,'cgs;',1X, a,1X,'AU')
!
END SUBROUTINE parms
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE parms1(teff2,q,finc,separ,period,reff1,reff2,  &
   gpole1,gpole2,vrot1,vrot2,gscale1,gscale2,omega1,omega2,  &
   obsparm,bdist,ecc,argper,teff1,ioutflag)
!
!   April 26, 2000
!
!   This routine will compute the component masses, radii, etc. based
!   on the mass ratio, inclination, orbital separation, and orbital period.
!   These values will be written to ELC.parm (unit=3)
!
!   July 24, 2000
!
!   Add the array obsparm to the argument list.  This contains the
!   computed physical parameters of stars 1 and 2
!
!   UPDATE September 21, 2008
!
!   Add K_1 and K_2 to the list
!
!   obsparm(1) = mass of star 1      (solar)
!   obsparm(2) = radius of star 1    (solar)
!   obsparm(3) = gravity of star 1   (log cgs)
!   obsparm(4) = V_rot*sin(i) star 1 (km/sec)
!   obsparm(5) = mass of star 2      (solar)
!   obsparm(6) = radius of star 2    (solar)
!   obsparm(7) = gravity of star 2   (log cgs)
!   obsparm(8) = V_rot*sin(i) star 2 (km/sec)
!   obsparm(9) = duration of X-ray eclipse (degrees)
!   obsparm(10) = K_1 (km/sec)
!   obsparm(11) = K_2 (km/sec)
!   obsparm(13) = Q
!   obsparm(14) = ecc
!   obsparm(15) = argper
!   obsparm(16) = teff1
!   obsparm(17) = teff2
!   obsparm(18) = (R1+R2)/separ
!   obsparm(19) = Teff3 (t3)
!   obsparm(20) = mass of star 3      (solar)
!   obsparm(21) = radius of star 3    (solar)
!   obsparm(22) = mass of star 4      (solar)
!   obsparm(23) = radius of star 4    (solar)
!   obsparm(24) = mass of star 5      (solar)
!   obsparm(25) = radius of star 5    (solar)
!
!   UPDATE September 11, 2001
!
!   Change the dimemsion of obsparm to 9.  The X-ray eclipse duration
!   (in degrees) will be stored there
!
!   UPDATE September 21, 2008
!
!   Make the dimension of obsparm 11
!
!   UPDATE October 10, 2008
!
!   Add finc, Q, ecc, argper, teff1, teff2 to the list in obsparm
!
!   UPDATE March 15, 2011
!
!   make the dimension of obsparm 18 (add sum of fractional radii)
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: teff2
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: reff1
   REAL(KIND=dp), INTENT(IN)                :: reff2
   REAL(KIND=dp), INTENT(OUT)               :: gpole1
   REAL(KIND=dp), INTENT(OUT)               :: gpole2
   REAL(KIND=dp), INTENT(OUT)               :: vrot1
   REAL(KIND=dp), INTENT(OUT)               :: vrot2
   REAL(KIND=dp), INTENT(OUT)               :: gscale1
   REAL(KIND=dp), INTENT(OUT)               :: gscale2
   REAL(KIND=dp), INTENT(IN)                :: omega1
   REAL(KIND=dp), INTENT(IN)                :: omega2
   REAL(KIND=dp), INTENT(OUT)               :: obsparm(25)
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: argper
   REAL(KIND=dp), INTENT(IN)                :: teff1
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp)  :: velk2,ppp,sifinc,velk1,fpsq,fincr
   REAL(KIND=dp)  :: total_mass,smet,rm1,rm2,r1,r2,fact,a1,a2,efact,hutfac
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmassinsolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   fpsq=4.0_dp*pie*pie
   fincr=finc*degtorad
   ppp=period*24.0_dp
   sifinc=SIN(fincr)
!
!   Use the formula separ = coef*(perid*period*total_mass)**(1/3) to
!   solve for the total mass in solar masses.  The separation is
!   entered in solar masses, so (R_sun/coef)**3=7.737294491.
!
   total_mass=(separ)**(3)*coeff/(ppp*ppp)
   smet=separ*solarrad
   total_mass=smet*smet*smet*fpsq/(period*secinday)**2/gmsun
!
   rm1=total_mass/(1.0_dp+q)
   rm2=q*rm1
!
   r1=reff1*separ
   IF(teff2 > 0.0_dp)THEN
      r2=reff2*separ
   ELSE
      r2=0.00_dp
   END IF
!
   gpole1=gsun*rm1/(r1*r1)
   IF(teff2 > 0.0_dp)THEN
      gpole2=gsun*rm2/(r2*r2)
   ELSE
      gpole2=1.0_dp
   END IF
!
   gscale1=gsun*rm1/(separ*separ)
   gscale2=gsun*rm2/(separ*separ)
!
   fact=solarrad*twopie/secinday/1.0E+03_dp
   vrot1=fact*r1/period*sifinc
   vrot2=fact*r2/period*sifinc
!
!   UPDATE MARCH 4, 2005
!
!   change a2 and a1 below
!
   a2=separ/(1.0_dp+q)*bdist
   a1=separ*(1.0_dp-bdist/(1.0_dp+q))
!
   a2=separ/(1.0_dp+q)
   a1=separ-a2
   efact=1.0_dp/SQRT(1.0_dp-ecc*ecc)
   velk1=fact*a1/period*sifinc*efact
   velk2=fact*a2/period*sifinc*efact
!
!   Add a correction factor to the rotational velocities in the
!   case of eccentric orbits.
!
   hutfac=(1.0_dp+7.5_dp*ecc*ecc+5.625_dp*ecc**4+0.3125_dp*ecc**6)/  &
      ((1.0_dp+3.0_dp*ecc*ecc+3.0_dp/8.0_dp*ecc**4)*SQRT((1.0_dp-ecc*ecc)**3))
!
   obsparm(1)=rm1
   obsparm(5)=rm2
   obsparm(2)=r1
   obsparm(6)=r2
   obsparm(3)=LOG10(gpole1)
   obsparm(7)=LOG10(gpole2)
   obsparm(4)=vrot1*omega1*hutfac
   obsparm(8)=vrot2*omega2*hutfac
!
!   UPDATE September 21, 2008
!
!   Add the K-velocities to obsparm
!
   obsparm(10)=velk1
   obsparm(11)=velk2
   obsparm(12)=finc
   obsparm(13)=q
   obsparm(14)=ecc
   obsparm(15)=argper
   obsparm(16)=teff1
   obsparm(17)=teff2
!
!   UPDATE March 15, 2011
!
!   Add sum of fractional radii to index 18
!
   obsparm(18)=(r1+r2)/separ
!
!   UPDATE September 11, 2001
!
!   initialize obsparm(9)
!
!           obsparm(9)=0.0d0
!
   IF(ioutflag == 1)THEN
      WRITE(3,10)rm1
      WRITE(3,20)rm2
      WRITE(3,30)r1
      WRITE(3,40)r2
      WRITE(3,50)LOG10(gpole1)
      WRITE(3,60)LOG10(gpole2)
      WRITE(3,70)a1
      WRITE(3,80)a2
      WRITE(3,90)separ
      WRITE(3,100)velk1
      WRITE(3,110)velk2
      WRITE(3,120)vrot1
      WRITE(3,130)vrot2
      WRITE(3,140)vrot1*omega1*hutfac
      WRITE(3,150)vrot2*omega2*hutfac
   END IF
!
   IF(ioutflag == 1)CLOSE(3)
!
   RETURN
!
10 FORMAT(f15.10,10X,'mass of star 1 in solar masses')
20 FORMAT(f15.10,10X,'mass of star 2 in solar masses')
30 FORMAT(f15.10,10X,'radius of star 1 in solar radii')
40 FORMAT(f15.10,10X,'radius of star 2 in solar radii')
50 FORMAT(f9.6,16X,'log(g) of star 1, cgs')
60 FORMAT(f9.6,16X,'log(g) of star 2, cgs')
70 FORMAT(f11.5,14X,'a1 (solar radii)')
80 FORMAT(f11.5,14X,'a2 (solar radii)')
90 FORMAT(f15.10,10X,'a (solar radii)')
100 FORMAT(f15.10,10X,'K_1 (km/sec)')
110 FORMAT(f15.10,10X,'K_2 (km/sec)')
120 FORMAT(f9.4,16X,'V1_rot*sin(i) (km/sec)')
130 FORMAT(f9.4,16X,'V2_rot*sin(i) (km/sec)')
140 FORMAT(f9.4,16X,'V1_rot*sin(i), scaled by omega1 (km/sec)')
150 FORMAT(f9.4,16X,'V2_rot*sin(i), scaled by omega2 (km/sec)')
!
END SUBROUTINE parms1
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE pdata(x,xend,ndim,n,q,p,qex,pex,rpar,ipar)
!
!   From Ernst Hairer
!
   USE accur
!
   IMPLICIT NONE

   REAL(KIND=dp), INTENT(OUT)               :: x
   REAL(KIND=dp), INTENT(OUT)               :: xend
   INTEGER, INTENT(IN)                      :: ndim
   INTEGER, INTENT(OUT)                     :: n
   REAL(KIND=dp), INTENT(OUT)               :: q(ndim)
   REAL(KIND=dp), INTENT(OUT)               :: p(ndim)
   REAL(KIND=dp), INTENT(OUT)               :: qex(ndim)
   REAL(KIND=dp), INTENT(OUT)               :: pex(ndim)
   REAL(KIND=dp), INTENT(IN)                :: rpar(*)
   INTEGER, INTENT(IN)                      :: ipar(*)
!
   REAL(KIND=dp) ::  pi,eccent
!
   INTEGER :: iprob
!
   iprob=ipar(11)
   IF(iprob == 1)THEN
      n=2
      pi=4.0_dp*ATAN(1.0_dp)
      eccent=rpar(11)
      x=0.0_dp
      xend=2*pi
      q(1)=1-eccent
      q(2)=0.0_dp
      p(1)=0.0_dp
      p(2)=SQRT((1+eccent)/(1-eccent))
      qex(1)=1-eccent
      qex(2)=0.0_dp
      pex(1)=0.0_dp
      pex(2)=SQRT((1+eccent)/(1-eccent))
   END IF
   IF(iprob == 2)THEN
      n=1
      pi=4.0_dp*ATAN(1.0_dp)
      x=0.0_dp
      xend=2.0_dp*pi
      q(1)=0.0_dp
      p(1)=1.0_dp
      qex(1)=0.0_dp
      pex(1)=1.0_dp
   END IF
   IF(iprob == 3)THEN
      n=1
      pi=4.0_dp*ATAN(1.0_dp)
      x=0.0_dp
      xend=2.0_dp*pi
      q(1)=0.0_dp
      p(1)=1.0_dp
      qex(1)=-0.443944662290259_dp
      pex(1)=0.897846803312944_dp
   END IF
   IF(iprob == 4)THEN
      n=18
      x=0.0_dp
      xend=500000.0_dp
      q(1)=-3.5023653_dp
      q(2)=-3.8169847_dp
      q(3)=-1.5507963_dp
      q(4)=9.0755314_dp
      q(5)=-3.0458353_dp
      q(6)=-1.6483708_dp
      q(7)=8.3101420_dp
      q(8)=-16.2901086_dp
      q(9)=-7.2521278_dp
      q(10)=11.4707666_dp
      q(11)=-25.7294829_dp
      q(12)=-10.8169456_dp
      q(13)=-15.5387357_dp
      q(14)=-25.2225594_dp
      q(15)=-3.1902382_dp
      q(16)=0.0_dp
      q(17)=0.0_dp
      q(18)=0.0_dp
      p(1)=0.00565429_dp
      p(2)=-0.00412490_dp
      p(3)=-0.00190589_dp
      p(4)=0.00168318_dp
      p(5)=0.00483525_dp
      p(6)=0.00192462_dp
      p(7)=0.00354178_dp
      p(8)=0.00137102_dp
      p(9)=0.00055029_dp
      p(10)=0.00288930_dp
      p(11)=0.00114527_dp
      p(12)=0.00039677_dp
      p(13)=0.00276725_dp
      p(14)=-0.00170702_dp
      p(15)=-0.00136504_dp
      p(16)=0.0_dp
      p(17)=0.0_dp
      p(18)=0.0_dp
      qex(1)=0.7766584086800482E+01_dp
      qex(2)=0.2531065754551048E+00_dp
      qex(3)=-0.9410571402013185E-01_dp
      qex(4)=-0.5564967162844037E+01_dp
      qex(5)=0.1674849740822012E+01_dp
      qex(6)=0.9767232069533176E+00_dp
      qex(7)=0.1963899572895227E+02_dp
      qex(8)=0.8958504552286460E+01_dp
      qex(9)=0.3611839157057347E+01_dp
      qex(10)=0.2493570870305177E+02_dp
      qex(11)=0.1769518676153705E+02_dp
      qex(12)=0.6583785164549242E+01_dp
      qex(13)=0.3178592511375764E+02_dp
      qex(14)=0.3863618958160644E+02_dp
      qex(15)=0.3192794169732889E+01_dp
      qex(16)=0.3084118473380683E+01_dp
      qex(17)=-0.1227726356581642E+01_dp
      qex(18)=-0.6162537634647217E+00_dp
      pex(1)=-0.2495503201917009E-02_dp
      pex(2)=0.6896467194473328E-02_dp
      pex(3)=0.3007950247474123E-02_dp
      pex(4)=-0.2255335935351989E-02_dp
      pex(5)=-0.4905913854771086E-02_dp
      pex(6)=-0.1938473641716708E-02_dp
      pex(7)=-0.2186170231167942E-02_dp
      pex(8)=0.2817177012110666E-02_dp
      pex(9)=0.1262882639181183E-02_dp
      pex(10)=-0.2148728705895163E-02_dp
      pex(11)=0.2128650077635786E-02_dp
      pex(12)=0.9248501411662923E-03_dp
      pex(13)=-0.1675173186229401E-02_dp
      pex(14)=0.1011833320388655E-02_dp
      pex(15)=0.8231800038576520E-03_dp
      pex(16)=0.9417379703028725E-05_dp
      pex(17)=-0.7855256238249194E-05_dp
      pex(18)=-0.3646926313230521E-05_dp
   END IF
   RETURN
!
END SUBROUTINE pdata
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE planetparms(planetparm,tref,q,finc,separ,period,  &
   reff1,reff2,ecc,sa3,tertperiod,tertt0,tertecos,tertesin,  &
   tertincl,tertomega,tertq,itconj,tertconj,p2tconj,  &
   p2period,p2t0,p2ecos,p2esin,p2incl,p2omega,p2q,p2ratrad,  &
   p3tconj,p3period,p3t0,p3ecos,p3esin,p3incl,p3omega,p3q,  &
   p3ratrad,p4tconj,p4period,p4t0,p4ecos,p4esin,p4incl,p4omega,  &
   p4q,p4ratrad,p5tconj,p5period,p5t0,p5ecos,p5esin,p5incl,  &
   p5omega,p5q,p5ratrad,p6tconj,p6period,p6t0,p6ecos,p6esin,  &
   p6incl,p6omega,p6q,p6ratrad,p7tconj,p7period,p7t0,p7ecos,  &
   p7esin,p7incl,p7omega,p7q,p7ratrad,p8tconj,p8period,p8t0,  &
   p8ecos,p8esin,p8incl,p8omega,p8q,p8ratrad,argper,t0,tconj,  &
   isw28,it1,rrad,rrau)
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   CHARACTER (LEN=3000), INTENT(OUT)        :: planetparm
   REAL(KIND=dp), INTENT(IN)                :: tref
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: reff1
   REAL(KIND=dp), INTENT(IN)                :: reff2
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: sa3
   REAL(KIND=dp), INTENT(IN)                :: tertperiod
   REAL(KIND=dp), INTENT(IN)                :: tertt0
   REAL(KIND=dp), INTENT(IN)                :: tertecos
   REAL(KIND=dp), INTENT(IN)                :: tertesin
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertomega
   REAL(KIND=dp), INTENT(IN)                :: tertq
   INTEGER, INTENT(IN)                      :: itconj
   REAL(KIND=dp), INTENT(IN OUT)            :: tertconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p2tconj
   REAL(KIND=dp), INTENT(IN)                :: p2period
   REAL(KIND=dp), INTENT(IN)                :: p2t0
   REAL(KIND=dp), INTENT(IN)                :: p2ecos
   REAL(KIND=dp), INTENT(IN)                :: p2esin
   REAL(KIND=dp), INTENT(IN)                :: p2incl
   REAL(KIND=dp), INTENT(IN)                :: p2omega
   REAL(KIND=dp), INTENT(IN)                :: p2q
   REAL(KIND=dp), INTENT(IN)                :: p2ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p3tconj
   REAL(KIND=dp), INTENT(IN)                :: p3period
   REAL(KIND=dp), INTENT(IN)                :: p3t0
   REAL(KIND=dp), INTENT(IN)                :: p3ecos
   REAL(KIND=dp), INTENT(IN)                :: p3esin
   REAL(KIND=dp), INTENT(IN)                :: p3incl
   REAL(KIND=dp), INTENT(IN)                :: p3omega
   REAL(KIND=dp), INTENT(IN)                :: p3q
   REAL(KIND=dp), INTENT(IN)                :: p3ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p4tconj
   REAL(KIND=dp), INTENT(IN)                :: p4period
   REAL(KIND=dp), INTENT(IN)                :: p4t0
   REAL(KIND=dp), INTENT(IN)                :: p4ecos
   REAL(KIND=dp), INTENT(IN)                :: p4esin
   REAL(KIND=dp), INTENT(IN)                :: p4incl
   REAL(KIND=dp), INTENT(IN)                :: p4omega
   REAL(KIND=dp), INTENT(IN)                :: p4q
   REAL(KIND=dp), INTENT(IN)                :: p4ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p5tconj
   REAL(KIND=dp), INTENT(IN)                :: p5period
   REAL(KIND=dp), INTENT(IN)                :: p5t0
   REAL(KIND=dp), INTENT(IN)                :: p5ecos
   REAL(KIND=dp), INTENT(IN)                :: p5esin
   REAL(KIND=dp), INTENT(IN)                :: p5incl
   REAL(KIND=dp), INTENT(IN)                :: p5omega
   REAL(KIND=dp), INTENT(IN)                :: p5q
   REAL(KIND=dp), INTENT(IN)                :: p5ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p6tconj
   REAL(KIND=dp), INTENT(IN)                :: p6period
   REAL(KIND=dp), INTENT(IN)                :: p6t0
   REAL(KIND=dp), INTENT(IN)                :: p6ecos
   REAL(KIND=dp), INTENT(IN)                :: p6esin
   REAL(KIND=dp), INTENT(IN)                :: p6incl
   REAL(KIND=dp), INTENT(IN)                :: p6omega
   REAL(KIND=dp), INTENT(IN)                :: p6q
   REAL(KIND=dp), INTENT(IN)                :: p6ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p7tconj
   REAL(KIND=dp), INTENT(IN)                :: p7period
   REAL(KIND=dp), INTENT(IN)                :: p7t0
   REAL(KIND=dp), INTENT(IN)                :: p7ecos
   REAL(KIND=dp), INTENT(IN)                :: p7esin
   REAL(KIND=dp), INTENT(IN)                :: p7incl
   REAL(KIND=dp), INTENT(IN)                :: p7omega
   REAL(KIND=dp), INTENT(IN)                :: p7q
   REAL(KIND=dp), INTENT(IN)                :: p7ratrad
   REAL(KIND=dp), INTENT(IN OUT)            :: p8tconj
   REAL(KIND=dp), INTENT(IN)                :: p8period
   REAL(KIND=dp), INTENT(IN)                :: p8t0
   REAL(KIND=dp), INTENT(IN)                :: p8ecos
   REAL(KIND=dp), INTENT(IN)                :: p8esin
   REAL(KIND=dp), INTENT(IN)                :: p8incl
   REAL(KIND=dp), INTENT(IN)                :: p8omega
   REAL(KIND=dp), INTENT(IN)                :: p8q
   REAL(KIND=dp), INTENT(IN)                :: p8ratrad
   REAL(KIND=dp), INTENT(IN)                :: argper
   REAL(KIND=dp), INTENT(IN OUT)            :: t0
   REAL(KIND=dp), INTENT(IN OUT)            :: tconj
   INTEGER, INTENT(IN)                      :: isw28
   INTEGER, INTENT(IN)                      :: it1
   REAL(KIND=dp), INTENT(OUT)               :: rrad(10)
   REAL(KIND=dp), INTENT(OUT)               :: rrau(10)
!
   REAL(KIND=dp)  :: tconj2,tperi1,arg8
   REAL(KIND=dp)  :: p8conj,p7conj,p6conj,p5conj,p4conj,p3conj,p2conj
   REAL(KIND=dp)  :: fincr,p,ppp,total_mass,rm1,rm2,r1,r2,volume
   REAL(KIND=dp)  :: den,term1,term2,term3,ttt,aueb,dummy,totalmass,tt1,tt2
   REAL(KIND=dp)  :: rimpacteb,durationeb,planetm1,planetr1,den1,au1,ecc1
   REAL(KIND=dp)  :: arg1,rinc1,omega1,p1tconj,t0_1,rmutual1,rimpact1
   REAL(KIND=dp)  :: duration1,planetm2,planetr2,den2,au2,ecc2,arg2,rinc2
   REAL(KIND=dp)  :: omega2,t0_2,rmutual2,rimpact2,duration2,planetm3,arg4
   REAL(KIND=dp)  :: planetr3,den3,au3,ecc3,arg3,rinc3,omega3,t0_3,rmutual3
   REAL(KIND=dp)  :: rimpact3,duration3,planetm4,planetr4,den4,au4,ecc4
   REAL(KIND=dp)  :: rinc4,omega4,t0_4,rmutual4,rimpact4,duration4,planetm5
   REAL(KIND=dp)  :: planetr5,den5,au5,ecc5,arg5,rinc5,omega5,t0_5,rmutual5
   REAL(KIND=dp)  :: rimpact5,duration5,planetm6,planetr6,den6,au6,ecc6
   REAL(KIND=dp)  :: rinc6,omega6,t0_6,rmutual6,rimpact6,duration6,planetm7
   REAL(KIND=dp)  :: planetr7,den7,au7,ecc7,arg7,rinc7,omega7,t0_7,rmutual7
   REAL(KIND=dp)  :: rimpact7,duration7,planetm8,planetr8,den8,au8,ecc8
   REAL(KIND=dp)  :: rinc8,omega8,t0_8,rmutual8,rimpact8,duration8,arg6
!
   INTEGER :: i
!
   CHARACTER(LEN=100) :: string1
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   fourpisquared=4.0_dp*pie*pie
!   fourthirdspie=4.0_dp/3.0_dp*pie
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   tconj2=0.0_dp
   tperi1=0.0_dp
   arg8=0.0_dp
   fincr=0.0_dp
   p=0.0_dp
   ppp=0.0_dp
   total_mass=0.0_dp
   rm1=0.0_dp
   rm2=0.0_dp
   r1=0.0_dp
   r2=0.0_dp
   volume=0.0_dp
   den=0.0_dp
   term1=0.0_dp
   term2=0.0_dp
   term3=0.0_dp
   ttt=0.0_dp
   aueb=0.0_dp
   dummy=0.0_dp
   totalmass=0.0_dp
   tt1=0.0_dp
   tt2=0.0_dp
   rimpacteb=0.0_dp
   durationeb=0.0_dp
   planetm1=0.0_dp
   planetr1=0.0_dp
   den1=0.0_dp
   au1=0.0_dp
   ecc1=0.0_dp
   arg1=0.0_dp
   rinc1=0.0_dp
   omega1=0.0_dp
   p1tconj=0.0_dp
   t0_1=0.0_dp
   rmutual1=0.0_dp
   rimpact1=0.0_dp
   duration1=0.0_dp
   planetm2=0.0_dp
   planetr2=0.0_dp
   den2=0.0_dp
   au2=0.0_dp
   ecc2=0.0_dp
   arg2=0.0_dp
   rinc2=0.0_dp
   omega2=0.0_dp
   t0_2=0.0_dp
   rmutual2=0.0_dp
   rimpact2=0.0_dp
   duration2=0.0_dp
   planetm3=0.0_dp
   arg4=0.0_dp
   planetr3=0.0_dp
   den3=0.0_dp
   au3=0.0_dp
   ecc3=0.0_dp
   arg3=0.0_dp
   rinc3=0.0_dp
   omega3=0.0_dp
   t0_3=0.0_dp
   rmutual3=0.0_dp
   rimpact3=0.0_dp
   duration3=0.0_dp
   planetm4=0.0_dp
   planetr4=0.0_dp
   den4=0.0_dp
   au4=0.0_dp
   ecc4=0.0_dp
   rinc4=0.0_dp
   omega4=0.0_dp
   t0_4=0.0_dp
   rmutual4=0.0_dp
   rimpact4=0.0_dp
   duration4=0.0_dp
   planetm5=0.0_dp
   planetr5=0.0_dp
   den5=0.0_dp
   au5=0.0_dp
   ecc5=0.0_dp
   arg5=0.0_dp
   rinc5=0.0_dp
   omega5=0.0_dp
   t0_5=0.0_dp
   rmutual5=0.0_dp
   rimpact5=0.0_dp
   duration5=0.0_dp
   planetm6=0.0_dp
   planetr6=0.0_dp
   den6=0.0_dp
   au6=0.0_dp
   ecc6=0.0_dp
   rinc6=0.0_dp
   omega6=0.0_dp
   t0_6=0.0_dp
   rmutual6=0.0_dp
   rimpact6=0.0_dp
   duration6=0.0_dp
   planetm7=0.0_dp
   planetr7=0.0_dp
   den7=0.0_dp
   au7=0.0_dp
   ecc7=0.0_dp
   arg7=0.0_dp
   rinc7=0.0_dp
   omega7=0.0_dp
   t0_7=0.0_dp
   rmutual7=0.0_dp
   rimpact7=0.0_dp
   duration7=0.0_dp
   planetm8=0.0_dp
   planetr8=0.0_dp
   den8=0.0_dp
   au8=0.0_dp
   ecc8=0.0_dp
   rinc8=0.0_dp
   omega8=0.0_dp
   t0_8=0.0_dp
   rmutual8=0.0_dp
   rimpact8=0.0_dp
   duration8=0.0_dp
   arg6=0.0_dp
!
   fincr=finc*degtorad
   rimpact1=0.0_dp
   ecc1=0.0_dp
   p=period*secinday
   ppp=period*24.0_dp
   total_mass=(separ)**(3)*coeff/(ppp*ppp)
   rm1=(separ*solarrad)**(3)*fourpiesquared
   rm1=rm1/(gmsun*p*p*(1.0_dp+q))
   rm2=q*rm1
   r1=reff1*separ
   r2=reff2*separ
   volume=(fourthirdspie)*(r2*solarrad*100.0_dp)**3
   den=rm2*(solarmass*1000.0_dp)/volume
   rimpacteb=COS(fincr)*separ/r1
   IF(rimpacteb < 1.0_dp)THEN
      term1=SQRT((1.0_dp+r2/r1)**2-rimpact1**2)
   ELSE
      term1=0.0_dp
   END IF
   term2=period*r1/(pie*separ*SQRT(1.0_dp-ecc*ecc))
   term3=(1.0_dp-ecc*ecc)/(1.0_dp-ecc*COS(argper*degtorad))
   durationeb=term1*term2*term3*24.0_dp
   aueb=separ*auinsolarrad
   rrad(1)=r1
   rrad(2)=r2
   rrau(1)=1.0_dp
   rrau(2)=1.0_dp
!
!   planet 1 (circumbinary case)
!
   IF(ABS(tertq) > EPSILON(tertq))THEN
      planetm1=(rm1+rm2)/tertq*earthmasstosolar
      IF(it1 == 2)planetm1=tertq
   ELSE
      planetm1=0.0_dp
   END IF
   ttt=sa3
   IF(ttt < 0.0_dp)THEN
      planetr1=0.0_dp
   ELSE
      planetr1=(r1/ttt)*earthradinsolar
   END IF
   den1=planetm1*earthgram/(fourthirdspie*(planetr1*earthcm)**3)
   IF(tertq <= 0.0_dp)THEN
      totalmass=0.0_dp
   ELSE
      totalmass=(total_mass)*(1.0_dp+1.0_dp/tertq)
      IF(it1 == 2)totalmass=total_mass+tertq/earthmasstosolar
   END IF
!
   au1=((tertperiod/daysinyear)**2*totalmass)**(1.0_dp/3.0_dp)
   ecc1=SQRT((tertesin**2+tertecos**2))
   arg1=(ATAN2(tertesin,tertecos))*radtodeg
!
   t0_1=tertt0
   IF(itconj >= 2)THEN
      CALL gett0(tertincl,tertperiod,ecc1,arg1,tperi1,tertconj)
      t0_1=tertconj
   END IF
   IF(itconj == 1)THEN
      CALL gett0tran(tertincl,tertperiod,ecc1,arg1,t0_1,tertconj)
   END IF
   IF(itconj == 0)THEN
      CALL getcontimes(finc,period,ecc1,arg1,t0_1,tertconj, tconj2)
   END IF
   tt1=SIN(tertincl*degtorad)*SIN(fincr)*COS(tertomega* degtorad)
   tt2=COS(tertincl*degtorad)*COS(fincr)
   rmutual1=ACOS(tt1+tt2)*radtodeg
   rimpact1=ABS(COS(tertincl*degtorad)*au1/auinsolarrad/r1)
   IF(rimpact1 < 1.0_dp)THEN
      term1=SQRT((1.0_dp+planetr1/earthradinsolar/r1)**2-rimpact1**2)
   ELSE
      term1=0.0_dp
   END IF
   term2=tertperiod*r1/(pie*au1/auinsolarrad*SQRT(1.0_dp-ecc1* ecc1))
   term3=(1.0_dp-ecc1*ecc1)/(1.0_dp-ecc1*COS(arg1))
   duration1=term1*term2*term3*24.0_dp
   rinc1=tertincl
   omega1=tertomega
   p1tconj=tertconj
   rrad(3)=planetr1/earthradinsolar
   rrau(3)=au1
!
!  planet 2 (body 4)
!
   IF((p2period <= 0.0_dp).OR.(p2q <= 0.0_dp))THEN
      planetm2=0.0_dp
      planetr2=0.0_dp
      den2=0.0_dp
      au2=0.0_dp
      ecc2=0.0_dp
      arg2=0.0_dp
      rinc2=0.0_dp
      omega2=0.0_dp
      rimpact2=0.0_dp
      rmutual2=0.0_dp
      duration2=0.0_dp*24.0_dp
      t0_2=0.0_dp
   ELSE
      IF(ABS(p2q) > EPSILON(p2q))THEN
         planetm2=(rm1+rm2)/p2q*earthmasstosolar
         IF(it1 == 2)planetm2=p2q
      ELSE
         planetm2=0.0_dp
      END IF
      IF(p2ratrad <= 0.0_dp)THEN
         planetr2=0.0_dp
      ELSE
         planetr2=r1/p2ratrad*earthradinsolar
      END IF
      IF(planetr2 <= 0.0_dp)THEN
         den2=0.0_dp
      ELSE
         den2=planetm2*earthgram/(fourthirdspie*(planetr2*earthcm)**3)
      END IF
      IF(p2q <= 0.0_dp)THEN
         totalmass=0.0_dp
      ELSE
         totalmass=(total_mass)*(1.0_dp+1.0_dp/p2q)
         IF(it1 == 2)totalmass=total_mass+p2q/earthmasstosolar
      END IF
      au2=((p2period/daysinyear)**2*totalmass)**(1.0_dp/3.0_dp)
      ecc2=SQRT((p2esin**2+p2ecos**2))
      arg2=(ATAN2(p2esin,p2ecos))*radtodeg
      IF(itconj >= 2)THEN
         CALL gett0(p2incl,p2period,ecc2,arg2,t0_2,p2tconj)
      END IF
      IF(itconj == 1)THEN
         CALL gett0tran(p2incl,p2period,ecc2,arg2,t0_2,p2tconj)
      END IF
      IF(itconj == 0)THEN
         CALL getcontimes(p2incl,p2period,ecc2,arg2,p2t0,p2conj, tconj2)
         t0_2=p2t0
      END IF
      tt1=SIN(p2incl*degtorad)*SIN(fincr)*COS(p2omega*degtorad)
      tt2=COS(p2incl*degtorad)*COS(fincr)
      rmutual2=ACOS(tt1+tt2)*radtodeg
      rimpact2=ABS(COS(p2incl*degtorad)*au2/auinsolarrad/r1)
      IF(rimpact2 < 1.0_dp)THEN
         term1=SQRT((1.0_dp+planetr2/earthradinsolar/r1)**2- rimpact2**2)
      ELSE
         term1=0.0_dp
      END IF
      term2=p2period*r1/(pie*au2/auinsolarrad*SQRT(1.0_dp-ecc2* ecc2))
      term3=(1.0_dp-ecc2*ecc2)/(1.0_dp-ecc2*COS(arg2))
      duration2=term1*term2*term3*24.0_dp
      rinc2=p2incl
      omega2=p2omega
      rrad(4)=planetr2/earthradinsolar
      rrau(4)=au2
   END IF
!
!  planet 3
!
   IF((p3period <= 0.0_dp).OR.(p3q <= 0.0_dp))THEN
      planetm3=0.0_dp
      planetr3=0.0_dp
      den3=0.0_dp
      au3=0.0_dp
      ecc3=0.0_dp
      arg3=0.0_dp
      rinc3=0.0_dp
      omega3=0.0_dp
      rimpact3=0.0_dp
      rmutual3=0.0_dp
      duration3=0.0_dp*24.0_dp
      t0_3=0.0_dp
   ELSE
      IF(ABS(p3q) > EPSILON(p3q))THEN
         planetm3=(rm1+rm2)/p3q*earthmasstosolar
         IF(it1 == 2)planetm3=p3q
      ELSE
         planetm3=0.0_dp
      END IF
      IF(p3ratrad <= 0.0_dp)THEN
         planetr3=0.0_dp
      ELSE
         planetr3=r1/p3ratrad*earthradinsolar
      END IF
      IF(planetr3 <= 0.0_dp)THEN
         den3=0.0_dp
      ELSE
         den3=planetm3*earthgram/(fourthirdspie*(planetr3*earthcm)**3)
      END IF
      IF(p3q <= 0.0_dp)THEN
         totalmass=0.0_dp
      ELSE
         totalmass=(total_mass)*(1.0_dp+1.0_dp/p3q)
         IF(it1 == 2)totalmass=total_mass+p3q/earthmasstosolar
      END IF
      au3=((p3period/daysinyear)**2*totalmass)**(1.0_dp/3.0_dp)
      ecc3=SQRT((p3esin**2+p3ecos**2))
      arg3=(ATAN2(p3esin,p3ecos))*radtodeg
      IF(itconj >= 2)THEN
         CALL gett0(p3incl,p3period,ecc3,arg3,t0_3,p3tconj)
      END IF
      IF(itconj == 1)THEN
         CALL gett0tran(p3incl,p3period,ecc3,arg3,t0_3,p3tconj)
      END IF
      IF(itconj == 0)THEN
         CALL getcontimes(p3incl,p3period,ecc3,arg3,p3t0,p3conj, tconj2)
         t0_3=p3t0
      END IF
      tt1=SIN(p3incl*degtorad)*SIN(fincr)*COS(p3omega*degtorad)
      tt2=COS(p3incl*degtorad)*COS(fincr)
      rmutual3=ACOS(tt1+tt2)*radtodeg
      rimpact3=ABS(COS(p3incl*degtorad)*au3/auinsolarrad/r1)
      IF(rimpact3 < 1.0_dp)THEN
         term1=SQRT((1.0_dp+planetr3/earthradinsolar/r1)**2- rimpact3**2)
      ELSE
         term1=0.0_dp
      END IF
      term2=p3period*r1/(pie*au3/auinsolarrad*SQRT(1.0_dp-ecc3* ecc3))
      term3=(1.0_dp-ecc3*ecc3)/(1.0_dp-ecc3*COS(arg3))
      duration3=term1*term2*term3*24.0_dp
      rinc3=p3incl
      omega3=p3omega
      rrad(5)=planetr3/earthradinsolar
      rrau(5)=au3
   END IF
!
!  planet 4
!
   IF((p4period <= 0.0_dp).OR.(p4q <= 0.0_dp))THEN
      planetm4=0.0_dp
      planetr4=0.0_dp
      den4=0.0_dp
      au4=0.0_dp
      ecc4=0.0_dp
      arg4=0.0_dp
      rinc4=0.0_dp
      omega4=0.0_dp
      rimpact4=0.0_dp
      rmutual4=0.0_dp
      duration4=0.0_dp*24.0_dp
      t0_4=0.0_dp
   ELSE
      IF(ABS(p4q) > EPSILON(p4q))THEN
         planetm4=(rm1+rm2)/p4q*earthmasstosolar
         IF(it1 == 2)planetm4=p4q
      ELSE
         planetm4=0.0_dp
      END IF
      IF(p4ratrad <= 0.0_dp)THEN
         planetr4=0.0_dp
      ELSE
         planetr4=r1/p4ratrad*earthradinsolar
      END IF
      IF(planetr4 <= 0.0_dp)THEN
         den4=0.0_dp
      ELSE
         den4=planetm4*earthgram/(fourthirdspie*(planetr4*earthcm)**3)
      END IF
      IF(p4q <= 0.0_dp)THEN
         totalmass=0.0_dp
      ELSE
         totalmass=(total_mass)*(1.0_dp+1.0_dp/p4q)
         IF(it1 == 2)totalmass=total_mass+p4q/earthmasstosolar
      END IF
      au4=((p4period/daysinyear)**2*totalmass)**(1.0_dp/3.0_dp)
      ecc4=SQRT((p4esin**2+p4ecos**2))
      arg4=(ATAN2(p4esin,p4ecos))*radtodeg
      IF(itconj >= 2)THEN
         CALL gett0(p4incl,p4period,ecc4,arg4,t0_4,p4tconj)
      END IF
      IF(itconj == 1)THEN
         CALL gett0tran(p4incl,p4period,ecc4,arg4,t0_4,p4tconj)
      END IF
      IF(itconj == 0)THEN
         CALL getcontimes(p4incl,p4period,ecc4,arg4,p4t0,p4conj, tconj2)
         t0_4=p4t0
      END IF
      tt1=SIN(p4incl*degtorad)*SIN(fincr)*COS(p4omega*degtorad)
      tt2=COS(p4incl*degtorad)*COS(fincr)
      rmutual4=ACOS(tt1+tt2)*radtodeg
      rimpact4=ABS(COS(p4incl*degtorad)*au4/auinsolarrad/r1)
      IF(rimpact4 < 1.0_dp)THEN
         term1=SQRT((1.0_dp+planetr4/earthradinsolar/r1)**2- rimpact4**2)
      ELSE
         term1=0.0_dp
      END IF
      term2=p4period*r1/(pie*au4/auinsolarrad*SQRT(1.0_dp-ecc4* ecc4))
      term3=(1.0_dp-ecc4*ecc4)/(1.0_dp-ecc4*COS(arg4))
      duration4=term1*term2*term3*24.0_dp
      rinc4=p4incl
      omega4=p4omega
      rrad(6)=planetr4/earthradinsolar
      rrau(6)=au4
   END IF
!
!  planet 5
!
   IF((p5period <= 0.0_dp).OR.(p5q <= 0.0_dp))THEN
      planetm5=0.0_dp
      planetr5=0.0_dp
      den5=0.0_dp
      au5=0.0_dp
      ecc5=0.0_dp
      arg5=0.0_dp
      rinc5=0.0_dp
      omega5=0.0_dp
      rimpact5=0.0_dp
      rmutual5=0.0_dp
      duration5=0.0_dp*24.0_dp
      t0_5=0.0_dp
   ELSE
      IF(ABS(p5q) > EPSILON(p5q))THEN
         planetm5=(rm1+rm2)/p5q*earthmasstosolar
         IF(it1 == 2)planetm5=p5q
      ELSE
         planetm5=0.0_dp
      END IF
      IF(p5ratrad <= 0.0_dp)THEN
         planetr5=0.0_dp
      ELSE
         planetr5=r1/p5ratrad*earthradinsolar
      END IF
      IF(planetr5 <= 0.0_dp)THEN
         den5=0.0_dp
      ELSE
         den5=planetm5*earthgram/(fourthirdspie*(planetr5*earthcm)**3)
      END IF
      IF(p5q <= 0.0_dp)THEN
         totalmass=0.0_dp
      ELSE
         totalmass=(total_mass)*(1.0_dp+1.0_dp/p5q)
         IF(it1 == 2)totalmass=total_mass+p5q/earthmasstosolar
      END IF
      au5=((p5period/daysinyear)**2*totalmass)**(1.0_dp/3.0_dp)
      ecc5=SQRT((p5esin**2+p5ecos**2))
      arg5=(ATAN2(p5esin,p5ecos))*radtodeg
      IF(itconj >= 2)THEN
         CALL gett0(p5incl,p5period,ecc5,arg5,t0_5,p5tconj)
      END IF
      IF(itconj == 1)THEN
         CALL gett0tran(p5incl,p5period,ecc5,arg5,t0_5,p5tconj)
      END IF
      IF(itconj == 0)THEN
         CALL getcontimes(p5incl,p5period,ecc5,arg5,p5t0,p5conj, tconj2)
         t0_5=p5t0
      END IF
      tt1=SIN(p5incl*degtorad)*SIN(fincr)*COS(p5omega*degtorad)
      tt2=COS(p5incl*degtorad)*COS(fincr)
      rmutual5=ACOS(tt1+tt2)*radtodeg
      rimpact5=ABS(COS(p5incl*degtorad)*au5/auinsolarrad/r1)
      IF(rimpact5 < 1.0_dp)THEN
         term1=SQRT((1.0_dp+planetr5/earthradinsolar/r1)**2- rimpact5**2)
      ELSE
         term1=0.0_dp
      END IF
      term2=p5period*r1/(pie*au5/auinsolarrad*SQRT(1.0_dp-ecc5* ecc5))
      term3=(1.0_dp-ecc5*ecc5)/(1.0_dp-ecc5*COS(arg5))
      duration5=term1*term2*term3*24.0_dp
      rinc5=p5incl
      omega5=p5omega
      rrad(7)=planetr5/earthradinsolar
      rrau(7)=au5
   END IF
!
!  planet 6
!
   IF((p6period <= 0.0_dp).OR.(p6q <= 0.0_dp))THEN
      planetm6=0.0_dp
      planetr6=0.0_dp
      den6=0.0_dp
      au6=0.0_dp
      ecc6=0.0_dp
      arg6=0.0_dp
      rinc6=0.0_dp
      omega6=0.0_dp
      rimpact6=0.0_dp
      rmutual6=0.0_dp
      duration6=0.0_dp*24.0_dp
      t0_6=0.0_dp
   ELSE
      IF(ABS(p6q) > EPSILON(p6q))THEN
         planetm6=(rm1+rm2)/p6q*earthmasstosolar
         IF(it1 == 2)planetm6=p6q
      ELSE
         planetm6=0.0_dp
      END IF
      IF(p6ratrad <= 0.0_dp)THEN
         planetr6=0.0_dp
      ELSE
         planetr6=r1/p6ratrad*earthradinsolar
      END IF
      IF(planetr6 <= 0.0_dp)THEN
         den6=0.0_dp
      ELSE
         den6=planetm6*earthgram/(fourthirdspie*(planetr6*earthcm)**3)
      END IF
      IF(p6q <= 0.0_dp)THEN
         totalmass=0.0_dp
      ELSE
         totalmass=(total_mass)*(1.0_dp+1.0_dp/p6q)
         IF(it1 == 2)totalmass=total_mass+p6q/earthmasstosolar
      END IF
      au6=((p6period/daysinyear)**2*totalmass)**(1.0_dp/3.0_dp)
      ecc6=SQRT((p6esin**2+p6ecos**2))
      arg6=(ATAN2(p6esin,p6ecos))*radtodeg
      IF(itconj >= 2)THEN
         CALL gett0(p6incl,p6period,ecc6,arg6,t0_6,p6tconj)
      END IF
      IF(itconj == 1)THEN
         CALL gett0tran(p6incl,p6period,ecc6,arg6,t0_6,p6tconj)
      END IF
      IF(itconj == 0)THEN
         CALL getcontimes(p6incl,p6period,ecc6,arg6,p6t0,p6conj, tconj2)
         t0_6=p6t0
      END IF
      tt1=SIN(p6incl*degtorad)*SIN(fincr)*COS(p6omega*degtorad)
      tt2=COS(p6incl*degtorad)*COS(fincr)
      rmutual6=ACOS(tt1+tt2)*radtodeg
      rimpact6=ABS(COS(p6incl*degtorad)*au6/auinsolarrad/r1)
      IF(rimpact6 < 1.0_dp)THEN
         term1=SQRT((1.0_dp+planetr6/earthradinsolar/r1)**2- rimpact6**2)
      ELSE
         term1=0.0_dp
      END IF
      term2=p6period*r1/(pie*au6/auinsolarrad*SQRT(1.0_dp-ecc6* ecc6))
      term3=(1.0_dp-ecc6*ecc6)/(1.0_dp-ecc6*COS(arg6))
      duration6=term1*term2*term3*24.0_dp
      rinc6=p6incl
      omega6=p6omega
      rrad(8)=planetr6/earthradinsolar
      rrau(8)=au6
   END IF
!
!  planet 7
!
   IF((p7period <= 0.0_dp).OR.(p7q <= 0.0_dp))THEN
      planetm7=0.0_dp
      planetr7=0.0_dp
      den7=0.0_dp
      au7=0.0_dp
      ecc7=0.0_dp
      arg7=0.0_dp
      rinc7=0.0_dp
      omega7=0.0_dp
      rimpact7=0.0_dp
      rmutual7=0.0_dp
      duration7=0.0_dp*24.0_dp
      t0_7=0.0_dp
   ELSE
      IF(ABS(p7q) > EPSILON(p7q))THEN
         planetm7=(rm1+rm2)/p7q*earthmasstosolar
         IF(it1 == 2)planetm7=p7q
      ELSE
         planetm7=0.0_dp
      END IF
      IF(p7ratrad <= 0.0_dp)THEN
         planetr7=0.0_dp
      ELSE
         planetr7=r1/p7ratrad*earthradinsolar
      END IF
      IF(planetr7 <= 0.0_dp)THEN
         den7=0.0_dp
      ELSE
         den7=planetm7*earthgram/(fourthirdspie*(planetr7*earthcm)**3)
      END IF
      IF(p7q <= 0.0_dp)THEN
         totalmass=0.0_dp
      ELSE
         totalmass=(total_mass)*(1.0_dp+1.0_dp/p7q)
         IF(it1 == 2)totalmass=total_mass+p7q/earthmasstosolar
      END IF
      au7=((p7period/daysinyear)**2*totalmass)**(1.0_dp/3.0_dp)
      ecc7=SQRT((p7esin**2+p7ecos**2))
      arg7=(ATAN2(p7esin,p7ecos))*radtodeg
      IF(itconj >= 2)THEN
         CALL gett0(p7incl,p7period,ecc7,arg7,t0_7,p7tconj)
      END IF
      IF(itconj == 1)THEN
         CALL gett0tran(p7incl,p7period,ecc7,arg7,t0_7,p7tconj)
      END IF
      IF(itconj == 0)THEN
         CALL getcontimes(p7incl,p7period,ecc7,arg7,p7t0,p7conj, tconj2)
         t0_7=p7t0
      END IF
      tt1=SIN(p7incl*degtorad)*SIN(fincr)*COS(p7omega*degtorad)
      tt2=COS(p7incl*degtorad)*COS(fincr)
      rmutual7=ACOS(tt1+tt2)*radtodeg
      rimpact7=ABS(COS(p7incl*degtorad)*au7/auinsolarrad/r1)
      IF(rimpact7 < 1.0_dp)THEN
         term1=SQRT((1.0_dp+planetr7/earthradinsolar/r1)**2- rimpact7**2)
      ELSE
         term1=0.0_dp
      END IF
      term2=p7period*r1/(pie*au7/auinsolarrad*SQRT(1.0_dp-ecc7* ecc7))
      term3=(1.0_dp-ecc7*ecc7)/(1.0_dp-ecc7*COS(arg7))
      duration7=term1*term2*term3*24.0_dp
      rinc7=p7incl
      omega7=p7omega
      rrad(9)=planetr7/earthradinsolar
      rrau(9)=au7
   END IF
!
!  planet 8
!
   IF((p8period <= 0.0_dp).OR.(p8q <= 0.0_dp))THEN
      planetm8=0.0_dp
      planetr8=0.0_dp
      den8=0.0_dp
      au8=0.0_dp
      ecc8=0.0_dp
      arg8=0.0_dp
      rinc8=0.0_dp
      omega8=0.0_dp
      rimpact8=0.0_dp
      rmutual8=0.0_dp
      duration8=0.0_dp*24.0_dp
      t0_8=0.0_dp
   ELSE
      IF(ABS(p8q) > EPSILON(p8q))THEN
         planetm8=(rm1+rm2)/p8q*earthmasstosolar
         IF(it1 == 2)planetm8=p8q
      ELSE
         planetm8=0.0_dp
      END IF
      IF(p8ratrad <= 0.0_dp)THEN
         planetr8=0.0_dp
      ELSE
         planetr8=r1/p8ratrad*earthradinsolar
      END IF
      IF(planetr8 <= 0.0_dp)THEN
         den8=0.0_dp
      ELSE
         den8=planetm8*earthgram/(fourthirdspie*(planetr8*earthcm)**3)
      END IF
      IF(p8q <= 0.0_dp)THEN
         totalmass=0.0_dp
      ELSE
         totalmass=(total_mass)*(1.0_dp+1.0_dp/p8q)
         IF(it1 == 2)totalmass=total_mass+p8q/earthmasstosolar
      END IF
      au8=((p8period/daysinyear)**2*totalmass)**(1.0_dp/3.0_dp)
      ecc8=SQRT((p8esin**2+p8ecos**2))
      arg8=(ATAN2(p8esin,p8ecos))*radtodeg
      IF(itconj >= 2)THEN
         CALL gett0(p8incl,p8period,ecc8,arg8,t0_8,p8tconj)
      END IF
      IF(itconj == 1)THEN
         CALL gett0tran(p8incl,p8period,ecc8,arg8,t0_8,p8tconj)
      END IF
      IF(itconj == 0)THEN
         CALL getcontimes(p8incl,p8period,ecc8,arg8,p8t0,p8conj, tconj2)
         t0_8=p8t0
      END IF
      tt1=SIN(p8incl*degtorad)*SIN(fincr)*COS(p8omega*degtorad)
      tt2=COS(p8incl*degtorad)*COS(fincr)
      rmutual8=ACOS(tt1+tt2)*radtodeg
      rimpact8=ABS(COS(p8incl*degtorad)*au8/auinsolarrad/r1)
      IF(rimpact8 < 1.0_dp)THEN
         term1=SQRT((1.0_dp+planetr8/earthradinsolar/r1)**2-rimpact8**2)
      ELSE
         term1=0.0_dp
      END IF
      term2=p8period*r1/(pie*au8/auinsolarrad*SQRT(1.0_dp-ecc8*ecc8))
      term3=(1.0_dp-ecc8*ecc8)/(1.0_dp-ecc8*COS(arg8))
      duration8=term1*term2*term3*24.0_dp
      rinc8=p8incl
      omega8=p8omega
      rrad(10)=planetr8/earthradinsolar
      rrau(10)=au8
   END IF
!
   IF((isw28 > 0))THEN
      CALL gett0star(finc,period,ecc,argper,t0,tconj)
   END IF
!
   IF(rimpacteb >= 1000.0_dp)rimpacteb=999.9999_dp
   IF(rimpact1 >= 1000.0_dp)rimpact1=999.9999_dp
   IF(rimpact2 >= 1000.0_dp)rimpact2=999.9999_dp
   IF(rimpact3 >= 1000.0_dp)rimpact3=999.9999_dp
   IF(rimpact4 >= 1000.0_dp)rimpact4=999.9999_dp
   IF(rimpact5 >= 1000.0_dp)rimpact5=999.9999_dp
   IF(rimpact6 >= 1000.0_dp)rimpact6=999.9999_dp
   IF(rimpact7 >= 1000.0_dp)rimpact7=999.9999_dp
   IF(rimpact8 >= 1000.0_dp)rimpact8=999.9999_dp
!
   IF(den1 >= 1000.0_dp)den1=999.9999_dp
   IF(den2 >= 1000.0_dp)den2=999.9999_dp
   IF(den3 >= 1000.0_dp)den3=999.9999_dp
   IF(den4 >= 1000.0_dp)den4=999.9999_dp
   IF(den5 >= 1000.0_dp)den5=999.9999_dp
   IF(den6 >= 1000.0_dp)den6=999.9999_dp
   IF(den7 >= 1000.0_dp)den7=999.9999_dp
   IF(den8 >= 1000.0_dp)den8=999.9999_dp
!
   dummy=0.0_dp
!
!          WRITE(planetparm,10)rM1,R1,rM2,R2,AUEB,Tref,period,rM2*
!     &     earthmasstosolar,R2*earthradinsolar,den,AUEB,ecc,argper,finc,
!     &     dummy,Tconj,T0,dummy,rimpactEB,durationEB,tertperiod,
!     &     planetM1,planetR1,den1,AU1,ecc1,arg1,rinc1,Omega1,P1tconj,
!     &     T0_1,rmutual1,rimpact1,duration1,P2period,planetM2,planetR2,
!     &     den2,AU2,ecc2,arg2,rinc2,Omega2,P2tconj,T0_2,rmutual2,
!     &     rimpact2,duration2,P3period,planetM3,planetR3,den3,AU3,ecc3,
!     &     arg3,rinc3,Omega3,P3tconj,T0_3,rmutual3,rimpact3,duration3,
!     &     P4period,planetM4,planetR4,den4,AU4,ecc4,arg4,rinc4,Omega4,
!     &     P4tconj,T0_4,rmutual4,rimpact4,duration4,P5period,planetM5,
!     &     planetR5,den5,AU5,ecc5,arg5,rinc5,Omega5,P5tconj,T0_5,
!     &     rmutual5,rimpact5,duration5,P6period,planetM6,planetR6,den6,
!     &     AU6,ecc6,arg6,rinc6,Omega6,P6tconj,T0_6,rmutual6,rimpact6,
!     &     duration6,P7period,planetM7,planetR7,den7,AU7,ecc7,arg7,
!     &     rinc7,Omega7,P7tconj,T0_7,rmutual7,rimpact7,duration7,
!     &     P8period,planetM8,planetR8,den8,AU8,ecc8,arg8,rinc8,Omega8,
!     &     P8tconj,T0_8,rmutual8,rimpact8,duration8
!!
!10        FORMAT(2(f14.8,1x,f12.6,1x),f8.5,1x,f13.6,f14.8,1x,f15.8,1x,
!     &     f12.6,1x,f6.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.10,1x,f8.5,
!     &     1x,2(f14.7,1x),f7.5,1x,f8.5,1x,f8.5,1x,f17.10,1x,f12.4,1x,
!     &     f10.4,1x,f7.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.10,1x,f15.
!     &     10,1x,2(f12.5,1x),f12.7,1x,f10.5,1x,f8.5,1x,f17.10,1x,f12.4,
!     &     1x,f10.4,1x,f7.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.10,1x,
!     &     f15.10,1x,2(f12.5,1x),f12.7,1x,f10.5,1x,f8.5,1x,f17.10,1x,
!     &     f10.4,1x,f10.4,1x,f7.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,f15.
!     &     10,1x,f15.10,1x,2(f12.5,1x),f12.7,1x,f10.5,1x,f8.5,1x,f17.10,
!     &     1x,f12.4,1x,f10.4,1x,f7.3,1x,f10.7,1x,f12.10,1x,f15.10,1x,
!     &     f15.10,1x,f15.10,1x,2(f12.5,1x),f12.7,1x,f10.5,1x,f8.5,1x,
!     &     f17.10,1x,f12.4,1x,f10.4,1x,f7.3,1x,f10.7,1x,f12.10,1x,f15.
!     &     10,1x,f15.10,1x,f15.10,1x,2(f12.5,1x),f12.7,1x,f10.5,1x,f8.5,
!     &     1x,f17.10,1x,f12.4,1x,f10.4,1x,f7.3,1x,f10.7,1x,f12.10,1x,
!     &     f15.10,1x,f15.10,1x,f15.10,1x,2(f12.5,1x),f12.7,1x,f10.5,1x,
!     &     f8.5,1x,f17.10,1x,f12.4,1x,f10.4,1x,f7.3,1x,f10.7,1x,f12.10,
!     &     1x,f15.10,1x,f15.10,1x,f15.10,1x,2(f12.5,1x),f12.7,1x,f10.5,
!     &     1x,f8.5,1x,f17.10,1x,f12.4,1x,f10.4,1x,f7.3,1x,f10.7,1x,f12.
!     &     10,1x,f15.10,1x,f15.10,1x,f15.10,1x,2(f12.5,1x),f12.7,1x,f10.
!     &     5,1x,f8.5,1x,f8.5)
!
   DO i=1,3000
      planetparm(i:i)=' '
   END DO
!
   WRITE(string1,20)rm1,r1,rm2,r2
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//string1

   WRITE(string1,30)aueb,tref,period,rm2*earthmasstosolar,r2*earthradinsolar
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,40)den,aueb,ecc,argper,finc
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,50)dummy,tconj,t0,dummy,rimpacteb
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,60)durationeb,tertperiod,planetm1,planetr1,den1
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,70)au1,ecc1,arg1,rinc1,omega1
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,80)p1tconj,t0_1,rmutual1,rimpact1,duration1
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,90)p2period,planetm2,planetr2,den2,au2
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,100)ecc2,arg2,rinc2,omega2,p2tconj,t0_2
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,110)rmutual2,rimpact2,duration2,p3period
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,120)planetm3,planetr3,den3,au3,ecc3
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,130)arg3,rinc3,omega3,p3tconj,t0_3
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,140)rmutual3,rimpact3,duration3,p4period
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,150)planetm4,planetr4,den4,au4,ecc4
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,160)arg4,rinc4,omega4,p4tconj,t0_4
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,170)rmutual4,rimpact4,duration4,p5period
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,180)planetm5,planetr5,den5,au5,ecc5
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,190)arg5,rinc5,omega5,p5tconj,t0_5
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,200)rmutual5,rimpact5,duration5,p6period
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,210)planetm6,planetr6,den6,au6,ecc6
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,220)arg6,rinc6,omega6,p6tconj,t0_6
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,230)rmutual6,rimpact6,duration6,p7period
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,240)planetm7,planetr7,den7,au7,ecc7
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,250)arg7,rinc7,omega7,p7tconj,t0_7
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,260)rmutual7,rimpact7,duration7,p8period
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,270)planetm8,planetr8,den8,au8,ecc8
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,280)arg8,rinc8,omega8,p8tconj,t0_8
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

   WRITE(string1,290)rmutual8,rimpact8,duration8
!   lll=lnblnk(planetparm)
   planetparm=TRIM(planetparm)//' '//string1

20 FORMAT(2(f14.8,1X,f12.6,1X))
30 FORMAT(f8.5,1X,f13.6,f14.8,1X,f15.8,1X,f12.6,1X)
40 FORMAT(f6.3,1X,f10.7,1X,f12.10,1X,f15.10,1X,f15.10,1X)
50 FORMAT(f8.5,1X,2(f14.7,1X),f7.5,1X,f8.5,1X)
60 FORMAT(f8.5,1X,f17.10,1X,f12.4,1X,f10.4,1X,f7.3,1X)
70 FORMAT(f10.7,1X,f12.10,1X,f15.10,1X,f15.10,1X,f15.10,1X)
80 FORMAT(2(f12.5,1X),f12.7,1X,f10.5,1X,f8.5,1X)
90 FORMAT(f17.10,1X,f12.4,1X,f10.4,1X,f7.3,1X,f10.7,1X)
100 FORMAT(f12.10,1X,f15.10,1X,f15.10,1X,f15.10,1X,2(f12.5,1X))
110 FORMAT(f12.7,1X,f10.5,1X,f8.5,1X,f17.10,1X)
120 FORMAT(f10.4,1X,f10.4,1X,f7.3,1X,f10.7,1X,f12.10,1X)
130 FORMAT(f15.10,1X,f15.10,1X,f15.10,1X,2(f12.5,1X))
140 FORMAT(f12.7,1X,f10.5,1X,f8.5,1X,f17.10,1X)
150 FORMAT(f12.4,1X,f10.4,1X,f7.3,1X,f10.7,1X,f12.10,1X)
160 FORMAT(f15.10,1X,f15.10,1X,f15.10,1X,2(f12.5,1X))
170 FORMAT(f12.7,1X,f10.5,1X,f8.5,1X,f17.10,1X)
180 FORMAT(f12.4,1X,f10.4,1X,f7.3,1X,f10.7,1X,f12.10,1X)
190 FORMAT(f15.10,1X,f15.10,1X,f15.10,1X,2(f12.5,1X))
200 FORMAT(f12.7,1X,f10.5,1X,f8.5,1X,f17.10,1X)
210 FORMAT(f12.4,1X,f10.4,1X,f7.3,1X,f10.7,1X,f12.10,1X)
220 FORMAT(f15.10,1X,f15.10,1X,f15.10,1X,2(f12.5,1X))
230 FORMAT(f12.7,1X,f10.5,1X,f8.5,1X,f17.10,1X)
240 FORMAT(f12.4,1X,f10.4,1X,f7.3,1X,f10.7,1X,f12.10,1X)
250 FORMAT(f15.10,1X,f15.10,1X,f15.10,1X,2(f12.5,1X))
260 FORMAT(f12.7,1X,f10.5,1X,f8.5,1X,f17.10,1X)
270 FORMAT(f12.4,1X,f10.4,1X,f7.3,1X,f10.7,1X,f12.10,1X)
280 FORMAT(f15.10,1X,f15.10,1X,f15.10,1X,2(f12.5,1X))
290 FORMAT(f12.7,1X,f10.5,1X,f8.5,1X,f8.5)
!
   RETURN
!
END SUBROUTINE planetparms
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE pnoequalstring(instring,iplace,chisq,outstring,  &
   ilength)
!
!  this routine will return the instring appended to a string
!  giving its value formatted in a compact way.  iplace gives the
!  number of decimal places. For example, chisq=12345.6789, iplace=1,
!  and instring='chi^2' yields 'chi^2 12345.8'
!
   USE accur
!
   IMPLICIT NONE
!
   CHARACTER (LEN=*), INTENT(IN)            :: instring
   INTEGER, INTENT(IN)                      :: iplace
   REAL(KIND=dp), INTENT(IN)                :: chisq
   CHARACTER (LEN=*), INTENT(OUT)           :: outstring
   INTEGER, INTENT(OUT)                     :: ilength
!
   REAL(KIND=dp)  :: tempchi
!
   CHARACTER (LEN=120) :: clip
!
   outstring=' '
   ilength=0
!
!   iplace=1
!
   IF(iplace == 1)THEN
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'9'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999999.9_dp)THEN
         tempchi=999999999999999.0_dp
!              WRITE(outstring,10)empchi
!              CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//'999999999999999.9'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,10)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=1
!
   END IF
!
!   iplace=2
!
   IF(iplace == 2)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.99_dp
         WRITE(outstring,20)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999999.99_dp)THEN
         tempchi=999999999999999.00_dp
!              WRITE(outstring,20)empchi
!              CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//'999999999999999.99'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF

      WRITE(outstring,20)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=2
!
   END IF
!
!   iplace=3
!
   IF(iplace == 3)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'99'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999999.999_dp)THEN
         tempchi=999999999999999.000_dp
!              WRITE(outstring,30)empchi
!              CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//'999999999999999.999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,30)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=3
!
   END IF
!
!   iplace=4
!
   IF(iplace == 4)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999999.9999_dp)THEN
         tempchi=9999999999999.9999_dp
!              WRITE(outstring,40)empchi
!              CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//'999999999999999.9999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,40)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=4
!
   END IF
!
!   iplace=5
!
   IF(iplace == 5)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'9999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999999.99999_dp)THEN
         tempchi=99999999999999.99_dp
!              WRITE(outstring,20)empchi
!              CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//'999999999999999.99999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,50)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=5
!
   END IF
!
!   iplace=6
!
   IF(iplace == 6)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'99999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'99999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,60)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=6
!
   END IF
!
!   iplace=7
!
   IF(iplace == 7)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,70)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=7
!
   END IF
!
!   iplace=8
!
   IF(iplace == 8)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'9999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.99999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'9999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,80)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=8
!
   END IF
!
!   iplace=9
!
   IF(iplace == 9)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'99999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'99999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,90)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=9
!
   END IF
!
!   iplace=10
!
   IF(iplace == 10)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,100)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=10
!
   END IF
!
!   iplace=11
!
   IF(iplace == 11)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'9999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.99999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'9999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF((chisq > 0.0_dp).AND.(chisq < 1.0E-08_dp))THEN
         WRITE(outstring,110)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      ELSE
         WRITE(outstring,120)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
!  end if iplace=11
!
   END IF
!
!   iplace=12
!
   IF(iplace == 12)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'99999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.999999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)//'99999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF((chisq > 0.0_dp).AND.(chisq < 1.0E-09_dp))THEN
         WRITE(outstring,130)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      ELSE
         WRITE(outstring,140)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
!  end if iplace=12
!
   END IF
!
10 FORMAT(f19.1)
20 FORMAT(f20.2)
30 FORMAT(f20.3)
40 FORMAT(f21.4)
50 FORMAT(f22.5)
60 FORMAT(f23.6)
70 FORMAT(f24.7)
80 FORMAT(f25.8)
90 FORMAT(f26.9)
100 FORMAT(f27.10)
110 FORMAT(1PE29.11)
120 FORMAT(f28.11)
130 FORMAT(1PE29.12)
140 FORMAT(f29.12)
!
   RETURN
!
END SUBROUTINE pnoequalstring
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE polint(xa,ya,n,x,y,dy)
!
!   Taken from Numerical Recipes.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: xa(n)
   REAL(KIND=dp), INTENT(IN)                :: ya(n)
   REAL(KIND=dp), INTENT(IN)                :: x
   REAL(KIND=dp), INTENT(OUT)               :: y
   REAL(KIND=dp), INTENT(OUT)               :: dy
!
   REAL(KIND=dp)  :: dif,dift,ho,hp,w,den
!
   INTEGER :: ns,i,m
!
   INTEGER, PARAMETER :: nmax=10
!
   REAL(KIND=dp), DIMENSION(nmax)  :: c,d
!
   ns=1
   dif=ABS(x-xa(1))
   DO  i=1,n
      dift=ABS(x-xa(i))
      IF(dift < dif)THEN
         ns=i
         dif=dift
      END IF
      c(i)=ya(i)
      d(i)=ya(i)
   END DO
   y=ya(ns)
   ns=ns-1
   DO  m=1,n-1
      DO  i=1,n-m
         ho=xa(i)-x
         hp=xa(i+m)-x
         w=c(i+1)-d(i)
         den=ho-hp
         IF(ABS(den) < EPSILON(den))THEN
            WRITE(*,*) 'pause in polint ',den,x,xa(i),ya(i)
         END IF
         den=w/den
         d(i)=hp*den
         c(i)=ho*den
      END DO
      IF(2*ns < n-m)THEN
         dy=c(ns+1)
      ELSE
         dy=d(ns)
         ns=ns-1
      END IF
      y=y+dy
   END DO
   RETURN
!
END SUBROUTINE polint
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE poten(q,omega,x,y,z,psi,psix,psixx,psiy,psiz,  &
   istar,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
!
!   October 6, 1999
!
!   Here is the subroutine from the original Avni code.  It computes
!   the potential (given Q and x,y,z) and various gradients.
!
!   February 15, 2000
!
!   The iflag is added because the potential computation needs to be
!   modified in some cases, specifically when star 2 is not synchronous.
!
!   UPDATE November 13, 2009
!
!   Add an option to use the potential computed from the equilibrium
!   tide approximation.   The flag itide will be the order of the polynomial
!   expansion.
!
!   UPDATE January 24, 2011
!
!   Add in the Hut factor to Omega
!
!   UPDATE February 16, 2011
!
!   Modify for misaligned spin axis
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: x
   REAL(KIND=dp), INTENT(IN)                :: y
   REAL(KIND=dp), INTENT(IN)                :: z
   REAL(KIND=dp), INTENT(OUT)               :: psi
   REAL(KIND=dp), INTENT(OUT)               :: psix
   REAL(KIND=dp), INTENT(OUT)               :: psixx
   REAL(KIND=dp), INTENT(OUT)               :: psiy
   REAL(KIND=dp), INTENT(OUT)               :: psiz
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: cox
   REAL(KIND=dp), INTENT(IN)                :: coy
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   INTEGER, INTENT(IN)                      :: itide
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
!
   REAL(KIND=dp), DIMENSION(0:100)   :: pn,pd
   REAL(KIND=dp) :: twx,twy,twz,txx,t1,hutfac,omegah,rst,rx,a,rst3,rx3,term1,term2
   REAL(KIND=dp) :: term3,term4,term5,term6,cpm,spm,s2tm,dterm1,dterm2
   REAL(KIND=dp) :: dterm3,tider,rr,psicos,stm,s2pm,rst5,rx5,w1
!
   INTEGER :: ii
!
!DIMENSION pn(0:100),pd(0:100)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   hutfac=(1.0_dp+7.5_dp*ecc*ecc+5.625_dp*ecc**4+0.3125_dp*ecc**6)/  &
      ((1.0_dp+3.0_dp*ecc*ecc+3.0_dp/8.0_dp*ecc**4)*SQRT((1.0_dp-ecc*ecc)**3))
!
   omegah=omega*hutfac
   IF(itide < 2)THEN
      rst=SQRT(x**2+y**2+z**2)
      rx=SQRT((x-bdist)**2+y**2+z**2)
      a=((1.0_dp+q)/2.0_dp)*omegah**2
      rst3=rst*rst*rst
      rx3=rx*rx*rx
!
      IF((ABS(thetamis) <= EPSILON(thetamis)).AND.(ABS(phimis) &
            <= EPSILON(phimis)))THEN
         term1=x*x
         term2=y*y
         term3=0.0_dp
         term4=0.0_dp
         term5=0.0_dp
         term6=0.0_dp
         cpm=1.0_dp
         spm=0.0_dp
         stm=0.0_dp
         s2pm=0.0_dp
         s2tm=0.0_dp
      ELSE
         cpm=COS(phimis)
         spm=SIN(phimis)
         stm=SIN(thetamis)
         s2pm=SIN(2.0_dp*phimis)
         s2tm=SIN(2.0_dp*thetamis)
         term1=x*x*(1.0_dp-cpm*cpm*stm*stm)
         term2=y*y*(1.0_dp-spm*spm*stm*stm)
         term3=z*z*stm*stm
         term4=-x*y*stm*stm*s2pm
         term5=-x*z*cpm*s2tm
         term6=-y*z*spm*s2tm
      END IF
      psi=1.0_dp/rst+q/rx-q*x/bdist/bdist+a*(term1+term2+term3+  &
            term4+term5+term6)
!
      dterm1=2.0_dp*x*(1.0_dp-cpm*cpm*stm*stm)
      dterm2=-y*stm*stm*s2pm
      dterm3=-z*cpm*s2tm
      psix=-x/rst3-q*(x-bdist)/rx3-q/bdist/bdist+a*(dterm1+dterm2+dterm3)
      IF(istar == 2)THEN
         psix=-x/rst3-q*(x-bdist)/rx3-2.0_dp*a+a*(dterm1+dterm2+  &
            dterm3)+1.0_dp/bdist/bdist
      END IF
!
      dterm1=2.0_dp*y*(1.0_dp-spm*spm*stm*stm)
      dterm2=-x*stm*stm*s2tm
      dterm3=-z*spm*s2tm
      psiy=-y/rst3-q*y/rx3+a*(dterm1+dterm2+dterm3)
!
      dterm1=2.0_dp*z*stm*stm
      dterm2=-x*cpm*s2tm
      dterm3=-y*spm*s2tm
      psiz=-z/rst3-q*z/rx3+a*(dterm1+dterm2+dterm3)
!
      rst5=rst3*rst*rst
      rx5=rx3*rx*rx
      dterm1=2.0_dp*(1.0_dp-cpm*cpm*stm*stm)
      psixx=-1.0_dp/rst3+3.0_dp*x**2/rst5-q/rx3+(3.0_dp*q*(x-bdist)**2)/rx5+a*dterm1
!
      RETURN
   END IF
!
   tider=tidephi*degtorad
   psicos=cox*COS(tider)+coy*SIN(tider)
!
   rr=x*x+y*y+z*z
   w1=(SQRT(rr))**3
   w1=1.0_dp/w1
!
   psi=1.0_dp/SQRT(rr)+q
   psix=-x*w1
   psiy=-y*w1
   psiz=-z*w1
   psixx=w1*(3.0_dp*x*x/rr-1.0_dp)
!
   CALL lpn(itide,psicos,pn,pd)
   DO  ii=2,itide
      t1=-q*rr**(0.5_dp*REAL(ii,KIND=dp))*pn(ii)
      psi=psi+t1
      twx=REAL(ii,KIND=dp)*x*q*rr**(0.5_dp*REAL(ii,KIND=dp)-1.0_dp)*pn(ii)
      twy=REAL(ii,KIND=dp)*y*q*rr**(0.5_dp*REAL(ii,KIND=dp)-1.0_dp)*pn(ii)
      twz=REAL(ii,KIND=dp)*z*q*rr**(0.5_dp*REAL(ii,KIND=dp)-1.0_dp)*pn(ii)
      txx=q*pn(ii)*(rr)**(0.5_dp**REAL(ii,KIND=dp)-1.0_dp)
      txx=txx*(2.0_dp*x*x*(0.5_dp*REAL(ii,KIND=dp)-1.0_dp)/rr+REAL(ii,KIND=dp))
      psix=psix+twx
      psiy=psiy+twy
      psiz=psiz+twz
      psixx=psixx+txx
   END DO
!
   RETURN
!
END SUBROUTINE poten
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE pspacestring(instring,iplace,chisq,outstring,  &
   ilength)
!
!  this routine will return the instring appended to a string
!  giving its value formatted in a compact way.  iplace gives the
!  number of decimal places. For example, chisq=12345.6789, iplace=1,
!  and instring='chi^2' yields 'chi^2=12345.8'
!
   USE accur
!
   IMPLICIT NONE
!
   CHARACTER(LEN=*), INTENT(IN)             :: instring
   INTEGER, INTENT(IN)                      :: iplace
   REAL(KIND=dp), INTENT(IN)                :: chisq
   CHARACTER(LEN=*), INTENT(OUT)            :: outstring
   INTEGER, INTENT(OUT)                     :: ilength
!
   REAL(KIND=dp)  :: tempchi
!
   CHARACTER(LEN=120) :: clip
!
   ilength=0
   outstring=' '
!
!   iplace=1
!
   IF(iplace == 1)THEN
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,10)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' = '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=1
!
   END IF
!
!   iplace=2
!
   IF(iplace == 2)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.99_dp
         WRITE(outstring,20)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9_dp)THEN
         tempchi=999999999999.99_dp
         WRITE(outstring,20)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF

      WRITE(outstring,20)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' = '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=2
!
   END IF
!
!   iplace=3
!
   IF(iplace == 3)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'99'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.999_dp)THEN
         tempchi=999999999999.999_dp
         WRITE(outstring,30)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,30)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' = '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=3
!
   END IF
!
!   iplace=4
!
   IF(iplace == 4)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9999_dp)THEN
         tempchi=999999999999.9999_dp
         WRITE(outstring,40)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,40)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' = '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=4
!
   END IF
!
!   iplace=5
!
   IF(iplace == 5)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'9999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.99999_dp)THEN
         tempchi=999999999999.99_dp
         WRITE(outstring,20)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,50)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' = '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=5
!
   END IF
!
!   iplace=6
!
   IF(iplace == 6)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'99999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'99999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,60)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' = '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=6
!
   END IF
!
!   iplace=7
!
   IF(iplace == 7)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,70)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' = '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=7
!
   END IF
!
!   iplace=8
!
   IF(iplace == 8)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'9999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.99999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'9999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,80)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' = '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=8
!
   END IF
!
!   iplace=9
!
   IF(iplace == 9)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'99999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'99999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,90)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' = '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=9
!
   END IF
!
!   iplace=10
!
   IF(iplace == 10)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,100)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//' = '//clip(1:ilength)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=10
!
   END IF
!
!   iplace=11
!
   IF(iplace == 11)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'9999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.99999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'9999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF((chisq > 0.0_dp).AND.(chisq < 1.0E-08_dp))THEN
         WRITE(outstring,110)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      ELSE
         WRITE(outstring,120)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
!  end if iplace=11
!
   END IF
!
!   iplace=12
!
   IF(iplace == 12)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'99999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.999999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)//'99999999999'
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF((chisq > 0.0_dp).AND.(chisq < 1.0E-09_dp))THEN
         WRITE(outstring,130)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      ELSE
         WRITE(outstring,140)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//' = '//clip(1:ilength)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
!  end if iplace=12
!
   END IF
!
10 FORMAT(f19.1)
20 FORMAT(f20.2)
30 FORMAT(f20.3)
40 FORMAT(f21.4)
50 FORMAT(f22.5)
60 FORMAT(f23.6)
70 FORMAT(f24.7)
80 FORMAT(f25.8)
90 FORMAT(f26.9)
100 FORMAT(f27.10)
110 FORMAT(1PE29.11)
120 FORMAT(f28.11)
130 FORMAT(1PE29.12)
140 FORMAT(f29.12)
!
   RETURN
!
END SUBROUTINE pspacestring
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE pstring(instring,iplace,chisq,outstring,ilength)
!
!  this routine will return the instring appended to a string
!  giving its value formatted in a compact way.  iplace gives the
!  number of decimal places. For example, chisq=12345.6789, iplace=1,
!  and instring='chi^2' yields 'chi^2=12345.8'
!
   USE accur
!
   IMPLICIT NONE
!
   CHARACTER(LEN=*), INTENT(IN)             :: instring
   INTEGER, INTENT(IN)                      :: iplace
   REAL(KIND=dp), INTENT(IN)                :: chisq
   CHARACTER(LEN=*), INTENT(OUT)            :: outstring
   INTEGER, INTENT(OUT)                     :: ilength
!
   REAL(KIND=dp)  :: tempchi
!
   CHARACTER(LEN=120) :: clip
!
   outstring=' '
   ilength=0
!
!   iplace=1
!
   IF(iplace == 1)THEN
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,10)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//'='//clip(1:ilength)
!  ilength=lnblnk(outstring)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=1
!
   END IF
!
!   iplace=2
!
   IF(iplace == 2)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.99_dp
         WRITE(outstring,20)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9_dp)THEN
         tempchi=999999999999.99_dp
         WRITE(outstring,20)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF

      WRITE(outstring,20)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//'='//clip(1:ilength)
!  ilength=lnblnk(outstring)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=2
!
   END IF
!
!   iplace=3
!
   IF(iplace == 3)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'99'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.999_dp)THEN
         tempchi=999999999999.999_dp
         WRITE(outstring,30)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,30)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//'='//clip(1:ilength)
!  ilength=lnblnk(outstring)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=3
!
   END IF
!
!   iplace=4
!
   IF(iplace == 4)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9999_dp)THEN
         tempchi=999999999999.9999_dp
         WRITE(outstring,40)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,40)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//'='//clip(1:ilength)
!  ilength=lnblnk(outstring)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=4
!
   END IF
!
!   iplace=5
!
   IF(iplace == 5)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'9999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.99999_dp)THEN
         tempchi=999999999999.99_dp
         WRITE(outstring,20)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,50)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//'='//clip(1:ilength)
!  ilength=lnblnk(outstring)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=5
!
   END IF
!
!   iplace=6
!
   IF(iplace == 6)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'99999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'99999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,60)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//'='//clip(1:ilength)
!  ilength=lnblnk(outstring)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=6
!
   END IF
!
!   iplace=7
!
   IF(iplace == 7)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,70)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//'='//clip(1:ilength)
!  ilength=lnblnk(outstring)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=7
!
   END IF
!
!   iplace=8
!
   IF(iplace == 8)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'9999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.99999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'9999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,80)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//'='//clip(1:ilength)
!  ilength=lnblnk(outstring)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=8
!
   END IF
!
!   iplace=9
!
   IF(iplace == 9)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'99999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'99999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,90)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//'='//clip(1:ilength)
!  ilength=lnblnk(outstring)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=9
!
   END IF
!
!   iplace=10
!
   IF(iplace == 10)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'999999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.9999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'999999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      WRITE(outstring,100)chisq
      CALL clipstring(outstring,clip,ilength)
      outstring=instring//'='//clip(1:ilength)
!  ilength=lnblnk(outstring)
      ilength=LEN_TRIM(outstring)
      RETURN
!
!  end if iplace=10
!
   END IF
!
!   iplace=11
!
   IF(iplace == 11)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'9999999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.99999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'9999999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF((chisq > 0.0_dp).AND.(chisq < 1.0E-08_dp))THEN
         WRITE(outstring,110)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      ELSE
         WRITE(outstring,120)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
!  end if iplace=11
!
   END IF
!
!   iplace=12
!
   IF(iplace == 12)THEN
!
      IF(chisq < -1000000000000.0_dp)THEN
         tempchi=-9999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'99999999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF(chisq > 999999999999.999999999999_dp)THEN
         tempchi=999999999999.9_dp
         WRITE(outstring,10)tempchi
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)//'99999999999'
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
      IF((chisq > 0.0_dp).AND.(chisq < 1.0E-09_dp))THEN
         WRITE(outstring,130)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      ELSE
         WRITE(outstring,140)chisq
         CALL clipstring(outstring,clip,ilength)
         outstring=instring//'='//clip(1:ilength)
!    ilength=lnblnk(outstring)
         ilength=LEN_TRIM(outstring)
         RETURN
      END IF
!
!  end if iplace=12
!
   END IF
!
10 FORMAT(f19.1)
20 FORMAT(f20.2)
30 FORMAT(f20.3)
40 FORMAT(f21.4)
50 FORMAT(f22.5)
60 FORMAT(f23.6)
70 FORMAT(f24.7)
80 FORMAT(f25.8)
90 FORMAT(f26.9)
100 FORMAT(f27.10)
110 FORMAT(1PE29.11)
120 FORMAT(f28.11)
130 FORMAT(1PE29.12)
140 FORMAT(f29.12)
!
   RETURN
!
END SUBROUTINE pstring
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION quadintgrd(phi,rmdn,cmnx,cmny)
!
!   Computes the integrand for the log law case.
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                 :: phi
   REAL(KIND=dp), INTENT(IN)                 :: rmdn
   REAL(KIND=dp), INTENT(IN)                 :: cmnx
   REAL(KIND=dp), INTENT(IN)                 :: cmny
!
   REAL(KIND=dp)  :: quadintgrd,xi,yi,rsq,xip,yip,bb,f
!
   xi=rmdn*COS(phi)+cmnx
   yi=rmdn*SIN(phi)+cmny
   rsq=xi*xi+yi*yi
   xip=-rmdn*SIN(phi)
   yip=rmdn*COS(phi)
   bb=xi*yip-yi*xip
   f=0.25_dp*rsq
   quadintgrd=f*bb
!
   RETURN
!
END FUNCTION quadintgrd
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE rad(q,omega,cox,coy,coz,psi0,r,x,y,z,iflag,bdist,  &
   tidephi,itide,ecc,thetamis,phimis)
!
!   October 6, 1999
!
!   This routine finds the radius of a given point on the Roche lobe.
!   From Avni's original code.
!
!   February 15, 2000
!
!   The iflag is added because the potential computation needs to be
!   modified in some cases, specifically when star 2 is not synchronous.
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: cox
   REAL(KIND=dp), INTENT(IN OUT)            :: coy
   REAL(KIND=dp), INTENT(IN)                :: coz
   REAL(KIND=dp), INTENT(IN)                :: psi0
   REAL(KIND=dp), INTENT(IN OUT)            :: r
   REAL(KIND=dp), INTENT(OUT)               :: x
   REAL(KIND=dp), INTENT(OUT)               :: y
   REAL(KIND=dp), INTENT(OUT)               :: z
   INTEGER, INTENT(IN)                      :: iflag
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   INTEGER, INTENT(IN)                      :: itide
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
!
   REAL(KIND=dp)  :: rnew,dpsidr,dr,aa,bb,aapsi,bbpsi,rmid
   REAL(KIND=dp)  :: rmidpsi,psi,x0,psiz,psiy,psix,psixx
!
   INTEGER :: i
!
   DO  i=1,190
      x=r*cox
      y=r*coy
      z=r*coz
!
      CALL spherepot(q,omega,cox,coz,r,psi,dpsidr,bdist,tidephi,  &
         itide,ecc,thetamis,phimis,coy)
      rnew=r-(psi-psi0)/dpsidr
      dr=ABS(rnew-r)
      IF(ABS(dr) < epsilon(dr)) GO TO 40
!
!      IF(PRECISION(dr).ge.18)THEN
!        IF(ABS(dr) < 1.0E-19_dp)GO TO 40
!      ELSE
!        IF(ABS(dr) < 1.0E-16_dp)GO TO 40
!      END IF
!
      r=rnew
   END DO
!
!   if we made to this point, the radius did not converge.  Try bisection
!   instead.
!
   CALL findl1(q,omega,x0,iflag,bdist,tidephi,ecc,thetamis,phimis)
!
!   The radius needed is between 0.0 and x0
!
   aa=1.0E-15_dp
   bb=x0
!
   DO  i=1,90
      CALL spherepot(q,omega,cox,coz,aa,psi,dpsidr,bdist,tidephi,  &
         itide,ecc,thetamis,phimis,coy)
      aapsi=psi-psi0
      CALL spherepot(q,omega,cox,coz,bb,psi,dpsidr,bdist,tidephi,  &
         itide,ecc,thetamis,phimis,coy)
      bbpsi=psi-psi0
      rmid=0.50_dp*(aa+bb)
      CALL spherepot(q,omega,cox,coz,rmid,psi,dpsidr,bdist,  &
         tidephi,itide,ecc,thetamis,phimis,coy)
      rmidpsi=psi-psi0
      IF(ABS(aapsi) <= EPSILON(aapsi))THEN
         r=aa
         GO TO 30
      END IF
      IF(ABS(bbpsi) <= EPSILON(aapsi))THEN
         r=bb
         GO TO 30
      END IF
      IF(aapsi*rmidpsi > 0.0_dp)THEN
         aa=rmid
      ELSE
         bb=rmid
      END IF
   END DO
   r=rmid
30 x=r*cox
   y=r*coy
   z=r*coz
!
40 CALL poten(q,omega,x,y,z,psi,psix,psixx,psiy,psiz,iflag,  &
      bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
!
   RETURN
!
END SUBROUTINE rad
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rc(x,y)
!
!   From Numerical Recipes
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: x
   REAL(KIND=dp), INTENT(IN)                       :: y
!
   REAL(KIND=dp)            :: rc
   REAL(KIND=dp), PARAMETER :: errtol=0.04_dp
   REAL(KIND=dp), PARAMETER :: tiny=1.69E-38_dp
   REAL(KIND=dp), PARAMETER :: sqrtny=1.3E-19_dp
   REAL(KIND=dp), PARAMETER :: big=3.0E+37_dp
   REAL(KIND=dp), PARAMETER :: tnbg=tiny*big
   REAL(KIND=dp), PARAMETER :: comp1=2.236_dp/sqrtny
   REAL(KIND=dp), PARAMETER :: comp2=tnbg*tnbg/25.0_dp
   REAL(KIND=dp), PARAMETER :: third=1.0_dp/3.0_dp
   REAL(KIND=dp), PARAMETER :: c1=0.3_dp
   REAL(KIND=dp), PARAMETER :: c2=1.0_dp/7.0_dp
   REAL(KIND=dp), PARAMETER :: c3=0.375_dp
   REAL(KIND=dp), PARAMETER :: c4=9.0_dp/22.0_dp
   REAL(KIND=dp)            :: alamb,ave,s,w,xt,yt
!
   IF((x < 0.0_dp).OR.(ABS(y) <= EPSILON(y)).OR.((x+ABS(y)) < tiny).OR.  &
         ((x+ABS(y)) > big).OR.((y < -comp1).AND.(x > 0.0_dp)  &
        .AND.(x < comp2)))THEN
      WRITE(*,*) 'invalid arguments in rc'
      STOP
   END IF
   IF(y > 0.0_dp)THEN
      xt=x
      yt=y
      w=1.0_dp
   ELSE
      xt=x-y
      yt=-y
      w=SQRT(x)/SQRT(xt)
   END IF
10 alamb=2.0_dp*SQRT(xt)*SQRT(yt)+yt
   xt=0.25_dp*(xt+alamb)
   yt=0.25_dp*(yt+alamb)
   ave=third*(xt+yt+yt)
   s=(yt-ave)/ave
   IF(ABS(s) > errtol)GO TO 10
   rc=w*(1.0_dp+s*s*(c1+s*(c2+s*(c3+s*c4))))/SQRT(ave)
   RETURN
!
END FUNCTION rc
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE rdint(iunit,i1,stringerr,filein)
!
!   A utility code to read an integer value from unit=iunit.
!   The value is returned in I1, and the same of the
!   variable is returned in the string stringerr.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: iunit
   INTEGER, INTENT(OUT)                     :: i1
   CHARACTER (LEN=*), INTENT(IN)            :: stringerr
   CHARACTER (LEN=8), INTENT(IN)            :: filein
!
   CHARACTER (LEN=60) :: blank
!
!   Read in the line from iunit and determine if it is
!   a comment line.  If so, then read the next line and
!   keep going until a non comment line is found.
!   After that, backspace and read in an integer value.
!
10 READ(iunit,30)blank
!
   IF((blank(1:1) == '!').OR.(blank(1:1) == '#').OR.(blank(1:1)  &
      == '%'))GO TO 10
!
   BACKSPACE(iunit)
!
   READ(iunit,*,ERR=20)i1
!
   RETURN
!
!   If we make it this far there is an error.
!
20 WRITE(*,40)stringerr,filein
   STOP
!
30 FORMAT(a60)
40 FORMAT('Error reading input file for variable ',a,1X,'in',1X,a)
!
   RETURN
!
END SUBROUTINE rdint
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE rdint2(iunit,i1,i2,stringerr,filein)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: iunit
   INTEGER, INTENT(OUT)                     :: i1
   INTEGER, INTENT(OUT)                     :: i2
   CHARACTER (LEN=*), INTENT(IN)            :: stringerr
   CHARACTER (LEN=8), INTENT(IN)            :: filein
!
   CHARACTER (LEN=60) :: blank
!
!   Read in the line from iunit and determine if it is
!   a comment line.  If so, then read the next line and
!   keep going until a non comment line is found.
!   After that, backspace and read in an integer value.
!
10 READ(iunit,30)blank
!
   IF((blank(1:1) == '!').OR.(blank(1:1) == '#').OR.(blank(1:1)  &
      == '%'))GO TO 10
!
   BACKSPACE(iunit)
!
   READ(iunit,*,ERR=20)i1,i2
!
   RETURN
!
!  If we made it this far, there was an error.
!
20 WRITE(*,40)stringerr,filein
   STOP
!
30 FORMAT(a60)
40 FORMAT('Error reading input file for variable ',a,1X,'in',1X, a)
!
   RETURN
!
END SUBROUTINE rdint2
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE rdint8(iunit,i1,i2,i3,i4,i5,i6,i7,i8,stringerr,  &
   filein)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: iunit
   INTEGER, INTENT(OUT)                     :: i1
   INTEGER, INTENT(OUT)                     :: i2
   INTEGER, INTENT(OUT)                     :: i3
   INTEGER, INTENT(OUT)                     :: i4
   INTEGER, INTENT(OUT)                     :: i5
   INTEGER, INTENT(OUT)                     :: i6
   INTEGER, INTENT(OUT)                     :: i7
   INTEGER, INTENT(OUT)                     :: i8
   CHARACTER (LEN=*), INTENT(IN)            :: stringerr
   CHARACTER (LEN=8), INTENT(IN)            :: filein
!
   CHARACTER (LEN=60) :: blank
!
!   Read in the line from iunit and determine if it is
!   a comment line.  If so, then read the next line and
!   keep going until a non comment line is found.
!   After that, backspace and read in an integer value.
!
10 READ(iunit,30)blank
!
   IF((blank(1:1) == '!').OR.(blank(1:1) == '#').OR.(blank(1:1)  &
      == '%'))GO TO 10
!
   BACKSPACE(iunit)
!
   READ(iunit,*,ERR=20)i1,i2,i3,i4,i5,i6,i7,i8
!
   RETURN
!
!  If we made it this far, there was an error.
!
20 WRITE(*,40)stringerr,filein
   STOP
!
30 FORMAT(a60)
40 FORMAT('Error reading input file for variable ',a,1X,'in',1X,a)
!
   RETURN
!
END SUBROUTINE rdint8
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE rdreal(iunit,r1,stringerr,filein)
!
!   Utility code to read in a real number from unit=iunit.
!   Value is returned in r1.  The name of the quantity
!   is returned as an error in the string stringerr.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: iunit
   REAL(KIND=dp), INTENT(OUT)               :: r1
   CHARACTER (LEN=*), INTENT(IN)            :: stringerr
   CHARACTER (LEN=8), INTENT(IN)            :: filein
!
   CHARACTER (LEN=60) :: blank
!
!   Read in the line from iunit and determine if it is
!   a comment line.  If so, then read the next line and
!   keep going until a non comment line is found.
!   After that, backspace and read in an integer value.
!
10 READ(iunit,30)blank
!
   IF((blank(1:1) == '!').OR.(blank(1:1) == '#').OR.(blank(1:1)  &
      == '%'))GO TO 10
!
   BACKSPACE(iunit)
!
   READ(iunit,*,ERR=20)r1
!
   RETURN
!
!  If we made here then there was an error.
!
20 WRITE(*,40)stringerr,filein
   STOP
!
30 FORMAT(a60)
40 FORMAT('Error reading input file for variable ',a,1X,'in',1X,a)
!
   RETURN
!
END SUBROUTINE rdreal
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE rdreal2(iunit,r1,r2,stringerr,filein)
!
!   Utility code to read in two real numbers from unit=iunit.
!   Values are returned in r1, r2.  The name of the quantities
!   is returned as an error in the string stringerr.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: iunit
   REAL(KIND=dp), INTENT(OUT)               :: r1
   REAL(KIND=dp), INTENT(OUT)               :: r2
   CHARACTER (LEN=*), INTENT(IN)            :: stringerr
   CHARACTER (LEN=8), INTENT(IN)            :: filein
!
   CHARACTER (LEN=60) :: blank
!
!   Read in the line from iunit and determine if it is
!   a comment line.  If so, then read the next line and
!   keep going until a non comment line is found.
!   After that, backspace and read in an integer value.
!
10 READ(iunit,30)blank
!
   IF((blank(1:1) == '!').OR.(blank(1:1) == '#').OR.(blank(1:1)  &
      == '%'))GO TO 10
!
   BACKSPACE(iunit)
!
   READ(iunit,*,ERR=20)r1,r2
!
   RETURN
!
!  If we made it this far, there was an error.
!
20 WRITE(*,40)stringerr,filein
   STOP
!
30 FORMAT(a60)
40 FORMAT('Error reading input file for variable ',a,1X,'in',1X,a)
!
   RETURN
!
END SUBROUTINE rdreal2
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE recordparm(nalph1,nbet1,nalph2,nbet2,fill1,fill2,  &
   omega1,omega2,dphase,q,finc,teff1,teff2,tgrav1,tgrav2,  &
   betarim,rinner,router,tdisk,xi,ntheta,nradius,alb1,alb2,nref,  &
   rlx,period,fm,separ,gamma,t3,g3,sa3,density,sw1,sw2,sw3,t0,  &
   idraw,iecheck,iidint,iatm,ism1,icnu,icnb,icnv,icnr,icni,icnj,  &
   icnh,icnk,irvfilt,isw1,isw2,isw3,isw4,ilaw,wave,dbolx,dboly,  &
   dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,sw8,sw9,ikeep,  &
   isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,spot2parm,  &
   spotdparm,primmass,primk,primrad,ratrad,frac1,frac2,ecosw,  &
   temprat,idark1,idark2,isw12,isw13,isw21,isw22,isw23,isw24,  &
   bigi,bigbeta,sw23,sw24,powercoeff,sw25,sw26,sw27,sw28,sw29,  &
   sw30,contam,tconj,beam1,beam2,isw25,isw26,isw27,isw28,isw29,  &
   isw30,isw31,isw32,isw33,isw34,ocose,osine,omegadot,contams0,  &
   contams1,contams2,contams3,sw47,sw48,sw49,ioutflag,sw80,sw81,  &
   sw82,sw83,sw84,sw85,sw86,sw87,sw88,sw89,isw80,isw81,isw82,  &
   isw83,isw84,isw85,isw86,isw87,isw88,isw89,sdarkint1,  &
   sdarkint2,sdarkint3,sdarkint4,sdarkint5)
!
!    Will record the parameters used in the file ELC.out, and will also
!    record interesting computed parameters.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nalph1
   INTEGER, INTENT(IN)                      :: nbet1
   INTEGER, INTENT(IN)                      :: nalph2
   INTEGER, INTENT(IN)                      :: nbet2
   REAL(KIND=dp), INTENT(IN)                :: fill1
   REAL(KIND=dp), INTENT(IN)                :: fill2
   REAL(KIND=dp), INTENT(IN)                :: omega1
   REAL(KIND=dp), INTENT(IN)                :: omega2
   REAL(KIND=dp), INTENT(IN)                :: dphase
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: teff1
   REAL(KIND=dp), INTENT(IN)                :: teff2
   REAL(KIND=dp), INTENT(IN)                :: tgrav1
   REAL(KIND=dp), INTENT(IN)                :: tgrav2
   REAL(KIND=dp), INTENT(IN)                :: betarim
   REAL(KIND=dp), INTENT(IN)                :: rinner
   REAL(KIND=dp), INTENT(IN)                :: router
   REAL(KIND=dp), INTENT(IN)                :: tdisk
   REAL(KIND=dp), INTENT(IN)                :: xi
   INTEGER, INTENT(IN)                      :: ntheta
   INTEGER, INTENT(IN)                      :: nradius
   REAL(KIND=dp), INTENT(IN)                :: alb1
   REAL(KIND=dp), INTENT(IN)                :: alb2
   INTEGER, INTENT(IN)                      :: nref
   REAL(KIND=dp), INTENT(IN)                :: rlx
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: fm
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: gamma
   REAL(KIND=dp), INTENT(IN)                :: t3
   REAL(KIND=dp), INTENT(IN)                :: g3
   REAL(KIND=dp), INTENT(IN)                :: sa3
   REAL(KIND=dp), INTENT(IN)                :: density
   REAL(KIND=dp), INTENT(IN)                :: sw1
   REAL(KIND=dp), INTENT(IN)                :: sw2
   REAL(KIND=dp), INTENT(IN)                :: sw3
   REAL(KIND=dp), INTENT(IN)                :: t0
   INTEGER, INTENT(IN)                      :: idraw
   INTEGER, INTENT(IN)                      :: iecheck
   INTEGER, INTENT(IN)                      :: iidint
   INTEGER, INTENT(IN)                      :: iatm
   INTEGER, INTENT(IN)                      :: ism1
   INTEGER, INTENT(IN)                      :: icnu
   INTEGER, INTENT(IN)                      :: icnb
   INTEGER, INTENT(IN)                      :: icnv
   INTEGER, INTENT(IN)                      :: icnr
   INTEGER, INTENT(IN)                      :: icni
   INTEGER, INTENT(IN)                      :: icnj
   INTEGER, INTENT(IN)                      :: icnh
   INTEGER, INTENT(IN)                      :: icnk
   INTEGER, INTENT(IN)                      :: irvfilt
   INTEGER, INTENT(IN)                      :: isw1
   INTEGER, INTENT(IN)                      :: isw2
   INTEGER, INTENT(IN)                      :: isw3
   INTEGER, INTENT(IN)                      :: isw4
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(IN)                :: wave(8)
   REAL(KIND=dp), INTENT(IN)                :: dbolx(8,2)
   REAL(KIND=dp), INTENT(IN)                :: dboly(8,2)
   REAL(KIND=dp), INTENT(IN)                :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN)                :: dwavey(8,10)
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: argper
   REAL(KIND=dp), INTENT(IN)                :: pshift
   REAL(KIND=dp), INTENT(IN)                :: sw5
   REAL(KIND=dp), INTENT(IN)                :: sw6
   REAL(KIND=dp), INTENT(IN)                :: sw7
   REAL(KIND=dp), INTENT(IN)                :: sw8
   REAL(KIND=dp), INTENT(IN)                :: sw9
   INTEGER, INTENT(IN)                      :: ikeep
   INTEGER, INTENT(IN)                      :: isynch
   INTEGER, INTENT(IN)                      :: isw5
   INTEGER, INTENT(IN)                      :: isw6
   INTEGER, INTENT(IN)                      :: isw7
   INTEGER, INTENT(IN)                      :: isw8
   INTEGER, INTENT(IN)                      :: isw9
   REAL(KIND=dp), INTENT(IN)                :: spot1parm(2,4)
   REAL(KIND=dp), INTENT(IN)                :: spot2parm(2,4)
   REAL(KIND=dp), INTENT(IN)                :: spotdparm(2,4)
   REAL(KIND=dp), INTENT(IN)                :: primmass
   REAL(KIND=dp), INTENT(IN)                :: primk
   REAL(KIND=dp), INTENT(IN)                :: primrad
   REAL(KIND=dp), INTENT(IN)                :: ratrad
   REAL(KIND=dp), INTENT(IN)                :: frac1
   REAL(KIND=dp), INTENT(IN)                :: frac2
   REAL(KIND=dp), INTENT(IN)                :: ecosw
   REAL(KIND=dp), INTENT(IN)                :: temprat
   INTEGER, INTENT(IN)                      :: idark1
   INTEGER, INTENT(IN)                      :: idark2
   INTEGER, INTENT(IN)                      :: isw12
   INTEGER, INTENT(IN)                      :: isw13
   INTEGER, INTENT(IN)                      :: isw21
   INTEGER, INTENT(IN)                      :: isw22
   INTEGER, INTENT(IN)                      :: isw23
   INTEGER, INTENT(IN)                      :: isw24
   REAL(KIND=dp), INTENT(IN)                :: bigi
   REAL(KIND=dp), INTENT(IN)                :: bigbeta
   REAL(KIND=dp), INTENT(IN)                :: sw23
   REAL(KIND=dp), INTENT(IN)                :: sw24
   REAL(KIND=dp), INTENT(IN)                :: powercoeff(8,9)
   REAL(KIND=dp), INTENT(IN)                :: sw25
   REAL(KIND=dp), INTENT(IN)                :: sw26
   REAL(KIND=dp), INTENT(IN)                :: sw27
   REAL(KIND=dp), INTENT(IN)                :: sw28
   REAL(KIND=dp), INTENT(IN)                :: sw29
   REAL(KIND=dp), INTENT(IN)                :: sw30
   REAL(KIND=dp), INTENT(IN)                :: contam
   REAL(KIND=dp), INTENT(IN)                :: tconj
   REAL(KIND=dp), INTENT(IN)                :: beam1
   REAL(KIND=dp), INTENT(IN)                :: beam2
   INTEGER, INTENT(IN)                      :: isw25
   INTEGER, INTENT(IN)                      :: isw26
   INTEGER, INTENT(IN)                      :: isw27
   INTEGER, INTENT(IN)                      :: isw28
   INTEGER, INTENT(IN)                      :: isw29
   INTEGER, INTENT(IN)                      :: isw30
   INTEGER, INTENT(IN)                      :: isw31
   INTEGER, INTENT(IN)                      :: isw32
   INTEGER, INTENT(IN)                      :: isw33
   INTEGER, INTENT(IN)                      :: isw34
   REAL(KIND=dp), INTENT(IN)                :: ocose
   REAL(KIND=dp), INTENT(IN)                :: osine
   REAL(KIND=dp), INTENT(IN)                :: omegadot
   REAL(KIND=dp), INTENT(IN)                :: contams0
   REAL(KIND=dp), INTENT(IN)                :: contams1
   REAL(KIND=dp), INTENT(IN)                :: contams2
   REAL(KIND=dp), INTENT(IN)                :: contams3
   REAL(KIND=dp), INTENT(IN)                :: sw47
   REAL(KIND=dp), INTENT(IN)                :: sw48
   REAL(KIND=dp), INTENT(IN)                :: sw49
   INTEGER, INTENT(IN)                      :: ioutflag
   REAL(KIND=dp), INTENT(IN)                :: sw80
   REAL(KIND=dp), INTENT(IN)                :: sw81
   REAL(KIND=dp), INTENT(IN)                :: sw82
   REAL(KIND=dp), INTENT(IN)                :: sw83
   REAL(KIND=dp), INTENT(IN)                :: sw84
   REAL(KIND=dp), INTENT(IN)                :: sw85
   REAL(KIND=dp), INTENT(IN)                :: sw86
   REAL(KIND=dp), INTENT(IN)                :: sw87
   REAL(KIND=dp), INTENT(IN)                :: sw88
   REAL(KIND=dp), INTENT(IN)                :: sw89
   INTEGER, INTENT(IN)                      :: isw80
   INTEGER, INTENT(IN)                      :: isw81
   INTEGER, INTENT(IN)                      :: isw82
   INTEGER, INTENT(IN)                      :: isw83
   INTEGER, INTENT(IN)                      :: isw84
   INTEGER, INTENT(IN)                      :: isw85
   INTEGER, INTENT(IN)                      :: isw86
   INTEGER, INTENT(IN)                      :: isw87
   INTEGER, INTENT(IN)                      :: isw88
   INTEGER, INTENT(IN)                      :: isw89
   REAL(KIND=dp), INTENT(IN)                :: sdarkint1(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint2(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint3(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint4(8)
   REAL(KIND=dp), INTENT(IN)                :: sdarkint5(8)
!
   INTEGER :: iu,ib,iv,ir,ii,ij,ih,ik,i,kk,kkk
!
   IF(ioutflag >= 1)OPEN(UNIT=2,FILE='ELC.out',STATUS='unknown')
!
   IF(ioutflag >= 1)THEN
      WRITE(2,*)'This is ELC version 5.0 (February 15, 2014)'
      WRITE(2,550)nalph1
      WRITE(2,560)nbet1
      WRITE(2,570)nalph2
      WRITE(2,580)nbet2
      WRITE(2,590)fill1
      WRITE(2,600)fill2
      WRITE(2,610)omega1
      WRITE(2,620)omega2
      WRITE(2,630)dphase
      WRITE(2,640)q
      WRITE(2,650)finc
      WRITE(2,660)teff1
      WRITE(2,670)teff2
      WRITE(2,680)tgrav1
      WRITE(2,690)tgrav2
      WRITE(2,700)betarim
      WRITE(2,710)rinner
      WRITE(2,720)router
      WRITE(2,730)tdisk
      WRITE(2,740)xi
      WRITE(2,750)ntheta
      WRITE(2,760)nradius
      WRITE(2,840)alb1
      WRITE(2,850)alb2
      WRITE(2,860)nref
      WRITE(2,770)rlx
      WRITE(2,780)period
      IF(fm > 1.0E-04_dp)THEN
         WRITE(2,790)fm
      ELSE
         WRITE(2,40)fm
      END IF
      WRITE(2,800)separ
      WRITE(2,920)gamma
      WRITE(2,930)t3
      WRITE(2,940)g3
      WRITE(2,950)sa3
      WRITE(2,960)density
      WRITE(2,970)sw1
      WRITE(2,980)sw2
      WRITE(2,990)sw3
      WRITE(2,1000)t0
      WRITE(2,810)idraw
      WRITE(2,820)iecheck
      WRITE(2,830)iidint
      WRITE(2,890)iatm
      WRITE(2,900)ism1
   END IF
!
!  May 16, 2001
!
!  Modify the icn? flags so that they are either 0 or 1, which conforms
!  to the output format statement.
!
!   Set the icn? control numbers back to zeros and 1s.
!
   IF(icnu == 430)THEN
      iu=0
   ELSE
      iu=1
   END IF
   IF(icnb == 430)THEN
      ib=0
   ELSE
      ib=1
   END IF
   IF(icnv == 430)THEN
      iv=0
   ELSE
      iv=1
   END IF
   IF(icnr == 430)THEN
      ir=0
   ELSE
      ir=1
   END IF
   IF(icni == 430)THEN
      ii=0
   ELSE
      ii=1
   END IF
   IF(icnj == 430)THEN
      ij=0
   ELSE
      ij=1
   END IF
   IF(icnh == 430)THEN
      ih=0
   ELSE
      ih=1
   END IF
   IF(icnk == 430)THEN
      ik=0
   ELSE
      ik=1
   END IF
!
   IF(ioutflag >= 1)WRITE(2,910)iu,ib,iv,ir,ii,ij,ih,ik
!
   IF(ioutflag >= 1)THEN
      WRITE(2,1010)irvfilt
      WRITE(2,1020)isw1
      WRITE(2,1030)isw2
      WRITE(2,1040)isw3
      WRITE(2,1050)isw4
      WRITE(2,880)ilaw
      DO  i=1,8
         WRITE(2,870)wave(i),dbolx(i,1),dboly(i,1),dbolx(i,2),  &
            dboly(i,2),dwavex(i,1),dwavey(i,1),dwavex(i,2),dwavey(i,2)
      END DO
      WRITE(2,1060)ecc
      WRITE(2,1070)argper
      WRITE(2,1080)pshift
      WRITE(2,1090)sw5
      WRITE(2,1100)sw6
      WRITE(2,1110)sw7
      WRITE(2,1120)sw8
      WRITE(2,1130)sw9
      WRITE(2,1140)ikeep
      WRITE(2,1150)isynch
      WRITE(2,1160)isw5
      WRITE(2,1170)isw6
      WRITE(2,1180)isw7
      WRITE(2,1190)isw8
      WRITE(2,1200)isw9
      WRITE(2,1210)spot1parm(1,1)
      WRITE(2,1220)spot1parm(1,2)
      WRITE(2,1230)spot1parm(1,3)
      WRITE(2,1240)spot1parm(1,4)
      WRITE(2,1250)spot1parm(2,1)
      WRITE(2,1260)spot1parm(2,2)
      WRITE(2,1270)spot1parm(2,3)
      WRITE(2,1280)spot1parm(2,4)
      WRITE(2,1290)spot2parm(1,1)
      WRITE(2,1300)spot2parm(1,2)
      WRITE(2,1310)spot2parm(1,3)
      WRITE(2,1320)spot2parm(1,4)
      WRITE(2,1330)spot2parm(2,1)
      WRITE(2,1340)spot2parm(2,2)
      WRITE(2,1350)spot2parm(2,3)
      WRITE(2,1360)spot2parm(2,4)
      WRITE(2,1370)spotdparm(1,1)
      WRITE(2,1380)spotdparm(1,2)
      WRITE(2,1390)spotdparm(1,3)
      WRITE(2,1400)spotdparm(1,4)
      WRITE(2,1410)spotdparm(2,1)
      WRITE(2,1420)spotdparm(2,2)
      WRITE(2,1430)spotdparm(2,3)
      WRITE(2,1440)spotdparm(2,4)
!
!   UPDATE August 10, 2004
!
!   Write out the 8 real and 4 new integer variables here.
!
      WRITE(2,430)primmass
      WRITE(2,440)primk
      WRITE(2,450)primrad
      WRITE(2,460)ratrad
      WRITE(2,470)frac1
      WRITE(2,480)frac2
      WRITE(2,490)ecosw
      WRITE(2,500)temprat
      WRITE(2,510)idark1
      WRITE(2,520)idark2
      WRITE(2,530)isw12
      WRITE(2,540)isw13
      WRITE(2,50)isw21
      WRITE(2,60)isw22
      WRITE(2,70)isw23
      WRITE(2,80)isw24
      DO  kk=1,8
         WRITE(2,30)powercoeff(kk,1),powercoeff(kk,2),  &
            powercoeff(kk,3),powercoeff(kk,4),powercoeff(kk,5),  &
            powercoeff(kk,6),powercoeff(kk,7),powercoeff(kk,8),  &
            powercoeff(kk,9)
      END DO
      WRITE(2,90)bigi
      WRITE(2,100)bigbeta
      WRITE(2,110)sw23
      WRITE(2,120)sw24
      WRITE(2,230)sw25
      WRITE(2,240)sw26
      WRITE(2,250)sw27
      WRITE(2,260)sw28
      WRITE(2,270)sw29
      WRITE(2,280)sw30
      WRITE(2,290)contam
      WRITE(2,300)tconj
      WRITE(2,310)beam1
      WRITE(2,320)beam2
      WRITE(2,330)isw25
      WRITE(2,340)isw26
      WRITE(2,350)isw27
      WRITE(2,360)isw28
      WRITE(2,370)isw29
      WRITE(2,380)isw30
      WRITE(2,390)isw31
      WRITE(2,400)isw32
      WRITE(2,410)isw33
      WRITE(2,420)isw34
      WRITE(2,130)ocose
      WRITE(2,140)osine
      WRITE(2,150)omegadot
      WRITE(2,160)contams0
      WRITE(2,170)contams1
      WRITE(2,180)contams2
      WRITE(2,190)contams3
      WRITE(2,200)sw47
      WRITE(2,210)sw48
      WRITE(2,220)sw49
      WRITE(2,1450)sw80
      WRITE(2,1460)sw81
      WRITE(2,1470)sw82
      WRITE(2,1480)sw83
      WRITE(2,1490)sw84
      WRITE(2,1500)sw85
      WRITE(2,1510)sw86
      WRITE(2,1520)sw87
      WRITE(2,1530)sw88
      WRITE(2,1540)sw89
      WRITE(2,1550)isw80
      WRITE(2,1560)isw81
      WRITE(2,1570)isw82
      WRITE(2,1580)isw83
      WRITE(2,1590)isw84
      WRITE(2,1600)isw85
      WRITE(2,1610)isw86
      WRITE(2,1620)isw87
      WRITE(2,1630)isw88
      WRITE(2,1640)isw89
      WRITE(2,1650)(sdarkint1(kkk),kkk=1,8)
      WRITE(2,1660)(sdarkint2(kkk),kkk=1,8)
      WRITE(2,1670)(sdarkint3(kkk),kkk=1,8)
      WRITE(2,1680)(sdarkint4(kkk),kkk=1,8)
      WRITE(2,1690)(sdarkint5(kkk),kkk=1,8)
!
   END IF
!
   RETURN
!
30 FORMAT(9(f7.4,1X))
40 FORMAT(1PE16.9,4X,'fm')
50 FORMAT(i1,19X,'ialign (1 for rotation aligned with orbit)')
60 FORMAT(i1,19X,'ifastgen (1 for fast genetic mode)')
70 FORMAT(i1,19X,'iwriteeclipse (1 to fit for eclipse times)')
80 FORMAT(i1,19X,'frac switch (>1 to enable ELCratio.???? ','fil'  &
      ,'es)')
90 FORMAT(f11.7,9X,'axis_I (inclination of rotation axis if',' i'  &
      ,'ialign=0)')
100 FORMAT(f11.7,9X,'axis_beta (angle of rotation axis wrt to ',''  &
      ,'orbit if ialign=0)')
110 FORMAT(f15.7,5X,'t_start')
120 FORMAT(f15.7,5X,'t_end')
130 FORMAT(f14.10,6X,'e*cos(omega)')
140 FORMAT(f14.10,6X,'e*sin(omega)')
150 FORMAT(f12.8,8X,'omega_dot (degrees per year)')
160 FORMAT(f12.8,8X,'contamS0 (season 0 contamination, tag s0)')
170 FORMAT(f12.8,8X,'contamS1 (season 1 contamination, tag s1)')
180 FORMAT(f12.8,8X,'contamS2 (season 2 contamination, tag s2)')
190 FORMAT(f12.8,8X,'contamS3 (season 3 contamination, tag s3)')
200 FORMAT(f16.8,4X,'Tref for dynamical integrator')
210 FORMAT(f12.8,8X,'threshold to write chi^2')
220 FORMAT(f13.9,7X,'Omga_bin ','(Nodal angle of binary in ','deg'  &
      ,'rees)')
230 FORMAT(f10.7,10X,'asini error')
240 FORMAT(f11.8,9X,'reference phase for disk fraction')
250 FORMAT(f11.8,9X,'radfill1 (set to use fill1 in terms of',' R'  &
      ,'_eff')
260 FORMAT(f11.8,9X,'radfill2 (set to use fill2 in terms of',' R'  &
      ,'_eff')
270 FORMAT(f10.6,10X,'bin size for light curves (minutes)')
280 FORMAT(f10.6,10X,'bin size for RV curves (minutes)')
290 FORMAT(f12.9,8X,'Kepler contamination')
300 FORMAT(f15.8,5X,'Tconj')
310 FORMAT(f9.6,11X,'beam1 (Doppler boost factor, star 1)')
320 FORMAT(f9.6,11X,'beam2 (Doppler boost factor, star 2)')
330 FORMAT(i1,19X,'X-ray foreshortening switch (1 for point',' so'  &
      ,'urce)')
340 FORMAT(i1,19X,'iGR (1 for GR, 2 for tidal, 3 for both)')
350 FORMAT(i6,14X,'Nterms for fast analytic')
360 FORMAT(i1,19X,'set to 1 to fit for Tconj')
370 FORMAT(i1,19X,'set to 1 to fit for e*cos(omega), e*sin(omega)' )
380 FORMAT(i1,19X,'body 3 switch')
390 FORMAT(i4,16X,'Ngap')
400 FORMAT(i11,9X,'jdum (seed for markovELC, geneticELC, ','rando'  &
      ,'mELC)')
410 FORMAT(i1,19X,'mandel (0 for Gimenez, 1 for Mandel & Agol)')
420 FORMAT(i1,19X,'Iseason (1 for seasonal Kepler contamination)')
430 FORMAT(f13.9,7X,'primmass (star 1 mass in solar masses)')
440 FORMAT(f14.9,6X,'primK (K-velocity of star 1 in km/sec)')
450 FORMAT(f14.9,6X,'primrad (star 1 radius in solar radii)')
460 FORMAT(f16.9,4X,'ratrad (ratio of star 1 radius and star 2',''  &
      ,' radius)')
470 FORMAT(f15.12,5X,'frac1 (fractional radius star 1: R_1/a)')
480 FORMAT(f15.12,5X,'frac2 (fractional radius star 2: R_2/a)')
490 FORMAT(f12.9,8X,'ecosw (phase difference between eclipses)')
500 FORMAT(f12.9,8X,'temprat (T_2/T_1)')
510 FORMAT(i1,19X,'idark1')
520 FORMAT(i1,19X,'idark2')
530 FORMAT(i6,14X,'Npoly (0 for numerical)')
540 FORMAT(i1,19X,'ifasttrans (>0 for fast transit mode)')
550 FORMAT(i4,16X,'Nalph1')
560 FORMAT(i3,17X,'Nbet1')
570 FORMAT(i4,16X,'Nalph2')
580 FORMAT(i3,17X,'Nbet2')
590 FORMAT(f12.9,8X,'fill1')
600 FORMAT(f12.9,8X,'fill2')
610 FORMAT(f11.7,9X,'omega1')
620 FORMAT(f11.7,9X,'omega2')
630 FORMAT(f11.6,9X,'dphase')
640 FORMAT(f15.10,5X,'Q')
650 FORMAT(f12.9,8X,'finc')
660 FORMAT(f11.4,9X,'Teff1')
670 FORMAT(f11.4,9X,'Teff2')
680 FORMAT(f10.7,10X,'Tgrav1')
690 FORMAT(f10.7,10X,'Tgrav2')
700 FORMAT(f9.5,11X,'betarim')
710 FORMAT(f9.6,11X,'rinner')
720 FORMAT(f9.6,11X,'router')
730 FORMAT(f9.3,11X,'tdisk')
740 FORMAT(f9.6,11X,'xi')
750 FORMAT(i3,17X,'Ntheta')
760 FORMAT(i3,17X,'Nradius')
770 FORMAT(f10.5,10X,'log10(Lx)')
780 FORMAT(f16.10,4X,'Period')
790 FORMAT(f8.5,12X,'fm')
800 FORMAT(f15.6,5X,'separ')
810 FORMAT(i1,19X,'idraw')
820 FORMAT(i1,19X,'iecheck')
830 FORMAT(i1,19X,'iidint')
840 FORMAT(f10.7,10X,'alb1')
850 FORMAT(f10.7,10X,'alb2')
860 FORMAT(i2,18X,'Nref')
870 FORMAT(f7.1,2X,8(f9.6,1X))
880 FORMAT(i2,18X,'ilaw  (1=lin. law, 2=log. law, 3=sqrt law,','4'  &
      ,'=quad. law)')
890 FORMAT(i1,19X,'iatm')
900 FORMAT(i1,19X,'ism1')
910 FORMAT(8(i1,1X),4X,'icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK')
920 FORMAT(f13.7,7X,'gamma velocity')
930 FORMAT(f13.5,7X,'t3')
940 FORMAT(f11.6,9X,'g3')
950 FORMAT(f12.6,8X,'SA3')
960 FORMAT(f12.6,8X,'density in g/cc')
970 FORMAT(f12.6,8X,'onephase')
980 FORMAT(f12.6,8X,'usepot1')
990 FORMAT(f12.6,8X,'usepot2')
1000 FORMAT(f16.9,4X,'T0 ')
1010 FORMAT(i1,19X,'iRVfilt')
1020 FORMAT(i1,19X,'ionephase')
1030 FORMAT(i1,19X,'isquare')
1040 FORMAT(i1,19X,'iusepot')
1050 FORMAT(i1,19X,'ifixgamma')
1060 FORMAT(f11.8,9X,'eccentricity')
1070 FORMAT(f13.8,7X,'argument of peristron in degrees')
1080 FORMAT(f11.8,9X,'pshift')
1090 FORMAT(f12.6,8X,'asini (projected semimajor axis in seconds)')
1100 FORMAT(f12.6,8X,'median fit (geneticELC only)')
1110 FORMAT(f12.6,8X,'sw7 (phase range when sw8>sw7>0)')
1120 FORMAT(f12.6,8X,'sw8 (phase range when sw8>sw7>0)')
1130 FORMAT(f13.7,7X,'sw9 (time step when itime=2)')
1140 FORMAT(i1,19X,'ikeep (1 to put eclipse at phase 0.0)')
1150 FORMAT(i1,19X,'isynch (1 to keep rotation synchronous',' at p'  &
      ,'eriastron)')
1160 FORMAT(i1,19X,'ispotprof')
1170 FORMAT(i1,19X,'igrav')
1180 FORMAT(i1,19X,'itime')
1190 FORMAT(i6,14X,'MonteCarlo (0 for interpolation, >10 ','for Mo'  &
      ,'nte Carlo)')
1200 FORMAT(i6,14X,'ielite')
1210 FORMAT(f11.8,9X,'Temperature factor spot 1, star 1')
1220 FORMAT(f11.7,9X,'Latitude of spot 1, star 1 (degrees)')
1230 FORMAT(f11.7,9X,'Longitude of spot 1, star 1 (degrees)')
1240 FORMAT(f11.7,9X,'Angular radius of spot 1, star 1 (degrees)')
1250 FORMAT(f11.8,9X,'Temperature factor spot 2, star 1')
1260 FORMAT(f11.7,9X,'Latitude of spot 2, star 1 (degrees)')
1270 FORMAT(f11.7,9X,'Longitude of spot 2, star 1 (degrees)')
1280 FORMAT(f11.7,9X,'Angular radius of spot 2, star 1 (degrees)')
1290 FORMAT(f11.8,9X,'Temperature factor spot 1, star 2')
1300 FORMAT(f11.7,9X,'Latitude of spot 1, star 2 (degrees)')
1310 FORMAT(f11.7,9X,'Longitude of spot 1, star 2 (degrees)')
1320 FORMAT(f11.7,9X,'Angular radius of spot 1, star 2 (degrees)')
1330 FORMAT(f11.8,9X,'Temperature factor spot 2, star 2')
1340 FORMAT(f11.7,9X,'Latitude of spot 2, star 2 (degrees)')
1350 FORMAT(f11.7,9X,'Longitude of spot 2, star 2 (degrees)')
1360 FORMAT(f11.7,9X,'Angular radius of spot 2, star 2 (degrees)')
1370 FORMAT(f11.8,9X,'Temperature factor spot 1, disk')
1380 FORMAT(f11.7,9X,'Azimuth of spot 1, disk (degrees)')
1390 FORMAT(f11.7,9X,'Radial cutoff of spot 1, disk (0 <= r_cut',''  &
      ,' <=1)')
1400 FORMAT(f11.7,9X,'Angular size of spot 1, disk (degrees)')
1410 FORMAT(f11.8,9X,'Temperature factor spot 2, disk')
1420 FORMAT(f11.7,9X,'Azimuth of spot 2, disk (degrees)')
1430 FORMAT(f11.7,9X,'Radial cutoff of spot 2, disk (0 <= r_cut',''  &
      ,' <=1)')
1440 FORMAT(f11.7,9X,'Angular size of spot 2, disk (degrees)')
1450 FORMAT(f10.4,10X,'Teff4       tag t4')
1460 FORMAT(f10.4,10X,'Teff5       tag t5')
1470 FORMAT(f7.4,13X,'g4')
1480 FORMAT(f7.4,13X,'g5')
1490 FORMAT(f12.2,8X,'chi^2 penalty for transit')
1500 FORMAT(f5.2,15X,'impact parameter threshold for eclipse ','ch'  &
      ,'ecking')
1510 FORMAT(f5.2,15X,'sw86 (currently inactive)')
1520 FORMAT(f5.2,15X,'sw87 (currently inactive)')
1530 FORMAT(f5.2,15X,'sw88 (currently inactive)')
1540 FORMAT(f5.2,15X,'sw89 (currently inactive)')
1550 FORMAT(i1,19X,'set to 1 for binary+binary mode (use body3 ',''  &
      ,'switch=4)')
1560 FORMAT(i1,19X,'set to 1 for transit penalty')
1570 FORMAT(i1,19X,'set to 1 to exclude body 3 eclipses')
1580 FORMAT(i1,19X,'set to 1 to exclude body 4 eclipses')
1590 FORMAT(i1,19X,'set to 1 to exclude body 5 eclipses')
1600 FORMAT(i1,19X,'isw85 (currently inactive)')
1610 FORMAT(i1,19X,'set to 1 to use fluxes (needs Nterms>0)')
1620 FORMAT(i1,19X,'set to 1 for fast binning of Kepler models')
1630 FORMAT(i3,17X,'Ndynwin')
1640 FORMAT(i1,19X,'NSC')
1650 FORMAT(8(f11.7,1X),' fluxes for star 1')
1660 FORMAT(8(f11.7,1X),' fluxes for star 2')
1670 FORMAT(8(f11.7,1X),' fluxes for star 3')
1680 FORMAT(8(f11.7,1X),' fluxes for star 4')
1690 FORMAT(8(f11.7,1X),' fluxes for star 5')
!
END SUBROUTINE recordparm
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE recordparm1(fill1,fill2,omega1,omega2,q,finc,  &
   teff1,teff2,betarim,rinner,router,tdisk,xi,rlx,separ,gamma,  &
   t3,g3,sa3,density,ioutflag)
!
!    Will record the parameters used in the file ELC.parm, and will also
!    record interesting computed parameters.
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: fill1
   REAL(KIND=dp), INTENT(IN)                :: fill2
   REAL(KIND=dp), INTENT(IN)                :: omega1
   REAL(KIND=dp), INTENT(IN)                :: omega2
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: teff1
   REAL(KIND=dp), INTENT(IN)                :: teff2
   REAL(KIND=dp), INTENT(IN)                :: betarim
   REAL(KIND=dp), INTENT(IN)                :: rinner
   REAL(KIND=dp), INTENT(IN)                :: router
   REAL(KIND=dp), INTENT(IN)                :: tdisk
   REAL(KIND=dp), INTENT(IN)                :: xi
   REAL(KIND=dp), INTENT(IN)                :: rlx
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: gamma
   REAL(KIND=dp), INTENT(IN)                :: t3
   REAL(KIND=dp), INTENT(IN)                :: g3
   REAL(KIND=dp), INTENT(IN)                :: sa3
   REAL(KIND=dp), INTENT(IN)                :: density
   INTEGER, INTENT(IN)                      :: ioutflag
!
   IF(ioutflag >= 1)OPEN(UNIT=3,FILE='oldELC.parm',STATUS= 'unknown')
!
   IF(ioutflag >= 1)THEN
      WRITE(3,10)fill1
      WRITE(3,20)fill2
      WRITE(3,30)omega1
      WRITE(3,40)omega2
      WRITE(3,50)q
      WRITE(3,60)finc
      WRITE(3,70)teff1
      WRITE(3,80)teff2
      WRITE(3,90)betarim
      WRITE(3,100)rinner
      WRITE(3,110)router
      WRITE(3,120)tdisk
      WRITE(3,130)xi
      WRITE(3,140)rlx
      WRITE(3,150)separ
      WRITE(3,160)gamma
      WRITE(3,170)t3
      WRITE(3,180)g3
      WRITE(3,190)sa3
      WRITE(3,200)density
   END IF
!
10 FORMAT(f15.13,10X,'fill1')
20 FORMAT(f15.13,10X,'fill2')
30 FORMAT(f15.9,10X,'omega1')
40 FORMAT(f15.9,10X,'omega2')
50 FORMAT(f18.15,7X,'Q')
60 FORMAT(f15.12,10X,'finc')
70 FORMAT(f11.4,14X,'Teff1')
80 FORMAT(f11.4,14X,'Teff2')
90 FORMAT(f13.10,12X,'betarim')
100 FORMAT(f13.10,12X,'rinner')
110 FORMAT(f13.10,12X,'router')
120 FORMAT(f12.3,13X,'tdisk')
130 FORMAT(f12.5,13X,'xi')
140 FORMAT(f15.10,10X,'log10(Lx)')
150 FORMAT(f23.10,2X,'separ')
160 FORMAT(f12.6,13X,'gamma velocity')
170 FORMAT(f15.4,10X,'t3')
180 FORMAT(f15.5,10X,'g3')
190 FORMAT(f17.8,8X,'SA3')
200 FORMAT(f17.6,8X,'density in g/cc')
!
   RETURN
!
END SUBROUTINE recordparm1
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE removepad(nphase,ymod,ypad)
!
!   This routine will remove the pad.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nphase
   REAL(KIND=dp), INTENT(OUT)               :: ymod(nphase)
   REAL(KIND=dp), INTENT(IN)                :: ypad(nphase*3)
!
   INTEGER :: icount,i
!
   icount=0
   DO  i=nphase+1,2*nphase
      icount=icount+1
      ymod(icount)=ypad(i)
   END DO
!
   RETURN
!
END SUBROUTINE removepad
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rf (x,y,z)
!
!   Code from Eric Agol
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: x
   REAL(KIND=dp), INTENT(IN)                :: y
   REAL(KIND=dp), INTENT(IN)                :: z
!
   REAL(KIND=dp)            :: rf
   REAL(KIND=dp), PARAMETER :: errtol=0.08_dp
   REAL(KIND=dp), PARAMETER :: tiny=1.5E-38_dp
   REAL(KIND=dp), PARAMETER :: big=3.0E+37_dp
   REAL(KIND=dp), PARAMETER :: third=1.0_dp/3.0_dp
   REAL(KIND=dp), PARAMETER :: c1=1.0_dp/24.0_dp
   REAL(KIND=dp), PARAMETER :: c2=0.1_dp
   REAL(KIND=dp), PARAMETER :: c3=3.0_dp/44.0_dp
   REAL(KIND=dp), PARAMETER :: c4=1.0_dp/14.0_dp
   REAL(KIND=dp)  :: alamb,ave,delx,dely,delz,e2,e3,sqrtx,sqrty,sqrtz,xt,yt,zt

   IF(MIN(x,y,z) < 0.0_dp.OR.MIN(x+y,x+z,y+z) < tiny.OR.MAX(x,y, z) > big)THEN
      WRITE(*,*)'invalid arguments in rf'
      STOP
   END IF
   xt=x
   yt=y
   zt=z
10 sqrtx=SQRT(xt)
   sqrty=SQRT(yt)
   sqrtz=SQRT(zt)
   alamb=sqrtx*(sqrty+sqrtz)+sqrty*sqrtz
   xt=0.25_dp*(xt+alamb)
   yt=0.25_dp*(yt+alamb)
   zt=0.25_dp*(zt+alamb)
   ave=third*(xt+yt+zt)
   delx=(ave-xt)/ave
   dely=(ave-yt)/ave
   delz=(ave-zt)/ave
   IF(MAX(ABS(delx),ABS(dely),ABS(delz)) > errtol)GO TO 10
   e2=delx*dely-delz**2
   e3=delx*dely*delz
   rf=(1.0_dp+(c1*e2-c2-c3*e3)*e2+c4*e3)/SQRT(ave)
   RETURN
!
END FUNCTION rf
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rj(x,y,z,p)
!
!   from Numerical Recipes
!
   USE accur

   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: x
   REAL(KIND=dp), INTENT(IN)                       :: y
   REAL(KIND=dp), INTENT(IN)                       :: z
   REAL(KIND=dp), INTENT(IN)                       :: p
!
   REAL(KIND=dp)  :: rj,ea,eb,ec,sum,tau,xt,yt
   REAL(KIND=dp)  :: a,alamb,alpha,ave,b,beta,delp,delx,dely,delz
   REAL(KIND=dp)  :: ed,ee,fac,pt,rcx,rho,sqrtx,sqrty,sqrtz
   REAL(KIND=dp)  :: zt,rc,rf
!
   REAL(KIND=dp), PARAMETER :: etol=0.05_dp
   REAL(KIND=dp), PARAMETER :: tny=2.5E-13_dp
   REAL(KIND=dp), PARAMETER :: bg=9.0E+11_dp
   REAL(KIND=dp), PARAMETER :: c1=3.0_dp/14.0_dp
   REAL(KIND=dp), PARAMETER :: c2=1.0_dp/3.0_dp
   REAL(KIND=dp), PARAMETER :: c3=3.0_dp/22.0_dp
   REAL(KIND=dp), PARAMETER :: c4=3.0_dp/26.0_dp
   REAL(KIND=dp), PARAMETER :: c5=0.75_dp*c3
   REAL(KIND=dp), PARAMETER :: c6=1.5_dp*c4
   REAL(KIND=dp), PARAMETER :: c7=0.5_dp*c2
   REAL(KIND=dp), PARAMETER :: c8=c3+c3
!
   IF(MIN(x,y,z) < 0.0_dp.OR.MIN(x+y,x+z,y+z,ABS(p)) < tny.OR.  &
      MAX(x,y,z,ABS(p)) > bg)THEN
      rj=1.0E+50_dp
      RETURN
   END IF
   sum=0.0_dp
   fac=1.0_dp
   IF(p > 0.0_dp)THEN
      xt=x
      yt=y
      zt=z
      pt=p
   ELSE
      xt=MIN(x,y,z)
      zt=MAX(x,y,z)
      yt=x+y+z-xt-zt
      a=1.0_dp/(yt-p)
      b=a*(zt-yt)*(yt-xt)
      pt=yt+b
      rho=xt*zt/yt
      tau=p*pt/yt
      rcx=rc(rho,tau)
   END IF
10 sqrtx=SQRT(xt)
   sqrty=SQRT(yt)
   sqrtz=SQRT(zt)
   alamb=sqrtx*(sqrty+sqrtz)+sqrty*sqrtz
   alpha=(pt*(sqrtx+sqrty+sqrtz)+sqrtx*sqrty*sqrtz)**2
   beta=pt*(pt+alamb)**2
   sum=sum+fac*rc(alpha,beta)
   fac=0.25_dp*fac
   xt=0.25_dp*(xt+alamb)
   yt=0.25_dp*(yt+alamb)
   zt=0.25_dp*(zt+alamb)
   pt=0.25_dp*(pt+alamb)
   ave=0.2_dp*(xt+yt+zt+pt+pt)
   delx=(ave-xt)/ave
   dely=(ave-yt)/ave
   delz=(ave-zt)/ave
   delp=(ave-pt)/ave
   IF(MAX(ABS(delx),ABS(dely),ABS(delz),ABS(delp)) > etol)GO TO 10
   ea=delx*(dely+delz)+dely*delz
   eb=delx*dely*delz
   ec=delp**2
   ed=ea-3.0_dp*ec
   ee=eb+2.0_dp*delp*(ea-ec)
   rj=3.0_dp*sum+fac*(1.0_dp+ed*(-c1+c5*ed-c6*ee)+eb*(c7+delp*(-c8+  &
      delp*c4))+delp*ea*(c2-delp*c3)-c2*delp*ec)/(ave*SQRT(ave))
   IF(p <= 0.0_dp)rj=a*(b*rj+3.0_dp*(rcx-rf(xt,yt,zt)))
   RETURN
!
END FUNCTION rj
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE rknite(n,ns,q,p,nsd,aa,c,ndgl,qq,zq,f,dyno,  &
   ipar,rmass,nbody)
!
!  from Ernst Hairer
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   INTEGER, INTENT(IN)                      :: ns
   REAL(KIND=dp), INTENT(IN)                :: q(n)
   REAL(KIND=dp), INTENT(IN)                :: p(n)
   INTEGER, INTENT(IN)                      :: nsd
   REAL(KIND=dp), INTENT(IN)                :: aa(nsd,ns)
   REAL(KIND=dp), INTENT(IN)                :: c(ns)
   INTEGER, INTENT(IN)                      :: ndgl
   REAL(KIND=dp), INTENT(OUT)               :: qq(ndgl)
   REAL(KIND=dp), INTENT(IN OUT)            :: zq(ndgl,ns)
   REAL(KIND=dp), INTENT(IN OUT)            :: f(ndgl*ns)
   REAL(KIND=dp), INTENT(OUT)               :: dyno
   INTEGER, INTENT(IN OUT)                  :: ipar(*)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
!
   INTEGER        :: js,j,i,is
!
   REAL(KIND=dp)  :: ssum,dnom
!
   DO js=1,ns
      DO j=1,n
         qq(j)=q(j)+zq(j,js)
      END DO
      CALL equa(n,qq,f(1+(js-1)*n),ipar,rmass,nbody)
   END DO
! ---
   dyno=0.0_dp
   DO i=1,n
      dnom=MAX(0.1_dp,ABS(q(i)))
      DO is=1,ns
         ssum=c(is)*p(i)
         DO js=1,ns
            ssum=ssum+aa(is,js)*f(i+(js-1)*n)
         END DO
         dyno=dyno+((ssum-zq(i,is))/dnom)**2
         zq(i,is)=ssum
      END DO
   END DO
   dyno=SQRT(dyno/REAL(ns*n,KIND=dp))
! ---
   RETURN
!
END SUBROUTINE rknite
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rocheradius(q)
!
!      Finds the radius of the Roche lobe around mass 1 as given in
!      Pringle and Wade where q = M1/M2
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                 :: q
!
   REAL(KIND=dp)                             :: q13,q23,t1,rocheradius
!
   q13=q**(1.0_dp/3.0_dp)
   q23=q13*q13
   t1=LOG(1.0_dp+q13)
   rocheradius=0.49_dp*q23/(0.6_dp*q23+t1)
   RETURN
!
END FUNCTION rocheradius
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE rotkern(ialphmax,ibetmax,nalf,ibetlim,istar,omega,  &
   phase,finc,q,flum,xcoords,ycoords,flux,separ,period,gamma,  &
   ecc,argrad,visib,extension,mmdx)
!
!    UPDATE May 22, 2002
!
!    This routine will compute a rotational broadening kernel for
!    star istar.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: flum(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: xcoords(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: ycoords(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: flux
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: gamma
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: argrad
   REAL(KIND=dp), INTENT(IN)                :: visib(ialphmax*ibetmax)
   CHARACTER (LEN=9), INTENT(IN)            :: extension
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
!
   REAL(KIND=dp), ALLOCATABLE    :: binx(:),biny(:),xscratch(:),yscratch(:)
!
   REAL(KIND=dp)  :: argfac,efact,overq,phaser,fincr,siphase
   REAL(KIND=dp)  :: cophase,sifinc,a,p,velamp,rmin,rmax,v1,binsize
   REAL(KIND=dp)  :: area,xx,yy,vel,x0,x1,y0,y1,weight
!
   INTEGER :: iidx,ialf,ibet,nbin,i,icount,jcount
!
   ALLOCATE(binx(1001),biny(1001),xscratch(10000),yscratch(10000))
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmassinsolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
!    Check to see if the star has any flux before going further!
!
   IF(flux <= 0.0_dp)THEN
      DEALLOCATE(binx,biny,xscratch,yscratch)
      RETURN
   END IF
!
   IF(istar == 1)OPEN(UNIT=98,FILE='star1rotkern.'//extension, STATUS='unknown')
   IF(istar == 2)OPEN(UNIT=98,FILE='star2rotkern.'//extension, STATUS='unknown')
!
   argfac=ecc*COS(argrad)
   efact=1.0_dp/SQRT(1.0_dp-ecc*ecc)
   vel=0.0_dp
   overq=q
   IF(istar == 2)overq=1.0_dp/q
   phaser=phase*degtorad
   fincr=finc*degtorad
   siphase=SIN(phaser)
   cophase=COS(phaser)
   sifinc=SIN(fincr)
!
!   Compute the expected K velocity, which is the circular velocity times
!   dsin(finc).
!
   a=separ*solarrad/1000.0_dp
   p=period*secinday
   velamp=twopie*a/p*efact
!
!    First, find the limits of the minimum and maximum rotational
!    velocity on the star.
!
   rmin=1.0E+44_dp
   rmax=-1.0E+44_dp
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=(ialf-1)*ibetlim(ialf)+ibet
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         v1=omega*(-xcoords(iidx)*siphase*sifinc-ycoords(iidx)*cophase*sifinc)
         IF(v1*velamp > rmax)rmax=v1*velamp
         IF(v1*velamp < rmin)rmin=v1*velamp
      END DO
   END DO
!
!   Next, define equal bins in velocity.
!
   nbin=501
   binsize=(rmax-rmin)/REAL(nbin-1,KIND=dp)
!
   DO  i=1,nbin
      binx(i)=REAL(i-1,KIND=dp)*binsize+rmin
      biny(i)=0.0_dp
   END DO
!
!   Finally, loop over the bins.
!   In the inner loop, loop over Nalph (go along latitude
!   rows) and save up curves of velocity and intensity.  In
!   general, these curves will either intersect the velocity
!   of the bin twice or not at all.  If there are intersections,
!   interpolate the intensities to the velocity of the bin velocity
!   and accumulate the sums.
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!                iidx=(ialf-1)*ibetlim(ialf)+ibet
!                iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         v1=omega*(-xcoords(iidx)*siphase*sifinc-ycoords(iidx)*cophase*sifinc)
         xscratch(ibet)=velamp*v1
         IF(ABS(visib(iidx)) > EPSILON(visib(iidx)))THEN
            yscratch(ibet)=flum(iidx)/visib(iidx)
         ELSE
            yscratch(ibet)=0.0_dp
         END IF
      END DO
!
      xscratch(ibetlim(ialf)+1)=xscratch(1)
      yscratch(ibetlim(ialf)+1)=yscratch(1)
!
      icount=0
      jcount=0
!
      DO  i=1,nbin
         DO  ibet=1,ibetlim(ialf)
            IF(((binx(i) > xscratch(ibet)).AND.(binx(i) <=  &
               xscratch(ibet+1))).OR.((binx(i) <= xscratch(ibet)).AND.  &
               (binx(i) > xscratch(ibet+1))))THEN
               x0=xscratch(ibet)
               x1=xscratch(ibet+1)
               y0=yscratch(ibet)
               y1=yscratch(ibet+1)
               xx=binx(i)
               yy=((x1-xx)*y0+(xx-x0)*y1)/(x1-x0)
               weight=2.0_dp/3.0_dp
               IF(MOD(ialf,2) == 0)weight=1.0_dp+1.0_dp/3.0_dp
               IF((ialf == 1).OR.(ialf == nalf))weight=1.0_dp/3.0_dp
               biny(i)=biny(i)+weight*yy
               icount=icount+1
               jcount=jcount+1
            END IF
         END DO
      END DO
   END DO
!
   area=0.0_dp
   DO  i=1,nbin
      area=area+binsize*biny(i)
   END DO
!
   vel=overq/(1.0_dp+overq)*(siphase+argfac)*sifinc
   vel=velamp*vel+gamma
   DO  i=1,nbin
      biny(i)=biny(i)/flux*(separ*solarrad)**2
      WRITE(98,100)binx(i),biny(i),vel
   END DO
!
   CLOSE(98)
!
100 FORMAT(f12.6,2X,1PE16.9,0PF12.6)
!
   DEALLOCATE(binx,biny,xscratch,yscratch)
!
   RETURN
!
END SUBROUTINE rotkern
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE rvarcintg4pt(ilaw,n,m,pathi,  &
   ctrn,rdn,ctrm,rdm,tol,intarray)
!
!   Will compute the integrals around the various arc paths.  The
!   limb darkening law is given by ilaw:
!
!   ilaw = 1 linear
!   ilaw = 2 log
!   ilaw = 3 sqrt
!   ilaw = 4 quad
!   ilaw = 5 Kipping quad law
!
!   This routine will compute the Rossiter effect for the quad
!   law.
!
!   Pathi is a vector with 5 elements giving
!   [body1,body2,start,diff,stop]
!
!   The plane-of-the-sky centers are given in CTRN and CTRN
!   (two elements each), and the radii in the same units are
!   given in RDN and RDM
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: n
   INTEGER, INTENT(IN)                      :: m
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: ctrn(2)
   REAL(KIND=dp), INTENT(IN)                :: rdn
   REAL(KIND=dp), INTENT(IN)                :: ctrm(2)
   REAL(KIND=dp), INTENT(IN)                :: rdm
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(OUT)               :: intarray(6)
!
   REAL(KIND=dp)  :: ctrnx,ctrmx,ctrny,ctrmy,rmdn,cmnx,cmny,phi0,phi1
   REAL(KIND=dp)  :: intqa,intca,intcb,intla,intlb,intqb,cmny2,cmny3
   REAL(KIND=dp)  :: rvintg4pt,a,b,c,d,e,f,g,cmnx2,cmnx3,rmdn2
!
   INTEGER :: ifilt
!
   DO ifilt=1,6
      intarray(ifilt)=0.0_dp
   END DO
!
   ctrnx=ctrn(1)
   ctrmx=ctrm(1)
   ctrny=ctrn(2)
   ctrmy=ctrm(2)
   rmdn=rdm/rdn
   cmnx=(ctrmx-ctrnx)/rdn
   cmny=(ctrmy-ctrny)/rdn
   phi0=pathi(3)
   phi1=pathi(5)
!
   IF(m == n)THEN
      intca=SIN(phi1)/2.0_dp - SIN(phi1)**3/6.0_dp  &
         -(SIN(phi0)/2.0_dp - SIN(phi0)**3/6.0_dp)
      intcb=-COS(phi1)/2.0_dp + (COS(phi1)**3)/6.0_dp  &
         -(-COS(phi0)/2.0_dp + (COS(phi0)**3)/6.0_dp)
      intla=0.0_dp
      intlb=0.0_dp
      intqa=0.0_dp
      intqb=0.0_dp
      intarray(1)=intca
      intarray(2)=intla
      intarray(3)=intqa
      intarray(4)=intcb
      intarray(5)=intlb
      intarray(6)=intqb
      RETURN
   END IF
!
!   compute arc terms, which don't depend on limb darkening
!
   IF((ilaw == 1).OR.(ilaw == 11))THEN
      intca=rvintg4pt(pathi,tol,rmdn,cmnx,cmny,1)
      intcb=rvintg4pt(pathi,tol,rmdn,cmnx,cmny,2)
      intla=rvintg4pt(pathi,tol,rmdn,cmnx,cmny,3)
      intlb=rvintg4pt(pathi,tol,rmdn,cmnx,cmny,4)
      intqa=0.0_dp
      intqb=0.0_dp
   END IF
!
   IF((ilaw == 5).OR.(ilaw == 15))THEN
      cmnx2=cmnx**2
      cmnx3=cmnx**3
      cmny2=cmny**2
      cmny3=cmny**3
      rmdn2=rmdn**2
!
      d=cmnx*rmdn
      c=rmdn**2/12.0_dp
      a=cmnx2 + 9.0_dp*c
      b=d/2.0_dp
      intca=rmdn*(a*(SIN(phi1)-SIN(phi0)) +  &
         b*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) +  &
         c*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0)) + d*(phi1-phi0))/2.0_dp
      a=-(cmny2 + rmdn2)
      b=rmdn2/3.0_dp
      c=-(cmny*rmdn)/2.0_dp
      d=-2.0_dp*c
      intcb=rmdn*(a*(COS(phi1)-COS(phi0)) +  &
         b*((COS(phi1))**3-(COS(phi0))**3)  +  &
         c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) + d*(phi1-phi0))/2.0_dp
      intla=rvintg4pt(pathi,tol,rmdn,cmnx,cmny,3)
      intlb=rvintg4pt(pathi,tol,rmdn,cmnx,cmny,4)
      a=cmnx*cmny*rmdn2
      b=rmdn*cmny*(cmnx2 + cmny2 + rmdn2 - 1.0_dp)/2.0_dp
      c=a/3.0_dp
      d=(-cmnx**4 - 2.0_dp*cmnx2*cmny2 + 2.0_dp*cmnx2 -  &
         cmny**4 + 2.0_dp*cmny2 + rmdn2*(2.0_dp - 5.0_dp*cmnx2-  &
         3.0_dp*cmny2 - rmdn2) - 1.0_dp)/2.0_dp
      e=rmdn*cmnx*(1.0_dp - cmny2 - rmdn2 - cmnx2)/2.0_dp
      f=rmdn2*(cmny2 - cmnx2)/6.0_dp
      g=2.0_dp*e
      intqa=rmdn*(a*(COS(phi1)-COS(phi0)) +  &
         b*(COS(2.0_dp*phi1)-COS(2.0_dp*phi0)) +  &
         c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0)) + d*(SIN(phi1)-SIN(phi0)) +  &
         e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) +  &
         f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0)) + g*(phi1-phi0))/2.0_dp
      a=(cmnx2*(cmnx2 + 2.0_dp*cmny2 + 3.0_dp*rmdn2 -  &
         2.0_dp) + cmny2*(cmny2 + 5.0_dp*rmdn2 - 2.0_dp) +  &
         rmdn2*(rmdn2 - 2.0_dp) + 1.0_dp)/4.0_dp
      b=rmdn*(cmnx3 + cmnx*cmny2 + cmnx*rmdn2 - cmnx)/4.0_dp
      c=rmdn2*(cmnx2 - cmny2)/12.0_dp
      d=rmdn2*(-cmnx*cmny)/2.0_dp
      e=rmdn*cmny*(cmnx2 + cmny2 + rmdn2 - 1.0_dp)/4.0_dp
      f=-d/3.0_dp
      g=-2.0_dp*e
      intqb=rmdn*(a*(COS(phi1)-COS(phi0))+ b*(COS(2.0_dp*phi1)-COS(2.0_dp*phi0))+  &
         c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0))+ d*(SIN(phi1)-SIN(phi0))+  &
         e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+  &
         f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0))+g*(phi1-phi0))
   END IF
!
   IF((ilaw == 4).OR.(ilaw == 14))THEN
      cmnx2=cmnx**2
      cmnx3=cmnx**3
      cmny2=cmny**2
      cmny3=cmny**3
      rmdn2=rmdn**2
!
      d=cmnx*rmdn
      c=rmdn2/12.0_dp
      a=cmnx2 + 9.0_dp*c
      b=d/2.0_dp
      intca=rmdn*(a*(SIN(phi1)-SIN(phi0)) +  &
         b*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) +  &
         c*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0)) + d*(phi1-phi0))/2.0_dp
      a=-(cmny2 + rmdn2)
      b=rmdn2/3.0_dp
      c=-(cmny*rmdn)/2.0_dp
      d=-2.0_dp*c
      intcb=rmdn*(a*(COS(phi1)-COS(phi0)) +  &
         b*((COS(phi1))**3-(COS(phi0))**3)  +  &
         c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) + d*(phi1-phi0))/2.0_dp
      intla=rvintg4pt(pathi,tol,rmdn,cmnx,cmny,3)
      intlb=rvintg4pt(pathi,tol,rmdn,cmnx,cmny,4)
      a=cmnx*cmny*rmdn2
      b=rmdn*cmny*(cmnx2 + cmny2 + rmdn2 - 1.0_dp)/2.0_dp
      c=a/3.0_dp
      d=(-cmnx**4 - 2.0_dp*cmnx2*cmny2 + 2.0_dp*cmnx2 -  &
         cmny**4 + 2.0_dp*cmny2 + rmdn2*(2.0_dp - 5.0_dp*cmnx2-  &
         3.0_dp*cmny2 - rmdn2) - 1.0_dp)/2.0_dp
      e=rmdn*cmnx*(1.0_dp - cmny2 - rmdn2 - cmnx2)/2.0_dp
      f=rmdn2*(cmny2 - cmnx2)/6.0_dp
      g=2.0_dp*e
      intqa=rmdn*(a*(COS(phi1)-COS(phi0)) +  &
         b*(COS(2.0_dp*phi1)-COS(2.0_dp*phi0)) +  &
         c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0)) + d*(SIN(phi1)-SIN(phi0)) +  &
         e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) +  &
         f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0)) + g*(phi1-phi0))/2.0_dp
      a=(cmnx2*(cmnx2 + 2.0_dp*cmny2 + 3.0_dp*rmdn2 -  &
         2.0_dp) + cmny2*(cmny2 + 5.0_dp*rmdn2 - 2.0_dp) +  &
         rmdn2*(rmdn2 - 2.0_dp) + 1.0_dp)/4.0_dp
      b=rmdn*(cmnx3 + cmnx*cmny2 + cmnx*rmdn2 - cmnx)/4.0_dp
      c=rmdn2*(cmnx2 - cmny2)/12.0_dp
      d=rmdn2*(-cmnx*cmny)/2.0_dp
      e=rmdn*cmny*(cmnx2 + cmny2 + rmdn2 - 1.0_dp)/4.0_dp
      f=-d/3.0_dp
      g=-2.0_dp*e
      intqb=rmdn*(a*(COS(phi1)-COS(phi0))+ b*(COS(2.0_dp*phi1)-COS(2.0_dp*phi0))+  &
         c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0))+ d*(SIN(phi1)-SIN(phi0))+  &
         e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+  &
         f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0))+g*(phi1-phi0))
   END IF
!
   IF((ilaw == 2).OR.(ilaw == 12))THEN
      intca=0.0_dp
      intcb=0.0_dp
      intla=0.0_dp
      intlb=0.0_dp
      intqa=0.0_dp
      intqb=0.0_dp
   END IF
!
   IF((ilaw == 3).OR.(ilaw == 13))THEN
      intca=0.0_dp
      intcb=0.0_dp
      intla=0.0_dp
      intlb=0.0_dp
      intqa=0.0_dp
      intqb=0.0_dp
   END IF
!
!   no limb darkening
!
   IF(ilaw == 0)THEN
      intca=0.0_dp
      intcb=0.0_dp
      intla=0.0_dp
      intlb=0.0_dp
      intqa=0.0_dp
      intqb=0.0_dp
   END IF
!
   intarray(1)=-intca
   intarray(2)=-intla
   intarray(3)=-intqa
   intarray(4)=-intcb
   intarray(5)=-intlb
   intarray(6)=-intqb
!
   RETURN
!
END SUBROUTINE rvarcintg4pt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE rvarcintgnpt(ilaw,n,m,pathi,  &
   ctrn,rdn,ctrm,rdm,tol,intarray)
!
!   Will compute the integrals around the various arc paths.  The
!   limb darkening law is given by ilaw:
!
!   ilaw = 1 linear
!   ilaw = 2 log
!   ilaw = 3 sqrt
!   ilaw = 4 quad
!   ilaw = 5 Kipping quad law
!   ilaw = 6 triangular log
!   ilaw = 7 triangular sqrt
!
!   This routine will compute the Rossiter effect for the quad
!   law.
!
!   Pathi is a vector with 5 elements giving
!   [body1,body2,start,diff,stop]
!
!   The plane-of-the-sky centers are given in CTRN and CTRN
!   (two elements each), and the radii in the same units are
!   given in RDN and RDM
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: n
   INTEGER, INTENT(IN)                      :: m
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: ctrn(2)
   REAL(KIND=dp), INTENT(IN)                :: rdn
   REAL(KIND=dp), INTENT(IN)                :: ctrm(2)
   REAL(KIND=dp), INTENT(IN)                :: rdm
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(OUT)               :: intarray(6)
!
   REAL(KIND=dp)  :: ctrnx,ctrmx,ctrny,ctrmy,rmdn,cmnx,cmny,phi0,phi1
   REAL(KIND=dp)  :: intqa,intca,intcb,intla,intlb,intqb,cmny2,cmny3
   REAL(KIND=dp)  :: rvintgnpt,a,b,c,d,e,f,g,cmnx2,cmnx3,rmdn2
!
   INTEGER :: ifilt
!
   DO ifilt=1,6
      intarray(ifilt)=0.0_dp
   END DO
!
   ctrnx=ctrn(1)
   ctrmx=ctrm(1)
   ctrny=ctrn(2)
   ctrmy=ctrm(2)
   rmdn=rdm/rdn
   cmnx=(ctrmx-ctrnx)/rdn
   cmny=(ctrmy-ctrny)/rdn
   phi0=pathi(3)
   phi1=pathi(5)
!
   IF(m == n)THEN
      intca=SIN(phi1)/2.0_dp - SIN(phi1)**3/6.0_dp  &
         -(SIN(phi0)/2.0_dp - SIN(phi0)**3/6.0_dp)
      intcb=-COS(phi1)/2.0_dp + (COS(phi1)**3)/6.0_dp  &
         -(-COS(phi0)/2.0_dp + (COS(phi0)**3)/6.0_dp)
      intla=0.0_dp
      intlb=0.0_dp
      intqa=0.0_dp
      intqb=0.0_dp
      intarray(1)=intca
      intarray(2)=intla
      intarray(3)=intqa
      intarray(4)=intcb
      intarray(5)=intlb
      intarray(6)=intqb
      RETURN
   END IF
!
!   compute arc terms, which don't depend on limb darkening
!
   IF((ilaw == 1).OR.(ilaw == 11))THEN
      intca=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      intcb=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,2)
      intla=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,3)
      intlb=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,4)
      intqa=0.0_dp
      intqb=0.0_dp
   END IF
!
   IF((ilaw == 5).OR.(ilaw == 15))THEN
      cmnx2=cmnx**2
      cmnx3=cmnx**3
      cmny2=cmny**2
      cmny3=cmny**3
      rmdn2=rmdn**2
!
      d=cmnx*rmdn
      c=rmdn**2/12.0_dp
      a=cmnx2 + 9.0_dp*c
      b=d/2.0_dp
      intca=rmdn*(a*(SIN(phi1)-SIN(phi0)) +  &
         b*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) +  &
         c*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0)) + d*(phi1-phi0))/2.0_dp
      a=-(cmny2 + rmdn2)
      b=rmdn2/3.0_dp
      c=-(cmny*rmdn)/2.0_dp
      d=-2.0_dp*c
      intcb=rmdn*(a*(COS(phi1)-COS(phi0)) +  &
         b*((COS(phi1))**3-(COS(phi0))**3)  +  &
         c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) + d*(phi1-phi0))/2.0_dp
      intla=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,3)
      intlb=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,4)
      a=cmnx*cmny*rmdn2
      b=rmdn*cmny*(cmnx2 + cmny2 + rmdn2 - 1.0_dp)/2.0_dp
      c=a/3.0_dp
      d=(-cmnx**4 - 2.0_dp*cmnx2*cmny2 + 2.0_dp*cmnx2 -  &
         cmny**4 + 2.0_dp*cmny2 + rmdn2*(2.0_dp - 5.0_dp*cmnx2-  &
         3.0_dp*cmny2 - rmdn2) - 1.0_dp)/2.0_dp
      e=rmdn*cmnx*(1.0_dp - cmny2 - rmdn2 - cmnx2)/2.0_dp
      f=rmdn2*(cmny2 - cmnx2)/6.0_dp
      g=2.0_dp*e
      intqa=rmdn*(a*(COS(phi1)-COS(phi0)) +  &
         b*(COS(2.0_dp*phi1)-COS(2.0_dp*phi0)) +  &
         c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0)) + d*(SIN(phi1)-SIN(phi0)) +  &
         e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) +  &
         f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0)) + g*(phi1-phi0))/2.0_dp
      a=(cmnx2*(cmnx2 + 2.0_dp*cmny2 + 3.0_dp*rmdn2 -  &
         2.0_dp) + cmny2*(cmny2 + 5.0_dp*rmdn2 - 2.0_dp) +  &
         rmdn2*(rmdn2 - 2.0_dp) + 1.0_dp)/4.0_dp
      b=rmdn*(cmnx3 + cmnx*cmny2 + cmnx*rmdn2 - cmnx)/4.0_dp
      c=rmdn2*(cmnx2 - cmny2)/12.0_dp
      d=rmdn2*(-cmnx*cmny)/2.0_dp
      e=rmdn*cmny*(cmnx2 + cmny2 + rmdn2 - 1.0_dp)/4.0_dp
      f=-d/3.0_dp
      g=-2.0_dp*e
      intqb=rmdn*(a*(COS(phi1)-COS(phi0))+ b*(COS(2.0_dp*phi1)-COS(2.0_dp*phi0))+  &
         c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0))+ d*(SIN(phi1)-SIN(phi0)) +  &
         e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+  &
         f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0))+g*(phi1-phi0))
   END IF
!
   IF((ilaw == 4).OR.(ilaw == 14))THEN
      cmnx2=cmnx**2
      cmnx3=cmnx**3
      cmny2=cmny**2
      cmny3=cmny**3
      rmdn2=rmdn**2
!
      d=cmnx*rmdn
      c=rmdn2/12.0_dp
      a=cmnx2 + 9.0_dp*c
      b=d/2.0_dp
      intca=rmdn*(a*(SIN(phi1)-SIN(phi0)) +  &
         b*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) +  &
         c*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0)) + d*(phi1-phi0))/2.0_dp
      a=-(cmny2 + rmdn2)
      b=rmdn2/3.0_dp
      c=-(cmny*rmdn)/2.0_dp
      d=-2.0_dp*c
      intcb=rmdn*(a*(COS(phi1)-COS(phi0)) +  &
         b*((COS(phi1))**3-(COS(phi0))**3)  +  &
         c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) + d*(phi1-phi0))/2.0_dp
      intla=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,3)
      intlb=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,4)
      a=cmnx*cmny*rmdn2
      b=rmdn*cmny*(cmnx2 + cmny2 + rmdn2 - 1.0_dp)/2.0_dp
      c=a/3.0_dp
      d=(-cmnx**4 - 2.0_dp*cmnx2*cmny2 + 2.0_dp*cmnx2 -  &
         cmny**4 + 2.0_dp*cmny2 + rmdn2*(2.0_dp - 5.0_dp*cmnx2-  &
         3.0_dp*cmny2 - rmdn2) - 1.0_dp)/2.0_dp
      e=rmdn*cmnx*(1.0_dp - cmny2 - rmdn2 - cmnx2)/2.0_dp
      f=rmdn2*(cmny2 - cmnx2)/6.0_dp
      g=2.0_dp*e
      intqa=rmdn*(a*(COS(phi1)-COS(phi0)) +  &
         b*(COS(2.0_dp*phi1)-COS(2.0_dp*phi0)) +  &
         c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0)) + d*(SIN(phi1)-SIN(phi0)) +  &
         e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0)) +  &
         f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0)) + g*(phi1-phi0))/2.0_dp
      a=(cmnx2*(cmnx2 + 2.0_dp*cmny2 + 3.0_dp*rmdn2 -  &
         2.0_dp) + cmny2*(cmny2 + 5.0_dp*rmdn2 - 2.0_dp) +  &
         rmdn2*(rmdn2 - 2.0_dp) + 1.0_dp)/4.0_dp
      b=rmdn*(cmnx3 + cmnx*cmny2 + cmnx*rmdn2 - cmnx)/4.0_dp
      c=rmdn2*(cmnx2 - cmny2)/12.0_dp
      d=rmdn2*(-cmnx*cmny)/2.0_dp
      e=rmdn*cmny*(cmnx2 + cmny2 + rmdn2 - 1.0_dp)/4.0_dp
      f=-d/3.0_dp
      g=-2.0_dp*e
      intqb=rmdn*(a*(COS(phi1)-COS(phi0))+ b*(COS(2.0_dp*phi1)-COS(2.0_dp*phi0))+  &
         c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0))+ d*(SIN(phi1)-SIN(phi0)) +  &
         e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+  &
         f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0))+g*(phi1-phi0))
   END IF
!
   IF((ilaw == 2).OR.(ilaw == 12))THEN
      intca=0.0_dp
      intcb=0.0_dp
      intla=0.0_dp
      intlb=0.0_dp
      intqa=0.0_dp
      intqb=0.0_dp
   END IF
!
   IF((ilaw == 6).OR.(ilaw == 16))THEN
      intca=0.0_dp
      intcb=0.0_dp
      intla=0.0_dp
      intlb=0.0_dp
      intqa=0.0_dp
      intqb=0.0_dp
   END IF
!
   IF((ilaw == 3).OR.(ilaw == 13))THEN
      intca=0.0_dp
      intcb=0.0_dp
      intla=0.0_dp
      intlb=0.0_dp
      intqa=0.0_dp
      intqb=0.0_dp
   END IF
!
   IF((ilaw == 7).OR.(ilaw == 17))THEN
      intca=0.0_dp
      intcb=0.0_dp
      intla=0.0_dp
      intlb=0.0_dp
      intqa=0.0_dp
      intqb=0.0_dp
   END IF
!
!   no limb darkening
!
   IF(ilaw == 0)THEN
      intca=0.0_dp
      intcb=0.0_dp
      intla=0.0_dp
      intlb=0.0_dp
      intqa=0.0_dp
      intqb=0.0_dp
   END IF
!
   intarray(1)=-intca
   intarray(2)=-intla
   intarray(3)=-intqa
   intarray(4)=-intcb
   intarray(5)=-intlb
   intarray(6)=-intqb
!
   RETURN
!
END SUBROUTINE rvarcintgnpt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rvconstantaintgrd(phi,rmdn,cmnx)
!
!   Used in the Rossiter effect
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: phi
   REAL(KIND=dp), INTENT(IN)                       :: rmdn
   REAL(KIND=dp), INTENT(IN)                       :: cmnx
!
   REAL(KIND=dp)  :: rvconstantaintgrd
!
   rvconstantaintgrd=0.5_dp*(rmdn*COS(phi)*(cmnx+rmdn*COS(phi))**2)
!
   RETURN
!
END FUNCTION rvconstantaintgrd
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rvconstantbintgrd(phi,rmdn,cmny)
!
!   Used in the Rossiter effect
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: phi
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmny
!
   REAL(KIND=dp)  rvconstantbintgrd
!
   rvconstantbintgrd=0.5_dp*(rmdn*SIN(phi)*(cmny+rmdn*SIN(phi))**2)
!
   RETURN
!
END FUNCTION rvconstantbintgrd
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rvintg4pt(pathi,tol,rmdn,cmnx,cmny,iterm)
!
!   Uses the Gaussian 4 point rule to evaluate the integral
!   for the Rossiter effect.
!
!   iterm = 1 constant A term
!   iterm = 2 constant B term
!   iterm = 3 linear A term
!   iterm = 4 linear B term
!   iterm = 5 quad A term
!   iterm = 6 quad B term
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
   INTEGER, INTENT(IN)                      :: iterm
!
   REAL(KIND=dp)  :: rvintg4pt,a,b,s,h,x,y,w1,w2
   REAL(KIND=dp)  :: rvconstantaintgrd,rvconstantbintgrd,z,t
   REAL(KIND=dp)  :: rvlinearaintgrd,rvlinearbintgrd
   REAL(KIND=dp)  :: rvquadaintgrd,rvquadbintgrd,delta,dist
!
   INTEGER :: k,m
!
   w1=3.47854845137453857373063949221999E-01_dp
   w2=6.52145154862546142626936050778001E-01_dp
!
   a=pathi(3)
   b=pathi(5)
   m=nint((2.0_dp*rmdn*pathi(4)+1.0_dp))
   m=nint(REAL(m,KIND=dp)*tol*0.5_dp)
   IF(MOD(m,2) == 0)m=m+1
   IF(rmdn < 1.0_dp)THEN
      delta=SQRT(cmnx**2+cmny**2)
      IF(delta < 1.0_dp-rmdn)THEN
         m=nint((2.0_dp*rmdn*pathi(4)+1.0_dp)*tol/3.0_dp)
         IF(m < 8)m=6
         dist=((delta-1.0_dp)**2+(rmdn-1.0_dp)**2)
         IF(dist < 1.24_dp)m=m+2
         IF(dist < 1.05_dp)m=m+2
         IF(dist < 0.95_dp)m=m+2
         IF(dist < 0.85_dp)m=m+2
         IF(dist < 0.80_dp)m=m+2
         IF(dist < 0.75_dp)m=m+2
         IF(rmdn+delta >= 0.990_dp)m=m+2
         IF(rmdn+delta >= 0.995_dp)m=m+2
         IF(rmdn+delta >= 0.997_dp)m=m+2
         IF(rmdn+delta >= 0.998_dp)m=m+2
         IF(tol > 4.0_dp)m=nint(tol/2.0_dp)*m
      END IF
   END IF
   s=0.0_dp
   h=(b-a)/REAL(m,KIND=dp)
   x = a + h*(1.0_dp-8.61136311594052575223946488892809E-01_dp)/2.0_dp
   y = a + h*(1.0_dp-3.39981043584856264802665759103245E-01_dp)/2.0_dp
   z = a + h*(1.0_dp+3.39981043584856264802665759103245E-01_dp)/2.0_dp
   t = a + h*(1.0_dp+8.61136311594052575223946488892809E-01_dp)/2.0_dp

   DO k=1,m
      IF(iterm == 1)THEN
         s = s + w1*(rvconstantaintgrd(x,rmdn,  &
            cmnx)+rvconstantaintgrd(t,rmdn,cmnx))+  &
            w2*(rvconstantaintgrd(y,rmdn,cmnx)  &
            +rvconstantaintgrd(z,rmdn,cmnx))
      END IF
      IF(iterm == 2)THEN
         s = s + w1*(rvconstantbintgrd(x,rmdn,  &
            cmny)+rvconstantbintgrd(t,rmdn,cmny))+  &
            w2*(rvconstantbintgrd(y,rmdn,cmny)  &
            +rvconstantbintgrd(z,rmdn,cmny))
      END IF
      IF(iterm == 3)THEN
         s = s + w1*(rvlinearaintgrd(x,rmdn,cmnx,  &
            cmny)+rvlinearaintgrd(t,rmdn,cmnx,cmny))+  &
            w2*(rvlinearaintgrd(y,rmdn,cmnx,cmny)  &
            +rvlinearaintgrd(z,rmdn,cmnx,cmny))
      END IF
      IF(iterm == 4)THEN
         s = s + w1*(rvlinearbintgrd(x,rmdn,cmnx,  &
            cmny)+rvlinearbintgrd(t,rmdn,cmnx,cmny))+  &
            w2*(rvlinearbintgrd(y,rmdn,cmnx,cmny)  &
            +rvlinearbintgrd(z,rmdn,cmnx,cmny))
      END IF
      IF(iterm == 5)THEN
         s = s + w1*(rvquadaintgrd(x,rmdn,cmnx,  &
            cmny)+rvquadaintgrd(t,rmdn,cmnx,cmny))+  &
            w2*(rvquadaintgrd(y,rmdn,cmnx,cmny)  &
            +rvquadaintgrd(z,rmdn,cmnx,cmny))
      END IF
      IF(iterm == 6)THEN
         s = s + w1*(rvquadbintgrd(x,rmdn,cmnx,  &
            cmny)+rvquadbintgrd(t,rmdn,cmnx,cmny))+  &
            w2*(rvquadbintgrd(y,rmdn,cmnx,cmny)  &
            +rvquadbintgrd(z,rmdn,cmnx,cmny))
      END IF
      x=x+h
      y=y+h
      z=z+h
      t=t+h
   END DO
   s=h*s/2.0_dp
!
   rvintg4pt=s
!
   RETURN
!
END FUNCTION rvintg4pt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rvintgnpt(pathi,tol,rmdn,cmnx,cmny,iterm)
!
!   Uses the Gaussian quadrature to evaluate the integral
!   for the Rossiter effect.
!
!   iterm = 1 constant A term
!   iterm = 2 constant B term
!   iterm = 3 linear A term
!   iterm = 4 linear B term
!   iterm = 5 quad A term
!   iterm = 6 quad B term
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
   INTEGER, INTENT(IN)                      :: iterm
!
   REAL(KIND=dp), DIMENSION(64)   :: xx,ww,xxa
   REAL(KIND=dp)  :: rvintgnpt,a,b,s,h
   REAL(KIND=dp)  :: rvconstantaintgrd,rvconstantbintgrd
   REAL(KIND=dp)  :: rvlinearaintgrd,rvlinearbintgrd
   REAL(KIND=dp)  :: rvquadaintgrd,rvquadbintgrd,delta,scale
!
   INTEGER :: k,m,muse,norder,kk,MAX,nopt
!
   a=pathi(3)
   b=pathi(5)
   m=nint((12.0_dp*rmdn*pathi(4)+1.0_dp))
   m=nint(REAL(m,KIND=dp)*tol)
!
   delta=SQRT(cmnx**2+cmny**2)
   scale=SQRT(rmdn)*SQRT(rmdn-1.0_dp)
   IF((rmdn > 1.0_dp).AND.(delta < scale))m=m+4
!
   IF(rmdn < 1.0_dp)THEN
      IF(delta < 1.0_dp-rmdn)THEN
         m=10
         IF((rmdn < 0.25_dp).AND.(delta > -0.75_dp/0.25_dp*rmdn+1.0_dp))m=m+1
         IF((rmdn >= 0.25_dp).AND.(delta > -0.25_dp/0.75_dp*  &
            (rmdn-0.25_dp)+0.25_dp))m=m+1
         IF((rmdn < 0.35_dp).AND.(delta > -0.65_dp/0.35_dp*rmdn+1.0_dp))m=m+1
         IF((rmdn >= 0.35_dp).AND.(delta > -0.35_dp/0.65_dp*  &
            (rmdn-0.35_dp)+0.35_dp))m=m+1
         IF((rmdn < 0.40_dp).AND.(delta > -0.60_dp/0.40_dp*rmdn+1.0_dp))m=m+1
         IF((rmdn >= 0.40_dp).AND.(delta > -0.40_dp/0.60_dp*  &
            (rmdn-0.40_dp)+0.40_dp))m=m+1
!
         IF(rmdn+delta >= 0.997_dp)m=m+2
         IF(tol > 1.0_dp)m=nint(tol)*m
      END IF
      m=m+4
      IF(rmdn > 0.010_dp)m=m+1
      IF(rmdn > 0.10_dp)m=m+1
      IF(rmdn > 0.25_dp)m=m+1
      IF(rmdn > 0.50_dp)m=m+2
   END IF
!
   IF(m < 1)m=1
   norder=4
   muse=m
   nopt=m
   MAX=64
   IF(nopt <= MAX)THEN
      norder=nopt
      muse=1
   END IF
   DO k=1,100
      IF((nopt >= MAX*k+1).AND.(nopt <= (k+1)*MAX))THEN
         norder=nopt/(k+1)
         muse=k+1
      END IF
   END DO
!
   IF((delta > 1.0_dp-rmdn).AND.(norder <= 9))norder=10
!
   CALL gausscoeff(norder,xx,ww)
!
   s=0.0_dp
   h=(b-a)/REAL(muse,KIND=dp)
   DO kk=1,norder
      xxa(kk)=a+h*(1.0_dp+xx(kk))/2.0_dp
   END DO
!
   DO k=1,muse
      IF(iterm == 1)THEN
         DO kk=1,norder
            s=s+ww(kk)*(rvconstantaintgrd(xxa(kk),rmdn,cmnx))
         END DO
      END IF
      IF(iterm == 2)THEN
         DO kk=1,norder
            s=s+ww(kk)*(rvconstantbintgrd(xxa(kk),rmdn,cmny))
         END DO
      END IF
      IF(iterm == 3)THEN
         DO kk=1,norder
            s=s+ww(kk)*(rvlinearaintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      IF(iterm == 4)THEN
         DO kk=1,norder
            s=s+ww(kk)*(rvlinearbintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      IF(iterm == 5)THEN
         DO kk=1,norder
            s=s+ww(k)*(rvquadaintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      IF(iterm == 6)THEN
         DO kk=1,norder
            s=s+ww(kk)*(rvquadbintgrd(xxa(kk),rmdn,cmnx,cmny))
         END DO
      END IF
      DO kk=1,norder
         xxa(kk)=xxa(kk)+h
      END DO
   END DO
   s=h*s/2.0_dp
!
   rvintgnpt=s
!
   RETURN
!
END FUNCTION rvintgnpt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rvlinearaintgrd(phi,rmdn,cmnx,cmny)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: phi
   REAL(KIND=dp), INTENT(IN)                       :: rmdn
   REAL(KIND=dp), INTENT(IN)                       :: cmnx
   REAL(KIND=dp), INTENT(IN)                       :: cmny
!
   REAL(KIND=dp) rvlinearaintgrd
!
   rvlinearaintgrd=-(rmdn*COS(phi)*(1.0_dp-(cmny+rmdn*SIN(phi))**2  &
      -(cmnx+rmdn*COS(phi))**2)**(1.5_dp))/3.0_dp
!
   RETURN
!
END FUNCTION rvlinearaintgrd
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rvlinearbintgrd(phi,rmdn,cmnx,cmny)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: phi
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
!
   REAL(KIND=dp)   :: rvlinearbintgrd
!
   rvlinearbintgrd=-(rmdn*SIN(phi)*(1.0_dp-(cmny+rmdn*SIN(phi))**  &
      2-(cmnx+rmdn*COS(phi))**2)**(1.5_dp))/3.0_dp
!
   RETURN
!
END FUNCTION rvlinearbintgrd
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rvquadaintgrd(phi,rmdn,cmnx,cmny)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: phi
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
!
   REAL(KIND=dp)  :: rvquadaintgrd
!
   rvquadaintgrd=-0.25_dp*(rmdn*COS(phi)*((cmnx+rmdn*COS(phi))**2+  &
      (cmny+rmdn*SIN(phi))**2-1.0_dp)**2)
!
   RETURN
!
END FUNCTION rvquadaintgrd
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION rvquadbintgrd(phi,rmdn,cmnx,cmny)
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: phi
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
!
   REAL(KIND=dp)  ::  rvquadbintgrd
!
   rvquadbintgrd=-0.25_dp*(rmdn*SIN(phi)*((cmnx+rmdn*COS(phi))**2+  &
      (cmny+rmdn*SIN(phi))**2-1.0_dp)**2)
!
   RETURN
!
END FUNCTION rvquadbintgrd
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE scontaminate(nmaxphase,nphase,xmod,ymodu,contams0,  &
   contams1,contams2,contams3)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN)                      :: nphase
   REAL(KIND=dp), INTENT(IN)                :: xmod(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: ymodu(nmaxphase)
   REAL(KIND=dp), INTENT(IN)                :: contams0
   REAL(KIND=dp), INTENT(IN)                :: contams1
   REAL(KIND=dp), INTENT(IN)                :: contams2
   REAL(KIND=dp), INTENT(IN)                :: contams3
!
   REAL(KIND=dp), ALLOCATABLE   ::  xscr(:),yscr(:)
   REAL(KIND=dp)                ::  rmed
!
   INTEGER               ::  i
!
   INTEGER, PARAMETER    ::  isize=7000000
!
   ALLOCATE(xscr(isize),yscr(isize))
!
   IF(isize < nmaxphase)THEN
      WRITE(*,*) 'Dimension error in subroutine Scontaminate.'
      WRITE(*,*) 'Make isize > Nmaxphase'
      STOP
   END IF
!
   DO  i=1,nphase
      xscr(i)=xmod(i)
      yscr(i)=ymodu(i)
   END DO

   IF(nphase > 1)CALL sort2(nphase,yscr,xscr)
!
   rmed=yscr(nphase/2)
!
   DO  i=1,nphase
      IF(xmod(i) < 0.0_dp)THEN
         ymodu(i)=ymodu(i)-contams0*ymodu(i)+rmed*contams0
      END IF
      IF((xmod(i) >= 0.0_dp).AND.(xmod(i) < 92.0_dp))THEN
         ymodu(i)=ymodu(i)-contams1*ymodu(i)+rmed*contams1
      END IF
      IF((xmod(i) >= 92.0_dp).AND.(xmod(i) < 183.0_dp))THEN
         ymodu(i)=ymodu(i)-contams2*ymodu(i)+rmed*contams2
      END IF
      IF((xmod(i) >= 183.0_dp).AND.(xmod(i) < 276.0_dp))THEN
         ymodu(i)=ymodu(i)-contams3*ymodu(i)+rmed*contams3
      END IF
      IF((xmod(i) >= 276.0_dp).AND.(xmod(i) < 372.0_dp))THEN
         ymodu(i)=ymodu(i)-contams0*ymodu(i)+rmed*contams0
      END IF
      IF((xmod(i) >= 372.0_dp).AND.(xmod(i) < 463.0_dp))THEN
         ymodu(i)=ymodu(i)-contams1*ymodu(i)+rmed*contams1
      END IF
      IF((xmod(i) >= 463.0_dp).AND.(xmod(i) < 553.0_dp))THEN
         ymodu(i)=ymodu(i)-contams2*ymodu(i)+rmed*contams2
      END IF
      IF((xmod(i) >= 553.0_dp).AND.(xmod(i) < 636.0_dp))THEN
         ymodu(i)=ymodu(i)-contams3*ymodu(i)+rmed*contams3
      END IF
      IF((xmod(i) >= 636.0_dp).AND.(xmod(i) < 739.0_dp))THEN
         ymodu(i)=ymodu(i)-contams0*ymodu(i)+rmed*contams0
      END IF
      IF((xmod(i) >= 739.0_dp).AND.(xmod(i) < 834.0_dp))THEN
         ymodu(i)=ymodu(i)-contams1*ymodu(i)+rmed*contams1
      END IF
      IF((xmod(i) >= 834.0_dp).AND.(xmod(i) < 932.0_dp))THEN
         ymodu(i)=ymodu(i)-contams2*ymodu(i)+rmed*contams2
      END IF
      IF((xmod(i) >= 932.0_dp).AND.(xmod(i) < 1015.5_dp))THEN
         ymodu(i)=ymodu(i)-contams3*ymodu(i)+rmed*contams3
      END IF
      IF((xmod(i) >= 1015.5_dp).AND.(xmod(i) < 1106.1_dp))THEN
         ymodu(i)=ymodu(i)-contams0*ymodu(i)+rmed*contams0
      END IF
      IF((xmod(i) >= 1106.1_dp).AND.(xmod(i) < 1205.0_dp))THEN
         ymodu(i)=ymodu(i)-contams1*ymodu(i)+rmed*contams1
      END IF
      IF((xmod(i) >= 1205.0_dp).AND.(xmod(i) < 1304.2_dp))THEN
         ymodu(i)=ymodu(i)-contams2*ymodu(i)+rmed*contams2
      END IF
      IF((xmod(i) >= 1304.2_dp).AND.(xmod(i) < 1391.2_dp))THEN
         ymodu(i)=ymodu(i)-contams3*ymodu(i)+rmed*contams3
      END IF
      IF((xmod(i) >= 1391.21_dp).AND.(xmod(i) < 1481.2_dp))THEN
         ymodu(i)=ymodu(i)-contams0*ymodu(i)+rmed*contams0
      END IF
!
!
!      IF((xmod(i) >= 3320.00_dp).AND.(xmod(i) < 3400.0_dp))THEN
!         ymodu(i)=ymodu(i)-contams0*ymodu(i)+rmed*contams0
!      END IF
!      IF((xmod(i) >= 3416.0_dp).AND.(xmod(i) < 3650.0_dp))THEN
!         ymodu(i)=ymodu(i)-contams1*ymodu(i)+rmed*contams1
!      END IF
!
   END DO
!
   DEALLOCATE(xscr,yscr)
!
   RETURN
!
END SUBROUTINE scontaminate
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE setangle(ioutflag,angsum1,angdiff1,tertincl,  &
   tertomega,angsum2,angdiff2,p2incl,p2omega,angsum3,angdiff3,  &
   p3incl,p3omega,angsum4,angdiff4,p4incl,p4omega,angsum5,  &
   angdiff5,p5incl,p5omega,angsum6,angdiff6,p6incl,p6omega,  &
   angsum7,angdiff7,p7incl,p7omega,angsum8,angdiff8,p8incl,  &
   p8omega)
!
!  Sets the inclination and Omega of the planetary orbits
!  if either the sum or difference is not zero.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ioutflag
   REAL(KIND=dp), INTENT(IN)                :: angsum1
   REAL(KIND=dp), INTENT(IN)                :: angdiff1
   REAL(KIND=dp), INTENT(OUT)               :: tertincl
   REAL(KIND=dp), INTENT(OUT)               :: tertomega
   REAL(KIND=dp), INTENT(IN)                :: angsum2
   REAL(KIND=dp), INTENT(IN)                :: angdiff2
   REAL(KIND=dp), INTENT(OUT)               :: p2incl
   REAL(KIND=dp), INTENT(OUT)               :: p2omega
   REAL(KIND=dp), INTENT(IN)                :: angsum3
   REAL(KIND=dp), INTENT(IN)                :: angdiff3
   REAL(KIND=dp), INTENT(OUT)               :: p3incl
   REAL(KIND=dp), INTENT(OUT)               :: p3omega
   REAL(KIND=dp), INTENT(IN)                :: angsum4
   REAL(KIND=dp), INTENT(IN)                :: angdiff4
   REAL(KIND=dp), INTENT(OUT)               :: p4incl
   REAL(KIND=dp), INTENT(OUT)               :: p4omega
   REAL(KIND=dp), INTENT(IN)                :: angsum5
   REAL(KIND=dp), INTENT(IN)                :: angdiff5
   REAL(KIND=dp), INTENT(OUT)               :: p5incl
   REAL(KIND=dp), INTENT(OUT)               :: p5omega
   REAL(KIND=dp), INTENT(IN)                :: angsum6
   REAL(KIND=dp), INTENT(IN)                :: angdiff6
   REAL(KIND=dp), INTENT(OUT)               :: p6incl
   REAL(KIND=dp), INTENT(OUT)               :: p6omega
   REAL(KIND=dp), INTENT(IN)                :: angsum7
   REAL(KIND=dp), INTENT(IN)                :: angdiff7
   REAL(KIND=dp), INTENT(OUT)               :: p7incl
   REAL(KIND=dp), INTENT(OUT)               :: p7omega
   REAL(KIND=dp), INTENT(IN)                :: angsum8
   REAL(KIND=dp), INTENT(IN)                :: angdiff8
   REAL(KIND=dp), INTENT(OUT)               :: p8incl
   REAL(KIND=dp), INTENT(OUT)               :: p8omega
!
   INTEGER :: ilength1,ilength2,iform
!
   CHARACTER(LEN=50) :: instring1,instring2
!
!   If angsum1 and or angdiff1 are not zero, set the inclination
!   and Omega of the body 3 orbit.
!
   iform=0
   IF((ABS(angsum1) > EPSILON(angsum1)).AND.(ABS(angdiff1) &
        >  EPSILON(angdiff1)))THEN
      tertincl=0.5_dp*(angsum1+angdiff1)
      tertomega=angsum1-tertincl
      CALL pnoequalstring('Setting body 3 orbit inclination to',  &
         6,tertincl,instring1,ilength1)
      CALL pnoequalstring('and Omega to',6,tertomega,instring2,ilength2)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),TRIM(instring2)
      ELSE
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),TRIM(instring2)
      END IF
      iform=99
   END IF
!
!   If angsum2 and or angdiff2 are not zero, set the inclination
!   and Omega of the body 4 orbit.
!
   IF((ABS(angsum2) > EPSILON(angsum2)).AND.(ABS(angdiff2)  &
        >  EPSILON(angdiff2)))THEN
      p2incl=0.5_dp*(angsum2+angdiff2)
      p2omega=angsum2-p2incl
      CALL pnoequalstring('Setting body 4 orbit inclination to',  &
         6,p2incl,instring1,ilength1)
      CALL pnoequalstring('and Omega to',6,p2omega,instring2, ilength2)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),TRIM(instring2)
      ELSE
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),TRIM(instring2)
      END IF
      iform=99
   END IF
!
!   If angsum3 and or angdiff3 are not zero, set the inclination
!   and Omega of the body 5 orbit.
!
   IF((ABS(angsum3) > EPSILON(angsum3)).AND.(ABS(angdiff3) &
         > EPSILON(angdiff3)))THEN
      p3incl=0.5_dp*(angsum3+angdiff3)
      p3omega=angsum3-p3incl
      CALL pnoequalstring('Setting body 5 orbit inclination to',  &
         6,p3incl,instring1,ilength1)
      CALL pnoequalstring('and Omega to',6,p3omega,instring2,ilength2)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),TRIM(instring2)
      ELSE
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),TRIM(instring2)
      END IF
      iform=99
   END IF
!
!   If angsum4 and or angdiff4 are not zero, set the inclination
!   and Omega of the body 6 orbit.
!
   IF((ABS(angsum4) > EPSILON(angsum4)).AND.(ABS(angdiff4) &
        > EPSILON(angdiff4)))THEN
      p4incl=0.5_dp*(angsum4+angdiff4)
      p4omega=angsum4-p4incl
      CALL pnoequalstring('Setting body 6 orbit inclination to',  &
         6,p4incl,instring1,ilength1)
      CALL pnoequalstring('and Omega to',6,p4omega,instring2,ilength2)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),TRIM(instring2)
      ELSE
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),TRIM(instring2)
      END IF
      iform=99
   END IF
!
!   If angsum5 and or angdiff5 are not zero, set the inclination
!   and Omega of the body 7 orbit.
!
   IF((ABS(angsum5) > EPSILON(angsum5)).AND.(ABS(angdiff5) &
          > EPSILON(angdiff5)))THEN
      p5incl=0.5_dp*(angsum5+angdiff5)
      p5omega=angsum5-p5incl
      CALL pnoequalstring('Setting body 7 orbit inclination to',  &
         6,p5incl,instring1,ilength1)
      CALL pnoequalstring('and Omega to',6,p5omega,instring2,ilength2)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),TRIM(instring2)
      ELSE
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),TRIM(instring2)
      END IF
      iform=99
   END IF
!
!   If angsum6 and or angdiff6 are not zero, set the inclination
!   and Omega of the body 8 orbit.
!
   IF((ABS(angsum6) > EPSILON(angsum6)).AND.(ABS(angdiff6) &
       > EPSILON(angdiff6)))THEN
      p6incl=0.5_dp*(angsum6+angdiff6)
      p6omega=angsum6-p6incl
      CALL pnoequalstring('Setting body 8 orbit inclination to',  &
         6,p6incl,instring1,ilength1)
      CALL pnoequalstring('and Omega to',6,p6omega,instring2,ilength2)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),TRIM(instring2)
      ELSE
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),TRIM(instring2)
      END IF
      iform=99
   END IF
!
!   If angsum7 and or angdiff7 are not zero, set the inclination
!   and Omega of the body 9 orbit.
!
   IF((ABS(angsum7) > EPSILON(angsum7)).AND.(ABS(angdiff7) &
          > EPSILON(angdiff7)))THEN
      p7incl=0.5_dp*(angsum7+angdiff7)
      p7omega=angsum7-p7incl
      CALL pnoequalstring('Setting body 9 orbit inclination to',  &
         6,p7incl,instring1,ilength1)
      CALL pnoequalstring('and Omega to',6,p7omega,instring2,ilength2)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),TRIM(instring2)
      ELSE
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),TRIM(instring2)
      END IF
      iform=99
   END IF
!
!   If angsum8 and or angdiff8 are not zero, set the inclination
!   and Omega of the body 10 orbit.
!
   IF((ABS(angsum8) > EPSILON(angsum8)).AND.(ABS(angdiff8) &
          > EPSILON(angdiff8)))THEN
      p8incl=0.5_dp*(angsum8+angdiff8)
      p8omega=angsum8-p8incl
      CALL pnoequalstring('Setting body 10 orbit inclination to',  &
         6,p8incl,instring1,ilength1)
      CALL pnoequalstring('and Omega to',6,p8omega,instring2,ilength2)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),TRIM(instring2)
      ELSE
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),TRIM(instring2)
      END IF
      iform=99
   END IF
!
10 FORMAT(/a,1X,'degrees',1X,a,/1X,'degrees.')
20 FORMAT(a,1X,'degrees',1X,a,/1X,'degrees.')
!
   RETURN
!
END SUBROUTINE setangle
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE setbinbinscale(ioutflag,rmass,reff3,reff4,  &
   b2masssum,b2massdiff,bin2q,b2radsum,b2raddiff,  &
   bin2ratrad,bin2m3,bin2m4,bin2r3,bin2r4,separ,bin2separ,  &
   p2period)
!
!   Will set the masses and radii of the stars in the second
!   binary if using binary+binary mode.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ioutflag
   REAL(KIND=dp), INTENT(OUT)               :: rmass(10)
   REAL(KIND=dp), INTENT(OUT)               :: reff3
   REAL(KIND=dp), INTENT(OUT)               :: reff4
   REAL(KIND=dp), INTENT(IN)                :: b2masssum
   REAL(KIND=dp), INTENT(IN)                :: b2massdiff
   REAL(KIND=dp), INTENT(IN)                :: bin2q
   REAL(KIND=dp), INTENT(IN)                :: b2radsum
   REAL(KIND=dp), INTENT(IN)                :: b2raddiff
   REAL(KIND=dp), INTENT(IN)                :: bin2ratrad
   REAL(KIND=dp), INTENT(IN)                :: bin2m3
   REAL(KIND=dp), INTENT(IN)                :: bin2m4
   REAL(KIND=dp), INTENT(IN)                :: bin2r3
   REAL(KIND=dp), INTENT(IN)                :: bin2r4
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(OUT)               :: bin2separ
   REAL(KIND=dp), INTENT(IN)                :: p2period
!
   REAL(KIND=dp)  :: p,q
!
   INTEGER :: ilength2,ilength3,ilength4,ilength1,isetmass,isetrad
!
   CHARACTER (LEN=40) :: instring1,instring2,instring3,instring4
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   isetmass=0
   isetrad=0
!
!   If b2masssum > 0, then set the masses
!
   IF(b2masssum > 0.0_dp)THEN
      IF(bin2q <= 0.0_dp)THEN
         rmass(3)=0.5_dp*(b2masssum+b2massdiff)
         rmass(4)=b2masssum-rmass(3)
         CALL pnoequalstring('bin2masssum fixed at',6,b2masssum,  &
            instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('bin2massdiff fixed at',4,  &
            b2massdiff,instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('M_3 set to',6,rmass(3),instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('M_4 set to',6,rmass(4),instring4,ilength4)
!         k4=lnblnk(instring4)
         IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4)
         isetmass=99
      ELSE
         rmass(3)=b2masssum/(1.0_dp+bin2q)
         rmass(4)=b2masssum-rmass(3)
         CALL pnoequalstring('bin2masssum fixed at',6,b2masssum,  &
            instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('bin2mQ fixed at',4,bin2q,instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('M_3 set to',6,rmass(3),instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('M_4 set to',6,rmass(4),instring4,ilength4)
!         k4=lnblnk(instring4)
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4)
         isetmass=99
      END IF
   END IF
!
!   If b2radsum > 0, then set the radii
!
   IF(b2radsum > 0.0_dp)THEN
      IF(bin2ratrad <= 0.0_dp)THEN
         reff3=0.5_dp*(b2radsum+b2raddiff)
         reff4=b2radsum-reff3
         CALL pnoequalstring('bin2radsum fixed at',6,b2radsum,  &
            instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('bin2raddiff fixed at',4,b2raddiff,  &
            instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('R_3 set to',6,reff3,instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('R_4 set to',6,reff4,instring4,ilength4)
!         k4=lnblnk(instring4)
         IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4)
         isetrad=99
      ELSE
         reff4=b2radsum/(1.0_dp+bin2ratrad)
         reff3=b2radsum-reff4
         CALL pnoequalstring('bin2radsum fixed at',6,b2radsum,  &
            instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('bin2ratrad fixed at',4,bin2ratrad,  &
            instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('R_3 set to',6,reff3,instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('R_4 set to',6,reff4,instring4,ilength4)
!         k4=lnblnk(instring4)
         IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4)
         isetrad=99
      END IF
      reff3=reff3/separ
      reff4=reff4/separ
   END IF
!
!  if the mass has not been set, then check values
!  of bin2M3 and bin2M4
!
!  bin2M3 > 0, bin2M4 = 0, bin2Q > 0
!
   IF(isetmass == 0)THEN
      IF((bin2m3 > 0.0_dp).AND.(bin2m4 <= 0.0_dp).AND.(bin2q > 0.0_dp))THEN
         rmass(3)=bin2m3
         rmass(4)=rmass(3)*bin2q
         CALL pnoequalstring('bin2M3 fixed at',6,bin2m3,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('bin2Q fixed at',4,bin2q,instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('M_3 set to',6,rmass(3),instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('M_4 set to',6,rmass(4),instring4,ilength4)
!         k4=lnblnk(instring4)
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4)
         isetmass=99
      END IF
   END IF
!
!  bin2M4 > 0, bin2M3 = 0, bin2Q > 0
!
   IF(isetmass == 0)THEN
      IF((bin2m4 > 0.0_dp).AND.(bin2m3 <= 0.0_dp).AND.(bin2q > 0.0_dp))THEN
         rmass(4)=bin2m4
         rmass(3)=rmass(4)/bin2q
         CALL pnoequalstring('bin2M4 fixed at',6,bin2m4,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('bin2Q fixed at',4,bin2q,instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('M_3 set to',6,rmass(3),instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('M_4 set to',6,rmass(4),instring4,ilength4)
!         k4=lnblnk(instring4)
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4)
         isetmass=99
      END IF
   END IF
!
!  bin2M3 > 0, bin2M4 > 0, bin2Q = 0
!
   IF(isetmass == 0)THEN
      IF((bin2m3 > 0.0_dp).AND.(bin2m4 > 0.0_dp).AND.(bin2q <= 0.0_dp))THEN
         rmass(3)=bin2m3
         rmass(4)=bin2m4
         CALL pnoequalstring('bin2M3 fixed at',6,bin2m3,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('bin2M4 fixed at',4,bin2m4,instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('M_3 set to',6,rmass(3),instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('M_4 set to',6,rmass(4),instring4,ilength4)
!         k4=lnblnk(instring4)
         IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4)
         isetmass=99
      END IF
   END IF
!
!  bin2M3 > 0, bin2M4 = 0, bin2Q = 0
!
   IF(isetmass == 0)THEN
      IF((bin2m3 > 0.0_dp).AND.(bin2m4 <= 0.0_dp).AND.(bin2q <= 0.0_dp))THEN
         rmass(3)=bin2m3
         CALL pnoequalstring('bin2M3 fixed at',6,bin2m3,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('M_3 set to',6,rmass(3),instring3,ilength3)
!         k3=lnblnk(instring3)
         IF(ioutflag == 1)WRITE(2,50)TRIM(instring1),TRIM(instring3)
      END IF
   END IF
!
!  bin2M4 > 0, bin2M3 = 0, bin2Q = 0
!
   IF(isetmass == 0)THEN
      IF((bin2m4 > 0.0_dp).AND.(bin2m3 <= 0.0_dp).AND.(bin2q <= 0.0_dp))THEN
         rmass(4)=bin2m4
         CALL pnoequalstring('bin2M4 fixed at',6,bin2m4,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('M_4 set to',6,rmass(4),instring3,ilength3)
!         k3=lnblnk(instring3)
         IF(ioutflag == 1)WRITE(2,50)TRIM(instring1),TRIM(instring3)
      END IF
   END IF
!
!  if the radius has not been set, then check values
!  of bin2R3 and bin2R4
!
!  bin2R3 > 0, bin2R4 = 0, bin2ratrad > 0
!
   IF(isetrad == 0)THEN
      IF((bin2r3 > 0.0_dp).AND.(bin2r4 <= 0.0_dp).AND.(bin2ratrad > 0.0_dp))THEN
         reff3=bin2r3
         reff4=reff3/bin2ratrad
         CALL pnoequalstring('bin2R3 fixed at',6,bin2r3,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('bin2ratrad fixed at',4,bin2ratrad,  &
            instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('R_3 set to',6,reff3,instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('R_4 set to',6,reff4,instring4,ilength4)
!         k4=lnblnk(instring4)
         IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4)
         isetrad=99
         reff3=reff3/separ
         reff4=reff4/separ
      END IF
   END IF
!
!  bin2R4 > 0, bin2R3 = 0, bin2ratrad > 0
!
   IF(isetrad == 0)THEN
      IF((bin2r4 > 0.0_dp).AND.(bin2r3 <= 0.0_dp).AND.(bin2ratrad > 0.0_dp))THEN
         reff4=bin2r4
         reff3=reff4*bin2ratrad
         CALL pnoequalstring('bin2R4 fixed at',6,bin2r4,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('bin2ratrad fixed at',4,bin2ratrad,  &
            instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('R_3 set to',6,reff3,instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('R_4 set to',6,reff4,instring4,ilength4)
!         k4=lnblnk(instring4)
         IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4)
         isetrad=99
         reff3=reff3/separ
         reff4=reff4/separ
      END IF
   END IF
!
!  bin2R3 > 0, bin2R4 > 0, bin2ratrad = 0
!
   IF(isetrad == 0)THEN
      IF((bin2r3 > 0.0_dp).AND.(bin2r4 > 0.0_dp).AND.(bin2ratrad <= 0.0_dp))THEN
         reff3=bin2r3
         reff4=bin2r4
         CALL pnoequalstring('bin2R3 fixed at',6,bin2r3,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('bin2R4 fixed at',4,bin2r4,instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('R_3 set to',6,reff3,instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('R_4 set to',6,reff4,instring4,ilength4)
!         k4=lnblnk(instring4)
         IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4)
         isetrad=99
         reff3=reff3/separ
         reff4=reff4/separ
      END IF
   END IF
!
!  bin2R3 > 0, bin2R4 = 0, bin2ratrad = 0
!
   IF(isetrad == 0)THEN
      IF((bin2r3 > 0.0_dp).AND.(bin2r4 <= 0.0_dp).AND.(bin2ratrad <= 0.0_dp))THEN
         reff3=bin2r3
         CALL pnoequalstring('bin2R3 fixed at',6,bin2r3,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('R_3 set to',6,reff3,instring3,ilength3)
!         k3=lnblnk(instring3)
         IF(ioutflag == 1)WRITE(2,60)TRIM(instring1),TRIM(instring3)
         reff3=reff3/separ
      END IF
   END IF
!
!  bin2R4 > 0, bin2R3 = 0, bin2ratrad = 0
!
   IF(isetrad == 0)THEN
      IF((bin2r4 > 0.0_dp).AND.(bin2r3 <= 0.0_dp).AND.(bin2ratrad <= 0.0_dp))THEN
         reff4=bin2r4
         CALL pnoequalstring('bin2R4 fixed at',6,bin2r4,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('R_4 set to',6,reff4,instring3,ilength3)
!         k3=lnblnk(instring3)
         IF(ioutflag == 1)WRITE(2,60)TRIM(instring1),TRIM(instring3)
         reff4=reff4/separ
      END IF
   END IF
!
!   Need to find semimajor axis of the second binary
!
   q=rmass(4)/rmass(3)
   p=p2period*secinday
   bin2separ=(gmsun*p*p*rmass(3)*(1.0_dp+q)/(fourpiesquared))**(1.0_dp/3.0_dp)
   bin2separ=bin2separ/solarrad
!
10 FORMAT(/'binary+binary mode:',/1X,a,1X,'solar masses and',1X,  &
      a,/1X,'solar masses.',1X,a,1X,'solar masses and',/1X,a,1X,'s'  &
      ,'olar masses.',/1X,a,1X,'solar masses.')
20 FORMAT(/'binary+binary mode:',/1X,a,1X,'solar masses and',1X,  &
      a,'.',/1X,a,1X,'solar masses and',1X,a,1X,'solar masses.',/  &
      1X,a,1X,'solar masses.')
30 FORMAT(/'binary+binary mode:',/1X,a,1X,'solar radii and',1X,a,  &
      /1X,'solar radii.',1X,a,1X,'solar radii and',/1X,a,1X,'solar'  &
      ,' radii.',/1X,a,1X,'solar radii.')
40 FORMAT(/'binary+binary mode:',/1X,a,1X,'solar radii and',1X,a,  &
      '.',/1X,a,1X,'solar radii and',1X,a,1X,'solar radii.',/1X,a,  &
      1X,'solar radii.')
50 FORMAT(/'binary+binary mode:',/1X,a,1X,'solar masses,',1X,a,  &
      1X,'solar masses.')
60 FORMAT(/'binary+binary mode:',/1X,a,1X,'solar radii,',1X,a,1X,  &
      'solar radi.')
!
   RETURN
!
END SUBROUTINE setbinbinscale
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE setdensity(fill1,omega,bdist,q,period,density,  &
   tidephi,itide,ecc,thetamis,phimis,ioutflag)
!
!   October 10, 2008
!
!   This a new subroutine to set the mass ratio given the fill factor
!   and density.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE

   REAL(KIND=dp), INTENT(IN)                :: fill1
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(OUT)               :: q
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(IN)                :: density
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   INTEGER, INTENT(IN)                      :: itide
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp)  :: p,ddd,qhigh,overqh,x,x0h,y,z,fhigh,qlow,overql
   REAL(KIND=dp)  :: savepsi0,qmid,overqm,coy,psiz,psiy,psix,psixx,psi,x0l,fmid
   REAL(KIND=dp)  :: reffhigh,x0m,refflow,cox,reffmid,denhigh,denmid
!
   INTEGER :: icount
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmassinsolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   p=period*secinday
   ddd=density*1000.0_dp
!
!   Have an ititial guess at Q
!
   qhigh=0.1_dp
   overqh=qhigh
   qlow=1.0E-20_dp
   overql=qlow
   icount=1
10 qmid=0.5_dp*(qhigh+qlow)
   overqh=qhigh
   overqm=qmid
   overql=qlow
!
   CALL findl1(overqh,omega,x0h,1,bdist,tidephi,ecc,thetamis,phimis)
!
   x=fill1*x0h
   y=0.0_dp
   z=0.0_dp
!
   CALL poten(overqh,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,  &
      bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
   savepsi0=psi
   CALL findradius(overqh,omega,savepsi0,x0h*fill1,bdist,  &
      reffhigh,tidephi,itide,ecc,thetamis,phimis)
   CALL findl1(overql,omega,x0l,1,bdist,tidephi,ecc,thetamis,phimis)
!
   x=fill1*x0l
   y=0.0_dp
   z=0.0_dp
   CALL poten(overql,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,  &
      bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
   savepsi0=psi
   CALL findradius(overql,omega,savepsi0,x0l*fill1,bdist,  &
      refflow,tidephi,itide,ecc,thetamis,phimis)
   CALL findl1(overqm,omega,x0m,1,bdist,tidephi,ecc,thetamis,phimis)
!
   x=fill1*x0m
   y=0.0_dp
   z=0.0_dp
   CALL poten(overqm,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,  &
      bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
   savepsi0=psi
   CALL findradius(overqm,omega,savepsi0,x0m*fill1,bdist,  &
      reffmid,tidephi,itide,ecc,thetamis,phimis)
   denhigh=3.0_dp*pie*solarmass/(reffhigh**3*gmsun*p*p*(1.0_dp+ qhigh))
   denmid=3.0_dp*pie*solarmass/(reffmid**3*gmsun*p*p*(1.0_dp+qmid))
!
   fmid=denmid-ddd
   fhigh=denhigh-ddd
   IF(fhigh*fmid > 0.0_dp)THEN
      qhigh=qmid
   ELSE
      qlow=qmid
   END IF
   icount=icount+1
   q=qmid
!
   IF((ABS(fmid) > 1.0E-12_dp).AND.(icount <= 200))GO TO 10
!
   IF(fmid <= 1.0E-12_dp)THEN
      IF(ioutflag >= 1)WRITE(2,20)density,fill1,q
   ELSE
      IF(ioutflag >= 1)WRITE(2,30)density,fill1,q
   END IF
!
20 FORMAT('Info:  density = ',f7.5,' g/cc and fill1 = ',f7.5/,' '  &
      ,'      The mass ratio has been set to ',1PE16.9)
30 FORMAT('Warning:  a density of ',f7.5,' g/cc and fill1 = ',f7.  &
      5/,'         is not possible.','  The mass ratio has been se'  &
      ,'t to ',1PE16.9)
   RETURN
!
END SUBROUTINE setdensity
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE setfill(istar,q,fill,radfill,omega,bdist,tidephi,  &
   itide,ecc,thetamis,phimis,ioutflag)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(OUT)               :: fill
   REAL(KIND=dp), INTENT(IN)                :: radfill
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   INTEGER, INTENT(IN)                      :: itide
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp)  :: overq,fbig,fsmall,x,y,z,cox,coy,savepsi0,psi
   REAL(KIND=dp)  :: reff,fnew,reffnew,psiz,psiy,psixx,psix,x0,reffa
!
   INTEGER :: i
!
   IF(radfill >= 1.0_dp)RETURN
   IF(radfill <= 0.0_dp)RETURN
!
   overq=q
   IF(istar == 2)overq=1.0_dp/q
!
   fbig=1.0_dp
   fsmall=0.0E-08_dp
!
!   First, find the distance to L1.
!
   CALL findl1(overq,omega,x0,1,bdist,tidephi,ecc,thetamis,phimis)
!
   x=x0
   y=0.0_dp
   z=0.0_dp
!
!   UPDATE November 14, 2009
!
!   initialize cox and coy for the routine that computes the tidal
!   equilibrium option.
!
   cox=1.0_dp
   coy=0.0_dp
   CALL poten(overq,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,  &
      bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
   savepsi0=psi
   CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
      itide,ecc,thetamis,phimis)
   reffa=reff
   CALL findl1(overq,omega,x0,1,bdist,tidephi,ecc,thetamis,phimis)
   x=x0*fsmall
   y=0.0_dp
   z=0.0_dp
   CALL poten(overq,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,  &
      bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
   savepsi0=psi
   CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
      itide,ecc,thetamis,phimis)
!
   DO  i=1,20
      fnew=0.5_dp*(fbig+fsmall)
      CALL findl1(overq,omega,x0,1,bdist,tidephi,ecc,thetamis,phimis)
      x=x0*fnew
      y=0.0_dp
      z=0.0_dp
      CALL poten(overq,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,  &
         bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
      savepsi0=psi
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      reffnew=reff
      IF((reffa*radfill-reffnew) > 0.0_dp)THEN
         fsmall=fnew
      ELSE
         fbig=fnew
      END IF
   END DO
!
   fill=fnew
   IF(ioutflag == 1)THEN
      IF(istar == 1)WRITE(2,20)radfill,fill
      IF(istar == 2)WRITE(2,30)radfill,fill
   END IF
!
20 FORMAT('Info:  radfill1 = ',f10.8,', fill1 set to ',f10.8)
30 FORMAT('Info:  radfill2 = ',f10.8,', fill2 set to ',f10.8)
!
   RETURN
!
END SUBROUTINE setfill
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE setperiod(ioutflag,isw28,itconj,period,tconj,  &
   pbmtc,pbptc,tertperiod,tertconj,p1mtc,p1ptc,p2period,p2mtc,  &
   p2ptc,p2tconj,p3period,p3mtc,p3ptc,p3tconj,p4period,p4mtc,  &
   p4ptc,p4tconj,p5period,p5mtc,p5ptc,p5tconj,p6period,p6mtc,  &
   p6ptc,p6tconj,p7period,p7mtc,p7ptc,p7tconj,p8period,p8mtc,  &
   p8ptc,p8tconj,binqtc,p1qtc,p2qtc,p3qtc,p4qtc,p5qtc,p6qtc,  &
   p7qtc,p8qtc,tbinoff,t1off,t2off,t3off,t4off,t5off,t6off,  &
   t7off,t8off)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ioutflag
   INTEGER, INTENT(OUT)                     :: isw28
   INTEGER, INTENT(OUT)                     :: itconj
   REAL(KIND=dp), INTENT(IN OUT)            :: period
   REAL(KIND=dp), INTENT(OUT)               :: tconj
   REAL(KIND=dp), INTENT(IN)                :: pbmtc
   REAL(KIND=dp), INTENT(IN)                :: pbptc
   REAL(KIND=dp), INTENT(IN OUT)            :: tertperiod
   REAL(KIND=dp), INTENT(OUT)               :: tertconj
   REAL(KIND=dp), INTENT(IN)                :: p1mtc
   REAL(KIND=dp), INTENT(IN)                :: p1ptc
   REAL(KIND=dp), INTENT(IN OUT)            :: p2period
   REAL(KIND=dp), INTENT(IN)                :: p2mtc
   REAL(KIND=dp), INTENT(IN)                :: p2ptc
   REAL(KIND=dp), INTENT(OUT)               :: p2tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p3period
   REAL(KIND=dp), INTENT(IN)                :: p3mtc
   REAL(KIND=dp), INTENT(IN)                :: p3ptc
   REAL(KIND=dp), INTENT(OUT)               :: p3tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p4period
   REAL(KIND=dp), INTENT(IN)                :: p4mtc
   REAL(KIND=dp), INTENT(IN)                :: p4ptc
   REAL(KIND=dp), INTENT(OUT)               :: p4tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p5period
   REAL(KIND=dp), INTENT(IN)                :: p5mtc
   REAL(KIND=dp), INTENT(IN)                :: p5ptc
   REAL(KIND=dp), INTENT(OUT)               :: p5tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p6period
   REAL(KIND=dp), INTENT(IN)                :: p6mtc
   REAL(KIND=dp), INTENT(IN)                :: p6ptc
   REAL(KIND=dp), INTENT(OUT)               :: p6tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p7period
   REAL(KIND=dp), INTENT(IN)                :: p7mtc
   REAL(KIND=dp), INTENT(IN)                :: p7ptc
   REAL(KIND=dp), INTENT(OUT)               :: p7tconj
   REAL(KIND=dp), INTENT(IN OUT)            :: p8period
   REAL(KIND=dp), INTENT(IN)                :: p8mtc
   REAL(KIND=dp), INTENT(IN)                :: p8ptc
   REAL(KIND=dp), INTENT(OUT)               :: p8tconj
   REAL(KIND=dp), INTENT(IN)                :: binqtc
   REAL(KIND=dp), INTENT(IN)                :: p1qtc
   REAL(KIND=dp), INTENT(IN)                :: p2qtc
   REAL(KIND=dp), INTENT(IN)                :: p3qtc
   REAL(KIND=dp), INTENT(IN)                :: p4qtc
   REAL(KIND=dp), INTENT(IN)                :: p5qtc
   REAL(KIND=dp), INTENT(IN)                :: p6qtc
   REAL(KIND=dp), INTENT(IN)                :: p7qtc
   REAL(KIND=dp), INTENT(IN)                :: p8qtc
   REAL(KIND=dp), INTENT(IN)                :: tbinoff
   REAL(KIND=dp), INTENT(IN)                :: t1off
   REAL(KIND=dp), INTENT(IN)                :: t2off
   REAL(KIND=dp), INTENT(IN)                :: t3off
   REAL(KIND=dp), INTENT(IN)                :: t4off
   REAL(KIND=dp), INTENT(IN)                :: t5off
   REAL(KIND=dp), INTENT(IN)                :: t6off
   REAL(KIND=dp), INTENT(IN)                :: t7off
   REAL(KIND=dp), INTENT(IN)                :: t8off
!
   REAL(KIND=dp)  :: you1,you2
!
   INTEGER :: ilength1,ilength2,iform,ilength3,ilength4
!
   CHARACTER(LEN=40) :: instring1,instring2,instring3,instring4
!
!  If PbpTc or PbmTc are non-zero, set the binary period
!  and value of Tc.
!
   iform=0
   IF((binqtc >= -1.0_dp).AND.(binqtc <= 1.0_dp))THEN
      isw28=1
      you1=(1.0_dp+0.5_dp*binqtc)*period
      you2=(1.0_dp-0.5_dp*binqtc)*period
      period=0.5_dp*(you1+you2)
      tconj=0.5_dp*(you1-you2)+tbinoff
      CALL pnoequalstring('binqTc =',6,binqtc,instring1,ilength1)
      CALL pnoequalstring('setting binary period to',6,period,instring2,ilength2)
      CALL pnoequalstring('and the conjunction time to',6,tconj,  &
         instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),'binqTc'
      iform=99
   ELSE
      IF((ABS(pbmtc) > EPSILON(pbmtc)).OR.(ABS(pbptc) &
             > EPSILON(pbptc)))THEN
         isw28=1
         period=0.5_dp*(pbmtc+pbptc)
         tconj=pbptc-period
         CALL pnoequalstring('PbmTc =',6,pbmtc,instring1,ilength1)
         CALL pnoequalstring('PbpTc =',6,pbptc,instring2,ilength2)
         CALL pnoequalstring('setting binary period to',6,period,  &
            instring3,ilength3)
         CALL pnoequalstring('and the conjunction time to',6,  &
            tconj,instring4,ilength4)
         IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4),'PbmTc','PbpTc'
         iform=99
      END IF
   END IF
!
!  Do the same for P1pTc and P1mTc (body 3 orbit).
!
   IF((p1qtc >= -1.0_dp).AND.(p1qtc <= 1.0_dp))THEN
      itconj=1
      you1=(1.0_dp+0.5_dp*p1qtc)*tertperiod
      you2=(1.0_dp-0.5_dp*p1qtc)*tertperiod
      tertperiod=0.5_dp*(you1+you2)
      tertconj=0.5_dp*(you1-you2)+t1off
      CALL pnoequalstring('P1qTc =',6,p1qtc,instring1,ilength1)
      CALL pnoequalstring('setting body 3 period to',6,  &
         tertperiod,instring2,ilength2)
      CALL pnoequalstring('and the conjunction time to',6,  &
         tertconj,instring3,ilength3)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,10)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P1qTc'
      ELSE
         IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P1qTc'
      END IF
      iform=99
   ELSE
      IF((ABS(p1mtc) > EPSILON(p1mtc)).OR.(ABS(p1ptc) &
           > EPSILON(p1ptc)))THEN
         itconj=1
         tertperiod=0.5_dp*(p1mtc+p1ptc)
         tertconj=p1ptc-tertperiod
         CALL pnoequalstring('P1mTc =',6,p1mtc,instring1,ilength1)
         CALL pnoequalstring('P1pTc =',6,p1ptc,instring2,ilength2)
         CALL pnoequalstring('setting body 3 period to',6,  &
            tertperiod,instring3,ilength3)
         CALL pnoequalstring('and the conjunction time to',6,  &
            tertconj,instring4,ilength4)
         IF(iform == 0)THEN
            IF(ioutflag == 1)WRITE(2,20)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P1mTc','P1pTc'
         ELSE
            IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P1mTc','P1pTc'
         END IF
         iform=99
      END IF
   END IF
!
!  Do the same for P2pTc and P2mTc (body 4 orbit).
!
   IF((p2qtc >= -1.0_dp).AND.(p2qtc <= 1.0_dp))THEN
      itconj=1
      you1=(1.0_dp+0.5_dp*p2qtc)*p2period
      you2=(1.0_dp-0.5_dp*p2qtc)*p2period
      p2period=0.5_dp*(you1+you2)
      p2tconj=0.5_dp*(you1-you2)+t2off
      CALL pnoequalstring('P2qTc =',6,p2qtc,instring1,ilength1)
      CALL pnoequalstring('Setting body 4 period to',6,p2period,  &
         instring2,ilength2)
      CALL pnoequalstring('and the conjunction time to',6,  &
         p2tconj,instring3,ilength3)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P2qTc'
      ELSE
         IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P2qTc'
      END IF
      iform=99
   ELSE
      IF((ABS(p2mtc) > EPSILON(p2mtc)).OR.(ABS(p2ptc) &
           > EPSILON(p2ptc)))THEN
         itconj=1
         p2period=0.5_dp*(p2mtc+p2ptc)
         p2tconj=p2ptc-p2period
         CALL pnoequalstring('P2mTc =',6,p2mtc,instring1,ilength1)
         CALL pnoequalstring('P2pTc =',6,p2ptc,instring2,ilength2)
         CALL pnoequalstring('setting body 4 period to',6,  &
            p2period,instring3,ilength3)
         CALL pnoequalstring('and the conjunction time to',6,  &
            p2tconj,instring4,ilength4)
         IF(iform == 0)THEN
            IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P2mTc','P2pTc'
         ELSE
            IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P2mTc','P2pTc'
         END IF
         iform=99
      END IF
   END IF
!
!  Do the same for P3pTc and P3mTc (body 5 orbit).
!
   IF((p3qtc >= -1.0_dp).AND.(p3qtc <= 1.0_dp))THEN
      itconj=1
      you1=(1.0_dp+0.5_dp*p3qtc)*p3period
      you2=(1.0_dp-0.5_dp*p3qtc)*p3period
      p3period=0.5_dp*(you1+you2)
      p3tconj=0.5_dp*(you1-you2)+t3off
      CALL pnoequalstring('P3qTc =',6,p3qtc,instring1,ilength1)
      CALL pnoequalstring('setting body 5 period to',6,p3period,  &
         instring2,ilength2)
      CALL pnoequalstring('and the conjunction time to',6,  &
         p3tconj,instring3,ilength3)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P3qTc'
      ELSE
         IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P3qTc'
      END IF
      iform=99
   ELSE
      IF((ABS(p3mtc) > EPSILON(p3mtc)).OR.(ABS(p3ptc)  &
           > EPSILON(p3ptc)))THEN
         itconj=1
         p3period=0.5_dp*(p3mtc+p3ptc)
         p3tconj=p3ptc-p3period
         CALL pnoequalstring('P3mTc =',6,p3mtc,instring1,ilength1)
         CALL pnoequalstring('P3pTc =',6,p3ptc,instring2,ilength2)
         CALL pnoequalstring('setting body 5 period to',6,  &
            p3period,instring3,ilength3)
         CALL pnoequalstring('and the conjunction time to',6,  &
            p3tconj,instring4,ilength4)
         IF(iform == 0)THEN
            IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P3mTc','P3pTc'
         ELSE
            IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P3mTc','P3pTc'
         END IF
         iform=99
      END IF
   END IF
!
!  Do the same for P4pTc and P4mTc (body 6 orbit).
!
   IF((p4qtc >= -1.0_dp).AND.(p4qtc <= 1.0_dp))THEN
      itconj=1
      you1=(1.0_dp+0.5_dp*p4qtc)*p4period
      you2=(1.0_dp-0.5_dp*p4qtc)*p4period
      p4period=0.5_dp*(you1+you2)
      p4tconj=0.5_dp*(you1-you2)+t4off
      CALL pnoequalstring('P4qTc =',6,p4qtc,instring1,ilength1)
      CALL pnoequalstring('setting body 6 period to',6,p4period,  &
         instring2,ilength2)
      CALL pnoequalstring('and the conjunction time to',6,  &
         p4tconj,instring3,ilength3)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P4qTc'
      ELSE
         IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P4qTc'
      END IF
      iform=99
   ELSE
      IF((ABS(p4mtc) > EPSILON(p4mtc)).OR.(ABS(p4ptc) &
           > EPSILON(p4mtc)))THEN
         itconj=1
         p4period=0.5_dp*(p4mtc+p4ptc)
         p4tconj=p4ptc-p4period
         CALL pnoequalstring('P4mTc =',6,p4mtc,instring1,ilength1)
         CALL pnoequalstring('P4pTc =',6,p4ptc,instring2,ilength2)
         CALL pnoequalstring('setting body 6 period to',6,  &
            p4period,instring3,ilength3)
         CALL pnoequalstring('and the conjunction time to',6,  &
            p4tconj,instring4,ilength4)
         IF(iform == 0)THEN
            IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P4mTc','P4pTc'
         ELSE
            IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P4mTc','P4pTc'
         END IF
         iform=99
      END IF
   END IF
!
!  Do the same for P5pTc and P5mTc (body 7 orbit).
!
   IF((p5qtc >= -1.0_dp).AND.(p5qtc <= 1.0_dp))THEN
      itconj=1
      you1=(1.0_dp+0.5_dp*p5qtc)*p5period
      you2=(1.0_dp-0.5_dp*p5qtc)*p5period
      p5period=0.5_dp*(you1+you2)
      p5tconj=0.5_dp*(you1-you2)+t5off
      CALL pnoequalstring('P5qTc =',6,p5qtc,instring1,ilength1)
      CALL pnoequalstring('setting body 7 period to',6,p5period,  &
         instring2,ilength2)
      CALL pnoequalstring('and the conjunction time to',6,  &
         p5tconj,instring3,ilength3)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P5qTc'
      ELSE
         IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P5qTc'
      END IF
      iform=99
   ELSE
      IF((ABS(p5mtc) > EPSILON(p5mtc)).OR.(ABS(p5ptc)  &
           > EPSILON(p5ptc)))THEN
         itconj=1
         p5period=0.5_dp*(p5mtc+p5ptc)
         p5tconj=p5ptc-p5period
         CALL pnoequalstring('P5mTc =',6,p5mtc,instring1,ilength1)
         CALL pnoequalstring('P5pTc =',6,p5ptc,instring2,ilength2)
         CALL pnoequalstring('setting body 7 period to',6,  &
            p5period,instring3,ilength3)
         CALL pnoequalstring('and the conjunction time to',6,  &
            p5tconj,instring4,ilength4)
         IF(iform == 0)THEN
            IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P5mTc','P5pTc'
         ELSE
            IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P5mTc','P5pTc'
         END IF
         iform=99
      END IF
   END IF
!
!  Do the same for P6pTc and P6mTc (body 8 orbit).
!
   IF((p6qtc >= -1.0_dp).AND.(p6qtc <= 1.0_dp))THEN
      itconj=1
      you1=(1.0_dp+0.5_dp*p6qtc)*p6period
      you2=(1.0_dp-0.5_dp*p6qtc)*p6period
      p6period=0.5_dp*(you1+you2)
      p6tconj=0.5_dp*(you1-you2)+t6off
      CALL pnoequalstring('P6qTc =',6,p6qtc,instring1,ilength1)
      CALL pnoequalstring('setting body 8 period to',6,p6period,  &
         instring2,ilength2)
      CALL pnoequalstring('and the conjunction time to',6,  &
         p6tconj,instring3,ilength3)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P6qTc'
      ELSE
         IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P6qTc'
      END IF
      iform=99
   ELSE
      IF((ABS(p6mtc) > EPSILON(p6mtc)).OR.(ABS(p6ptc) &
          >  EPSILON(p6ptc)))THEN
         itconj=1
         p6period=0.5_dp*(p6mtc+p6ptc)
         p6tconj=p6ptc-p6period
         CALL pnoequalstring('P6mTc =',6,p6mtc,instring1,ilength1)
         CALL pnoequalstring('P6pTc =',6,p6ptc,instring2,ilength2)
         CALL pnoequalstring('setting body 8 period to',6,  &
            p6period,instring3,ilength3)
         CALL pnoequalstring('and the conjunction time to',6,  &
            p6tconj,instring4,ilength4)
         IF(iform == 0)THEN
            IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P6mTc','P6pTc'
         ELSE
            IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P6mTc','P6pTc'
         END IF
         iform=99
      END IF
   END IF
!
!  Do the same for P7pTc and P7mTc (body 9 orbit).
!
   IF((p7qtc >= -1.0_dp).AND.(p7qtc <= 1.0_dp))THEN
      itconj=1
      you1=(1.0_dp+0.5_dp*p7qtc)*p7period
      you2=(1.0_dp-0.5_dp*p7qtc)*p7period
      p7period=0.5_dp*(you1+you2)
      p7tconj=0.5_dp*(you1-you2)+t7off
      CALL pnoequalstring('P7qTc =',6,p7qtc,instring1,ilength1)
      CALL pnoequalstring('setting body 9 period to',6,p7period,  &
         instring2,ilength2)
      CALL pnoequalstring('and the conjunction time to',6,  &
         p7tconj,instring3,ilength3)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P7qTc'
      ELSE
         IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P7qTc'
      END IF
      iform=99
   ELSE
      IF((ABS(p7mtc) > EPSILON(p7mtc)).OR.(ABS(p7ptc)  &
          >  EPSILON(p7ptc)))THEN
         itconj=1
         p7period=0.5_dp*(p7mtc+p7ptc)
         p7tconj=p7ptc-p7period
         CALL pnoequalstring('P7mTc =',6,p7mtc,instring1,ilength1)
         CALL pnoequalstring('P7pTc =',6,p7ptc,instring2,ilength2)
         CALL pnoequalstring('setting body 9 period to',6,  &
            p7period,instring3,ilength3)
         CALL pnoequalstring('and the conjunction time to',6,  &
            p7tconj,instring4,ilength4)
         IF(iform == 0)THEN
            IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P7mTc','P7pTc'
         ELSE
            IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P7mTc','P7pTc'
         END IF
         iform=99
      END IF
   END IF
!
!  Do the same for P8pTc and P8mTc (body 10 orbit).
!
   IF((p8qtc >= -1.0_dp).AND.(p8qtc <= 1.0_dp))THEN
      itconj=1
      you1=(1.0_dp+0.5_dp*p8qtc)*p8period
      you2=(1.0_dp-0.5_dp*p8qtc)*p8period
      p8period=0.5_dp*(you1+you2)
      p8tconj=0.5_dp*(you1-you2)+t8off
      CALL pnoequalstring('P8qTc =',6,p8qtc,instring1,ilength1)
      CALL pnoequalstring('setting body 10 period to',6,p8period,  &
         instring2,ilength2)
      CALL pnoequalstring('and the conjunction time to',6,  &
         p8tconj,instring3,ilength3)
      IF(iform == 0)THEN
         IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P8qTc'
      ELSE
         IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),'P8qTc'
      END IF
      iform=99
   ELSE
      IF((ABS(p8mtc) > EPSILON(p8mtc)).OR.(ABS(p8ptc) &
            > EPSILON(p8ptc)))THEN
         itconj=1
         p8period=0.5_dp*(p8mtc+p8ptc)
         p8tconj=p8ptc-p8period
         CALL pnoequalstring('P8mTc =',6,p8mtc,instring1,ilength1)
         CALL pnoequalstring('P8pTc =',6,p8ptc,instring2,ilength2)
         CALL pnoequalstring('setting body 10 period to',6,  &
            p8period,instring3,ilength3)
         CALL pnoequalstring('and the conjunction time to',6,  &
            p8tconj,instring4,ilength4)
         IF(iform == 0)THEN
            IF(ioutflag == 1)WRITE(2,30)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P8mTc','P8pTc'
         ELSE
            IF(ioutflag == 1)WRITE(2,40)TRIM(instring1),  &
               TRIM(instring2),TRIM(instring3),TRIM(instring4),'P8mTc','P8pTc'
         END IF
         iform=99
      END IF
   END IF
!
10 FORMAT(/a,',',1X,a,1X,'days',1X,/1X,a,1X,'(set',1X,a,  &
      '=-99.0 to disable)')
20 FORMAT(/a,1X,'and',1X,a,',',1X,a,1X,'days',/1X,a,1X,'(set',  &
      1X,a,1X,'and',1X,a,1X,'equal to zero to disable)')
30 FORMAT(a,',',1X,a,1X,'days',1X,/1X,a,1X,'(set',1X,a,  &
      '=-99.0 to disable)')
40 FORMAT(a,1X,'and',1X,a,',',1X,a,1X,'days',/1X,a,1X,'(set',  &
      1X,a,1X,'and',1X,a,1X,'equal to zero to disable)')
!
   RETURN
!
END SUBROUTINE setperiod
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE setscale(q,finc,teff2,period,separ,primmass,primk,  &
   sw5,ecc,ioutflag,masssum,massdiff,secmass,qtemp)
!
!   August 10, 2004
!
!   This a new subroutine to set constraints specified by the
!   new variables primmass, primK, etc.
!
!   Updated May 18, 2017
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN OUT)            :: q
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(IN)                :: teff2
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(OUT)               :: separ
   REAL(KIND=dp), INTENT(IN)                :: primmass
   REAL(KIND=dp), INTENT(IN)                :: primk
   REAL(KIND=dp), INTENT(IN)                :: sw5
   REAL(KIND=dp), INTENT(IN)                :: ecc
   INTEGER, INTENT(IN)                      :: ioutflag
   REAL(KIND=dp), INTENT(IN)                :: masssum
   REAL(KIND=dp), INTENT(IN)                :: massdiff
   REAL(KIND=dp), INTENT(IN)                :: secmass
   REAL(KIND=dp), INTENT(OUT)               :: qtemp
!
   REAL(KIND=dp)  :: p,rkns,efact,vfcn,smet,total_mass
   REAL(KIND=dp)  :: vkcgs,fincr,dqhi,dqlo,qhigh,qlow,qmid,aa,cc,rm1,rm2
!
   INTEGER :: kk,ilength1,ilength2,ilength3,ilength4,ilength5
!
   CHARACTER (LEN=40) :: instring1,instring2,instring3,instring4,instring5
!
!   We can set most of the constraints specified by primmas, primK,
!   primrad here.  ratrad needs to be dealt with in getinput.
!
!   There are various combinations of parameters that one can adjust,
!   and depending on which constraints are specified, different
!   ways are used:
!
!   if sw5 > 0, then bail out (MSP mode).
!
!   primmass > 0 only:  set the separation.
!   primK > 0 only:     compute f(M), use getradius() to set separation.
!   primrad > 0 only:   scale the separation
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   fourpiesquared=4.0_dp*pie*pie
!   CALL constants(earthmassinsolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   p=period*secinday
   fincr=finc*degtorad
!
!   MSP mode:
!
!   Add the variable sw5 to the argument list.  If teff2 < 0 and
!   sw5 > 0, then the separation will be set as follows:
!
!   rkns = 2*pie*sw5*c/Period   ! K-velocity of pulsar, if sw5 is
!                                  projected semimajor axis in seconds
!
   IF((teff2 <= 0.0_dp).AND.(sw5 > 0.0_dp))THEN
      rkns=twopie*sw5*speedlightkm/period
      efact=SQRT(1.0_dp-ecc*ecc)
!
!   UPDATE November 14, 2008
!
!   If primK >0, set the mass ratio
!
      IF(primk > 0.0_dp)q=primk*86400.0_dp/(rkns*efact)
      IF(primk > 0.0_dp)qtemp=q
      vkcgs=primk*100000.0_dp*efact
      fincr=finc*degtorad
      separ=vkcgs*p*(1.0_dp+q)/(twopie*SIN(fincr)*q)/(solarrad*100.0_dp)
      separ=(q+1.0_dp)*sw5*speedlightkm/(SIN(fincr))/(solarrad*100.0_dp)
      separ=separ*1.0E+05_dp
      IF(ioutflag >= 1)WRITE(2,100)separ
      IF((primk > 0.0_dp).AND.(ioutflag >= 1))WRITE(2,110)primk,q
      RETURN
   END IF
!
!  primass > 0 and secmass > 0
!
   IF((primmass > 0.0_dp).AND.(secmass > 0.0_dp))THEN
      q=secmass/primmass
      qtemp=q
      separ=(gmsun*p*p*primmass*(1.0_dp+q)/(fourpiesquared))**(1.0_dp/3.0_dp)
      separ=separ/solarrad
      rm1=primmass
      rm2=secmass
      CALL pnoequalstring('primmmass fixed at',6,primmass,instring1,ilength1)
      CALL pnoequalstring('secmmass fixed at',6,secmass,instring2,ilength2)
      CALL pnoequalstring('The mass ratio is set to',6,q,instring3,ilength3)
      CALL pnoequalstring('the separation is set to',6,separ,instring4,ilength4)
!      k1=lnblnk(instring1)
!      k2=lnblnk(instring2)
!      k3=lnblnk(instring3)
!      k4=lnblnk(instring4)
      IF(ioutflag >= 1)WRITE(2,40)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring4)
      GO TO 30
   END IF
!
!  masssum > 0
!
   IF(masssum > 0.0_dp)THEN
      IF(q <= 0.0_dp)THEN
         rm1=0.5_dp*(masssum+massdiff)
         rm2=masssum-rm1
         qtemp=rm2/rm1
         separ=(gmsun*p*p*rm1*(1.0_dp+qtemp)/(fourpiesquared))**(1.0_dp/3.0_dp)
         separ=separ/solarrad
         CALL pnoequalstring('M_1 + M_2 fixed at',6,masssum,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('M_1 - M_2 fixed at',6,massdiff,instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('M_1 set to',6,rm1,instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('M_2 set to',6,rm2,instring4,ilength4)
!         k4=lnblnk(instring4)
         CALL pnoequalstring('The separation set to',6,separ,instring5,ilength5)
!         k5=lnblnk(instring5)
         IF(ioutflag >= 1)WRITE(2,50)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4),TRIM(instring5)
      ELSE
         rm1=masssum/(1.0_dp+q)
         rm2=masssum-rm1
         qtemp=rm2/rm1
         separ=(gmsun*p*p*rm1*(1.0_dp+qtemp)/(fourpiesquared))**(1.0_dp/3.0_dp)
         separ=separ/solarrad
         CALL pnoequalstring('M_1 + M_2 fixed at',6,masssum,instring1,ilength1)
!         k1=lnblnk(instring1)
         CALL pnoequalstring('Q fixed at',6,q,instring2,ilength2)
!         k2=lnblnk(instring2)
         CALL pnoequalstring('M_1 set to',6,rm1,instring3,ilength3)
!         k3=lnblnk(instring3)
         CALL pnoequalstring('M_2 set to',6,rm2,instring4,ilength4)
!         k4=lnblnk(instring4)
         CALL pnoequalstring('The separation set to',6,separ,instring5,ilength5)
!         k5=lnblnk(instring5)
         IF(ioutflag >= 1)WRITE(2,60)TRIM(instring1),  &
            TRIM(instring2),TRIM(instring3),TRIM(instring4),TRIM(instring5)
      END IF
      GO TO 30
   END IF
!
!   primmass > 0 only (secmass=0 and primK=0),
!   set the separation
!
   IF((primmass > 0.0_dp).AND.(primk <= 0.0_dp))THEN
      rm1=primmass
      rm2=q*rm1
      separ=(gmsun*p*p*primmass*(1.0_dp+q)/(fourpiesquared))**(1.0_dp/3.0_dp)
      separ=separ/solarrad
      CALL pnoequalstring('M_1 fixed at',6,primmass,instring1,ilength1)
!      k1=lnblnk(instring1)
      CALL pnoequalstring('Q fixed at',6,q,instring2,ilength2)
!      k2=lnblnk(instring2)
      CALL pnoequalstring('M_2 set to',6,rm2,instring3,ilength3)
!      k3=lnblnk(instring3)
      CALL pnoequalstring('the separation set to',6,separ,instring4,ilength4)
!      k4=lnblnk(instring4)
      IF(ioutflag >= 1)WRITE(2,70)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring4)
      GO TO 30
   END IF
!
!   secmass> 0, primmass=0, and Q > 0
!
   IF((secmass > 0.0_dp).AND.(primmass <= 0.0_dp).AND.(q > 0.0_dp) )THEN
      rm1=secmass/q
      rm2=secmass
      qtemp=rm2/rm1
      separ=(gmsun*p*p*rm1*(1.0_dp+qtemp)/(fourpiesquared))**(1.0_dp/3.0_dp)
      separ=separ/solarrad
      CALL pnoequalstring('M_2 fixed at',6,secmass,instring1,ilength1)
!      k1=lnblnk(instring1)
      CALL pnoequalstring('Q fixed at',6,q,instring2,ilength2)
!      k2=lnblnk(instring2)
      CALL pnoequalstring('M_1 set to',6,rm1,instring3,ilength3)
!      k3=lnblnk(instring3)
      CALL pnoequalstring('the separation set to',6,separ,instring4,ilength4)
!      k4=lnblnk(instring4)
      IF(ioutflag >= 1)WRITE(2,70)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring4)
      GO TO 30
   END IF
!
!   primK > 0 only, set the separation (Q>0, primmass=secmass=0)
!
   IF((primmass <= 0.0_dp).AND.(primk > 0.0_dp))THEN
      efact=SQRT(1.0_dp-ecc*ecc)
      vkcgs=primk*100000.0_dp*efact
      separ=vkcgs*p*(1.0_dp+q)/(twopie*SIN(fincr)*q)/solarrad/100.0_dp
      smet=separ*solarrad
      total_mass=smet*smet*smet*fourpiesquared/(period*secinday)**2/gmsun
      rm1=total_mass/(1.0_dp+qtemp)
      rm2=qtemp*rm1
      CALL pnoequalstring('K_1 fixed at',6,primk,instring1,ilength1)
!      k1=lnblnk(instring1)
      CALL pnoequalstring('The separation set to',6,separ,instring2,ilength2)
!      k2=lnblnk(instring2)
      IF(ioutflag >= 1)WRITE(2,80)TRIM(instring1),TRIM(instring2)
      GO TO 30
   END IF
!
!   primmass > 0 and primK > 0.  Solve for Q and separ
!
   IF((primmass > 0.0_dp).AND.(primk > 0.0_dp))THEN
      efact=SQRT(1.0_dp-ecc*ecc)
      dqhi=7.0_dp
      dqlo=-7.0_dp
      DO  kk=1,35
         qhigh=10.0_dp**dqhi
         qlow=10.0_dp**dqlo
         qmid=10.0_dp**((dqhi+dqlo)*0.5_dp)
         aa=vfcn(qlow,period,finc,primmass,primk,ecc)
         cc=vfcn(qmid,period,finc,primmass,primk,ecc)
         IF(aa*cc < 0.0_dp)THEN
            dqhi=(dqhi+dqlo)*0.5_dp
         ELSE
            dqlo=(dqhi+dqlo)*0.50_dp
         END IF
      END DO
      DO  kk=1,25
         qmid=(qhigh+qlow)*0.5_dp
         aa=vfcn(qlow,period,finc,primmass,primk,ecc)
         cc=vfcn(qmid,period,finc,primmass,primk,ecc)
         IF(aa*cc < 0.0_dp)THEN
            qhigh=(qhigh+qlow)*0.5_dp
         ELSE
            qlow=(qhigh+qlow)*0.50_dp
         END IF
      END DO
      q=qmid
      qtemp=q
      separ=(gmsun*p*p*primmass*(1.0_dp+q)/(fourpiesquared))**(1.0_dp/3.0_dp)
      separ=separ/solarrad
      smet=separ*solarrad
      total_mass=smet*smet*smet*fourpiesquared/(period*secinday)**2/gmsun
      rm1=total_mass/(1.0_dp+qtemp)
      rm2=qtemp*rm1
      CALL pnoequalstring('M_1 fixed at',6,primmass,instring1,ilength1)
!      k1=lnblnk(instring1)
      CALL pnoequalstring('K_1 fixed at',4,primk,instring2,ilength2)
!      k2=lnblnk(instring2)
      CALL pnoequalstring('Q set to',6,q,instring3,ilength3)
!      k3=lnblnk(instring3)
      CALL pnoequalstring('the separation set to',6,separ,instring5,ilength5)
!      k5=lnblnk(instring5)
      IF(ioutflag >= 1)WRITE(2,90)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3),TRIM(instring5)
      GO TO 30
   END IF
!
30 RETURN
!
40 FORMAT(/'numerical mode:',/1X,a,1X,'solar masses and',1X,a,1X,  &
      /' solar masses.',1X,a,1X,'and',/1X,a,1X,'solar radii.')
50 FORMAT(/'numerical mode:',/1X,a,1X,'solar masses and',1X,a,1X,  &
      'solar masses.',/1X,a,1X,'solar masses and',1X,a,1X,'so','la'  &
      ,'r masses.',/1X,a,1X,'solar radii.')
60 FORMAT(/'numerical mode:',/1X,a,1X,'solar masses and',1X,a,'.'  &
      ,1X,/1X,a,1X,'solar masses and',1X,a,1X,'solar masses.',/1X,  &
      a,1X,'solar radii.')
70 FORMAT(/'numerical mode:',/1X,a,1X,'solar masses and',1X,a,'.'  &
      ,/1X,a,1X,'solar masses and',/1X,a,1X,'solar radii.')
80 FORMAT(/'numerical mode:',/1X,a,1X,'km/sec.',1X,a,1X,'sol','a'  &
      ,'r radii.')
90 FORMAT(/'numerical mode:',/1X,a,1X,'solar masses and',1X,a,1X,  &
      'km/sec.',/1X,a,1X,'and',1X,a,1X,'solar radii.')
100 FORMAT('Info:  MSP mode:  separation has been set to ',f13.7,  &
      7X,' solar radii.')
110 FORMAT('Info:  MSP mode:  primK = ',f13.7,' the mass ratio ha'  &
      ,'s'/,6X,' been set to',f13.7)
!
   RETURN
!
END SUBROUTINE setscale
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE setupgeo(istar,ialphmax,ibetmax,nalph,nbet,  &
   ibetlim,fill,omega,q,finc,xarray,yarray,zarray,surf,radarray,  &
   gradx,grady,gradz,garray,xend,separation,tgrav,teff,reff,rl,  &
   tpole,rpol,regg,sarea,pot,gpole,phiar,isquare,iusepot,usepot,  &
   ivrt,pervol,fillper,bdist,potsum,mmdx,primmass,primk,  &
   primrad,ratrad,frac1,frac2,ecc,period,size1,sw5,tteff2,  &
   density,tidephi,itide,phistart,thetamis,phimis,ioutflag,  &
   arrsobx,montemax,masssum,massdiff,radsum,raddiff,  &
   secmass,secrad,fracsum,fracdiff,qtemp,fillsum,filldiff)
!
!   October 6, 1999
!
!   This subroutine will return the radii and surface coordinates
!   for star 1 or 2:
!
!   xarray, yarray, zarray, surf, gradx, grady, gradz, radarray, garray
!
!   The two element array xend will contain the x-coordinates of the
!   two points along the x-axis.  The gradx term is +1 at positive
!   x-axis and -1 at negative x-axis.
!
!   istar is the flag to identify which star is being computed.  If
!   istar=2, then we need to flip the mass ratio.
!
!   February 15, 2000
!
!   I have added 'dummy' arguments for the x-gradient, gravity, and
!   surface elements.  When star 2 has non-synchronous rotation, the
!   form of the x derivative of the potential needs to be modified.
!   This modified form is only  needed for the reflection effect.
!   The computation of the light curve is otherwise OK with the
!   standard gradients.
!
!   ********removed May 11, 2000*************
!
!   May 4, 2000
!
!   Change the distribution of grid points. Use a normal polar
!   coordinate scheme.
!
!   ************************
!
!   February 5, 2001
!
!   Generalize to eccentric orbits.  Need extra parameters:
!
!   ivrt=0, normal mode,
!   ivrt=1, find the filling so that the volume is equal to pervol
!   fillper is the filling factor at periastron
!
!   UPDATE August 12, 2004
!
!   Add the arguments frac1,frac2,ratrad, etc. to the argument list.
!   These are the fractional radii, and the ratio of the radii.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalph
   INTEGER, INTENT(IN)                      :: nbet
   INTEGER, INTENT(IN OUT)                  :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: fill
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN OUT)            :: q
   REAL(KIND=dp), INTENT(IN)                :: finc
   REAL(KIND=dp), INTENT(OUT)               :: xarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: yarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: zarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: surf(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: radarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: gradx(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: grady(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: gradz(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: garray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: xend(4)
   REAL(KIND=dp), INTENT(IN OUT)            :: separation
   REAL(KIND=dp), INTENT(IN)                :: tgrav
   REAL(KIND=dp), INTENT(IN)                :: teff
   REAL(KIND=dp), INTENT(IN OUT)            :: reff
   REAL(KIND=dp), INTENT(OUT)               :: rl
   REAL(KIND=dp), INTENT(OUT)               :: tpole
   REAL(KIND=dp), INTENT(OUT)               :: rpol(ialphmax)
   REAL(KIND=dp), INTENT(OUT)               :: regg
   REAL(KIND=dp), INTENT(OUT)               :: sarea
   REAL(KIND=dp), INTENT(OUT)               :: pot
   REAL(KIND=dp), INTENT(OUT)               :: gpole
   REAL(KIND=dp), INTENT(OUT)               :: phiar(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: isquare
   INTEGER, INTENT(IN)                      :: iusepot
   REAL(KIND=dp), INTENT(IN)                :: usepot
   INTEGER, INTENT(IN)                      :: ivrt
   REAL(KIND=dp), INTENT(IN OUT)            :: pervol
   REAL(KIND=dp), INTENT(IN OUT)            :: fillper
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(OUT)               :: potsum
   INTEGER, INTENT(OUT)                     :: mmdx(ialphmax,ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: primmass
   REAL(KIND=dp), INTENT(IN OUT)            :: primk
   REAL(KIND=dp), INTENT(IN)                :: primrad
   REAL(KIND=dp), INTENT(IN)                :: ratrad
   REAL(KIND=dp), INTENT(IN)                :: frac1
   REAL(KIND=dp), INTENT(IN)                :: frac2
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: period
   REAL(KIND=dp), INTENT(OUT)               :: size1
   REAL(KIND=dp), INTENT(IN)                :: sw5
   REAL(KIND=dp), INTENT(IN)                :: tteff2
   REAL(KIND=dp), INTENT(IN OUT)            :: density
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   INTEGER, INTENT(IN)                      :: itide
   REAL(KIND=dp), INTENT(OUT)               :: phistart(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
   INTEGER, INTENT(IN)                      :: ioutflag
   INTEGER, INTENT(IN)                      :: montemax
   REAL(KIND=dp), INTENT(IN)                :: arrsobx(montemax)
   REAL(KIND=dp), INTENT(IN)                :: masssum
   REAL(KIND=dp), INTENT(IN)                :: massdiff
   REAL(KIND=dp), INTENT(IN)                :: radsum
   REAL(KIND=dp), INTENT(IN)                :: raddiff
   REAL(KIND=dp), INTENT(IN OUT)            :: secmass
   REAL(KIND=dp), INTENT(IN)                :: secrad
   REAL(KIND=dp), INTENT(IN)                :: fracsum
   REAL(KIND=dp), INTENT(IN)                :: fracdiff
   REAL(KIND=dp), INTENT(IN OUT)            :: qtemp
   REAL(KIND=dp), INTENT(IN)                :: fillsum
   REAL(KIND=dp), INTENT(IN)                :: filldiff
!
   REAL(KIND=dp)  :: coy,coz,savepsi0,psixx,psix,psiy,psiz,psi,ff2,x,y,z,cox
   REAL(KIND=dp)  :: x0,critpsi,aa,fff,tempcox,tempcoy,tempcoz,ff1
   REAL(KIND=dp)  :: bigrad,psi0,vol,r,theta,dphi,fac,snth,cnth,r2
   REAL(KIND=dp)  :: snth3,phi,diff,acc,oneoverg,div,zpole,rocheradius
   REAL(KIND=dp)  :: overq,dtheta,fbig,fsmall,fnew,bigfrac,bb,r1
!
   INTEGER :: iidx,kount,nnn,i,iii,nalf2,ialf,ibet,ilength1
   INTEGER :: ilength2,ilength3
!
   CHARACTER(LEN=40) :: instring1,instring2,instring3
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   IF(ialphmax < nalph)THEN
      WRITE(*,*)'Error:  make Nalphmax greater than ',nalph,' for star ',istar
      STOP
   END IF
   IF(ibetmax < 1+4*nbet)THEN
      WRITE(*,*)'Error:  make ibetmax greater than ',1+4*nbet,' f or star ',istar
      STOP
   END IF
!
!   initialize some variables
!
   rpol=0.0_dp
   xarray=0.0_dp
   yarray=0.0_dp
   zarray=0.0_dp
   surf=0.0_dp
   radarray=0.0_dp
   gradx=0.0_dp
   grady=0.0_dp
   gradz=0.0_dp
   garray=0.0_dp
   xend=0.0_dp
   rl=0.0_dp
   tpole=0.0_dp
   regg=0.0_dp
   sarea=0.0_dp
   pot=0.0_dp
   gpole=0.0_dp
   phiar=0.0_dp
   phistart=0.0_dp
!  
!
!   UPDATE December 21, 2008
!
!   Add this routine if radfill is given.  radfill defines the
!   filling factor in terms of the effective radius.  Adjust fill1
!   and fill2 accordingly
!
!   UPDATE October 10, 2008
!
!   Add this new call to the routine that sets the mass ratio given
!   the density and fill factor of star 1.
!
   IF((istar == 1).AND.(frac1 <= 0.0_dp).AND.(primmass <= 0.0_dp)  &
      .AND.(density > 0.0_dp).AND.(primrad <= 0.0_dp))THEN
      CALL setdensity(fill,omega,bdist,q,period,density,tidephi,  &
         itide,ecc,thetamis,phimis,ioutflag)
   END IF
!
!  UPDATE August 12, 2004
!
!  If istar=1 and IVRT=0, set the separation and Q depending
!  on the values of primmass and primK.
!
   qtemp=q
   IF(istar == 1.AND.ivrt == 0)THEN
      CALL setscale(q,finc,tteff2,period,separation,primmass,  &
         primk,sw5,ecc,ioutflag,masssum,massdiff,secmass,qtemp)
   END IF
!
!   The scale of the binary (Q and separation) are found.
!   Figure out the filling factors needed to get the requested
!   radii.
!
   overq=q
   overq=qtemp
   IF(istar == 2)overq=1.0_dp/qtemp
!
!   Set up the grid on the star, define step size and number of steps.
!
   dtheta=pie/REAL(nalph,KIND=dp)
!
!   Initialize the bisection limits.
!
   fbig=fillper
   fsmall=0.0E-08_dp
   fnew=0.5_dp*(fbig+fsmall)
!
!   First, find the distance to L1.
!
   CALL findl1(overq,omega,x0,1,bdist,tidephi,ecc,thetamis,phimis)
!
!   save the L1 distance
!
   rl=x0
   x=x0
   y=0.0_dp
   z=0.0_dp
   cox=1.0_dp
   coy=0.0_dp
   CALL poten(overq,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,  &
      bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
   savepsi0=psi
   critpsi=psi
!
!  primrad > zero and secrad > zero
!
   IF((istar == 1).AND.(ivrt == 0).AND.(primrad > 0.0_dp).AND.  &
      (secrad > 0.0_dp))THEN
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigrad=reff*separation
      IF(primrad > bigrad)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,210)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a  radius larger than the
!   requested radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(primrad >= reff*separation)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      size1=reff
      CALL pnoequalstring('primrad fixed at',6,primrad,instring1,ilength1)
      CALL pspacestring('Setting fill1',6,fill,instring2,ilength2)
      IF(ioutflag == 1)WRITE(2,140)TRIM(instring1),TRIM(instring2)
      GO TO 10
   END IF
!
   IF((istar == 2).AND.(ivrt == 0).AND.(primrad > 0.0_dp).AND.  &
      (secrad > 0.0_dp))THEN
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigrad=reff*separation
      IF(secrad > bigrad)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,220)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a  radius larger than the
!   requested radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(secrad >= reff*separation)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      size1=reff
      CALL pnoequalstring('secrad fixed at',6,secrad,instring1,ilength1)
      CALL pspacestring('Setting fill2',6,fill,instring2,ilength2)
      IF(ioutflag == 1)WRITE(2,140)TRIM(instring1),TRIM(instring2)
      GO TO 10
   END IF
!
!  radsum > 0.  If ratrat=0, then use raddiff to find R1, R2.
!  Otherwise use radsum and ratrad to get R1 and R2.
!
   IF((istar == 1).AND.(ivrt == 0).AND.(radsum > 0.0_dp))THEN
      IF(ABS(ratrad) <= EPSILON(ratrad))THEN
         r1=0.5_dp*(radsum+raddiff)
         r2=radsum-r1
         CALL findradius(overq,omega,savepsi0,x0,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         bigrad=reff*separation
         IF(r1 > bigrad)THEN
            fill=1.0_dp
            IF(ioutflag == 1)WRITE(2,210)
            GO TO 10
         END IF
!
!   Presumably the Roche lobe has a  radius larger than the
!   requested radius.  Use bisection to find the filling
!   factor fill1.
!
         aa=0.0_dp
         bb=1.0_dp
         y=0.0_dp
         z=0.0_dp
         DO i=1,60
            fff=(aa+bb)*0.5_dp
            CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
               psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
               tidephi,itide,ecc,thetamis,phimis)
            IF(r1 >= reff*separation)THEN
               aa=fff
            ELSE
               bb=fff
            END IF
         END DO
!
         fill=fff
         size1=reff
         CALL pnoequalstring('radsum fixed at',6,radsum,instring1,ilength1)
         CALL pnoequalstring('raddiff fixed at',6,raddiff,instring2,ilength2)
         CALL pspacestring('Setting fill1',6,fill,instring3,ilength3)
         IF(ioutflag == 1)WRITE(2,150)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3)
         GO TO 10
      ELSE
         r2=radsum/(1.0_dp+ratrad)
         r1=radsum-r2
         CALL findradius(overq,omega,savepsi0,x0,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         bigrad=reff*separation
         IF(r1 > bigrad)THEN
            fill=1.0_dp
            IF(ioutflag == 1)WRITE(2,210)
            GO TO 10
         END IF
!
!   Presumably the Roche lobe has a  radius larger than the
!   requested radius.  Use bisection to find the filling
!   factor fill1.
!
         aa=0.0_dp
         bb=1.0_dp
         y=0.0_dp
         z=0.0_dp
         DO i=1,60
            fff=(aa+bb)*0.5_dp
            CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
               psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
               tidephi,itide,ecc,thetamis,phimis)
            IF(r1 >= reff*separation)THEN
               aa=fff
            ELSE
               bb=fff
            END IF
         END DO
!
         fill=fff
         size1=reff
         CALL pnoequalstring('radsum fixed at',6,radsum,instring1,ilength1)
         CALL pnoequalstring('ratrad fixed at',6,ratrad,instring2,ilength2)
         CALL pspacestring('Setting fill1',6,fill,instring3,ilength3)
         IF(ioutflag == 1)WRITE(2,160)TRIM(instring1),TRIM(instring2), &
            TRIM(instring3)
         GO TO 10
      END IF
   END IF
!
   IF((istar == 2).AND.(ivrt == 0).AND.(radsum > 0.0_dp))THEN
      IF(ABS(ratrad) <= EPSILON(ratrad))THEN
         r1=0.5_dp*(radsum+raddiff)
         r2=radsum-r1
         CALL findradius(overq,omega,savepsi0,x0,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         bigrad=reff*separation
         IF(r2 > bigrad)THEN
            fill=1.0_dp
            IF(ioutflag == 1)WRITE(2,220)
            GO TO 10
         END IF
!
!   Presumably the Roche lobe has a  radius larger than the
!   requested radius.  Use bisection to find the filling
!   factor fill1.
!
         aa=0.0_dp
         bb=1.0_dp
         y=0.0_dp
         z=0.0_dp
         DO i=1,60
            fff=(aa+bb)*0.5_dp
            CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
               psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
               tidephi,itide,ecc,thetamis,phimis)
            IF(r2 >= reff*separation)THEN
               aa=fff
            ELSE
               bb=fff
            END IF
         END DO
!
         fill=fff
         size1=reff
         CALL pnoequalstring('radsum fixed at',6,radsum,instring1,ilength1)
         CALL pnoequalstring('raddiff fixed at',6,raddiff, instring2,ilength2)
         CALL pspacestring('Setting fill2',6,fill,instring3,ilength3)
         IF(ioutflag == 1)WRITE(2,150)TRIM(instring1),TRIM(instring2), &
            TRIM(instring3)
         GO TO 10
      ELSE
         r2=radsum/(1.0_dp+ratrad)
         r1=radsum-r2
         CALL findradius(overq,omega,savepsi0,x0,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         bigrad=reff*separation
         IF(r2 > bigrad)THEN
            fill=1.0_dp
            IF(ioutflag == 1)WRITE(2,220)
            GO TO 10
         END IF
!
!   Presumably the Roche lobe has a  radius larger than the
!   requested radius.  Use bisection to find the filling
!   factor fill1.
!
         aa=0.0_dp
         bb=1.0_dp
         y=0.0_dp
         z=0.0_dp
         DO i=1,60
            fff=(aa+bb)*0.5_dp
            CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
               psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
               tidephi,itide,ecc,thetamis,phimis)
            IF(r2 >= reff*separation)THEN
               aa=fff
            ELSE
               bb=fff
            END IF
         END DO
!
         fill=fff
         size1=reff
         CALL pnoequalstring('radsum fixed at',6,radsum,instring1,ilength1)
         CALL pnoequalstring('ratrad fixed at',6,ratrad,instring2,ilength2)
         CALL pspacestring('Setting fill2',6,fill,instring3,ilength3)
         IF(ioutflag == 1)WRITE(2,160)TRIM(instring1),TRIM(instring2), &
            TRIM(instring3)
         GO TO 10
      END IF
   END IF
!
!  If fracsum > 0, and ratrad=0, find frac1, frac2 using fracsum
!  and fracdiff.  If fracsum > 0 and ratrad > 0, find frac1 and
!  frac2.
!
   IF((istar == 1).AND.(ivrt == 0).AND.fracsum > 0.0_dp)THEN
      IF(ABS(ratrad) <= EPSILON(ratrad))THEN
         ff1=0.5_dp*(fracsum+fracdiff)
         ff2=fracsum-ff1
         CALL findradius(overq,omega,savepsi0,x0,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         bigfrac=reff
         IF(ff1 > bigfrac)THEN
            fill=1.0_dp
            size1=reff
            IF(ioutflag == 1)WRITE(2,190)
            GO TO 10
         END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
         aa=0.0_dp
         bb=1.0_dp
         y=0.0_dp
         z=0.0_dp
         DO i=1,60
            fff=(aa+bb)*0.5_dp
            CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
               psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
               tidephi,itide,ecc,thetamis,phimis)
            IF(ff1 >= reff)THEN
               aa=fff
            ELSE
               bb=fff
            END IF
         END DO
!
         fill=fff
         size1=reff
         CALL pnoequalstring('fracsum fixed at',6,fracsum,instring1,ilength1)
         CALL pnoequalstring('fracdiff fixed at',6,fracdiff,instring2,ilength2)
         CALL pspacestring('Setting fill1',6,fill,instring3,ilength3)
         IF(ioutflag == 1)WRITE(2,170)TRIM(instring1),TRIM(instring2), &
            TRIM(instring3)
         GO TO 10
      ELSE
         ff2=fracsum/(1.0_dp+ratrad)
         ff1=fracsum-ff2
         CALL findradius(overq,omega,savepsi0,x0,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         bigfrac=reff
         IF(ff1 > bigfrac)THEN
            fill=1.0_dp
            size1=reff
            IF(ioutflag == 1)WRITE(2,190)
            GO TO 10
         END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
         aa=0.0_dp
         bb=1.0_dp
         y=0.0_dp
         z=0.0_dp
         DO i=1,60
            fff=(aa+bb)*0.5_dp
            CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
               psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
               tidephi,itide,ecc,thetamis,phimis)
            IF(ff1 >= reff)THEN
               aa=fff
            ELSE
               bb=fff
            END IF
         END DO
!
         fill=fff
         size1=reff
         CALL pnoequalstring('fracsum fixed at',6,fracsum,instring1,ilength1)
         CALL pnoequalstring('ratrad fixed at',6,ratrad,instring2,ilength2)
         CALL pspacestring('Setting fill1',6,fill,instring3,ilength3)
         IF(ioutflag == 1)WRITE(2,170)TRIM(instring1),TRIM(instring2), &
            TRIM(instring3)
         GO TO 10
      END IF
   END IF
!
   IF((istar == 2).AND.(ivrt == 0).AND.fracsum > 0.0_dp)THEN
      IF(ABS(ratrad) <= EPSILON(ratrad))THEN
         ff1=0.5_dp*(fracsum+fracdiff)
         ff2=fracsum-ff1
         CALL findradius(overq,omega,savepsi0,x0,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         bigfrac=reff
         IF(ff2 > bigfrac)THEN
            fill=1.0_dp
            size1=reff
            IF(ioutflag == 1)WRITE(2,200)
            GO TO 10
         END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
         aa=0.0_dp
         bb=1.0_dp
         y=0.0_dp
         z=0.0_dp
         DO i=1,60
            fff=(aa+bb)*0.5_dp
            CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
               psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
               tidephi,itide,ecc,thetamis,phimis)
            IF(ff2 >= reff)THEN
               aa=fff
            ELSE
               bb=fff
            END IF
         END DO
!
         fill=fff
         size1=reff
         CALL pnoequalstring('fracsum fixed at',6,fracsum,instring1,ilength1)
         CALL pnoequalstring('fracdiff fixed at',6,fracdiff,instring2,ilength2)
         CALL pspacestring('Setting fill2',6,fill,instring3,ilength3)
         IF(ioutflag == 1)WRITE(2,170)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3)
         GO TO 10
      ELSE
         ff2=fracsum/(1.0_dp+ratrad)
         ff1=fracsum-ff2
         CALL findradius(overq,omega,savepsi0,x0,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         bigfrac=reff
         IF(ff2 > bigfrac)THEN
            fill=1.0_dp
            size1=reff
            IF(ioutflag == 1)WRITE(2,200)
            GO TO 10
         END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
         aa=0.0_dp
         bb=1.0_dp
         y=0.0_dp
         z=0.0_dp
         DO i=1,60
            fff=(aa+bb)*0.5_dp
            CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
               psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
               tidephi,itide,ecc,thetamis,phimis)
            IF(ff2 >= reff)THEN
               aa=fff
            ELSE
               bb=fff
            END IF
         END DO
!
         fill=fff
         size1=reff
         CALL pnoequalstring('fracsum fixed at',6,fracsum,instring1,ilength1)
         CALL pnoequalstring('ratrad fixed at',6,ratrad,instring2,ilength2)
         CALL pspacestring('Setting fill2',6,fill,instring3,ilength3)
         IF(ioutflag == 1)WRITE(2,170)TRIM(instring1),TRIM(instring2),  &
            TRIM(instring3)
         GO TO 10
      END IF
   END IF
!
!  frac1 and frac2 both greater than zero.  Find the fill
!  factors.
!
   IF((istar == 1).AND.(ivrt == 0).AND.(frac1 > 0.0_dp).AND. &
          (frac2 > 0.0_dp))THEN
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigfrac=reff
      IF(frac1 > bigfrac)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,190)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(frac1 >= reff)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('frac1 fixed at',6,frac1,instring1,ilength1)
      CALL pspacestring('Setting fill1',6,fill,instring2,ilength2)
      IF(ioutflag == 1)WRITE(2,180)TRIM(instring1),TRIM(instring2)
      GO TO 10
   END IF
!
   IF((istar == 2).AND.(ivrt == 0).AND.(frac1 > 0.0_dp).AND. &
           (frac2 > 0.0_dp))THEN
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigfrac=reff
      IF(frac2 > bigfrac)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,200)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(frac2 >= reff)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('frac2 fixed at',6,frac1,instring1,ilength1)
      CALL pspacestring('Setting fill2',6,fill,instring2,ilength2)
      IF(ioutflag == 1)WRITE(2,180)TRIM(instring1),TRIM(instring2)
      GO TO 10
   END IF
!
!  frac1 > 0, and frac2 = 0, and ratrad > 0.  Find the fill
!  factors.
!
   IF((istar == 1).AND.(ivrt == 0).AND.(frac1 > 0.0_dp).AND.  &
      (ratrad > 0.0_dp).AND.(ABS(frac2) <= EPSILON(frac2)))THEN
      ff1=frac1
      ff2=ff1/ratrad
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigfrac=reff
      IF(ff1 > bigfrac)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,190)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(ff1 >= reff)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('frac1 fixed at',6,frac1,instring1,ilength1)
      CALL pnoequalstring('ratrad fixed at',6,ratrad,instring2,ilength2)
      CALL pspacestring('Setting fill1',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,170)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3)
      GO TO 10
   END IF
!
   IF((istar == 2).AND.(ivrt == 0).AND.(frac1 > 0.0_dp).AND.  &
      (ratrad > 0.0_dp).AND.(ABS(frac2) <= EPSILON(frac2)))THEN
      ff1=frac1
      ff2=ff1/ratrad
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigfrac=reff
      IF(ff2 > bigfrac)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,200)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(ff2 >= reff)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('frac1 fixed at',6,frac1,instring1,ilength1)
      CALL pnoequalstring('ratrad fixed at',6,ratrad,instring2,ilength2)
      CALL pspacestring('Setting fill2',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,170)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3)
      GO TO 10
   END IF
!
!  frac1 > 0 and secrad > 0.  Find the fill
!  factors.
!
   IF((istar == 1).AND.(ivrt == 0).AND.(frac1 > 0.0_dp).AND.  &
      (secrad > 0.0_dp))THEN
      ff1=frac1
      ff2=ff1/ratrad
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigfrac=reff
      IF(ff1 > bigfrac)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,190)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(ff1 >= reff)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('frac1 fixed at',6,frac1,instring1,ilength1)
      CALL pnoequalstring('secrad fixed at',6,ratrad,instring2,ilength2)
      CALL pspacestring('Setting fill1',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,170)TRIM(instring1),TRIM(instring2),TRIM(instring3)
      GO TO 10
   END IF
!
   IF((istar == 2).AND.(ivrt == 0).AND.(frac1 > 0.0_dp).AND.  &
      (secrad > 0.0_dp))THEN
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigrad=reff*separation
      IF(secrad > bigrad)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,200)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(secrad >= reff*separation)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('frac1 fixed at',6,frac1,instring1,ilength1)
      CALL pnoequalstring('secrad fixed at',6,secrad,instring2,ilength2)
      CALL pspacestring('Setting fill2',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,170)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3)
      GO TO 10
   END IF
!
!   primrad > 0 and frac2 > 0
!
   IF((istar == 1).AND.(ivrt == 0).AND.(frac2 > 0.0_dp).AND.  &
      (primrad > 0.0_dp))THEN
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigrad=reff*separation
      IF(primrad > bigrad)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,190)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(primrad >= reff*separation)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('frac2 fixed at',6,frac2,instring1,ilength1)
      CALL pnoequalstring('primrad fixed at',6,primrad,instring2,ilength2)
      CALL pspacestring('Setting fill1',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,160)TRIM(instring2),TRIM(instring1),  &
         TRIM(instring3)
      GO TO 10
   END IF
!
   IF((istar == 2).AND.(ivrt == 0).AND.(frac2 > 0.0_dp).AND.  &
      (primrad > 0.0_dp))THEN
      ff2=frac2
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigfrac=reff
      IF(ff2 > bigfrac)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,200)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(ff2 >= reff)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('frac2 fixed at',6,frac2,instring1,ilength1)
      CALL pnoequalstring('primrad fixed at',6,primrad,instring2,ilength2)
      CALL pspacestring('Setting fill2',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,160)TRIM(instring2),TRIM(instring1),  &
         TRIM(instring3)
      GO TO 10
   END IF
!
!   primrad > 0 and ratrad > 0
!
   IF((istar == 1).AND.(ivrt == 0).AND.(ratrad > 0.0_dp).AND.  &
      (primrad > 0.0_dp))THEN
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigrad=reff*separation
      IF(primrad > bigrad)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,190)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(primrad >= reff*separation)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('primrad fixed at',6,primrad,instring1,ilength1)
      CALL pnoequalstring('ratrad fixed at',6,ratrad,instring2,ilength2)
      CALL pspacestring('Setting fill1',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,160)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3)
      GO TO 10
   END IF
!
   IF((istar == 2).AND.(ivrt == 0).AND.(ratrad > 0.0_dp).AND.  &
      (primrad > 0.0_dp))THEN
      ff2=primrad/ratrad
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigrad=reff*separation
      IF(ff2 > bigrad)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,200)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(ff2 >= reff*separation)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('primrad fixed at',6,primrad,instring1,ilength1)
      CALL pnoequalstring('ratrad fixed at',6,ratrad,instring2,ilength2)
      CALL pspacestring('Setting fill2',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,160)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3)
      GO TO 10
   END IF
!
!   secrad > 0 and ratrad > 0
!
   IF((istar == 1).AND.(ivrt == 0).AND.(ratrad > 0.0_dp).AND.  &
      (secrad > 0.0_dp))THEN
      ff1=secrad*ratrad
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigrad=reff*separation
      IF(ff1 > bigrad)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,190)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(ff1 >= reff*separation)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('secrad fixed at',6,secrad,instring1,ilength1)
      CALL pnoequalstring('ratrad fixed at',6,ratrad,instring2,ilength2)
      CALL pspacestring('Setting fill1',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,160)TRIM(instring1),TRIM(instring2),  &
         TRIM(instring3)
      GO TO 10
   END IF
!
   IF((istar == 2).AND.(ivrt == 0).AND.(ratrad > 0.0_dp).AND.  &
      (secrad > 0.0_dp))THEN
      ff2=secrad
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigrad=reff*separation
      IF(ff2 > bigrad)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,200)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(ff2 >= reff*separation)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('secrad fixed at',6,secrad,instring1,ilength1)
      CALL pnoequalstring('ratrad fixed at',6,ratrad,instring2,ilength2)
      CALL pspacestring('Setting fill2',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,160)TRIM(instring1),TRIM(instring2),TRIM(instring3)
      GO TO 10
   END IF
!
!  fillsum > 0, use fillsum and filldiff
!
   IF((istar == 1).AND.(ivrt == 0).AND.(fillsum > 0.0_dp))THEN
      fill=0.5_dp*(fillsum+filldiff)
      IF(fill > 1.0_dp)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,200)
         GO TO 10
      END IF
      CALL pnoequalstring('fillsum fixed at',6,fillsum,instring1, ilength1)
      CALL pnoequalstring('filldiff fixed at',6,filldiff, instring2,ilength2)
      CALL pspacestring('Setting fill1',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,170)TRIM(instring1),TRIM(instring2),TRIM(instring3)
      GO TO 10
   END IF
!
   IF((istar == 2).AND.(ivrt == 0).AND.(fillsum > 0.0_dp))THEN
      fill=0.5_dp*(fillsum-filldiff)
      IF(fill > 1.0_dp)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,210)
         GO TO 10
      END IF
      CALL pnoequalstring('fillsum fixed at',6,fillsum,instring1,ilength1)
      CALL pnoequalstring('filldiff fixed at',6,filldiff,instring2,ilength2)
      CALL pspacestring('Setting fill2',6,fill,instring3,ilength3)
      IF(ioutflag == 1)WRITE(2,170)TRIM(instring1),TRIM(instring2),TRIM(instring3)
      GO TO 10
   END IF
!
!   primrad > 0 only (assume Teff2 < 0)
!
   IF((istar == 1).AND.(ivrt == 0).AND.(ratrad >= 0.0_dp).AND.  &
      (primrad > 0.0_dp))THEN
      CALL findradius(overq,omega,savepsi0,x0,bdist,reff,tidephi,  &
         itide,ecc,thetamis,phimis)
      bigrad=reff*separation
      IF(primrad > bigrad)THEN
         fill=1.0_dp
         IF(ioutflag == 1)WRITE(2,190)
         GO TO 10
      END IF
!
!   Presumably the Roche lobe has a fractional radius large than the
!   requested fractional radius.  Use bisection to find the filling
!   factor fill1.
!
      aa=0.0_dp
      bb=1.0_dp
      y=0.0_dp
      z=0.0_dp
      DO i=1,60
         fff=(aa+bb)*0.5_dp
         CALL poten(overq,omega,x0*fff,y,z,psi,psix,psixx,psiy,  &
            psiz,1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         CALL findradius(overq,omega,psi,x0*fff,bdist,reff,  &
            tidephi,itide,ecc,thetamis,phimis)
         IF(primrad >= reff*separation)THEN
            aa=fff
         ELSE
            bb=fff
         END IF
      END DO
!
      fill=fff
      CALL pnoequalstring('primrad fixed at',6,primrad,instring1,ilength1)
      CALL pspacestring('Setting fill1',6,fill,instring3, ilength3)
      IF(ioutflag == 1)WRITE(2,165)TRIM(instring1),TRIM(instring3)
      GO TO 10
   END IF
!
!   Skip down to here when constraints are set
!
10 nnn=40
   IF(ivrt == 0)nnn=1
!
!  here is the loop point when we need to invert
!
   DO  iii=1,nnn
!
      IF(ivrt > 0)fill=fnew
!
!   If the flag 'iusepot' is 1 or larger, then we must compute the
!   filling factor needed to get the entered value of 'usepot'.
!   If the requested potential is *smaller* than the critical potential,
!   then set the filling factor to 1.0.
!
      IF(iusepot >= 1)THEN
         IF(ivrt == 0)THEN
            CALL findfill(istar,overq,omega,critpsi,x0,usepot,psi0,  &
               fill,bdist,tidephi,itide,ecc,thetamis,phimis,ioutflag)
            x=fill*x0
         ELSE
            x=fill*x0
            y=0.0_dp
            z=0.0_dp
            CALL poten(overq,omega,x,y,z,psi,psix,psixx,psiy,psiz,  &
               1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            psi0=psi
         END IF
      ELSE
         x=fill*x0
         y=0.0_dp
         z=0.0_dp
         CALL poten(overq,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,  &
            bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
         psi0=psi
      END IF
!
      IF(ivrt == 0)fillper=fill
!
      vol=0.0_dp
      sarea=0.0_dp
      r=x
      potsum=0.0_dp
      DO  ialf=1,nalph
         theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
!
!   UPDATE January 11, 2010
!
!   Change to make similar to W-D
!
         ibetlim(ialf)=1+NINT(1.3_dp*REAL(4*nbet,KIND=dp)*SIN(theta))
         IF(MOD(ibetlim(ialf),2) == 1)ibetlim(ialf)=ibetlim(ialf)-1
         IF(isquare >= 1)ibetlim(ialf)=4*nbet
         theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
      END DO
!
!   UPDATE January 11, 2010
!
!   Now that ibetlim is set, initalize the random starting phi values
!
      nnn=2
      DO  ialf=1,nalph
         dphi=twopie/REAL(ibetlim(ialf),KIND=dp)
         fac=(arrsobx(ialf)-0.5_dp)*0.5_dp
         fac=0.0_dp
         phistart(ialf)=fac*dphi
      END DO
!
!   The following is a quick loop to find the volume.
!
      DO  ialf=1,nalph/2
!
!   UPDATE MARCH 17, 2004
!
!   make the initial value of r smaller here.
!
         r=0.0000001_dp
         tempcox=0.0_dp
         tempcoy=0.0_dp
         tempcoz=1.0_dp
         CALL rad(overq,omega,tempcox,tempcoy,tempcoz,psi0,r,x,y,z,1,  &
            bdist,tidephi,itide,ecc,thetamis,phimis)
         theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
         dphi=twopie/REAL(ibetlim(ialf),KIND=dp)
         snth=SIN(theta)
         snth3=snth/3.0_dp
         cnth=COS(theta)
         DO  ibet=1,ibetlim(ialf)/2
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!                iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
!                mcount=mcount+1
!                mmdx(ialf,ibet)=mcount
!                iidx=mcount
!
            iidx=kount(ialphmax,ialf,ibetlim)+ibet
            phi=-0.5_dp*dphi+dphi*REAL(ibet,KIND=dp)
            phiar(iidx)=phi
            cox=COS(phi)*snth
            coy=SIN(phi)*snth
            coz=cnth
            CALL rad(overq,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,  &
               tidephi,itide,ecc,thetamis,phimis)
            vol=vol+4.0_dp*r*r*r*dphi*dtheta*snth3
         END DO
      END DO
!
      diff=vol-pervol
      IF(ivrt == 0)THEN
!
!  reference volume
!
         pervol=vol
         vol=0.0_dp
         sarea=0.0_dp
         r=x
         potsum=0.0_dp
         x=fill*x0
         y=0.0_dp
         z=0.0_dp
         EXIT
      END IF
!
!   Here is a little bisection block which compares the volume
!   just found to the reference volume pervol.
!
      IF(diff <= 0.0_dp)THEN
         fsmall=fnew
         fnew=0.5_dp*(fsmall+fbig)
      ELSE
         fbig=fnew
         fnew=0.5_dp*(fsmall+fbig)
      END IF
      acc=0.5_dp*ABS(fbig-fsmall)/(fbig+fsmall)
      IF(acc < 1.0E-10_dp)THEN
         vol=0.0_dp
         sarea=0.0_dp
         r=x
         potsum=0.0_dp
         EXIT
      END IF
   END DO
!
!   We have the correct volume now.  Go and assign the other variables.
!
   vol=0.0_dp
   sarea=0.0_dp
   potsum=0.0_dp
   x=fill*x0
   y=0.0_dp
   z=0.0_dp
!
!   Note the loop below is set for the whole star.  If using one fourth
!   of the star, change the term in the Vol = command to 4.0
!
   IF(itide < 2)THEN
      DO  ialf=1,nalph
!
!   UPDATE MARCH 17, 2004
!
!   make the initial value of r smaller here.
!
         r=0.0000001_dp
         tempcox=0.0_dp
         tempcoy=0.0_dp
         tempcoz=1.0_dp
         CALL rad(overq,omega,tempcox,tempcoy,tempcoz,psi0,r,x,y,z,1,  &
            bdist,tidephi,itide,ecc,thetamis,phimis)
         theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
         dphi=twopie/REAL(ibetlim(ialf),KIND=dp)
         snth=SIN(theta)
         snth3=SIN(theta)/3.0_dp
         cnth=COS(theta)
         DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
            iidx=kount(ialphmax,ialf,ibetlim)+ibet
            mmdx(ialf,ibet)=iidx
            phi=-0.5_dp*dphi+dphi*REAL(ibet,KIND=dp)
            phi=phi+phistart(ialf)
            phiar(iidx)=phi
            cox=COS(phi)*snth
            coy=SIN(phi)*snth
            coz=cnth
            CALL rad(overq,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,  &
               tidephi,itide,ecc,thetamis,phimis)
            CALL poten(overq,omega,x,y,z,psi,psix,psixx,psiy,psiz,  &
               1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            radarray(iidx)=r
            garray(iidx)=SQRT(psix**2+psiy**2+psiz**2)
            oneoverg=1.0_dp/garray(iidx)
            gradx(iidx)=-psix*oneoverg
            grady(iidx)=-psiy*oneoverg
            gradz(iidx)=-psiz*oneoverg
            surf(iidx)=cox*gradx(iidx)+coy*grady(iidx)+coz* gradz(iidx)
!
!   The following check is for large separations.
!
            IF(surf(iidx) < 0.7_dp)surf(iidx)=0.7_dp
!
            surf(iidx)=r**2/surf(iidx)
!
!   Add terms to account for the delta phi and delta theta terms.
!
!   Expression with distribution of points linear in theta.
!
            surf(iidx)=surf(iidx)*dphi*dtheta*snth
!
!   Expression with distribution of points linear in cos(theta)
!
!               surf(iidx)=surf(iidx)*dphi*dcostheta
!
!   Keep track of the surface area and volume.
!
            sarea=sarea+surf(iidx)
!
!   Expression with distribution of points linear in theta.
!
            vol=vol+1.0_dp*r*r*r*dphi*dtheta*snth3
!
!   Expression with distribution of points linear in cos(theta)
!
!              VOL = VOL + R*R*R*dphi*dcostheta/3.0d0
!
!   Assign x,y,z coordinates of grid point
!
            xarray(iidx)=x
            yarray(iidx)=y
            zarray(iidx)=z
!
         END DO
      END DO
!
!   end if itide < 2
!
   END IF
!
!  If we are using the tidal approximation,
!  we cannot use symmetry.  Loop over the full range of
!  Nalph and Nbet
!
   IF(itide >= 2)THEN
!
!          tider=pie*tidephi/80.0d0

      DO  ialf=1,nalph
!
!   UPDATE MARCH 17, 2004
!
!   make the initial value of r smaller here.
!
         r=0.0000001_dp
         tempcox=0.0_dp
         tempcoy=0.0_dp
         tempcoz=1.0_dp
         CALL rad(overq,omega,tempcox,tempcoy,tempcoz,psi0,r,x,y,z,1,  &
            bdist,tidephi,itide,ecc,thetamis,phimis)
         theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
         dphi=twopie/REAL(ibetlim(ialf),KIND=dp)
         snth=SIN(theta)
         snth3=SIN(theta)/3.0_dp
         cnth=COS(theta)
         DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
            iidx=kount(ialphmax,ialf,ibetlim)+ibet
            mmdx(ialf,ibet)=iidx
            phi=-0.5_dp*dphi+dphi*REAL(ibet,KIND=dp)
            phi=phi+phistart(ialf)
            phiar(iidx)=phi
            cox=COS(phi)*snth
            coy=SIN(phi)*snth
            coz=cnth
            CALL rad(overq,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,  &
               tidephi,itide,ecc,thetamis,phimis)
            CALL poten(overq,omega,x,y,z,psi,psix,psixx,psiy,psiz,  &
               1,bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
            radarray(iidx)=r
            garray(iidx)=SQRT(psix**2+psiy**2+psiz**2)
            oneoverg=1.0_dp/garray(iidx)
            gradx(iidx)=-psix*oneoverg
            grady(iidx)=-psiy*oneoverg
            gradz(iidx)=-psiz*oneoverg
            surf(iidx)=cox*gradx(iidx)+coy*grady(iidx)+coz*gradz(iidx)
!
!   The following check is for large separations.
!
            IF(surf(iidx) < 0.7_dp)surf(iidx)=0.7_dp
!
            surf(iidx)=r**2/surf(iidx)
!
!   Add terms to account for the delta phi and delta theta terms.
!
!   Expression with distribution of points linear in theta.
!
            surf(iidx)=surf(iidx)*dphi*dtheta*snth
!
!   Expression with distribution of points linear in cos(theta)
!
!               surf(iidx)=surf(iidx)*dphi*dcostheta
!
!   Keep track of the surface area and volume.
!
            sarea=sarea+surf(iidx)
!
!   Expression with distribution of points linear in theta.
!
            vol=vol+1.0_dp*r*r*r*dphi*dtheta*snth3
!
!   Expression with distribution of points linear in cos(theta)
!
!              VOL = VOL + R*R*R*dphi*dcostheta/3.0d0
!
!   Assign x,y,z coordinates of grid point
!
            xarray(iidx)=x
            yarray(iidx)=y
            zarray(iidx)=z
!
         END DO
      END DO
!
!  end if itide >= 2
!
   END IF
!
   reff=(0.75_dp*vol/pie)**(1.0_dp/3.0_dp)
   nalf2=nalph/2
   cox=0.0_dp
   coy=0.0_dp
   coz=1.0_dp
   r=radarray(1)
   CALL rad(overq,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,  &
      tidephi,itide,ecc,thetamis,phimis)
   CALL poten(overq,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,  &
      bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
   div=SQRT(psix**2+psiy**2+psiz**2)
   gpole=div
   rpol(nalf2)=r
   zpole=z
!
   potsum=0.0_dp
   DO  ialf=1,nalph
      DO  ibet=1,ibetlim(ialf)
!
!   Keep track of the sums of the normalized gravities to compute the
!   intensity weighted effective temperature.
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         potsum=((garray(iidx)/div)**(4.0_dp*tgrav))*surf(iidx)+potsum
!
      END DO
   END DO
!
!   keep track of the point on the star on x-axis
!
   cox=1.0_dp
   coy=0.0_dp
   coz=0.0_dp
   r=fill*x0
   CALL rad(overq,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,  &
      tidephi,itide,ecc,thetamis,phimis)
   xend(3)=r
   cox=-1.0_dp
   coy=0.0_dp
   coz=0.0_dp
   CALL rad(overq,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,  &
      tidephi,itide,ecc,thetamis,phimis)
   xend(4)=r
!
   tpole=teff*SQRT(SQRT(sarea/potsum))
!
!  UPDATE September 11, 2001
!
!  Put the if-then clauses around the write statements.
!
   pot=psi0
   IF(istar == 1)THEN
      IF(ioutflag == 1)THEN
         CALL pspacestring('Q',7,q,instring1,ilength1)
         CALL pspacestring('1/Q',7,1.0_dp/qtemp,instring2,ilength2)
         WRITE(2,260)TRIM(instring1),TRIM(instring2)
         WRITE(2,270)rl,rl*fill,reff,fill*rocheradius(1.0_dp/qtemp)
         WRITE(2,290)reff*separation
         WRITE(2,320)rocheradius(1.0_dp/qtemp)
         WRITE(2,330)rpol(nalf2)
         WRITE(2,310)xend(3),xend(4)
         WRITE(2,230)(reff-rpol(nalf2))/reff*100.0_dp
         WRITE(2,240)(reff-xend(3))/reff*100.0_dp
         WRITE(2,250)(reff-xend(4))/reff*100.0_dp
         WRITE(2,340)savepsi0,psi0
      END IF
      regg=rocheradius(1.0_dp/q)
   END IF
   IF(istar == 2)THEN
      psi0=psi0/overq+0.5_dp*(overq-1.0_dp)/overq
      savepsi0=savepsi0/overq+0.5_dp*(overq-1.0_dp)/overq
      IF(ioutflag == 1)THEN
         WRITE(2,280)rl,rl*fill,reff,fill*rocheradius(q)
         WRITE(2,290)reff*separation
         WRITE(2,320)rocheradius(q)
         WRITE(2,330)rpol(nalf2)
         WRITE(2,310)xend(3),xend(4)
         WRITE(2,230)(reff-rpol(nalf2))/reff*100.0_dp
         WRITE(2,240)(reff-xend(3))/reff*100.0_dp
         WRITE(2,250)(reff-xend(4))/reff*100.0_dp
         WRITE(2,340)savepsi0,psi0
      END IF
      regg=rocheradius(qtemp)
   END IF
!
!   Make the xend array contain the poles of the star for compatability
!   with the plotting subroutine
!
   xend(1)=zpole
   xend(2)=-zpole
!
!   UPDATE September 11, 2001
!
!   Put the if-then clause around the write statement.
!
   IF(ioutflag == 1)WRITE(2,300)sarea,vol,teff,tpole
!
140 FORMAT(/'numerical mode:',/1X,a,1X,'solar radii.',1X,a,'.')
150 FORMAT(/'numerical mode:',/1X,a,1X,'solar radii',1X,'and',1X,  &
      a,1X,'solar radii.',/1X,a,'.')
160 FORMAT(/'numerical mode:',/1X,a,1X,'solar radii',1X,'and',1X,  &
      a,'.',/1X,a,'.')
165 FORMAT(/'numerical mode:',/1X,a,1X,'solar radii.',/1X,a,'.')
170 FORMAT(/'numerical mode:',/1X,a,1X,'and',1X,a,'.',1X,a,'.')
180 FORMAT(/'numerical mode:',/1X,a,'.',1X,a,'.')
190 FORMAT(/'Warning:  frac1 exceeds Roche radius. Setting fil',''  &
      ,'l1=1.0')
200 FORMAT(/'Warning:  frac2 exceeds Roche radius. Setting fil',''  &
      ,'l2=1.0')
210 FORMAT('Warning:  primary radius exceeds Roche ',' radius','.'  &
      ,'  Setting fill1=1.0')
220 FORMAT('Warning:  secondary radius exceeds Roche ',' radius',  &
      '.  Setting fill2=1.0')
230 FORMAT('reff-r_pole   = ',f16.11,' percent')
240 FORMAT('reff-x(point) = ',f16.11,' percent')
250 FORMAT('reff-x(end)   = ',f16.11,' percent')
260 FORMAT(/a,',',1X,a,'.')
270 FORMAT(/'star 1:'/'L1 = ',f7.4,',  fill*L1 = ',f7.4,', r_eff '  &
      ,'= ',f10.7,', r_eff (Eggleton) = ',f10.7)
280 FORMAT(/'star 2:'/'L1 = ',f7.4,',  fill*L1 = ',f7.4,', r_eff '  &
      ,'= ',f10.7,', r_eff (Eggleton) = ',f10.7)
290 FORMAT('effective radius in solar units = ',f12.5)
!
300 FORMAT('surface area = ',e16.9,2X,'volume = ',e16.9,2X,/'effe'  &
      ,'ctive temperature = ',f9.3,2X,'polar temperature = ',f9.3)
310 FORMAT('x(point) = ',f11.8,2X,'x(end) = ',f11.8)
320 FORMAT('Roche lobe effective dimensionless radius ','(Eggleto'  &
      ,'n formula) = ',f8.5)
330 FORMAT('polar radius = ',f11.8)
340 FORMAT('potential at L1 = ',f12.6,2X,'potential at ','fill*L1'  &
      ,' = ',f12.6)
!
   RETURN
!
END SUBROUTINE setupgeo
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE setupgeo3(ialphmax,ibetmax,nalph,nbet,ibetlim,  &
   xarray,yarray,zarray,mmdx,phiarr,surf,radarray,gradx,grady,  &
   gradz,garray,tmatrix,reff1,sa3,reff3,t3,g3,grav3)
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalph
   INTEGER, INTENT(IN)                      :: nbet
   INTEGER, INTENT(OUT)                     :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(OUT)               :: xarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: yarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: zarray(ialphmax*ibetmax)
   INTEGER, INTENT(OUT)                     :: mmdx(ialphmax,ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: phiarr(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: surf(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: radarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: gradx(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: grady(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: gradz(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: garray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(OUT)               :: tmatrix(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: reff1
   REAL(KIND=dp), INTENT(IN)                :: sa3
   REAL(KIND=dp), INTENT(OUT)               :: reff3
   REAL(KIND=dp), INTENT(IN)                :: t3
   REAL(KIND=dp), INTENT(IN OUT)            :: g3
   REAL(KIND=dp), INTENT(OUT)               :: grav3(ialphmax*ibetmax)
!
   REAL(KIND=dp)  :: thetamis,phimis,bdist,omega,psi0,overq,vol,dtheta
   REAL(KIND=dp)  :: dphi,snth,snth3,cnth,cox,coy,coz,x,y,z,theta,phi
   REAL(KIND=dp)  :: psiz,psiy,psix,psixx,psi,oneoverg,sarea,reff,sa1,r
   REAL(KIND=dp)  :: sneed,rneed,scale,tempcox,tempcoy,tempcoz,tidephi,ecc
!
   INTEGER :: itide,ialf,iidx,ibet,kount
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   itide=0
   tidephi=0.0_dp
   ecc=0.0_dp
   thetamis=0.0_dp
   phimis=0.0_dp
   bdist=1.0_dp
   omega=1.0_dp
   psi0=1.0E+03_dp
   overq=1.0_dp/30.0_dp
   vol=0.0_dp
!
   dtheta=pie/REAL(nalph,KIND=dp)
!
   DO  ialf=1,nalph
      ibetlim(ialf)=4*nbet
      r=0.00000001_dp
      tempcox=0.0_dp
      tempcoy=0.0_dp
      tempcoz=0.0_dp
      CALL rad(overq,omega,tempcox,tempcoy,tempcoz,psi0,r,x,y,z,1,  &
         bdist,tidephi,itide,ecc,thetamis,phimis)
      theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
      dphi=twopie/REAL(ibetlim(ialf),KIND=dp)
      snth=SIN(theta)
      snth3=SIN(theta)/3.0_dp
      cnth=COS(theta)
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
         iidx=kount(ialphmax,ialf,ibetlim)+ibet
         mmdx(ialf,ibet)=iidx
         phi=-0.5_dp*dphi+dphi*REAL(ibet,KIND=dp)
         phiarr(iidx)=phi
         cox=COS(phi)*snth
         coy=SIN(phi)*snth
         coz=cnth
         CALL rad(overq,omega,cox,coy,coz,psi0,r,x,y,z,1,bdist,  &
            tidephi,itide,ecc,thetamis,phimis)
         CALL poten(overq,omega,x,y,z,psi,psix,psixx,psiy,psiz,1,  &
            bdist,cox,coy,tidephi,itide,ecc,thetamis,phimis)
!
         radarray(iidx)=r
         garray(iidx)=SQRT(psix**2+psiy**2+psiz**2)
         oneoverg=1.0_dp/garray(iidx)
         gradx(iidx)=-psix*oneoverg
         grady(iidx)=-psiy*oneoverg
         gradz(iidx)=-psiz*oneoverg
         surf(iidx)=cox*gradx(iidx)+coy*grady(iidx)+coz*gradz(iidx)
!
!   The following check is for large separations.
!
!              if(surf(iidx).lt.0.7d0)surf(iidx)=0.7d0
!
         surf(iidx)=r**2/surf(iidx)
!
!   Add terms to account for the delta phi and delta theta terms.
!
!   Expression with distribution of points linear in theta.
!
         surf(iidx)=surf(iidx)*dphi*dtheta*snth
!
!   Keep track of the surface area and volume.
!
         sarea=sarea+surf(iidx)
!
!   Expression with distribution of points linear in theta.
!
         vol=vol+1.0_dp*r*r*r*dphi*dtheta*snth3
!
!   Assign x,y,z coordinates of grid point
!
         xarray(iidx)=x
         yarray(iidx)=y
         zarray(iidx)=z
!
      END DO
   END DO
!
   reff=(0.75_dp*vol/pie)**(1.0_dp/3.0_dp)
!
   sa1=reff1*reff1*4.0_dp*pie
   sneed=sa1*sa3
   rneed=SQRT(sneed/4.0_dp/pie)
   scale=rneed/reff
!
   DO  ialf=1,nalph
      DO  ibet=1,ibetlim(ialf)
         iidx=kount(ialphmax,ialf,ibetlim)+ibet
         radarray(iidx)=radarray(iidx)*scale
         surf(iidx)=surf(iidx)*scale*scale
         xarray(iidx)=xarray(iidx)*scale
         yarray(iidx)=yarray(iidx)*scale
         zarray(iidx)=zarray(iidx)*scale
         tmatrix(iidx)=t3
         grav3(iidx)=10.0_dp**(g3)
      END DO
   END DO
!
   reff3=rneed
!
   RETURN
!
END SUBROUTINE setupgeo3
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE setuptemp(istar,ialphmax,ibetmax,nalf,ibetlim,  &
   gmatrix,tpole,tgrav,tmatrix,gpole,mmdx,ioutflag)
!
!   This routine will assign the temperatures of the grid points
!   based on the polar temperature and the gravity darkening law.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: istar
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalf
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: gmatrix(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN OUT)            :: tpole
   REAL(KIND=dp), INTENT(IN)                :: tgrav
   REAL(KIND=dp), INTENT(OUT)               :: tmatrix(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gpole
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp)  :: tmax,tmin,gmin,gmax
   REAL(KIND=dp)  :: div,g_div
!
   INTEGER :: iidx, iamin,ibmin,iamax,ibmax,iagmin,ibgmin
   INTEGER :: ibgmax,ibet,iagmax,ialf
!
   tmax=-12345678.0_dp
   tmin=12345678.0_dp
   gmin=12345678.0_dp
   gmax=-12345678.0_dp
   div=gpole
!
   DO  ialf=1,nalf
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         g_div=gmatrix(iidx)/div
         tmatrix(iidx)=((g_div**tgrav*tpole))
!
         IF(tmatrix(iidx) < tmin)THEN
            tmin=tmatrix(iidx)
            iamin=ialf
            ibmin=ibet
         END IF
         IF(tmatrix(iidx) > tmax)THEN
            tmax=tmatrix(iidx)
            iamax=ialf
            ibmax=ibet
         END IF
         IF(gmatrix(iidx) < gmin)THEN
            gmin=gmatrix(iidx)
            iagmin=ialf
            ibgmin=ibet
         END IF
         IF(gmatrix(iidx) > gmax)THEN
            gmax=gmatrix(iidx)
            iagmax=ialf
            ibgmax=ibet
         END IF
      END DO
   END DO
!
   IF(ioutflag == 1)WRITE(2,30)istar,tmin,iamin,ibmin,tmax,iamax,ibmax
   IF(ioutflag == 1)WRITE(2,40)istar,gmin,iagmin,ibgmin,gmax,iagmax,ibgmax
!
30 FORMAT(/'star ',i1,':  min temp = ',f11.1,'   (at ialf = ',i4,  &
      ' ibet = ',i4,')',/'         max temp = ',f11.1,'   (at ia'  &
      ,'lf = ',i4,' ibet = ',i4,')')
40 FORMAT('star ',i1,':  min grav = ',f11.1,'   (at ialf = ',i4,  &
      ' ibet = ',i4,', program units)',/'         max grav = ',f11.  &
      1,'   (at ialf = ',i4,' ibet = ',i4,', program units)')
!
   RETURN
!
END SUBROUTINE setuptemp
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE shiftlc(nmaxphase,nphase,xxx,yyy,pshift,ilast)
!
!   February 5, 2001
!
!   This routine will apply a phase shift to a light or velocity curve
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxphase
   INTEGER, INTENT(IN)                      :: nphase
   REAL(KIND=dp), INTENT(IN OUT)            :: xxx(nmaxphase)
   REAL(KIND=dp), INTENT(IN OUT)            :: yyy(nmaxphase)
   REAL(KIND=dp), INTENT(IN)                :: pshift
   INTEGER, INTENT(IN)                      :: ilast
!
   REAL(KIND=dp), ALLOCATABLE     :: xdum(:),ydum(:)
   REAL(KIND=dp)                  :: xmax,xmin
!
   INTEGER :: i
!
   INTEGER, PARAMETER :: nndum=1000001
!
   ALLOCATE(ydum(nndum),xdum(nndum))
!
   DO  i=1,nphase
      xdum(i)=xxx(i)
   END DO
!
   DO  i=1,nphase
      xdum(i)=xdum(i)+pshift
      xdum(i)=MOD(xdum(i),1.0_dp)
      ydum(i)=yyy(i)
   END DO
!
!   April 19, 2001
!
!   Add the loop below to ensure that the final x-values are always between
!   0.0 and 1.0.  In some cases where the eccentricity is large, the
!   first pass above might not be enough.
!
   xmax=-999.0_dp
   xmin=999.0_dp
30 DO  i=1,nphase
      IF(xdum(i) > xmax)xmax=xdum(i)
      IF(xdum(i) < xmin)xmin=xdum(i)
      IF(xdum(i) >= 1.0_dp)xdum(i)=xdum(i)-1.0_dp
      IF(xdum(i) < 0.0_dp)xdum(i)=xdum(i)+1.0_dp
   END DO
!
   IF(xmax >= 2.0_dp)GO TO 30
   IF(xmin < -1.0_dp)GO TO 30
!
   IF(nphase > 1)CALL sort3(nphase,xdum,yyy,ydum)
!
   IF(ilast == 1)THEN
      DO  i=1,nphase
         xxx(i)=xdum(i)
      END DO
   END IF
!
   DEALLOCATE(ydum,xdum)
!
   RETURN
!
END SUBROUTINE shiftlc
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE shortmethod(nbody,ilaw,zlist,xylist,radlist,  &
   dwavex,dwavey,reffluxlst,corrlist,rotlist,aalist,bblist,  &
   donvellist,tol)
!
!   Will implement Don Short's method for multi-body
!   transits (which follows Pal).  Can use the linear, quadratic
!   sqrt, or log limb darkening law.
!
!   arguments:
!
!   Nbody       number of bodies, 2 through 10
!   ilaw        flag to select limb darkening (1=linear
!               2=log, 3=sqrt, 4=quad)
!   zlist       1D array with the z-coordinates of each body, where
!               larger z-coordinates are closer to observer
!   xylist      2D array with x and y coordinates of the
!               centers of each body
!   radlist     1D array with the radius of each body
!   dwavex      2D array with x-coefficients for limb darkening,
!               where the first index is the filter and the
!               second index is the body number
!   dwavey      2D array with y-coefficients for limb darkening,
!               where the first index is the filter and the
!               second index is the body number
!   reffluxlst 2D array with reference fluxes for each body,
!               where the first index is the body number and
!               the second index is the filter number
!   corrlist    2D array with the flux corrections, first index
!               is the body number, the second index is the
!               filter number (output)
!   rotlist     1D array with the coefficient needed for
!               scaling the Rossiter effect for each body
!   AAlist      1D array with the A-coefficient for the
!               rotation of the spin axis for each body
!   BBlist      1D array with the B-coefficient for the
!               rotation of the spin axis for each body
!   donvellist  2D array with the Rossiter effect correction,
!               first index is the body number and the
!               second index is the filter number
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nbody
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(IN)                :: zlist(10)
   REAL(KIND=dp), INTENT(IN)                :: xylist(10,2)
   REAL(KIND=dp), INTENT(IN)                :: radlist(10)
   REAL(KIND=dp), INTENT(IN)                :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN)                :: dwavey(8,10)
   REAL(KIND=dp), INTENT(IN)                :: reffluxlst(10,8)
   REAL(KIND=dp), INTENT(OUT)               :: corrlist(10,8)
   REAL(KIND=dp), INTENT(IN)                :: rotlist(10)
   REAL(KIND=dp), INTENT(IN)                :: aalist(10)
   REAL(KIND=dp), INTENT(IN)                :: bblist(10)
   REAL(KIND=dp), INTENT(OUT)               :: donvellist(10,8)
   REAL(KIND=dp), INTENT(IN)                :: tol
!
   REAL(KIND=dp), DIMENSION(10,8)    :: dvsum,sumsave
   REAL(KIND=dp), DIMENSION(10)      :: rd
   REAL(KIND=dp), DIMENSION(10,2)    :: ctm
   REAL(KIND=dp), DIMENSION(10,27,5) :: path,bdr
   REAL(KIND=dp), DIMENSION(8,10)    :: cc,fluxfrac
   REAL(KIND=dp), DIMENSION(27,5)    :: pathn
   REAL(KIND=dp), DIMENSION(5)       :: pathi
   REAL(KIND=dp), DIMENSION(2)       :: ctrn,ctrm
   REAL(KIND=dp), DIMENSION(8)       :: sarray,sumarray
   REAL(KIND=dp), DIMENSION(6)       :: intarray
!
   REAL(KIND=dp)  :: rot,aa,bb,ldx,ldy,alpha,beta,kldx,kldy,ttt,rdm,rdn
!
   INTEGER, DIMENSION(10)   :: indexpath,indexbdr,ilawlist,indxzlist
   INTEGER                  :: i,j,k,n,m,INDEX,idx,ifilt
!
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!  We have to sort the z-coordinate array zlist.  A larger z
!  means closer, smaller z means further away.  The various
!  subroutines need the Nbody stars sorted from near to far.
!
   CALL indexx(10,zlist,indxzlist)
!
!  Construct the RD array (sorted stellar radii)
!
   k=1
   DO i=10,(10-nbody+1),-1
      rd(k)=radlist(indxzlist(i))
      ctm(k,1)=xylist(indxzlist(i),1)
      ctm(k,2)=xylist(indxzlist(i),2)
      ilawlist(k)=indxzlist(i)
      k=k+1
   END DO
!
!  Find the arcs and borders
!
   CALL integrationpaths(nbody,ctm,rd,path,bdr,indexpath,indexbdr)
!
!  Fill the correction array with zeros
!
   DO i=1,10
      DO j=1,8
         corrlist(i,j)=0.0_dp
         sumsave(i,j)=0.0_dp
      END DO
   END DO
!
   DO i=1,6
      intarray(i)=0.0_dp
   END DO
!
!  Now find the flux fractions, and loop over filters
!
!          Tol=3.0d0
!
   DO ifilt=1,8
      fluxfrac(ifilt,1)=1.0_dp
      cc(ifilt,1)=twopie
      dvsum(1,ifilt)=0.0_dp
      dvsum(2,ifilt)=0.0_dp
      dvsum(3,ifilt)=0.0_dp
      dvsum(4,ifilt)=0.0_dp
      dvsum(5,ifilt)=0.0_dp
      dvsum(6,ifilt)=0.0_dp
      dvsum(7,ifilt)=0.0_dp
      dvsum(8,ifilt)=0.0_dp
      dvsum(9,ifilt)=0.0_dp
      dvsum(10,ifilt)=0.0_dp
   END DO
!
   DO n=2,nbody
!
      idx=indxzlist(10-n+1)
      rot=rotlist(idx)
      aa=aalist(idx)
      bb=bblist(idx)
!
!   copy the path array for body N
!
      DO j=1,indexpath(n)
         pathn(j,1)=path(n,j,1)
         pathn(j,2)=path(n,j,2)
         pathn(j,3)=path(n,j,3)
         pathn(j,4)=path(n,j,4)
         pathn(j,5)=path(n,j,5)
      END DO
!
      INDEX=indexpath(n)
      IF(INDEX <= 0)THEN
         DO ifilt=1,8
            fluxfrac(ifilt,n)=0.0_dp
         END DO
         GO TO 10
      END IF
!
      IF(INDEX == 1)THEN
         IF(pathn(1,4) <= 0.0_dp)THEN
            DO ifilt=1,8
               fluxfrac(ifilt,n)=0.0_dp   !1.0_dp   
            END DO
         ELSE
            DO ifilt=1,8
               fluxfrac(ifilt,n)=1.0_dp
               cc(ifilt,n)=twopie
            END DO
         END IF
         GO TO 10
      END IF
!
      DO ifilt=1,8
         sumarray(ifilt)=0.0_dp
      END DO
!
      DO i=1,INDEX
         pathi(1)=pathn(i,1)
         pathi(2)=pathn(i,2)
         pathi(3)=pathn(i,3)
         pathi(4)=pathn(i,4)
         pathi(5)=pathn(i,5)
         m=nint(pathi(2))
         ctrn(1)=ctm(n,1)
         ctrn(2)=ctm(n,2)
         ctrm(1)=ctm(m,1)
         ctrm(2)=ctm(m,2)
         rdm=rd(m)
         rdn=rd(n)
         CALL arcintv3sub(ilaw,ilawlist(n),dwavex,dwavey,n,m,  &
            pathi,ctrn,rdn,ctrm,rdm,tol,sarray)
         CALL rvarcintgnpt(ilaw,n,m,pathi,ctrn,rdn,ctrm,rdm,tol,intarray)
         DO ifilt=1,8
            sumarray(ifilt)=sumarray(ifilt)+sarray(ifilt)
            ldx=dwavex(ifilt,ilawlist(n))
            ldy=dwavey(ifilt,ilawlist(n))
            IF(ilaw == 5)THEN
               kldx=ldx
               kldy=ldy
               ldx=2.0_dp*SQRT(kldx)*kldy
               ldy=SQRT(kldx)*(1.00_dp-2.0_dp*kldy)
            END IF
            IF(ilaw == 6)THEN
               kldx=ldx
               kldy=ldy
               ldx=1.0_dp-SQRT(kldx)*kldy
               ldy=1.0_dp-SQRT(kldx)
            END IF
            IF(ilaw == 7)THEN
               kldx=ldx
               kldy=ldy
               ldx=SQRT(kldx)*(1.0_dp-2.0_dp*kldy)
               ldy=2.0_dp*SQRT(kldx)*kldy
            END IF
            alpha=ldx+ldy
            beta=ldx+2.0_dp*ldy
            dvsum(idx,ifilt)=dvsum(idx,ifilt)+rot*(  &
               (1.0_dp-alpha)*aa*intarray(1) + aa*beta*intarray(2) -  &
               ldy*aa*intarray(3) + bb*(1.0_dp-alpha)*intarray(4) +  &
               bb*beta*intarray(5) - ldy*bb*intarray(6))
         END DO
      END DO
      pathi(1)=REAL(n,KIND=dp)
      pathi(2)=REAL(n,KIND=dp)
      pathi(3)=0.0_dp
      pathi(4)=twopie
      pathi(5)=twopie
      CALL arcintv3sub(ilaw,ilawlist(n),dwavex,dwavey,n,n,pathi,  &
         ctrn,rdn,ctrn,rdn,tol,sarray)
      DO ifilt=1,8
         cc(ifilt,n)=sarray(ifilt)
         fluxfrac(ifilt,n)=sumarray(ifilt)/cc(ifilt,n)
      END DO
!
      DO ifilt=1,8
         sumsave(idx,ifilt)=sumarray(ifilt) 
      END DO
!
10    CONTINUE
!
!  end the loop over bodies
!
   END DO
!
!   Now we have to fill the corrlist
!
   DO ifilt=1,8
      DO k=1,nbody
         idx=indxzlist(10-k+1)
         ttt=-(1.0_dp-fluxfrac(ifilt,k))
         corrlist(idx,ifilt)=reffluxlst(idx,ifilt)*ttt
         IF(ABS(sumsave(idx,ifilt)) > EPSILON(sumsave(idx,ifilt)))THEN
            donvellist(idx,ifilt)=-dvsum(idx,ifilt)/sumsave(idx,ifilt)
         ELSE
            donvellist(idx,ifilt)=0.0_dp
         END IF
      END DO
   END DO
!
   RETURN
!
END SUBROUTINE shortmethod
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE shortmethod2(ilaw,iback,xfront,yfront,xback,  &
   yback,rfront,rback,dwavex,dwavey,reffluxback,corrback,rot,aa,  &
   bb,donvel,tol,irossiter)
!
!   Will implement Don Short's method for multi-body
!   transits (which follows Pal).  Can use the linear, quadratic
!   sqrt, or log limb darkening law.  This routine is streamlined
!   assuming only two bodies.
!
!   ilaw:   an integer flag giving the limb darkening law (1=linear
!           2=log, 3=sqrt, 4=quad)
!   iback:  index of body in back (used for limb darkening coefficients)
!   xfront:  x-coordinate of center of the front body
!   yfront:  y-coordinate of center of the front body
!   xback:   x-coordinate of center of the back body
!   yback:   y-coordinate of center of the back body
!   rfront:  radius of the front body
!   rback:   radius of the back body
!   dwavex:  array of limb darkening x-coefficients, for 8
!            bandpasses and up to 10 stars
!   dwavey:  array of limb darkening y-coefficients, for 8
!            bandpasses and up to 10 stars
!   reffluxback:   fluxes for star in back, 8 bandpasses
!   corrback:      corrections to the flux for the back body,
!                  8 bandpasses
!   rot:     ratio of spin frequency to orbital frequency of
!            back star
!   AA,BB:   Used for misaligned rotation axes (AA=1 and BB=0 for
!            aligned axis)
!   Tol:     Sets the accuracy of the integration
!   iRossiter:  Flag to include the Rossiter effect
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: iback
   REAL(KIND=dp), INTENT(IN)                :: xfront
   REAL(KIND=dp), INTENT(IN)                :: yfront
   REAL(KIND=dp), INTENT(IN)                :: xback
   REAL(KIND=dp), INTENT(IN)                :: yback
   REAL(KIND=dp), INTENT(IN)                :: rfront
   REAL(KIND=dp), INTENT(IN)                :: rback
   REAL(KIND=dp), INTENT(IN)                :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN)                :: dwavey(8,10)
   REAL(KIND=dp), INTENT(IN)                :: reffluxback(8)
   REAL(KIND=dp), INTENT(OUT)               :: corrback(8)
   REAL(KIND=dp), INTENT(IN)                :: rot
   REAL(KIND=dp), INTENT(IN)                :: aa
   REAL(KIND=dp), INTENT(IN)                :: bb
   REAL(KIND=dp), INTENT(OUT)               :: donvel(8)
   REAL(KIND=dp), INTENT(IN)                :: tol
   INTEGER, INTENT(IN)                      :: irossiter
!
   REAL(KIND=dp)  :: rdm,rdn,ttt,ldx,ldy,alpha,beta
   REAL(KIND=dp)  :: kldx,kldy,dist,tiny,w,phi1,phi0,r1,r2,a,b,c,ang1
   REAL(KIND=dp)  :: phi0front,phi1front,phi0back,phi1back,s,xsave
   REAL(KIND=dp)  :: ysave,rmdn,ctrnx,ctrny,ctrmx,ctrmy,cmnx,cmny,intc,intl
   REAL(KIND=dp)  :: newintgnpt,cmnx2,cmnx3,cmny2,cmny3,rmdn2,d,e2,intq
   REAL(KIND=dp)  :: intlog,intsq,intgnpt,rvintgnpt,e,f,g,intca,intcb,intla
   REAL(KIND=dp)  :: intlb,intqa,intqb
!
   REAL(KIND=dp), DIMENSION(10)    :: rd
   REAL(KIND=dp), DIMENSION(5)     :: arcn,arci,pathi
   REAL(KIND=dp), DIMENSION(2)     :: ct1,ct2,ctrn,ctrm,arcout,arcin
   REAL(KIND=dp), DIMENSION(8)     :: sumarray,sarray,dvsum
   REAL(KIND=dp), DIMENSION(10,2)  :: ctm
   REAL(KIND=dp), DIMENSION(8,10)  :: cc,fluxfrac
   REAL(KIND=dp), DIMENSION(6)     :: intarray
!
   INTEGER :: j,n,ifilt,ifront,iiback,ilawt
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
!   IF(PRECISION(tiny).ge.18)THEN
!     tiny=3.0E-18_dp
!   ELSE
!     tiny=3.0E-15_dp
!   END IF
!
   tiny=10.0_dp*epsilon(tiny)
!
   ifront=1
   iiback=2
!
   DO ifilt=1,8
      sumarray(ifilt)=0.0_dp
      dvsum(ifilt)=0.0_dp
      sarray(ifilt)=0.0_dp
   END DO
!
!   We will shift the center of the front body to (delta,0)
!   and the center of the back body to (0,0).  This will allow
!   us to use symmetry later on to reduce the number of
!   steps in the Gaussian quadrature.
!
   dist=SQRT((xfront-xback)**2+(yfront-yback)**2)
   ct1(1)=dist
   ct1(2)=0.0_dp
   ct2(1)=0.0_dp
   ct2(2)=0.0_dp
   ctm(1,1)=dist
   ctm(1,2)=0.0_dp
   ctm(2,1)=0.0_dp
   ctm(2,2)=0.0_dp
   rd(1)=rfront
   rd(2)=rback
!
!   If we are doing the Rossiter effect, we cannot rotate
!   the coordinates
!
   IF(irossiter >= 1)THEN
      ct1(1)=xfront
      ct1(2)=yfront
      ct2(1)=xback
      ct2(2)=yback
      ctm(1,1)=xfront
      ctm(1,2)=yfront
      ctm(2,1)=xback
      ctm(2,2)=yback
   END IF
!
   IF(rfront+rback-tiny <= dist)THEN
!
!   no eclipse event
!
      DO ifilt=1,8
         corrback(ifilt)=0.0_dp
         donvel(ifilt)=0.0_dp
      END DO
      RETURN
   END IF
!
   IF(dist+rfront <= rback-tiny)THEN
!
!   front inside back, transit event
!
      phi0front=0.0_dp
      phi1front=twopie
      phi0back=0.0_dp
      phi1back=twopie
      GO TO 10
   END IF
!
   IF(dist+rback <= rfront+tiny)THEN
!
!   front contained within back, total eclipse
!
      DO ifilt=1,8
         corrback(ifilt)=-1.0_dp*reffluxback(ifilt)
         donvel(ifilt)=0.0_dp
      END DO
      RETURN
   END IF
!
   r1=rfront
   r2=rback
   phi0=MOD(ATAN2(ct2(2)-ct1(2),ct2(1)-ct1(1)),twopie)
   IF(phi0 < 0.0_dp)phi0=phi0+twopie
   w=(r1*r1+dist*dist-r2*r2)/(2.0_dp*r1*dist)
!
!   Trap a rare round-off error using the tiny
!
   IF(w > 1.0_dp)w=w-tiny
   IF(w < -1.0_dp)w=w+tiny
   IF(ABS(w) <= 1.0_dp)THEN
      phi1=ACOS(w)
      arcin(1)=MOD(phi0-phi1,twopie)
      IF(arcin(1) < 0.0_dp)arcin(1)=arcin(1)+twopie
      arcin(2)=2.0_dp*phi1
      a=arcin(1)
      b=arcin(2)
      c=a+b
      arci(1)=REAL(iiback,KIND=dp)
      arci(2)=REAL(ifront,KIND=dp)
      arci(3)=a
      arci(4)=c-a
      arci(5)=c
   ELSE
      WRITE(*,*) 'Cosine Error1'
   END IF
!
   phi0front=arci(3)
   phi1front=arci(5)
!
   w=(r2*r2+dist*dist-r1*r1)/(2.0_dp*r2*dist)
!
!   Trap a rare round-off error using the tiny
!
   IF(w > 1.0_dp)w=w-tiny
   IF(w < -1.0_dp)w=w+tiny
!
   IF(ABS(w) <= 1.0_dp)THEN
      phi1=pie-ACOS(w)
      ang1=MOD(phi0-phi1,twopie)
      IF(ang1 < 0.0_dp)ang1=ang1+twopie
      arcout(1)=ang1
      arcout(2)=2.0_dp*phi1
      a=arcout(1)
      b=arcout(2)
      c=a+b
      arcn(1)=REAL(iiback,KIND=dp)
      arcn(2)=REAL(iiback,KIND=dp)
      arcn(3)=a
      arcn(4)=c-a
      arcn(5)=c
   ELSE
      WRITE(*,*) 'Cosine Error2'
   END IF
!
   phi0back=arcn(3)
   phi1back=arcn(5)
10 CONTINUE
!
   phi1=phi1back
   phi0=phi0back
!
!  Fill the correction array
!
   DO j=1,8
      corrback(j)=0.0_dp
   END DO
!
   DO j=1,6
      intarray(j)=0.0_dp
   END DO
!
!  Now find the flux fractions, and loop over filters
!
   DO ifilt=1,8
      fluxfrac(ifilt,1)=1.0_dp
      cc(ifilt,1)=twopie
   END DO
!
   n=2
!
   DO ifilt=1,8
      sumarray(ifilt)=0.0_dp
      dvsum(ifilt)=0.0_dp
      s=0.0_dp
   END DO
!
   ctrn(1)=ctm(2,1)
   ctrn(2)=ctm(2,2)
   ctrm(1)=ctm(1,1)
   ctrm(2)=ctm(1,2)
   rdm=rd(1)
   rdn=rd(2)
!
!  back body, done in closed form
!
   DO ifilt=1,8
      ldx=dwavex(ifilt,iback)
      ldy=dwavey(ifilt,iback)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         s=(0.5_dp-ldx/6.0_dp)*(phi1back-phi0back)
      END IF
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         s=(0.5_dp-(ldx+2.0_dp*ldy)/6.0_dp+ldy/4.0_dp)*(phi1back-phi0back)
      END IF
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         s=(0.5_dp-(ldx+2.0_dp*ldy)/6.0_dp+ldy/4.0_dp)*(phi1back-phi0back)
      END IF
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         s=(0.5_dp-ldx/6.0_dp-ldy/10.0_dp)*(phi1back-phi0back)
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         s=(0.5_dp-ldx/6.0_dp-ldy/10.0_dp)*(phi1back-phi0back)
      END IF
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         s=(0.5_dp-ldx/6.0_dp+ldy/9.0_dp)*(phi1back-phi0back)
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         s=(0.5_dp-ldx/6.0_dp+ldy/9.0_dp)*(phi1back-phi0back)
      END IF
      IF(ilaw == 0)THEN
         s=0.5_dp*(phi1back-phi0back)
      END IF
      sarray(ifilt)=s
   END DO
!
   DO ifilt=1,8
      sumarray(ifilt)=sumarray(ifilt)+sarray(ifilt)
   END DO
!
!  body in front
!
   rmdn=rdm/rdn
!
   ctrnx=ctrn(1)
   ctrmx=ctrm(1)
   ctrny=ctrn(2)
   ctrmy=ctrm(2)
   cmnx=(ctrmx-ctrnx)/rdn
   cmny=(ctrmy-ctrny)/rdn
!
   phi0=phi0front
   phi1=phi1front
!
!   Compute arc terms, which don't depend on limb darkening.  For
!   this subroutine, call a different function to evaluate the
!   Gaussian quadrature (newIntGNpt instead of IntGNpt).
!
   IF((ilaw == 1).OR.(ilaw == 11))THEN
!
!   integral of constant term for linear
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of linear term
!
      pathi(3)=phi0
      pathi(4)=(phi1-phi0)
      pathi(5)=phi1
      IF(irossiter == 0)THEN
         intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
      ELSE
         intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
      END IF
   END IF
!
   IF((ilaw == 5).OR.(ilaw == 15))THEN
!
!   integral of constant term for Kipping quad
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of quadratic term
!
      cmnx2=cmnx**2
      cmnx3=cmnx**3
      cmny2=cmny**2
      cmny3=cmny**3
      rmdn2=rmdn**2
!
      a=(-cmnx2*cmny-cmny3-3.0_dp*cmny*rmdn2)*rmdn/4.0_dp
      b=(-(cmnx*cmny*rmdn2)/4.0_dp)
      c=(cmnx2-cmny2)*rmdn2/8.0_dp
      d=(cmnx3+cmnx*cmny2+3.0_dp*cmnx*rmdn2)*rmdn/4.0_dp
      e2=(cmnx2+cmny2+rmdn2/2.0_dp)*rmdn2/2.0_dp
      intq=a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-COS(2.0_dp*  &
         phi0))+c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+d*(SIN(phi1)-  &
         SIN(phi0))+e2*(phi1-phi0)
!
      pathi(3)=phi0
      pathi(4)=(phi1-phi0)
      pathi(5)=phi1
      IF(irossiter == 0)THEN
         intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      ELSE
         intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      END IF
   END IF

   IF((ilaw == 4).OR.(ilaw == 14))THEN
!
!   integral of constant term for quad
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of quadratic term
!
      cmnx2=cmnx**2
      cmnx3=cmnx**3
      cmny2=cmny**2
      cmny3=cmny**3
      rmdn2=rmdn**2
!
      a=(-cmnx2*cmny-cmny3-3.0_dp*cmny*rmdn2)*rmdn/4.0_dp
      b=(-(cmnx*cmny*rmdn2)/4.0_dp)
      c=(cmnx2-cmny2)*rmdn2/8.0_dp
      d=(cmnx3+cmnx*cmny2+3.0_dp*cmnx*rmdn2)*rmdn/4.0_dp
      e2=(cmnx2+cmny2+rmdn2/2.0_dp)*rmdn2/2.0_dp
      intq=a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-COS(2.0_dp*  &
         phi0))+c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+d*(SIN(phi1)-  &
         SIN(phi0))+e2*(phi1-phi0)
!
!   integral of linear term (note the value of 1 at end)
!
      pathi(3)=phi0
      pathi(4)=(phi1-phi0)
      pathi(5)=phi1
      IF(irossiter == 0)THEN
         intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      ELSE
         intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      END IF
!
   END IF
!
   IF((ilaw == 2).OR.(ilaw == 12))THEN
!
!   integral of constant term
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of the linear term (note the value of 1 at the end)
!
      pathi(3)=phi0
      pathi(4)=(phi1-phi0)
      pathi(5)=phi1
      IF(irossiter == 0)THEN
         intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      ELSE
         intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      END IF
!
!   integral of the log term
!
      IF(irossiter == 0)THEN
         intlog=newintgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
      ELSE
         intlog=intgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
      END IF
   END IF
!
   IF((ilaw == 6).OR.(ilaw == 16))THEN
!
      ilawt=2
!
!   integral of constant term
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of the linear term (note the value of 1 at the end)
!
      pathi(3)=phi0
      pathi(4)=(phi1-phi0)
      pathi(5)=phi1
      IF(irossiter == 0)THEN
         intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      ELSE
         intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      END IF
!
!   integral of the log term
!
      IF(irossiter == 0)THEN
         intlog=newintgnpt(pathi,tol,rmdn,cmnx,cmny,ilawt)
      ELSE
         intlog=intgnpt(pathi,tol,rmdn,cmnx,cmny,ilawt)
      END IF
   END IF
!
   IF((ilaw == 3).OR.(ilaw == 13))THEN
!
!   integral of constant term for sqrt law
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of sqrt term
!
      pathi(3)=phi0
      pathi(4)=(phi1-phi0)
      pathi(5)=phi1
      IF(irossiter == 0)THEN
         intsq=newintgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
      ELSE
         intsq=intgnpt(pathi,tol,rmdn,cmnx,cmny,ilaw)
      END IF
!
!   integral of linear term (note the value of 1 at end)
!
      IF(irossiter == 0)THEN
         intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      ELSE
         intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      END IF
   END IF
!
   IF((ilaw == 7).OR.(ilaw == 17))THEN
!
      ilawt=3
!
!   integral of constant term for sqrt law
!
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
!
!   integral of sqrt term
!
      pathi(3)=phi0
      pathi(4)=(phi1-phi0)
      pathi(5)=phi1
      IF(irossiter == 0)THEN
         intsq=newintgnpt(pathi,tol,rmdn,cmnx,cmny,ilawt)
      ELSE
         intsq=intgnpt(pathi,tol,rmdn,cmnx,cmny,ilawt)
      END IF
!
!   integral of linear term (note the value of 1 at end)
!
      IF(irossiter == 0)THEN
         intl=newintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      ELSE
         intl=intgnpt(pathi,tol,rmdn,cmnx,cmny,1)
      END IF
   END IF
!
!   no limb darkening
!
   IF(ilaw == 0)THEN
      intc=rmdn*(rmdn*(phi1-phi0)-cmny*(COS(phi1)-COS(phi0))+cmnx*  &
         (SIN(phi1)-SIN(phi0)))/2.0_dp
      s=-intc
   END IF
!
!   now loop over filters and apply limb darkening parameters
!
   DO ifilt=1,8
      ldx=dwavex(ifilt,iback)
      ldy=dwavey(ifilt,iback)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF(ilaw == 0)THEN
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         s=-intc+ldx*intl
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         s=-intc+ldx*intl+ldy*intlog
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         s=-intc+ldx*intl+ldy*intlog
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         s=-intc+ldx*intl+ldy*intsq
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         s=-intc+ldx*intl+ldy*intsq
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         s=(-intc+(ldx+2.0_dp*ldy)*intl-ldy*intq)
         sarray(ifilt)=s
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         s=(-intc+(ldx+2.0_dp*ldy)*intl-ldy*intq)
         sarray(ifilt)=s
      END IF
!
   END DO
!
   DO ifilt=1,8
      sumarray(ifilt)=sumarray(ifilt)+sarray(ifilt)
   END DO
!
   IF(irossiter >= 1)THEN
      phi1=phi1back
      phi0=phi0back
!
!  back body
!
      intca=SIN(phi1)/2.0_dp-SIN(phi1)**3/6.0_dp-(SIN(phi0)/2.0_dp-  &
         SIN(phi0)**3/6.0_dp)
      intcb=-COS(phi1)/2.0_dp+(COS(phi1)**3)/6.0_dp-(-COS(phi0)/2.0_dp  &
         +(COS(phi0)**3)/6.0_dp)
      intla=0.0_dp
      intlb=0.0_dp
      intqa=0.0_dp
      intqb=0.0_dp
      intarray(1)=intca
      intarray(2)=intla
      intarray(3)=intqa
      intarray(4)=intcb
      intarray(5)=intlb
      intarray(6)=intqb
!
      DO ifilt=1,8
         IF(irossiter >= 1)THEN
            ldx=dwavex(ifilt,iback)
            ldy=dwavey(ifilt,iback)
            IF(ilaw == 5)THEN
               kldx=ldx
               kldy=ldy
               ldx=2.0_dp*SQRT(kldx)*kldy
               ldy=SQRT(kldx)*(1.00_dp-2.0_dp*kldy)
            END IF
            IF(ilaw == 15)THEN
               kldx=ldx
               kldy=ldy
               ldx=2.0_dp*SQRT(kldx)*kldy
               ldy=SQRT(kldx)*(1.00_dp-2.0_dp*kldy)
            END IF
            IF(ilaw == 6)THEN
               kldx=ldx
               kldy=ldy
               ldx=1.0_dp-SQRT(kldx)*kldy
               ldy=1.0_dp-SQRT(kldx)
            END IF
            IF(ilaw == 16)THEN
               kldx=ldx
               kldy=ldy
               ldx=1.0_dp-SQRT(kldx)*kldy
               ldy=1.0_dp-SQRT(kldx)
            END IF
            IF(ilaw == 7)THEN
               kldx=ldx
               kldy=ldy
               ldx=SQRT(kldx)*(1.0_dp-2.0_dp*kldy)
               ldy=2.0_dp*SQRT(kldx)*kldy
            END IF
            IF(ilaw == 17)THEN
               kldx=ldx
               kldy=ldy
               ldx=SQRT(kldx)*(1.0_dp-2.0_dp*kldy)
               ldy=2.0_dp*SQRT(kldx)*kldy
            END IF
            alpha=ldx+ldy
            beta=ldx+2.0_dp*ldy
            dvsum(ifilt)=dvsum(ifilt)+((1.0_dp-alpha)*aa*intarray(1)+  &
               aa*beta*intarray(2)-ldy*aa*intarray(3)+bb*(1.0_dp-alpha)  &
               *intarray(4)+bb*beta*intarray(5)-ldy*bb*intarray(6))
         END IF
      END DO
!
!   front body
!
      phi1=phi1front
      phi0=phi0front
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         intca=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,1)
         intcb=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,2)
         intla=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,3)
         intlb=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,4)
         intqa=0.0_dp
         intqb=0.0_dp
      END IF
!
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         cmnx2=cmnx**2
         cmnx3=cmnx**3
         cmny2=cmny**2
         cmny3=cmny**3
         rmdn2=rmdn**2
!
         d=cmnx*rmdn
         c=rmdn**2/12.0_dp
         a=cmnx2+9.0_dp*c
         b=d/2.0_dp
         intca=rmdn*(a*(SIN(phi1)-SIN(phi0))+b*(SIN(2.0_dp*phi1)-  &
            SIN(2.0_dp*phi0))+c*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0))+ &
            d*(phi1-phi0))/2.0_dp
!
         a=-(cmny2+rmdn2)
         b=rmdn2/3.0_dp
         c=-(cmny*rmdn)/2.0_dp
         d=-2.0_dp*c
         intcb=rmdn*(a*(COS(phi1)-COS(phi0))+b*((COS(phi1))**3-  &
            (COS(phi0))**3)+c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+d* &
            (phi1-phi0))/2.0_dp
!
         intla=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,3)
         intlb=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,4)
!
         a=cmnx*cmny*rmdn2
         b=rmdn*cmny*(cmnx2+cmny2+rmdn2-1.0_dp)/2.0_dp
         c=a/3.0_dp
         d=(-cmnx**4-2.0_dp*cmnx2*cmny2+2.0_dp*cmnx2-cmny**4+2.0_dp*  &
            cmny2+rmdn2*(2.0_dp-5.0_dp*cmnx2-3.0_dp*cmny2-rmdn2)-1.0_dp)/2.0_dp
         e=rmdn*cmnx*(1.0_dp-cmny2-rmdn2-cmnx2)/2.0_dp
         f=rmdn2*(cmny2-cmnx2)/6.0_dp
         g=2.0_dp*e
         intqa=rmdn*(a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-  &
            COS(2.0_dp*phi0))+c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0))+d*  &
            (SIN(phi1)-SIN(phi0))+e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))  &
            +f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0))+g*(phi1-phi0))/2.0_dp
!
         a=(cmnx2*(cmnx2+2.0_dp*cmny2+3.0_dp*rmdn2-2.0_dp)+cmny2*  &
            (cmny2+5.0_dp*rmdn2-2.0_dp)+rmdn2*(rmdn2-2.0_dp)+1.0_dp)/4.0_dp
         b=rmdn*(cmnx3+cmnx*cmny2+cmnx*rmdn2-cmnx)/4.0_dp
         c=rmdn2*(cmnx2-cmny2)/12.0_dp
         d=rmdn2*(-cmnx*cmny)/2.0_dp
         e=rmdn*cmny*(cmnx2+cmny2+rmdn2-1.0_dp)/4.0_dp
         f=-d/3.0_dp
         g=-2.0_dp*e
         intqb=rmdn*(a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-  &
            COS(2.0_dp*phi0))+c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0))+d*  &
            (SIN(phi1)-SIN(phi0))+e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))  &
            +f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0))+g*(phi1-phi0))
!
      END IF
!
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         cmnx2=cmnx**2
         cmnx3=cmnx**3
         cmny2=cmny**2
         cmny3=cmny**3
         rmdn2=rmdn**2
!
         d=cmnx*rmdn
         c=rmdn2/12.0_dp
         a=cmnx2+9.0_dp*c
         b=d/2.0_dp
         intca=rmdn*(a*(SIN(phi1)-SIN(phi0))+b*(SIN(2.0_dp*phi1)-  &
            SIN(2.0_dp*phi0))+c*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0))+d* &
              (phi1-phi0))/2.0_dp
!
         a=-(cmny2+rmdn2)
         b=rmdn2/3.0_dp
         c=-(cmny*rmdn)/2.0_dp
         d=-2.0_dp*c
         intcb=rmdn*(a*(COS(phi1)-COS(phi0))+b*((COS(phi1))**3-  &
            (COS(phi0))**3)+c*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))+d* &
            (phi1-phi0))/2.0_dp
!
         intla=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,3)
         intlb=rvintgnpt(pathi,tol,rmdn,cmnx,cmny,4)
!
         a=cmnx*cmny*rmdn2
         b=rmdn*cmny*(cmnx2+cmny2+rmdn2-1.0_dp)/2.0_dp
         c=a/3.0_dp
         d=(-cmnx**4-2.0_dp*cmnx2*cmny2+2.0_dp*cmnx2-cmny**4+2.0_dp*  &
            cmny2+rmdn2*(2.0_dp-5.0_dp*cmnx2-3.0_dp*cmny2-rmdn2)-1.0_dp)/2.0_dp
         e=rmdn*cmnx*(1.0_dp-cmny2-rmdn2-cmnx2)/2.0_dp
         f=rmdn2*(cmny2-cmnx2)/6.0_dp
         g=2.0_dp*e
         intqa=rmdn*(a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-  &
            COS(2.0_dp*phi0))+c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0))+d*  &
            (SIN(phi1)-SIN(phi0))+e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))  &
            +f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0))+g*(phi1-phi0))/2.0_dp
!
         a=(cmnx2*(cmnx2+2.0_dp*cmny2+3.0_dp*rmdn2-2.0_dp)+cmny2*  &
            (cmny2+5.0_dp*rmdn2-2.0_dp)+rmdn2*(rmdn2-2.0_dp)+1.0_dp)/4.0_dp
         b=rmdn*(cmnx3+cmnx*cmny2+cmnx*rmdn2-cmnx)/4.0_dp
         c=rmdn2*(cmnx2-cmny2)/12.0_dp
         d=rmdn2*(-cmnx*cmny)/2.0_dp
         e=rmdn*cmny*(cmnx2+cmny2+rmdn2-1.0_dp)/4.0_dp
         f=-d/3.0_dp
         g=-2.0_dp*e
         intqb=rmdn*(a*(COS(phi1)-COS(phi0))+b*(COS(2.0_dp*phi1)-  &
            COS(2.0_dp*phi0))+c*(COS(3.0_dp*phi1)-COS(3.0_dp*phi0))+d*  &
            (SIN(phi1)-SIN(phi0))+e*(SIN(2.0_dp*phi1)-SIN(2.0_dp*phi0))  &
            +f*(SIN(3.0_dp*phi1)-SIN(3.0_dp*phi0))+g*(phi1-phi0))
!
      END IF
!
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         intca=0.0_dp
         intcb=0.0_dp
         intla=0.0_dp
         intlb=0.0_dp
         intqa=0.0_dp
         intqb=0.0_dp
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         intca=0.0_dp
         intcb=0.0_dp
         intla=0.0_dp
         intlb=0.0_dp
         intqa=0.0_dp
         intqb=0.0_dp
      END IF
!
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         intca=0.0_dp
         intcb=0.0_dp
         intla=0.0_dp
         intlb=0.0_dp
         intqa=0.0_dp
         intqb=0.0_dp
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         intca=0.0_dp
         intcb=0.0_dp
         intla=0.0_dp
         intlb=0.0_dp
         intqa=0.0_dp
         intqb=0.0_dp
      END IF
!
!   no limb darkening
!
      IF(ilaw == 0)THEN
         intca=0.0_dp
         intcb=0.0_dp
         intla=0.0_dp
         intlb=0.0_dp
         intqa=0.0_dp
         intqb=0.0_dp
      END IF
!
      intarray(1)=-intca
      intarray(2)=-intla
      intarray(3)=-intqa
      intarray(4)=-intcb
      intarray(5)=-intlb
      intarray(6)=-intqb
!
      DO ifilt=1,8
         IF(irossiter >= 1)THEN
            ldx=dwavex(ifilt,iback)
            ldy=dwavey(ifilt,iback)
            IF(ilaw == 5)THEN
               kldx=ldx
               kldy=ldy
               ldx=2.0_dp*SQRT(kldx)*kldy
               ldy=SQRT(kldx)*(1.00_dp-2.0_dp*kldy)
            END IF
            IF(ilaw == 15)THEN
               kldx=ldx
               kldy=ldy
               ldx=2.0_dp*SQRT(kldx)*kldy
               ldy=SQRT(kldx)*(1.00_dp-2.0_dp*kldy)
            END IF
            IF(ilaw == 6)THEN
               kldx=ldx
               kldy=ldy
               ldx=1.0_dp-SQRT(kldx)*kldy
               ldy=1.0_dp-SQRT(kldx)
            END IF
            IF(ilaw == 16)THEN
               kldx=ldx
               kldy=ldy
               ldx=1.0_dp-SQRT(kldx)*kldy
               ldy=1.0_dp-SQRT(kldx)
            END IF
            IF(ilaw == 7)THEN
               kldx=ldx
               kldy=ldy
               ldx=SQRT(kldx)*(1.0_dp-2.0_dp*kldy)
               ldy=2.0_dp*SQRT(kldx)*kldy
            END IF
            IF(ilaw == 17)THEN
               kldx=ldx
               kldy=ldy
               ldx=SQRT(kldx)*(1.0_dp-2.0_dp*kldy)
               ldy=2.0_dp*SQRT(kldx)*kldy
            END IF
            alpha=ldx+ldy
            beta=ldx+2.0_dp*ldy
            dvsum(ifilt)=dvsum(ifilt)+((1.0_dp-alpha)*aa*intarray(1)+  &
               aa*beta*intarray(2)-ldy*aa*intarray(3)+bb*(1.0_dp-alpha)  &
               *intarray(4)+bb*beta*intarray(5)-ldy*bb*intarray(6))
         END IF
      END DO
!
   END IF
!
   phi1=twopie
   phi0=0.0_dp
!
   DO ifilt=1,8
      ldx=dwavex(ifilt,iback)
      ldy=dwavey(ifilt,iback)
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         xsave=ldx
         ysave=ldy
         ldx=2.0_dp*SQRT(xsave)*ysave
         ldy=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
      END IF
!
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         xsave=ldx
         ysave=ldy
         ldx=1.0_dp-SQRT(xsave)*ysave
         ldy=1.0_dp-SQRT(xsave)
      END IF
!
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         xsave=ldx
         ysave=ldy
         ldx=SQRT(xsave)*(1.0_dp-2.0_dp*ysave)
         ldy=2.0_dp*SQRT(xsave)*ysave
      END IF
!
      IF((ilaw == 1).OR.(ilaw == 11))THEN
         s=(0.5_dp-ldx/6.0_dp)*phi1
      END IF
      IF((ilaw == 5).OR.(ilaw == 15))THEN
         s=(0.5_dp-(ldx+2.0_dp*ldy)/6.0_dp+ldy/4.0_dp)*phi1
      END IF
      IF((ilaw == 4).OR.(ilaw == 14))THEN
         s=(0.5_dp-(ldx+2.0_dp*ldy)/6.0_dp+ldy/4.0_dp)*phi1
      END IF
      IF((ilaw == 2).OR.(ilaw == 12))THEN
         s=(0.5_dp-ldx/6.0_dp+ldy/9.0_dp)*phi1
      END IF
      IF((ilaw == 6).OR.(ilaw == 16))THEN
         s=(0.5_dp-ldx/6.0_dp+ldy/9.0_dp)*phi1
      END IF
      IF((ilaw == 3).OR.(ilaw == 13))THEN
         s=(0.5_dp-ldx/6.0_dp-ldy/10.0_dp)*phi1
      END IF
      IF((ilaw == 7).OR.(ilaw == 17))THEN
         s=(0.5_dp-ldx/6.0_dp-ldy/10.0_dp)*phi1
      END IF
      IF(ilaw == 0)THEN
         s=0.5_dp*phi1
      END IF
      sarray(ifilt)=s
   END DO
!
   DO ifilt=1,8
      cc(ifilt,n)=sarray(ifilt)
      fluxfrac(ifilt,n)=sumarray(ifilt)/cc(ifilt,n)
   END DO
!
!   Now we have to fill the corrlist
!
   DO ifilt=1,8
      ttt=-(1.0_dp-fluxfrac(ifilt,2))
      corrback(ifilt)=reffluxback(ifilt)*ttt
      IF(irossiter >= 1)THEN
         IF(ABS(sarray(ifilt)) > EPSILON(sarray(ifilt)))THEN
            donvel(ifilt)=-rot*dvsum(ifilt)/sumarray(ifilt)
         ELSE
            donvel(ifilt)=0.0_dp
         END IF
      END IF
   END DO
!
   RETURN
!
END SUBROUTINE shortmethod2
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE simplerefl(ialphmax1,ibetmax1,nalph1,ibetlim1,  &
   nalph2,ibetlim2,xarray1,yarray1,zarray1,gradx1,grady1,gradz1,  &
   garray1,xarray2,yarray2,zarray2,gradx2,grady2,gradz2,garray2,  &
   temp1,temp2,dbolx,dboly,ilaw,alb1,alb2,teff1,teff2,tgrav1,  &
   tgrav2,rlx,iidint,redge,betarim,gpole1,gpole2,tpole1,tpole2,  &
   bdist,sa1,sa2,rad1,rad2,separ,mmdx1,mmdx2,ialphmax2,ibetmax2,  &
   isw25,ioutflag)
!
!    UPDATE March 22, 2002
!
!    This routine is a simplified and faster version of the detailed
!    reflection, valid for nearly spherical stars.
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax1
   INTEGER, INTENT(IN)                      :: ibetmax1
   INTEGER, INTENT(IN)                      :: ialphmax2
   INTEGER, INTENT(IN)                      :: ibetmax2
   INTEGER, INTENT(IN)                      :: nalph1
   INTEGER, INTENT(IN)                      :: ibetlim1(ialphmax1)
   INTEGER, INTENT(IN)                      :: nalph2
   INTEGER, INTENT(IN)                      :: ibetlim2(ialphmax2)
   REAL(KIND=dp), INTENT(IN)                :: xarray1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: yarray1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: zarray1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: gradx1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: grady1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: gradz1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: garray1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: xarray2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: yarray2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: zarray2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: gradx2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: grady2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: gradz2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: garray2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN OUT)            :: temp1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN OUT)            :: temp2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: dbolx(8,2)
   REAL(KIND=dp), INTENT(IN)                :: dboly(8,2)
   INTEGER, INTENT(IN)                      :: ilaw
   REAL(KIND=dp), INTENT(IN)                :: alb1
   REAL(KIND=dp), INTENT(IN)                :: alb2
   REAL(KIND=dp), INTENT(IN)                :: teff1
   REAL(KIND=dp), INTENT(IN)                :: teff2
   REAL(KIND=dp), INTENT(IN)                :: tgrav1
   REAL(KIND=dp), INTENT(IN)                :: tgrav2
   REAL(KIND=dp), INTENT(IN)                :: rlx
   INTEGER, INTENT(IN)                      :: iidint
   REAL(KIND=dp), INTENT(IN)                :: redge
   REAL(KIND=dp), INTENT(IN)                :: betarim
   REAL(KIND=dp), INTENT(IN)                :: gpole1
   REAL(KIND=dp), INTENT(IN)                :: gpole2
   REAL(KIND=dp), INTENT(IN)                :: tpole1
   REAL(KIND=dp), INTENT(IN)                :: tpole2
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: sa1
   REAL(KIND=dp), INTENT(IN OUT)            :: sa2
   REAL(KIND=dp), INTENT(IN)                :: rad1(ialphmax1*ibetmax1)
   REAL(KIND=dp), INTENT(IN)                :: rad2(ialphmax2*ibetmax2)
   REAL(KIND=dp), INTENT(IN)                :: separ
   INTEGER, INTENT(IN)                      :: mmdx1(ialphmax1,ibetmax1)
   INTEGER, INTENT(IN)                      :: mmdx2(ialphmax2,ibetmax2)
   INTEGER, INTENT(IN)                      :: isw25
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp)  :: term1,dist1,dist,zcross,c1,darkboly1,zb,xa,ya
   REAL(KIND=dp)  :: darkboly2,dint1,dint2,div1,div2,diff1max,diff2max,yb
   REAL(KIND=dp)  :: rbol,t4g2,t4g1,za,xb,darkbolx1,darkbolx2,summ,foreshort1
   REAL(KIND=dp)  :: xshort,zrim,fpboverfa,tnew,diff,c2,fpaoverfb
!
   INTEGER :: iidx,ialf,ibet,i1,j2,izz,jzz,jjdx,ilength1
!
   CHARACTER(LEN=60) :: instring1
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmassinsolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
!   Start with star 1 and compute the flux from star 2.
!
   darkbolx1=dbolx(1,1)
   darkboly1=dboly(1,1)
   darkbolx2=dbolx(1,2)
   darkboly2=dboly(1,2)
   c1=0.5_dp
!
!   Define the integrated  limb darkening coefficients.
!   The equation is
!
!   dint=2*pi*int_0^1{mu*(1-x*(1-mu))d(mu)}  for the linear law, etc.
!
   dint1=pie*(1.0_dp-darkbolx1/3.0_dp)
   dint2=pie*(1.0_dp-darkbolx2/3.0_dp)
   IF((ilaw == 2).OR.(ilaw == 12))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp+2.0_dp*darkboly1/9.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp+2.0_dp*darkboly2/9.0_dp)
   END IF
   IF((ilaw == 6).OR.(ilaw == 16))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp+2.0_dp*darkboly1/9.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp+2.0_dp*darkboly2/9.0_dp)
   END IF
   IF((ilaw == 3).OR.(ilaw == 13))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp-darkboly1/5.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp-darkboly2/5.0_dp)
   END IF
   IF((ilaw == 7).OR.(ilaw == 17))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp-darkboly1/5.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp-darkboly2/5.0_dp)
   END IF
!
!   UPDATE JULY 21, 2004
!
!   Add a quadratic limb darkening law, ilaw=4
!
   IF((ilaw == 4).OR.(ilaw == 14))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp-darkboly1/6.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp-darkboly2/6.0_dp)
   END IF
   IF((ilaw == 5).OR.(ilaw == 15))THEN
      dint1=pie*(1.0_dp-darkbolx1/3.0_dp-darkboly1/6.0_dp)
      dint2=pie*(1.0_dp-darkbolx2/3.0_dp-darkboly2/6.0_dp)
   END IF
!
   IF(teff2 > 0.0_dp)THEN
      c1=(tpole2/tpole1)**(4)*(dint1/dint2)
      c1=c1*alb1/dint1
   END IF
   div1=gpole1
   div2=gpole2
!
!   If teff2 < 0, we are in X-ray binary mode.  The parameter rLx is the
!   log10 of the X-ray luminosity.  Compute the bolometric luminosity
!   of star 1, and compute what surface area it would need to have a
!   luminosity equal to that of Lx.   Put this fake surface area as
!   the area of star 2
!
   IF(teff2 <= 0.0_dp)THEN
      rbol=sa1*(separ*solarrad*100.0_dp)**2*stefan*teff1**4
      sa2=sa1*10.0_dp**(rlx)/rbol
      c1=alb1/dint2
   END IF
   diff1max=-1.0_dp
   diff2max=-1.0_dp
!
   t4g2=4.0_dp*tgrav2
   t4g1=4.0_dp*tgrav1
!
   loop20:  DO  ialf=1,nalph1/2
      DO  ibet=1,ibetlim1(ialf)/2
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=(ialf-1)*ibetlim1(ialf)+ibet
!              iidx=kount(ialphmax,ialf,ibetlim1)+ibet
!
         iidx=mmdx1(ialf,ibet)
         summ=0.0_dp
         term1=(bdist-xarray1(iidx))*gradx1(iidx)-(yarray1(iidx))*  &
            grady1(iidx)-(zarray1(iidx))*gradz1(iidx)
         IF(term1 <= 0.0_dp)CYCLE loop20
         dist1=SQRT(rad1(iidx)**2+bdist*(bdist-2.0_dp*xarray1(iidx)))
         foreshort1=(term1/(dist1))
         summ=foreshort1*(0.25_dp*sa2)*(dint2/pie)/(dist1*dist1)
!
!   UPDATE August 7, 2008
!
!   If the flag isw25 is 0, then
!   Add a foreshortening correction for the X-ray heating (the disk
!   is assumed to be a thin disk in the plane, not a point source).
!
!   If isw25 = 1, then assume a point source.
!
         IF((teff2 < 0.0_dp).AND.(isw25 == 0))THEN
            xa=xarray1(iidx)
            ya=yarray1(iidx)
            za=zarray1(iidx)
            xb=bdist
            yb=0.0_dp
            zb=0.0_dp
            dist=SQRT(xa*xa+ya*ya+(za-bdist)*(za-bdist))
            xshort=ABS(za)/dist
            summ=summ*xshort
         END IF
!
         IF((iidint >= 1))THEN
            zrim=redge*TAN(betarim*degtorad)
            xa=xarray1(iidx)
            ya=yarray1(iidx)
            za=zarray1(iidx)
            xb=bdist
            yb=0.0_dp
            zb=0.0_dp
            CALL zheight(xa,ya,za,xb,yb,zb,redge,zcross)
            IF(summ < 0.0_dp)summ=0.0_dp
            IF((za >= 0.0_dp).AND.(zcross < zrim))summ=0.0_dp
            IF((za < 0.0_dp).AND.(zcross > -zrim))summ=0.0_dp
         END IF
!
         fpboverfa=c1/((garray1(iidx)/div1)**(t4g1))*summ
         tnew=temp1(iidx)*(1.0_dp+fpboverfa)**0.25_dp
         diff=tnew-temp1(iidx)
         IF(diff > diff1max)diff1max=diff
         temp1(iidx)=tnew
      END DO
   END DO loop20
!
!   Now go to star 2 and compute the irradation from star 1
!
   IF(teff2 <= 0.0_dp)GO TO 50
   c2=(tpole1/tpole2)**(4)*(dint2/dint1)
   c2=c2*alb2/dint2
!
   loop40:  DO  ialf=1,nalph2/2
      DO  ibet=1,ibetlim2(ialf)/2
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=(ialf-1)*ibetlim2(ialf)+ibet
!              iidx=kount(ialphmax,ialf,ibetlim2)+ibet
!
         iidx=mmdx2(ialf,ibet)
         summ=0.0_dp
         term1=(bdist-xarray2(iidx))*gradx2(iidx)-(yarray2(iidx))*  &
            grady2(iidx)-(zarray2(iidx))*gradz2(iidx)
         IF(term1 <= 0.0_dp)CYCLE loop40
         dist1=SQRT(rad2(iidx)**2+bdist*(bdist-2.0_dp*xarray2(iidx) ))
         foreshort1=(term1/(dist1))
         summ=foreshort1*(0.25_dp*sa1)*(dint1/pie)/(dist1*dist1)
         IF((iidint >= 1))THEN
            zrim=redge*TAN(betarim*degtorad)
            xa=xarray2(iidx)
            ya=yarray2(iidx)
            za=zarray2(iidx)
            xb=bdist
            yb=0.0_dp
            zb=0.0_dp
            CALL zheight (xa,ya,za,xb,yb,zb,redge,zcross)
            IF(summ < 0.0_dp)summ=0.0_dp
            IF((za >= 0.0_dp).AND.(zcross < zrim))summ=0.0_dp
            IF((za < 0.0_dp).AND.(zcross > -zrim))summ=0.0_dp
         END IF
         fpaoverfb=c2/((garray2(iidx)/div2)**(t4g2))*summ
         tnew=temp2(iidx)*(1.0_dp+fpaoverfb)**0.25_dp
         diff=tnew-temp2(iidx)
         IF(diff > diff2max)diff2max=diff
         temp2(iidx)=tnew
      END DO
   END DO loop40
!
!   Now use symmetry to fill in the other quadrants on the star.
!
50 CONTINUE
!
   DO  ialf=1,nalph1/2
      DO  ibet=1,ibetlim1(ialf)/2
         i1=nalph1-(ialf-1)
         j2=ibetlim1(ialf)-(ibet-1)
         izz=ialf
         jzz=ibet
         iidx=mmdx1(izz,jzz)
         izz=ialf
         jzz=j2
         jjdx=mmdx1(izz,jzz)
         temp1(jjdx)=temp1(iidx)
         izz=i1
         jzz=ibet
         jjdx=mmdx1(izz,jzz)
         temp1(jjdx)=temp1(iidx)
         izz=i1
         jzz=j2
         jjdx=mmdx1(izz,jzz)
         temp1(jjdx)=temp1(iidx)
      END DO
   END DO
!
   IF(teff2 <= 0.0_dp)GO TO 100
   DO  ialf=1,nalph2/2
      DO  ibet=1,ibetlim2(ialf)/2
         i1=nalph2-(ialf-1)
         j2=ibetlim2(ialf)-(ibet-1)
         izz=ialf
         jzz=ibet
         iidx=mmdx2(izz,jzz)
         izz=ialf
         jzz=j2
         jjdx=mmdx2(izz,jzz)
         temp2(jjdx)=temp2(iidx)
         izz=i1
         jzz=ibet
         jjdx=mmdx2(izz,jzz)
         temp2(jjdx)=temp2(iidx)
         izz=i1
         jzz=j2
         jjdx=mmdx2(izz,jzz)
         temp2(jjdx)=temp2(iidx)
      END DO
   END DO
!
100 IF(diff2max < 0.0_dp)diff2max=0.0_dp
   IF(diff1max < 0.0_dp)diff1max=0.0_dp
!
   CALL pspacestring('Maximum temperature change for star 1',4,  &
      diff1max,instring1,ilength1)
   IF(ioutflag == 1)WRITE(2,110)TRIM(instring1)
!
   IF(teff2 > 0.0_dp)THEN
      CALL pspacestring('Maximum temperature change for star 2',4,  &
         diff2max,instring1,ilength1)
      IF(ioutflag == 1)WRITE(2,110)TRIM(instring1)
   END IF
!
110 FORMAT(/a,1X,'K.')
!
   RETURN
!
END SUBROUTINE simplerefl
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE sobseq(n,x)
!
!   taken from Numerical Recipes
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, PARAMETER                       :: maxdim=6
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(OUT)               :: x(2)
!
   INTEGER, PARAMETER :: maxbit=30
!
   INTEGER :: i,im,in,ipp,j,k,l,ip(maxdim),iu(maxdim,maxbit),mm
   INTEGER :: iv(maxbit*maxdim),ix(maxdim),mdeg(maxdim),kkk,ll
!
   REAL(KIND=dp)   :: fac
!
   SAVE  ip,mdeg,ix,iv,in,fac
   EQUIVALENCE(iv,iu)
!
   DATA ip/0,1,1,2,1,4/,mdeg/1,2,3,3,4,4/,ix/6*0/
   DATA iv/6*1,3,1,3,3,1,1,5,7,7,3,3,5,15,11,5,15,13,9,156*0/
!
   IF(n == -1)THEN
      in=0
!
      DO  ll=1,maxdim
         DO  mm=1,maxbit
            iu(ll,mm)=0
         END DO
      END DO
!
      DO  kkk=1,6
         ix(kkk)=0
         iv(kkk)=1
      END DO
!
      iv(7)=3
      iv(8)=1
      iv(9)=3
      iv(10)=3
      iv(11)=1
      iv(12)=1
      iv(13)=5
      iv(14)=7
      iv(15)=7
      iv(16)=3
      iv(17)=3
      iv(18)=5
      iv(19)=15
      iv(20)=11
      iv(21)=5
      iv(22)=15
      iv(23)=13
      iv(24)=9
!
      DO  kkk=0,155
         iv(kkk+25)=0
      END DO
!
   END IF
!
   IF(n < 0)THEN
      DO  k=1,maxdim
         DO  j=1,mdeg(k)
            iu(k,j)=iu(k,j)*2**(maxbit-j)
         END DO
         DO  j=mdeg(k)+1,maxbit
            ipp=ip(k)
            i=iu(k,j-mdeg(k))
            i=IEOR(i,i/2**mdeg(k))
            DO  l=mdeg(k)-1,1,-1
               IF(IAND(ipp,1) /= 0)i=IEOR(i,iu(k,j-l))
               ipp=ipp/2
            END DO
            iu(k,j)=i
         END DO
      END DO
      fac=1.0_dp/2.0_dp**maxbit
      in=0
   ELSE
      im=in
      DO  j=1,maxbit
         IF(IAND(im,1) == 0)GO TO 100
         im=im/2
      END DO
      WRITE(*,*) 'MAXBIT too small in sobseq'
      STOP
100   im=(j-1)*maxdim
      DO  k=1,MIN(n,maxdim)
         ix(k)=IEOR(ix(k),iv(im+k))
         x(k)=REAL(ix(k),KIND=dp)*fac
      END DO
      in=in+1
   END IF
   RETURN
!
END SUBROUTINE sobseq
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE solfid(nr,x,y,n,rmass,nbody)
!
!   From Ernst Hairer,  solves first-order system
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nr
   REAL(KIND=dp), INTENT(IN)                :: x
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN OUT)            :: y(n)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
!
   REAL(KIND=dp)  :: xdes,ydes,an,ymean,ydevi,dang,errh
   REAL(KIND=dp)  :: dhamex,dangex,dham
!
   INTEGER :: ist
!
   DIMENSION dang(3)
!
   COMMON /interp/ dhamex,dangex(3),xdes(5000),ydes(5000),an,ist
   COMMON /destat/ ymean(5000),ydevi(5000)
!
   IF(MOD(nr,51) == 0)THEN
      CALL dhamil(n,y,dham,rmass,nbody)
      CALL dmomen(n,y,dang,rmass,nbody)
      errh=(dham-dhamex)/dhamex
      ist=ist+1
      xdes(ist)=x
      ydes(ist)=errh
      ymean(ist)=ymean(ist)+errh
      ydevi(ist)=ydevi(ist)+errh**2
   END IF
   RETURN
!
END SUBROUTINE solfid
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE solfix(nr,p,q,n,rpar,rmass,nbody)
!
!   From Ernst Hairer
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   INTEGER, INTENT(IN)                      :: nr
   REAL(KIND=dp), INTENT(IN OUT)            :: p(n)
   REAL(KIND=dp), INTENT(IN OUT)            :: q(n)
   REAL(KIND=dp), INTENT(IN OUT)            :: rpar(20)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
!
   REAL(KIND=dp)  ::  hamil
!
   CALL hamilton(n,q,p,hamil,rmass,nbody)
   IF(nr == 0)THEN
      rpar(12)=hamil
      rpar(13)=0.0_dp
   ELSE
      rpar(13)=MAX(rpar(13),ABS(rpar(12)-hamil))
   END IF
   RETURN
!
END SUBROUTINE solfix
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE solveorbit(nbody,h,tstart,tend,nstep,qq,pp,rmass,  &
   odetime,zzq,timeinterp,ndyn,igr,tideparm,ndynwin,dynwinlow,  &
   dynwinhigh,isw80,body01posx,body01posy,body01posz,  &
   body02posx,body02posy,body02posz,body03posx,body03posy,  &
   body03posz,body04posx,body04posy,body04posz,body05posx,  &
   body05posy,body05posz,body06posx,body06posy,body06posz,  &
   body07posx,body07posy,body07posz,body08posx,body08posy,  &
   body08posz,body09posx,body09posy,body09posz,body10posx,  &
   body10posy,body10posz,body01velx,body01vely,body01velz,  &
   body02velx,body02vely,body02velz,body03velx,body03vely,  &
   body03velz,body04velx,body04vely,body04velz,body05velx,  &
   body05vely,body05velz,body06velx,body06vely,body06velz,  &
   body07velx,body07vely,body07velz,body08velx,body08vely,  &
   body08velz,body09velx,body09vely,body09velz,body10velx,  &
   body10vely,body10velz)
!
!   This will integrate the equations of motion using a 12th order
!   Gaussian Runga Kutta scheme devised by E. Hairer.
!
!   Nbody = number of bodies, limit 10.  Body 1 is the primary of the
!   binary and body 2 is the secondary.
!
!   h = the stepsize in days.  It should be about P_binary/400 or
!   smaller.
!
!   tstart,tend =  The start and end times of the integration, in days.
!
!   Nstep = the number of integration steps, which is computed below
!
!   QQ = the array with the positions of each body in AU:
!        QQ(1) = x-coordinate of primary
!        QQ(2) = y-coordinate of primary
!        QQ(3) = z-coordinate of primary
!        QQ(4) = x-coordinate of secondary
!
!   PP = the array with the velocities, in AU/day
!
!   rmass = the array with the masses in solar masses
!
!   posarray, velarray = arrays of dimension (Nstep,30) with the
!     positions and velocities of all of the bodies
!
!   odetime = array of size Nstep with the times at each point
!
!   zzq = array of dimension (6,30,nstep) interior node points from
!    the ode solver.  These will be used to interpolate intermediate
!    values
!
!   timeinterp = array of dimension 6 that has the times of the interior
!     node points
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ndyn
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: h
   REAL(KIND=dp), INTENT(IN)                :: tstart
   REAL(KIND=dp), INTENT(IN)                :: tend
   INTEGER, INTENT(IN OUT)                  :: nstep
   REAL(KIND=dp), INTENT(IN OUT)            :: qq(30)
   REAL(KIND=dp), INTENT(IN OUT)            :: pp(30)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(OUT)               :: odetime(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: zzq(6,60,2)
   REAL(KIND=dp), INTENT(IN OUT)            :: timeinterp(6)
   INTEGER, INTENT(IN)                      :: igr
   REAL(KIND=dp), INTENT(IN)                :: tideparm(20)
   INTEGER, INTENT(IN)                      :: ndynwin
   REAL(KIND=dp), INTENT(IN)                :: dynwinlow(10)
   REAL(KIND=dp), INTENT(IN)                :: dynwinhigh(10)
   INTEGER, INTENT(IN)                      :: isw80
   REAL(KIND=dp), INTENT(OUT)               :: body01posx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body01posy(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body01posz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body02posx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body02posy(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body02posz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body03posx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body03posy(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body03posz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body04posx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body04posy(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body04posz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body05posx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body05posy(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body05posz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body06posx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body06posy(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body06posz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body07posx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body07posy(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body07posz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body08posx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body08posy(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body08posz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body09posx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body09posy(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body09posz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body10posx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body10posy(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body10posz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body01velx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body01vely(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body01velz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body02velx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body02vely(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body02velz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body03velx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body03vely(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body03velz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body04velx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body04vely(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body04velz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body05velx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body05vely(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body05velz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body06velx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body06vely(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body06velz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body07velx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body07vely(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body07velz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body08velx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body08vely(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body08velz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body09velx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body09vely(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body09velz(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body10velx(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body10vely(ndyn)
   REAL(KIND=dp), INTENT(OUT)               :: body10velz(ndyn)
!
   REAL(KIND=dp)  :: oldpp,oldqq,rpar
   REAL(KIND=dp)  :: dpar,dy,oldzzq,smallzzq,smallposarray,smallodetime
   REAL(KIND=dp)  :: smallvelarray,x,xend,xsave,xendsave,dx,dxend
!
   INTEGER :: ipar,meth,iprob,i,ntimes,kk
   INTEGER :: kkk,mmeth,iout,ndynsmall,jj,j,nequ,ii,icount
!
   INTEGER, PARAMETER :: ndim=30
!
   DIMENSION  oldpp(ndim),oldqq(ndim),dy(60),smallposarray(2,30)
   DIMENSION  smallodetime(2),smallvelarray(2,30),rpar(20),ipar(20)
   DIMENSION  meth(10),oldzzq(6,60,2),smallzzq(6,60,2),dpar(10)
!
!   old dimensions
!
!          DIMENSION zzq(6,60,Ndyn),oldzzq(6,60,Ndyn),smallzzq(6,60,2)
!
!          EXTERNAL EQUA,SOLFIX,DEQUA
!
! --- CHOOSE THE PROBLEM
!  IPROB = 1 : KEPLER PROBLEM, ECCENTRICITY IN RPAR(1)
!  IPROB = 2 : HARMONIC OSCILLATOR
!  IPROB = 3 : PENDULUM
!  IPROB = 4 : OUTER SOLAR SYSTEM
!
   iprob=4
   ipar(11)=iprob
!
! --- CHOOSE THE THE METHOD
! --- GAUSS METHOD OF ORDER 2*METH
!
   mmeth=6
!
   icount=0
!
   x=tstart
   xend=tend
   xsave=x
   nstep=nint((xend-x)/h)
   IF(ndynwin <= 1)THEN
      IF(nstep > ndyn)THEN
         WRITE(*,*)'Error:  Number of integration steps > Ndyn'
         STOP
      END IF
   END IF
!
   IF(ndynwin > 1)THEN
      DO i=1,nstep
         xsave=xsave+h
         DO j=1,ndynwin
            IF((xsave > dynwinlow(j)).AND.(xsave < dynwinhigh(j))) THEN
               icount=icount+1
            END IF
         END DO
      END DO
      IF(icount > ndyn)THEN
         WRITE(*,*)'Error:  Number of integration steps in '
         WRITE(*,*)'the intervals > Ndyn.  Need ',icount+10
         STOP
      END IF
   END IF
   icount=0
!
   DO i=1,10
      rpar(i)=0.0_dp
      ipar(i)=0
   END DO
   ipar(12)=0
   iout=0
!
!  Step through each time step and add it to the output
!  arrays depending on the ELCdynwin intervals.
!
   IF(igr <= 0)THEN
      x=tstart
      xend=tend
      ntimes=nstep
      ndynsmall=2
      DO kkk=1,ntimes
         xend=x+h
         nstep=1
         xsave=x
         xendsave=xend
         CALL gni_irk2(nbody*3,nstep,x,pp,qq,mmeth,iout,rpar,  &
            ipar,rmass,nbody,smallposarray,smallvelarray,  &
            smallodetime,smallzzq,timeinterp,ndynsmall,h,igr)
!
         DO i=1,3*nbody
            DO j=1,6
               IF(kkk <= 2)zzq(j,i,kkk)=smallzzq(j,i,1)
            END DO
         END DO
!
         DO ii=1,ndynwin
            IF((smallodetime(1) >= dynwinlow(ii)).AND.  &
               (smallodetime(1) <= dynwinhigh(ii)))THEN
               icount=icount+1
               odetime(icount)=smallodetime(1)
!
               body01posx(icount)=smallposarray(1,1)
               body01posy(icount)=smallposarray(1,2)
               body01posz(icount)=smallposarray(1,3)
!
               body02posx(icount)=smallposarray(1,4)
               body02posy(icount)=smallposarray(1,5)
               body02posz(icount)=smallposarray(1,6)
!
               body03posx(icount)=smallposarray(1,7)
               body03posy(icount)=smallposarray(1,8)
               body03posz(icount)=smallposarray(1,9)
!
               IF(nbody >= 4)THEN
                  body04posx(icount)=smallposarray(1,10)
                  body04posy(icount)=smallposarray(1,11)
                  body04posz(icount)=smallposarray(1,12)
               END IF
!
               IF(nbody >= 5)THEN
                  body05posx(icount)=smallposarray(1,13)
                  body05posy(icount)=smallposarray(1,14)
                  body05posz(icount)=smallposarray(1,15)
               END IF
!
               IF(nbody >= 6)THEN
                  body06posx(icount)=smallposarray(1,16)
                  body06posy(icount)=smallposarray(1,17)
                  body06posz(icount)=smallposarray(1,18)
               END IF
!
               IF(nbody >= 7)THEN
                  body07posx(icount)=smallposarray(1,19)
                  body07posy(icount)=smallposarray(1,20)
                  body07posz(icount)=smallposarray(1,21)
               END IF
!
               IF(nbody >= 8)THEN
                  body08posx(icount)=smallposarray(1,22)
                  body08posy(icount)=smallposarray(1,23)
                  body08posz(icount)=smallposarray(1,24)
               END IF
!
               IF(nbody >= 9)THEN
                  body09posx(icount)=smallposarray(1,25)
                  body09posy(icount)=smallposarray(1,26)
                  body09posz(icount)=smallposarray(1,27)
               END IF
!
               IF(nbody >= 10)THEN
                  body10posx(icount)=smallposarray(1,28)
                  body10posy(icount)=smallposarray(1,29)
                  body10posz(icount)=smallposarray(1,30)
               END IF
!
               body01velx(icount)=smallvelarray(1,1)
               body01vely(icount)=smallvelarray(1,2)
               body01velz(icount)=smallvelarray(1,3)
!
               body02velx(icount)=smallvelarray(1,4)
               body02vely(icount)=smallvelarray(1,5)
               body02velz(icount)=smallvelarray(1,6)
!
               body03velx(icount)=smallvelarray(1,7)
               body03vely(icount)=smallvelarray(1,8)
               body03velz(icount)=smallvelarray(1,9)
!
               IF(nbody >= 4)THEN
                  body04velx(icount)=smallvelarray(1,10)
                  body04vely(icount)=smallvelarray(1,11)
                  body04velz(icount)=smallvelarray(1,12)
               END IF
!
               IF(nbody >= 5)THEN
                  body05velx(icount)=smallvelarray(1,13)
                  body05vely(icount)=smallvelarray(1,14)
                  body05velz(icount)=smallvelarray(1,15)
               END IF
!
               IF(nbody >= 6)THEN
                  body06velx(icount)=smallvelarray(1,16)
                  body06vely(icount)=smallvelarray(1,17)
                  body06velz(icount)=smallvelarray(1,18)
               END IF
!
               IF(nbody >= 7)THEN
                  body07velx(icount)=smallvelarray(1,19)
                  body07vely(icount)=smallvelarray(1,20)
                  body07velz(icount)=smallvelarray(1,21)
               END IF
!
               IF(nbody >= 8)THEN
                  body08velx(icount)=smallvelarray(1,22)
                  body08vely(icount)=smallvelarray(1,23)
                  body08velz(icount)=smallvelarray(1,24)
               END IF
!
               IF(nbody >= 9)THEN
                  body09velx(icount)=smallvelarray(1,25)
                  body09vely(icount)=smallvelarray(1,26)
                  body09velz(icount)=smallvelarray(1,27)
               END IF
!
               IF(nbody >= 10)THEN
                  body10velx(icount)=smallvelarray(1,28)
                  body10vely(icount)=smallvelarray(1,29)
                  body10velz(icount)=smallvelarray(1,30)
               END IF
!
            END IF
         END DO
!
!   end the kkk loop over time steps
!
      END DO
!
      nstep=icount
!
!  end if iGR = 0
!
   END IF
!
   ntimes=nstep
   IF(igr >= 1)THEN
      x=tstart
      xend=tend
      ntimes=nstep
      ndynsmall=2
      DO kkk=1,ntimes
         xend=x+h
         nstep=1
         xsave=x
         xendsave=xend
         DO jj=1,ndim
            oldpp(jj)=pp(jj)
            oldqq(jj)=qq(jj)
         END DO
!
!  We run the second-order solver to get better initial
!  guesses for the iterations of the first-order solver.
!
         CALL gni_irk2(nbody*3,nstep,x,oldpp,oldqq,mmeth,  &
            iout,rpar,ipar,rmass,nbody,smallposarray,smallvelarray,  &
            smallodetime,smallzzq,timeinterp,ndynsmall,h,igr)
!
         DO i=1,6*nbody
            DO j=1,6
               oldzzq(j,i,1)=smallzzq(j,i,1)
            END DO
         END DO
!
         x=xsave
         xend=xendsave
         nequ=nbody*6
         meth(1)=6
         meth(2)=0
         meth(3)=0
         meth(4)=0
         meth(5)=0
         meth(6)=0
         meth(7)=0
         meth(8)=0
         meth(9)=0
         meth(10)=0
         dx=x
         dxend=xend
         dpar(1)=2.0E-20_dp
         iout=0
         DO kk=1,3*nbody
            dy(kk)=qq(kk)
            dy(kk+3*nbody)=pp(kk)
         END DO
!
         CALL grkaad(nequ,nstep,dx,dy,meth,iout,dpar,rmass,  &
            nbody,smallposarray,smallvelarray,smallodetime,smallzzq,  &
            timeinterp,ndynsmall,h,igr,oldzzq,tideparm,isw80)
!
         DO kk=1,3*nbody
            qq(kk)=dy(kk)
            pp(kk)=dy(kk+3*nbody)
         END DO
!
         DO i=1,3*nbody
            DO j=1,6
               IF(kkk <= 2)zzq(j,i,kkk)=smallzzq(j,i,1)
            END DO
         END DO
!
         x=x+h
!
         DO ii=1,ndynwin
            IF((smallodetime(1) >= dynwinlow(ii)).AND.  &
               (smallodetime(1) <= dynwinhigh(ii)))THEN
               icount=icount+1
               odetime(icount)=smallodetime(1)
!
               body01posx(icount)=smallposarray(1,1)
               body01posy(icount)=smallposarray(1,2)
               body01posz(icount)=smallposarray(1,3)
!
               body02posx(icount)=smallposarray(1,4)
               body02posy(icount)=smallposarray(1,5)
               body02posz(icount)=smallposarray(1,6)
!
               body03posx(icount)=smallposarray(1,7)
               body03posy(icount)=smallposarray(1,8)
               body03posz(icount)=smallposarray(1,9)
!
               IF(nbody >= 4)THEN
                  body04posx(icount)=smallposarray(1,10)
                  body04posy(icount)=smallposarray(1,11)
                  body04posz(icount)=smallposarray(1,12)
               END IF
!
               IF(nbody >= 5)THEN
                  body05posx(icount)=smallposarray(1,13)
                  body05posy(icount)=smallposarray(1,14)
                  body05posz(icount)=smallposarray(1,15)
               END IF
!
               IF(nbody >= 6)THEN
                  body06posx(icount)=smallposarray(1,16)
                  body06posy(icount)=smallposarray(1,17)
                  body06posz(icount)=smallposarray(1,18)
               END IF
!
               IF(nbody >= 7)THEN
                  body07posx(icount)=smallposarray(1,19)
                  body07posy(icount)=smallposarray(1,20)
                  body07posz(icount)=smallposarray(1,21)
               END IF
!
               IF(nbody >= 8)THEN
                  body08posx(icount)=smallposarray(1,22)
                  body08posy(icount)=smallposarray(1,23)
                  body08posz(icount)=smallposarray(1,24)
               END IF
!
               IF(nbody >= 9)THEN
                  body09posx(icount)=smallposarray(1,25)
                  body09posy(icount)=smallposarray(1,26)
                  body09posz(icount)=smallposarray(1,27)
               END IF
!
               IF(nbody >= 10)THEN
                  body10posx(icount)=smallposarray(1,28)
                  body10posy(icount)=smallposarray(1,29)
                  body10posz(icount)=smallposarray(1,30)
               END IF
!
               body01velx(icount)=smallvelarray(1,1)
               body01vely(icount)=smallvelarray(1,2)
               body01velz(icount)=smallvelarray(1,3)
!
               body02velx(icount)=smallvelarray(1,4)
               body02vely(icount)=smallvelarray(1,5)
               body02velz(icount)=smallvelarray(1,6)
!
               body03velx(icount)=smallvelarray(1,7)
               body03vely(icount)=smallvelarray(1,8)
               body03velz(icount)=smallvelarray(1,9)
!
               IF(nbody >= 4)THEN
                  body04velx(icount)=smallvelarray(1,10)
                  body04vely(icount)=smallvelarray(1,11)
                  body04velz(icount)=smallvelarray(1,12)
               END IF
!
               IF(nbody >= 5)THEN
                  body05velx(icount)=smallvelarray(1,13)
                  body05vely(icount)=smallvelarray(1,14)
                  body05velz(icount)=smallvelarray(1,15)
               END IF
!
               IF(nbody >= 6)THEN
                  body06velx(icount)=smallvelarray(1,16)
                  body06vely(icount)=smallvelarray(1,17)
                  body06velz(icount)=smallvelarray(1,18)
               END IF
!
               IF(nbody >= 7)THEN
                  body07velx(icount)=smallvelarray(1,19)
                  body07vely(icount)=smallvelarray(1,20)
                  body07velz(icount)=smallvelarray(1,21)
               END IF
!
               IF(nbody >= 8)THEN
                  body08velx(icount)=smallvelarray(1,22)
                  body08vely(icount)=smallvelarray(1,23)
                  body08velz(icount)=smallvelarray(1,24)
               END IF
!
               IF(nbody >= 9)THEN
                  body09velx(icount)=smallvelarray(1,25)
                  body09vely(icount)=smallvelarray(1,26)
                  body09velz(icount)=smallvelarray(1,27)
               END IF
!
               IF(nbody >= 10)THEN
                  body10velx(icount)=smallvelarray(1,28)
                  body10vely(icount)=smallvelarray(1,29)
                  body10velz(icount)=smallvelarray(1,30)
               END IF
!
            END IF
         END DO
!
!   end the kkk loop over time steps
!
      END DO
!
      nstep=icount
!
!  end if iGR > 0
!
   END IF
!
   CALL newtondiff(odetime,zzq,2,timeinterp,nbody,ii,ndyn)
!
   RETURN
!
END SUBROUTINE solveorbit
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE sort2(n,ra,rb)
!
!   UPDATE September 10, 2001
!
!   This is a new subroutine, similar to sort3.
!
!   Taken from Numerical Recipes.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN OUT)            :: ra(n)
   REAL(KIND=dp), INTENT(IN OUT)            :: rb(n)
!
   REAL(KIND=dp) ::  rra,rrb
!
   INTEGER :: l,ir,i,j
!
   l=n/2+1
   ir=n
10 IF(l > 1)THEN
      l=l-1
      rra=ra(l)
      rrb=rb(l)
   ELSE
      rra=ra(ir)
      rrb=rb(ir)
      ra(ir)=ra(1)
      rb(ir)=rb(1)
      ir=ir-1
      IF(ir == 1)THEN
         ra(1)=rra
         rb(1)=rrb
         RETURN
      END IF
   END IF
   i=l
   j=l+l
20 IF(j <= ir)THEN
      IF(j < ir)THEN
         IF(ra(j) < ra(j+1))j=j+1
      END IF
      IF(rra < ra(j))THEN
         ra(i)=ra(j)
         rb(i)=rb(j)
         i=j
         j=j+j
      ELSE
         j=ir+1
      END IF
      GO TO 20
   END IF
   ra(i)=rra
   rb(i)=rrb
   GO TO 10
!
END SUBROUTINE sort2
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE sort3(n,ra,rb,rc)
!
!  October 7, 1999
!
!  This routine will sort an array RA, and rearrange the arrays rb and rc.
!  Taken from Numerical Recipes.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN OUT)            :: ra(n)
   REAL(KIND=dp), INTENT(IN OUT)            :: rb(n)
   REAL(KIND=dp), INTENT(IN OUT)            :: rc(n)
!
   REAL(KIND=dp) ::  rra,rrb,rrc
!
   INTEGER :: l,ir,i,j
!
   l=n/2+1
   ir=n
10 IF(l > 1)THEN
      l=l-1
      rra=ra(l)
      rrb=rb(l)
      rrc=rc(l)
   ELSE
      rra=ra(ir)
      rrb=rb(ir)
      rrc=rc(ir)
      ra(ir)=ra(1)
      rb(ir)=rb(1)
      rc(ir)=rc(1)
      ir=ir-1
      IF(ir == 1)THEN
         ra(1)=rra
         rb(1)=rrb
         rc(1)=rrc
         RETURN
      END IF
   END IF
   i=l
   j=l+l
20 IF(j <= ir)THEN
      IF(j < ir)THEN
         IF(ra(j) < ra(j+1))j=j+1
      END IF
      IF(rra < ra(j))THEN
         ra(i)=ra(j)
         rb(i)=rb(j)
         rc(i)=rc(j)
         i=j
         j=j+j
      ELSE
         j=ir+1
      END IF
      GO TO 20
   END IF
   ra(i)=rra
   rb(i)=rrb
   rc(i)=rrc
   GO TO 10
!
END SUBROUTINE sort3
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE sortcircle(n,xcir,ycir)
!
!   October 7, 1999
!
!   This routine will arrange the (x,y) points of the polygon in order by
!   sorting by theta in polar coordinates.  Written by Orosz circa 1996.
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN OUT)            :: xcir(n)
   REAL(KIND=dp), INTENT(IN OUT)            :: ycir(n)
!
   REAL(KIND=dp)  :: xxx,yyy,xcenter,ycenter,xmin,xmax
   REAL(KIND=dp)  :: ymin,ymax
   REAL(KIND=dp),ALLOCATABLE  :: theta(:)
!
   INTEGER :: i
!
   ALLOCATE(theta(10000))
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   CALL getmaxvalues(n,xcir,ycir,xmin,xmax,ymin,ymax)
!
   xcenter=(xmax+xmin)/2.0_dp
   ycenter=(ymax+ymin)/2.0_dp
!
!   convert to polar coordinates
!
   DO  i=1,n
      xxx=xcir(i)-xcenter
      yyy=ycir(i)-ycenter
      IF(ABS(xxx) <= EPSILON(xxx))THEN
         IF(yyy < 0.0_dp)THEN
            theta(i)=3.0_dp*pie/2.0_dp
            CYCLE
         END IF
         IF(yyy >= 0.0_dp)THEN
            theta(i)=halfpie
            CYCLE
         END IF
      END IF
      IF((yyy >= 0.0_dp).AND.(xxx >= 0.0_dp))THEN
         theta(i)=(ATAN2(yyy,xxx))
      END IF
      IF((yyy >= 0.0_dp).AND.(xxx < 0.0_dp))THEN
         theta(i)=(ATAN2(yyy,xxx))
      END IF
      IF((yyy < 0.0_dp).AND.(xxx < 0.0_dp))THEN
         theta(i)=twopie+(ATAN2(yyy,xxx))
      END IF
      IF((yyy < 0.0_dp).AND.(xxx >= 0.0_dp))THEN
         theta(i)=twopie+ATAN2(yyy,xxx)
      END IF
   END DO
!
   IF(n > 1)THEN
!
!  sort by theta and swap x and y also
!
      CALL sort3(n,theta,xcir,ycir)
   END IF
!
   DEALLOCATE(theta)
!
   RETURN
!
END SUBROUTINE sortcircle
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE spherepot(q,omega,cox,coz,r,psi,dpsidr,bdist,  &
   tidephi,itide,ecc,thetamis,phimis,coy)
!
!   May 3, 2000
!
!   This routine will return the value of the potential and its
!   derivative at r in the direction (cox,coy,coz)
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: q
   REAL(KIND=dp), INTENT(IN)                :: omega
   REAL(KIND=dp), INTENT(IN)                :: cox
   REAL(KIND=dp), INTENT(IN)                :: coz
   REAL(KIND=dp), INTENT(IN)                :: r
   REAL(KIND=dp), INTENT(OUT)               :: psi
   REAL(KIND=dp), INTENT(OUT)               :: dpsidr
   REAL(KIND=dp), INTENT(IN)                :: bdist
   REAL(KIND=dp), INTENT(IN)                :: tidephi
   INTEGER, INTENT(IN)                      :: itide
   REAL(KIND=dp), INTENT(IN)                :: ecc
   REAL(KIND=dp), INTENT(IN)                :: thetamis
   REAL(KIND=dp), INTENT(IN)                :: phimis
   REAL(KIND=dp), INTENT(IN OUT)            :: coy
!
   REAL(KIND=dp)  :: pn,pd,term4,psicos,hutfac,x,y,z,term1,term2,term3,t2
   REAL(KIND=dp)  :: term5,term6,cpm,spm,stm,s2pm,tider,omegah,s2tm,t1
!
   INTEGER :: ii
!
   DIMENSION pn(0:100),pd(0:100)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   hutfac=(1.0_dp+7.5_dp*ecc*ecc+5.625_dp*ecc**4+0.3125_dp*ecc**6)/  &
      ((1.0_dp+3.0_dp*ecc*ecc+3.0_dp/8.0_dp*ecc**4)*SQRT((1.0_dp-ecc*ecc)**3))
   omegah=omega*hutfac
!
   x=cox
   y=coy
   z=coz
   IF((ABS(phimis) <= EPSILON(phimis)).AND.(ABS(thetamis) <=  &
         EPSILON(thetamis)))THEN
      term1=x*x
      term2=y*y
      term3=0.0_dp
      term4=0.0_dp
      term5=0.0_dp
      term6=0.0_dp
   ELSE
      cpm=COS(phimis)
      spm=SIN(phimis)
      stm=SIN(thetamis)
      s2pm=SIN(2.0_dp*phimis)
      s2tm=SIN(2.0_dp*thetamis)
      term1=x*x*(1.0_dp-cpm*cpm*stm*stm)
      term2=y*y*(1.0_dp-spm*spm*stm*stm)
      term3=z*z*stm*stm
      term4=-x*y*stm*stm*s2pm
      term5=-x*z*cpm*s2tm
      term6=-y*z*spm*s2tm
   END IF
   IF(itide < 2)THEN
      t1=(bdist*bdist-2.0_dp*cox*r*bdist+r*r)
      t2=0.5_dp*omegah*omegah*(1.0_dp+q)*(term1+term2+term3+term4+term5+term6)
      psi=1.0_dp/r+q*(1.0_dp/SQRT(t1)-cox*r/(bdist*bdist))+t2*r*r
      dpsidr=-1.0_dp/(r*r)+q*((SQRT(t1)**3)*(cox*bdist-r)-cox/  &
         (bdist*bdist))+2.0_dp*r*t2
      RETURN
   END IF
!
   coy=coz
   tider=tidephi*degtorad
   psicos=cox*COS(tider)+coy*SIN(tider)
!
   CALL lpn(itide,psicos,pn,pd)
!
   psi=1.0_dp/(r)+q
   dpsidr=-1.0_dp/(r*r)
!
   DO  ii=2,itide
      psi=psi-q*(r**(ii))*pn(ii)
      dpsidr=dpsidr+REAL(ii,KIND=dp)*q*(r**(ii-1))*pn(ii)
   END DO
!
   RETURN
!
END SUBROUTINE spherepot
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE spline(x,y,n,yp1,ypn,y2)
!
!   November 12, 1999
!
!   This is a spline interpolation routine taken from NUMERICAL RECIPES.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: x(n)
   REAL(KIND=dp), INTENT(IN)                :: y(n)
   REAL(KIND=dp), INTENT(IN)                :: yp1
   REAL(KIND=dp), INTENT(IN)                :: ypn
   REAL(KIND=dp), INTENT(OUT)               :: y2(n)
!
   REAL(KIND=dp), ALLOCATABLE  :: u(:)
   REAL(KIND=dp)               ::  p,qn,sig,un   
!
   INTEGER :: i,k
!
   ALLOCATE(u(n+2))
!
   IF(yp1 > 0.99E+30_dp)THEN
      y2(1)=0.0_dp
      u(1)=0.0_dp
   ELSE
      y2(1)=-0.5_dp
      u(1)=(3.0_dp/(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1)
   END IF
   DO  i=2,n-1
      sig=(x(i)-x(i-1))/(x(i+1)-x(i-1))
      p=sig*y2(i-1)+2.0_dp
      y2(i)=(sig-1.0_dp)/p
      u(i)=(6.0_dp*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1))/(x(i)-  &
         x(i-1)))/(x(i+1)-x(i-1))-sig*u(i-1))/p
      IF(ABS(u(i)) < 1.0E-250_dp)u(i)=0.0_dp
   END DO
   IF(ypn > 0.99E+30_dp)THEN
      qn=0.0_dp
      un=0.0_dp
   ELSE
      qn=0.5_dp
      un=(3.0_dp/(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))
   END IF
   y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.0_dp)
   DO  k=n-1,1,-1
      y2(k)=y2(k)*y2(k+1)+u(k)
      IF(ABS(y2(k)) < 1.0E-250_dp)y2(k)=0.0_dp
   END DO
   DEALLOCATE(u)
   RETURN
!
END SUBROUTINE spline
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE splint(xa,ya,y2a,n,x,y)
!
!   November 12, 1999
!
!   This is a spline interpolation routine taken from Numerical Recipes.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: xa(n)
   REAL(KIND=dp), INTENT(IN)                :: ya(n)
   REAL(KIND=dp), INTENT(IN)                :: y2a(n)
   REAL(KIND=dp), INTENT(IN)                :: x
   REAL(KIND=dp), INTENT(OUT)               :: y
!
   INTEGER :: k,khi,klo
!
   REAL(KIND=dp)  :: a,b,h
!
   klo=1
   khi=n
10 IF(khi-klo > 1)THEN
      k=(khi+klo)/2
      IF(xa(k) > x)THEN
         khi=k
      ELSE
         klo=k
      END IF
      GO TO 10
   END IF
   h=xa(khi)-xa(klo)
   IF(ABS(h)  <= EPSILON(h))THEN
      WRITE(*,*) 'bad xa input in splint'
      STOP
   END IF
   a=(xa(khi)-x)/h
   b=(x-xa(klo))/h
   y=a*ya(klo)+b*ya(khi)+((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.0_dp
   RETURN
!
END SUBROUTINE splint
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION sqrtintgrd(phi,rmdn,cmnx,cmny)
!
!   Computes the integrand for the log law case.
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: phi
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
!
   REAL(KIND=dp)  :: sqrtintgrd, xi,yi,rsq,xip,yip,bb,f
!
   xi=rmdn*COS(phi)+cmnx
   yi=rmdn*SIN(phi)+cmny
   rsq=xi*xi+yi*yi
   xip=-rmdn*SIN(phi)
   yip=rmdn*COS(phi)
   bb=xi*yip-yi*xip
   f=0.5_dp+(0.4_dp)*((1.0_dp-rsq)**(1.25_dp)-1.0_dp)/(rsq)
   sqrtintgrd=f*bb
!
   RETURN
!
END FUNCTION sqrtintgrd
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE startb(n,p,q,ns,ndgl,fs,ps,zq,nsd,e,yh,nm,  &
   am,f,c,ipar,rmass,nbody)
!
!   from Ernst Hairer
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nm
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(IN)                :: p(n)
   REAL(KIND=dp), INTENT(IN)                :: q(n)
   INTEGER, INTENT(IN)                      :: ns
   INTEGER, INTENT(IN)                      :: ndgl
   REAL(KIND=dp), INTENT(IN OUT)            :: fs(ndgl)
   REAL(KIND=dp), INTENT(IN OUT)            :: ps(n)
   REAL(KIND=dp), INTENT(IN OUT)            :: zq(ndgl,ns)
   INTEGER, INTENT(IN)                      :: nsd
   REAL(KIND=dp), INTENT(IN)                :: e(nsd,ns+nm)
   REAL(KIND=dp), INTENT(OUT)               :: yh(ndgl)
   REAL(KIND=dp), INTENT(IN)                :: am(ns+nm)
   REAL(KIND=dp), INTENT(IN OUT)            :: f(n*ns)
   REAL(KIND=dp), INTENT(IN)                :: c(ns)
   INTEGER, INTENT(IN OUT)                  :: ipar(*)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   INTEGER, INTENT(IN)                      :: nbody
!
   INTEGER :: ns1,ns2,nsm,i,js,is
!
   REAL(KIND=dp)  :: sav,zqiis
!
   ns1=ns+1
   ns2=ns+2
   nsm=ns+nm
   DO i=1,n
      sav=0.0_dp
      DO js=1,ns
         sav=sav+am(js)*zq(i,js)
      END DO
      yh(i)=sav+am(ns1)*ps(i)+am(ns2)*p(i)+q(i)
      DO is=1,ns
         sav=0.0_dp
         DO js=1,ns
            sav=sav+e(is,js)*f(i+(js-1)*n)
         END DO
         zq(i,is)=sav+e(is,ns1)*fs(i)
      END DO
   END DO
!
   CALL equa(n,q,fs,ipar,rmass,nbody)
   CALL equa(n,yh,f,ipar,rmass,nbody)
   DO i=1,n
      ps(i)=p(i)
      DO is=1,ns
         zqiis=zq(i,is)+e(is,ns2)*fs(i)+e(is,nsm)*f(i)
         zq(i,is)=zqiis+c(is)*p(i)
      END DO
   END DO
   RETURN
!
END SUBROUTINE startb
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE subatmintgnpt(pathi,tol,rmdn,cmnx,cmny,nmu,nmumax,  &
   table51,table52,table53,table54,table55,table56,table57,  &
   table58,sarray,isym)
!
!  Uses N point Gaussian integration to evaluate the tablulated
!  intensities in Table5
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: pathi(5)
   REAL(KIND=dp), INTENT(IN)                :: tol
   REAL(KIND=dp), INTENT(IN)                :: rmdn
   REAL(KIND=dp), INTENT(IN)                :: cmnx
   REAL(KIND=dp), INTENT(IN)                :: cmny
   INTEGER, INTENT(IN)                      :: nmu
   INTEGER, INTENT(IN)                      :: nmumax
   REAL(KIND=dp), INTENT(IN)                :: table51(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table52(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table53(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table54(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table55(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table56(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table57(nmumax,5)
   REAL(KIND=dp), INTENT(IN)                :: table58(nmumax,5)
   REAL(KIND=dp), INTENT(OUT)               :: sarray(8)
   INTEGER, INTENT(IN)                      :: isym
!
   REAL(KIND=dp)  :: a,b,h,phi,delta,summ6,summ7,summ8,phistop
   REAL(KIND=dp)  :: xi,yi,rsq,xip,yip,bb,f,ig,p,xx,ww
   REAL(KIND=dp)  :: summ1,summ2,summ3,summ4,summ5
!
   INTEGER :: k,m,indrsq,iceiling,norder,muse,nopt,MAX,kk
!
   INTEGER, PARAMETER :: maxm=64
!
   DIMENSION  phi(maxm),xx(64),ww(64)
!
   DO m=1,8
      sarray(m)=0.0_dp
   END DO
   a=pathi(3)
   b=pathi(5)
   phistop=a+0.5_dp*pathi(4)
!
   m=nint(REAL(INT(5.0_dp*rmdn*pathi(4))+1,KIND=dp)*tol)
   IF(MOD(m,2) == 1)m=m+1
   delta=SQRT(cmnx**2+cmny**2)
!
   IF(m < 8)m=8
!
   norder=4
   muse=m
   nopt=m
   MAX=64
!
   IF(nopt <= MAX)THEN
      norder=nopt
      muse=1
   END IF
   DO k=1,100
      IF((nopt >= MAX*k+1).AND.(nopt <= (k+1)*MAX))THEN
         IF(k == 1)THEN
            norder=nopt/2
            muse=2
         END IF
         IF(k == 2)THEN
            IF(MOD(nopt,3) == 1)nopt=nopt+2
            IF(MOD(nopt,3) == 2)nopt=nopt+1
            norder=nopt/3
            muse=3
            IF(MOD(norder,2) == 1)norder=norder+1
         END IF
         IF(k == 3)THEN
            IF(MOD(nopt,4) == 1)nopt=nopt+3
            IF(MOD(nopt,4) == 2)nopt=nopt+2
            IF(MOD(nopt,4) == 3)nopt=nopt+1
            norder=nopt/4
            muse=4
            IF(MOD(norder,2) == 1)norder=norder+1
         END IF
         IF(k == 4)THEN
            IF(MOD(nopt,5) == 1)nopt=nopt+4
            IF(MOD(nopt,5) == 2)nopt=nopt+3
            IF(MOD(nopt,5) == 3)nopt=nopt+2
            IF(MOD(nopt,5) == 4)nopt=nopt+1
            norder=nopt/5
            muse=5
         END IF
      END IF
   END DO
!
   CALL gausscoeff(norder,xx,ww)
!
   h=(b-a)/REAL(muse,KIND=dp)
   DO k=1,norder
      phi(k)=a+h*(1.0_dp+xx(k))/2.0_dp
   END DO
!
   summ1=0.0_dp
   summ2=0.0_dp
   summ3=0.0_dp
   summ4=0.0_dp
   summ5=0.0_dp
   summ6=0.0_dp
   summ7=0.0_dp
   summ8=0.0_dp
!
!   collect the evaluation points from Table5
!
   DO kk=1,muse
      DO k=1,norder
         IF((isym == 0).AND.(phi(k) > phistop))CYCLE  !GO TO 99
         xi=rmdn*COS(phi(k))+cmnx
         yi=rmdn*SIN(phi(k))+cmny
         rsq=xi**2+yi**2
         xip=-rmdn*SIN(phi(k))
         yip=rmdn*COS(phi(k))
         bb=xi*yip-yi*xip
         indrsq=nmu-iceiling(REAL(nmu-1,KIND=dp)*SQRT(1.0_dp-rsq))
         p=rsq
         f=table51(indrsq,2)+(p-table51(indrsq,1))*  &
            (table51(indrsq,3)+(p-table51(indrsq,1))*  &
            (table51(indrsq,4)+(p-table51(indrsq+1,1))* &
            table51(indrsq,5)))
         ig=f*bb
         summ1=summ1+ig*ww(k)
!
         f=table52(indrsq,2)+(p-table52(indrsq,1))*  &
            (table52(indrsq,3)+(p-table52(indrsq,1))*  &
            (table52(indrsq,4)+(p-table52(indrsq+1,1))* &
            table52(indrsq,5)))
         ig=f*bb
         summ2=summ2+ig*ww(k)
!
         f=table53(indrsq,2)+(p-table53(indrsq,1))*  &
            (table53(indrsq,3)+(p-table53(indrsq,1))*  &
            (table53(indrsq,4)+(p-table53(indrsq+1,1))* &
            table53(indrsq,5)))
         ig=f*bb
         summ3=summ3+ig*ww(k)
!
         f=table54(indrsq,2)+(p-table54(indrsq,1))*  &
            (table54(indrsq,3)+(p-table54(indrsq,1))*  &
            (table54(indrsq,4)+(p-table54(indrsq+1,1))* &
            table54(indrsq,5)))
         ig=f*bb
         summ4=summ4+ig*ww(k)
!
         f=table55(indrsq,2)+(p-table55(indrsq,1))*  &
            (table55(indrsq,3)+(p-table55(indrsq,1))*  &
            (table55(indrsq,4)+(p-table55(indrsq+1,1))* &
            table55(indrsq,5)))
         ig=f*bb
         summ5=summ5+ig*ww(k)
!
         f=table56(indrsq,2)+(p-table56(indrsq,1))*  &
            (table56(indrsq,3)+(p-table56(indrsq,1))*  &
            (table56(indrsq,4)+(p-table56(indrsq+1,1))* &
            table56(indrsq,5)))
         ig=f*bb
         summ6=summ6+ig*ww(k)
!
         f=table57(indrsq,2)+(p-table57(indrsq,1))*  &
            (table57(indrsq,3)+(p-table57(indrsq,1))*  &
            (table57(indrsq,4)+(p-table57(indrsq+1,1))* &
            table57(indrsq,5)))
         ig=f*bb
         summ7=summ7+ig*ww(k)
!
         f=table58(indrsq,2)+(p-table58(indrsq,1))*  &
            (table58(indrsq,3)+(p-table58(indrsq,1))*  &
            (table58(indrsq,4)+(p-table58(indrsq+1,1))* &
            table58(indrsq,5)))
         ig=f*bb
         summ8=summ8+ig*ww(k)
!
!    99           CONTINUE
      END DO
      DO k=1,norder
         phi(k)=phi(k)+h
      END DO
   END DO
!
   IF(isym == 0)THEN
      sarray(1)=-h*summ1
      sarray(2)=-h*summ2
      sarray(3)=-h*summ3
      sarray(4)=-h*summ4
      sarray(5)=-h*summ5
      sarray(6)=-h*summ6
      sarray(7)=-h*summ7
      sarray(8)=-h*summ8
   END IF
   IF(isym > 0)THEN
      sarray(1)=-h*summ1*0.5_dp
      sarray(2)=-h*summ2*0.5_dp
      sarray(3)=-h*summ3*0.5_dp
      sarray(4)=-h*summ4*0.5_dp
      sarray(5)=-h*summ5*0.5_dp
      sarray(6)=-h*summ6*0.5_dp
      sarray(7)=-h*summ7*0.5_dp
      sarray(8)=-h*summ8*0.5_dp
   END IF
!
   RETURN
!
END SUBROUTINE subatmintgnpt
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE tertnu(tertphase,tertecc,tertbdist,tertrnu)
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertecc
   REAL(KIND=dp), INTENT(OUT)               :: tertbdist
   REAL(KIND=dp), INTENT(OUT)               :: tertrnu
!
   REAL(KIND=dp)  :: em,bige
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   em=tertphase*degtorad
   CALL gete(em,tertecc,bige)
   bige=MOD(bige,twopie)
   tertrnu=2.0_dp*ATAN(SQRT((1.0_dp+tertecc)/(1.0_dp-tertecc))*TAN(bige/2.0_dp))
   tertrnu=MOD(tertrnu,twopie)
   tertbdist=(1.0_dp-tertecc*COS(bige))
!
   RETURN
!
END SUBROUTINE tertnu
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION tertxcen(iflag,tertincl,tertbdist,tertphase,  &
   tertq,axisscale)
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: iflag
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
!
   REAL(KIND=dp) :: fincr,bdist,xtran,tertxcen,dummyphase,overq,xx,yy,zz
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   dummyphase=tertphase
   overq=tertq
   xx=0.0_dp
   yy=0.0_dp
   zz=0.0_dp
   IF(iflag == 2)dummyphase=tertphase+180.0_dp
   fincr=tertincl*degtorad
   bdist=tertbdist*axisscale
   tertxcen=xtran(xx,yy,dummyphase,overq,iflag,bdist)
   RETURN
!
END FUNCTION tertxcen
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION tertxtrans(xx,yy,zz,tertphase,tertincl,tertq,  &
   tertbdist,axisscale,tertomega)
!
   USE accur
   USE getpie

   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: xx
   REAL(KIND=dp), INTENT(IN)                :: yy
   REAL(KIND=dp), INTENT(IN)                :: zz
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp)  :: fincr,tomrad,xp,yp,xtran,ytran,bdist,tertxtrans,xc
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   fincr=tertincl*degtorad
   bdist=tertbdist*axisscale
   tomrad=tertomega*degtorad
   xp=xtran(xx,yy,tertphase,tertq,1,bdist)
   yp=ytran(xx,yy,zz,tertphase,fincr,tertq,1,bdist)
   xc=xp*COS(tomrad)-yp*SIN(tomrad)
   tertxtrans=xc
!
   RETURN
!
END FUNCTION tertxtrans
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION tertycen(iflag,tertincl,tertbdist,tertphase,  &
   tertq,axisscale)
!
   USE accur
   USE getpie

   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: iflag
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: axisscale
!
   REAL(KIND=dp)  :: dummyphase,overq,tertycen,xx,yy,zz,fincr,ytran,bdist
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   dummyphase=tertphase
   overq=tertq
   xx=0.0_dp
   yy=0.0_dp
   zz=0.0_dp
   IF(iflag == 2)dummyphase=tertphase+180.0_dp
   fincr=tertincl*degtorad
   bdist=tertbdist*axisscale
   tertycen=ytran(xx,yy,zz,dummyphase,fincr,overq,iflag,bdist)
   RETURN
!
END FUNCTION tertycen
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION tertytrans(xx,yy,zz,tertphase,tertincl,tertq,  &
   tertbdist,axisscale,tertomega)
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: xx
   REAL(KIND=dp), INTENT(IN)                :: yy
   REAL(KIND=dp), INTENT(IN)                :: zz
   REAL(KIND=dp), INTENT(IN)                :: tertphase
   REAL(KIND=dp), INTENT(IN)                :: tertincl
   REAL(KIND=dp), INTENT(IN)                :: tertq
   REAL(KIND=dp), INTENT(IN)                :: tertbdist
   REAL(KIND=dp), INTENT(IN)                :: axisscale
   REAL(KIND=dp), INTENT(IN)                :: tertomega
!
   REAL(KIND=dp)  :: bdist,tomrad,xp,yp,yc,xtran,ytran,fincr,tertytrans
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   fincr=tertincl*degtorad
   bdist=tertbdist*axisscale
   tomrad=tertomega*degtorad
   xp=xtran(xx,yy,tertphase,tertq,1,bdist)
   yp=ytran(xx,yy,zz,tertphase,fincr,tertq,1,bdist)
   yc=xp*SIN(tomrad)+yp*COS(tomrad)
   tertytrans=yc
!
   RETURN
!
END FUNCTION tertytrans
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE thirdlight(iatm,t3,g3,sa3,third,maxlines,maxmu,  &
   nlines,atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
   atmint5,atmint6,atmint7,atmint8,icnu,icnb,icnv,icnr,icni,  &
   icnj,icnh,icnk,separ,dwavex,dwavey,ilaw,istar,reff,ioutflag)
!
!  January 7, 2000
!
!  This subroutine will compute a 'third light' flux using the
!  model atmosphere table.  The user specifies the temperature,
!  gravity, and fractional surface area of the third star.  The
!  fractional surface area is given in terms of the ratio of the
!  surface area of star 3 to that of star 1.  Finally, the third light
!  that is added to the output light curves is given by
!
!  third(ifilt) = SA3*inty(ifilt)*2*pi*pi*SA1)
!
!  December 19, 2000
!
!  Bug fix:  third(ifilt) = SA1*SA3*inty(ifilt,mu=1)/4.0
!
!  UPDATE April 2, 2002
!
!  Add separ to the argument list of thirdlight.  Then scale the fluxes
!  by (separ*solarrad)**2
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: iatm
   REAL(KIND=dp), INTENT(IN)                :: t3
   REAL(KIND=dp), INTENT(IN)                :: g3
   REAL(KIND=dp), INTENT(IN)                :: sa3
   REAL(KIND=dp), INTENT(OUT)               :: third(8)
   INTEGER, INTENT(IN)                      :: maxlines
   INTEGER, INTENT(IN)                      :: maxmu
   INTEGER, INTENT(IN)                      :: nlines
   REAL(KIND=dp), INTENT(IN)                :: atmt(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmg(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmmu(maxlines,maxmu)
   INTEGER, INTENT(IN)                      :: nmu(maxlines)
   REAL(KIND=dp), INTENT(IN)                :: atmint1(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint2(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint3(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint4(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint5(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint6(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint7(maxlines,maxmu)
   REAL(KIND=dp), INTENT(IN)                :: atmint8(maxlines,maxmu)
   INTEGER, INTENT(IN)                      :: icnu
   INTEGER, INTENT(IN)                      :: icnb
   INTEGER, INTENT(IN)                      :: icnv
   INTEGER, INTENT(IN)                      :: icnr
   INTEGER, INTENT(IN)                      :: icni
   INTEGER, INTENT(IN)                      :: icnj
   INTEGER, INTENT(IN)                      :: icnh
   INTEGER, INTENT(IN)                      :: icnk
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavex(8,10)
   REAL(KIND=dp), INTENT(IN OUT)            :: dwavey(8,10)
   INTEGER, INTENT(IN)                      :: ilaw
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: reff
   INTEGER, INTENT(IN)                      :: ioutflag
!
   REAL(KIND=dp)  :: summ,tin,gin,hhh,rmuin,outinty
!
   INTEGER :: itguess, k, i
!
   DIMENSION  summ(8),outinty(8)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmassinsolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
!   Initialize
!
   DO  i=1,8
      third(i)=0.0_dp
      summ(i)=0.0_dp
   END DO
!
!   Check for negative values of the input parameters.  If
!   any are negative, then the third light option is turned off.
!
   IF(t3 <= 0.0_dp)THEN
      IF(ioutflag == 1)WRITE(2,40)
      RETURN
   END IF
!
   IF(g3 <= 0.0_dp)THEN
      IF(ioutflag == 1)WRITE(2,40)
      RETURN
   END IF
!
   IF(sa3 <= 0.0_dp)THEN
      IF(ioutflag == 1)WRITE(2,40)
      RETURN
   END IF
!
!   If the atmosphere option is not on, then set the third light
!   to zero.
!
   IF(iatm <= 0)THEN
      IF(ioutflag == 1)WRITE(2,40)
      RETURN
   END IF
!
!   Now compute the third light.  Define a series of mu values
!   from 0.01 to 1.0 and integrate.
!
   tin=t3
   gin=g3
   itguess=1
!
!   UPDATE JULY 16, 2011
!
!   Change the routine below to make the scaling
!   agree better.
!
   hhh=0.01_dp
   DO  i=100,0,-1
      rmuin=REAL(i,KIND=dp)/100.0_dp
      IF(rmuin > 0.0_dp)THEN
         CALL computeinty(tin,gin,rmuin,maxlines,maxmu,nlines,  &
            atmt,atmg,atmmu,nmu,atmint1,atmint2,atmint3,atmint4,  &
            atmint5,atmint6,atmint7,atmint8,outinty,icnu,icnb,icnv,  &
            icnr,icni,icnj,icnh,icnk,itguess,dwavex,dwavey,ilaw,iatm,istar)
      ELSE
         outinty(1)=0.0_dp
         outinty(2)=0.0_dp
         outinty(3)=0.0_dp
         outinty(4)=0.0_dp
         outinty(5)=0.0_dp
         outinty(6)=0.0_dp
         outinty(7)=0.0_dp
         outinty(8)=0.0_dp
      END IF
!
      DO  k=1,8
         IF(i == 100)THEN
            summ(k)=summ(k)+1.0_dp*hhh*outinty(k)*rmuin
         ELSE
            summ(k)=summ(k)+2.0_dp*hhh*outinty(k)*rmuin
         END IF
         third(k)=summ(k)*pie*reff*reff
         third(k)=sa3*third(k)*(separ*solarrad)**2
      END DO
   END DO
!
40 FORMAT(/'Info:  There is no third light')
!
   RETURN
!
END SUBROUTINE thirdlight
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION trueatomeana(theta,ecc)
!
   USE accur
   USE getpie
!   
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: theta
   REAL(KIND=dp), INTENT(IN)                       :: ecc
!
   REAL(KIND=dp)  :: psi,psippi,bige,sss,trueatomeana
!
   INTEGER :: n,ifloor
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   n=ifloor(theta/twopie)
   psi=theta-twopie*REAL(n+1,KIND=dp)
   psippi=psi+pie
   bige=2.0_dp*ATAN(SQRT((1.0_dp-ecc)/(1.0_dp+ecc))*TAN(psi/2.0_dp))
   sss=0.0_dp
   IF(psippi > 0.0_dp)sss=1.0_dp
   IF(psippi < 0.0_dp)sss=-1.0_dp
   IF(ABS(psippi) <= EPSILON(psippi))sss=0.0_dp
   trueatomeana=bige-ecc*SIN(bige)+twopie*(REAL(n,KIND=dp)+0.5_dp+sss/2.0_dp)
!
   RETURN
!
END FUNCTION trueatomeana
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE uniquepoint(nbig,xbig,ybig,ntrim,xtrim,ytrim)
!
!   October 8, 1999
!
!   This routine will take the large arrays xbig and ybig and remove
!   possible duplicate points.  It is assumed that the arrays xbig
!   and ybig have been passed to 'sortcircle' so that duplicate points
!   are in adjacent array positions.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nbig
   REAL(KIND=dp), INTENT(IN)                :: xbig(nbig)
   REAL(KIND=dp), INTENT(IN)                :: ybig(nbig)
   INTEGER, INTENT(OUT)                     :: ntrim
   REAL(KIND=dp), INTENT(OUT)               :: xtrim(nbig)
   REAL(KIND=dp), INTENT(OUT)               :: ytrim(nbig)
!
   REAL(KIND=dp)  :: t1,t2,distance
!
   INTEGER :: i
!
!   UPDATE JULY 2, 2004
!
!   Change the threshold to 1.0d-5
!
   ntrim=0
   DO  i=2,nbig
      t1=xbig(i)-xbig(i-1)
      t2=ybig(i)-ybig(i-1)
      distance=SQRT(t1*t1+t2*t2)
      IF(distance > 1.0E-05_dp)THEN
         ntrim=ntrim+1
         xtrim(ntrim)=xbig(i-1)
         ytrim(ntrim)=ybig(i-1)
      END IF
   END DO
!
!   Are the two points at the end the same?  If not, then write the last one.
!
   t1=xbig(nbig)-xbig(nbig-1)
   t2=ybig(nbig)-ybig(nbig-1)
   distance=SQRT(t1*t1+t2*t2)
   IF(distance > 1.0E-05_dp)THEN
      ntrim=ntrim+1
      xtrim(ntrim)=xbig(nbig)
      ytrim(ntrim)=ybig(nbig)
   END IF
!
   RETURN
!
END SUBROUTINE uniquepoint
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION vfcn(q,period,finc,primmass,primk,ecc)
!
!   UPDATE NOVEMBER 1
!
!   add the efact  =  dsqrt(1-e*e)
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                       :: q
   REAL(KIND=dp), INTENT(IN)                       :: period
   REAL(KIND=dp), INTENT(IN)                       :: finc
   REAL(KIND=dp), INTENT(IN)                       :: primmass
   REAL(KIND=dp), INTENT(IN)                       :: primk
   REAL(KIND=dp), INTENT(IN)                       :: ecc
!
   REAL(KIND=dp)  :: p,fincr,tt1,tt2,vfcn,efact
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmassinsolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   efact=SQRT(1.0_dp-ecc*ecc)
   p=period*secinday
   fincr=finc*degtorad
   tt1=twopie*SIN(fincr)/p*(q/(q+1.0_dp))
   tt2=gmsun*p*p*(1.0_dp+q)*primmass/fourpiesquared
   tt2=tt2**(1.0_dp/3.0_dp)*100.0_dp
   vfcn=tt1*tt2-primk*100000.0_dp*efact
!
   RETURN
!
END FUNCTION vfcn
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE wlinmod(icount,xmod,ymod,fileout,isw7,scale)
!
!  November 10, 1999
!
!  This routine will open the output file and record the given model
!  with flux in linear units.  The phases will be scaled to go from 0.0 to
!  1.0, and an extra phase will be added.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: icount
   REAL(KIND=dp), INTENT(IN)                :: xmod(icount)
   REAL(KIND=dp), INTENT(IN)                :: ymod(icount)
   CHARACTER (LEN=*), INTENT(IN)            :: fileout
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: scale
!
   INTEGER :: i
!
   OPEN(UNIT=20,FILE=fileout,STATUS='unknown')
!
   DO  i=1,icount
      WRITE(20,30)xmod(i),ymod(i)*scale
   END DO
!
   IF(isw7 >= 2)THEN
      CLOSE(20)
      RETURN
   END IF
!
   DO  i=1,icount
      WRITE(20,30)xmod(i)+1.0_dp,ymod(i)*scale
   END DO
!
   CLOSE(20)
!
30 FORMAT(f23.15,3X,1PE21.14)
!
   RETURN
!
END SUBROUTINE wlinmod
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE wmagmod(icount,xmod,ymod,fileout,isw7,zeropoint)
!
!  November 10, 1999
!
!  This routine will open the output file and record the given model
!  with flux in linear units.  The phases will be scaled to go from 0.0 to
!  1.0, and an extra phase will be added.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: icount
   REAL(KIND=dp), INTENT(IN)                :: xmod(icount)
   REAL(KIND=dp), INTENT(IN)                :: ymod(icount)
   CHARACTER (LEN=*), INTENT(IN)            :: fileout
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: zeropoint
!
   REAL(KIND=dp)  ::  eb
!
   INTEGER :: i
!
   OPEN(UNIT=20,FILE=fileout,STATUS='unknown')
!
!   UPDATE April 3, 2002
!
!   Add a variable called zeropoint, instead of 40.0d0
!
   eb=0.005_dp
   DO  i=1,icount
      WRITE(20,30)xmod(i),-2.5_dp*LOG10(ymod(i))+zeropoint,eb
   END DO
!
   IF(isw7 >= 2)THEN
      CLOSE(20)
      RETURN
   END IF
!
   DO  i=1,icount
      WRITE(20,30)xmod(i)+1.0_dp,-2.5_dp*LOG10(ymod(i))+zeropoint,eb
   END DO
!
   CLOSE(20)
!
30 FORMAT(f16.10,3X,f13.9,3X,f9.6)
!
   RETURN
!
END SUBROUTINE wmagmod
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE writebody3input(nalph3,nbet3,tertperiod,tertt0,  &
   tertecos,tertesin,tertincl,tertomega,tertq,dwavex,dwavey,  &
   itconj,it1,it2,it3,it4,tertconj,tertratrad,hh,sw72,sw73,  &
   p2tconj,p2period,p2t0,p2ecos,p2esin,p2incl,p2omega,p2q,  &
   p2ratrad,p3tconj,p3period,p3t0,p3ecos,p3esin,p3incl,p3omega,  &
   p3q,p3ratrad,p4tconj,p4period,p4t0,p4ecos,p4esin,p4incl,  &
   p4omega,p4q,p4ratrad,p5tconj,p5period,p5t0,p5ecos,p5esin,  &
   p5incl,p5omega,p5q,p5ratrad,p6tconj,p6period,p6t0,p6ecos,  &
   p6esin,p6incl,p6omega,p6q,p6ratrad,p7tconj,p7period,p7t0,  &
   p7ecos,p7esin,p7incl,p7omega,p7q,p7ratrad,p8tconj,p8period,  &
   p8t0,p8ecos,p8esin,p8incl,p8omega,p8q,p8ratrad)
!
!    will write the correctly formatted file ELCbody3.inp and return
!    default parameters
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(OUT)                     :: nalph3
   INTEGER, INTENT(OUT)                     :: nbet3
   REAL(KIND=dp), INTENT(OUT)               :: tertperiod
   REAL(KIND=dp), INTENT(OUT)               :: tertt0
   REAL(KIND=dp), INTENT(OUT)               :: tertecos
   REAL(KIND=dp), INTENT(OUT)               :: tertesin
   REAL(KIND=dp), INTENT(OUT)               :: tertincl
   REAL(KIND=dp), INTENT(OUT)               :: tertomega
   REAL(KIND=dp), INTENT(OUT)               :: tertq
   REAL(KIND=dp), INTENT(OUT)               :: dwavex(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: dwavey(8,10)
   INTEGER, INTENT(OUT)                     :: itconj
   INTEGER, INTENT(OUT)                     :: it1
   INTEGER, INTENT(OUT)                     :: it2
   INTEGER, INTENT(OUT)                     :: it3
   INTEGER, INTENT(OUT)                     :: it4
   REAL(KIND=dp), INTENT(OUT)               :: tertconj
   REAL(KIND=dp), INTENT(OUT)               :: tertratrad
   REAL(KIND=dp), INTENT(OUT)               :: hh
   REAL(KIND=dp), INTENT(OUT)               :: sw72
   REAL(KIND=dp), INTENT(OUT)               :: sw73
   REAL(KIND=dp), INTENT(OUT)               :: p2tconj
   REAL(KIND=dp), INTENT(OUT)               :: p2period
   REAL(KIND=dp), INTENT(OUT)               :: p2t0
   REAL(KIND=dp), INTENT(OUT)               :: p2ecos
   REAL(KIND=dp), INTENT(OUT)               :: p2esin
   REAL(KIND=dp), INTENT(OUT)               :: p2incl
   REAL(KIND=dp), INTENT(OUT)               :: p2omega
   REAL(KIND=dp), INTENT(OUT)               :: p2q
   REAL(KIND=dp), INTENT(OUT)               :: p2ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p3tconj
   REAL(KIND=dp), INTENT(OUT)               :: p3period
   REAL(KIND=dp), INTENT(OUT)               :: p3t0
   REAL(KIND=dp), INTENT(OUT)               :: p3ecos
   REAL(KIND=dp), INTENT(OUT)               :: p3esin
   REAL(KIND=dp), INTENT(OUT)               :: p3incl
   REAL(KIND=dp), INTENT(OUT)               :: p3omega
   REAL(KIND=dp), INTENT(OUT)               :: p3q
   REAL(KIND=dp), INTENT(OUT)               :: p3ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p4tconj
   REAL(KIND=dp), INTENT(OUT)               :: p4period
   REAL(KIND=dp), INTENT(OUT)               :: p4t0
   REAL(KIND=dp), INTENT(OUT)               :: p4ecos
   REAL(KIND=dp), INTENT(OUT)               :: p4esin
   REAL(KIND=dp), INTENT(OUT)               :: p4incl
   REAL(KIND=dp), INTENT(OUT)               :: p4omega
   REAL(KIND=dp), INTENT(OUT)               :: p4q
   REAL(KIND=dp), INTENT(OUT)               :: p4ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p5tconj
   REAL(KIND=dp), INTENT(OUT)               :: p5period
   REAL(KIND=dp), INTENT(OUT)               :: p5t0
   REAL(KIND=dp), INTENT(OUT)               :: p5ecos
   REAL(KIND=dp), INTENT(OUT)               :: p5esin
   REAL(KIND=dp), INTENT(OUT)               :: p5incl
   REAL(KIND=dp), INTENT(OUT)               :: p5omega
   REAL(KIND=dp), INTENT(OUT)               :: p5q
   REAL(KIND=dp), INTENT(OUT)               :: p5ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p6tconj
   REAL(KIND=dp), INTENT(OUT)               :: p6period
   REAL(KIND=dp), INTENT(OUT)               :: p6t0
   REAL(KIND=dp), INTENT(OUT)               :: p6ecos
   REAL(KIND=dp), INTENT(OUT)               :: p6esin
   REAL(KIND=dp), INTENT(OUT)               :: p6incl
   REAL(KIND=dp), INTENT(OUT)               :: p6omega
   REAL(KIND=dp), INTENT(OUT)               :: p6q
   REAL(KIND=dp), INTENT(OUT)               :: p6ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p7tconj
   REAL(KIND=dp), INTENT(OUT)               :: p7period
   REAL(KIND=dp), INTENT(OUT)               :: p7t0
   REAL(KIND=dp), INTENT(OUT)               :: p7ecos
   REAL(KIND=dp), INTENT(OUT)               :: p7esin
   REAL(KIND=dp), INTENT(OUT)               :: p7incl
   REAL(KIND=dp), INTENT(OUT)               :: p7omega
   REAL(KIND=dp), INTENT(OUT)               :: p7q
   REAL(KIND=dp), INTENT(OUT)               :: p7ratrad
   REAL(KIND=dp), INTENT(OUT)               :: p8tconj
   REAL(KIND=dp), INTENT(OUT)               :: p8period
   REAL(KIND=dp), INTENT(OUT)               :: p8t0
   REAL(KIND=dp), INTENT(OUT)               :: p8ecos
   REAL(KIND=dp), INTENT(OUT)               :: p8esin
   REAL(KIND=dp), INTENT(OUT)               :: p8incl
   REAL(KIND=dp), INTENT(OUT)               :: p8omega
   REAL(KIND=dp), INTENT(OUT)               :: p8q
   REAL(KIND=dp), INTENT(OUT)               :: p8ratrad
!
   INTEGER :: i
!
   CHARACTER (LEN=1) :: bell
!
   bell=CHAR(7)
   WRITE(*,110)bell
!
   nalph3=60
   nbet3=20
   tertperiod=20.0_dp
   tertt0=1020.0_dp
   tertecos=0.10_dp
   tertesin=-0.20_dp
   tertincl=90.0_dp
   tertomega=0.0_dp
   tertq=0.5_dp
   tertconj=50.0_dp
   itconj=0
   it1=0
   it2=0
   it3=0
   it4=0
   tertratrad=0.0_dp
   hh=0.0_dp
   sw72=0.0_dp
   sw73=0.0_dp
   p2tconj=0.0_dp
   p2period=0.0_dp
   p2t0=0.0_dp
   p2ecos=0.0_dp
   p2esin=0.0_dp
   p2incl=0.0_dp
   p2omega=0.0_dp
   p2q=0.0_dp
   p2ratrad=0.0_dp
   p3tconj=0.0_dp
   p3period=0.0_dp
   p3t0=0.0_dp
   p3ecos=0.0_dp
   p3esin=0.0_dp
   p3incl=0.0_dp
   p3omega=0.0_dp
   p3q=0.0_dp
   p3ratrad=0.0_dp
   p4tconj=0.0_dp
   p4period=0.0_dp
   p4t0=0.0_dp
   p4ecos=0.0_dp
   p4esin=0.0_dp
   p4incl=0.0_dp
   p4omega=0.0_dp
   p4q=0.0_dp
   p4ratrad=0.0_dp
   p5tconj=0.0_dp
   p5period=0.0_dp
   p5t0=0.0_dp
   p5ecos=0.0_dp
   p5esin=0.0_dp
   p5incl=0.0_dp
   p5omega=0.0_dp
   p5q=0.0_dp
   p5ratrad=0.0_dp
   p6tconj=0.0_dp
   p6period=0.0_dp
   p6t0=0.0_dp
   p6ecos=0.0_dp
   p6esin=0.0_dp
   p6incl=0.0_dp
   p6omega=0.0_dp
   p6q=0.0_dp
   p6ratrad=0.0_dp
   p7tconj=0.0_dp
   p7period=0.0_dp
   p7t0=0.0_dp
   p7ecos=0.0_dp
   p7esin=0.0_dp
   p7incl=0.0_dp
   p7omega=0.0_dp
   p7q=0.0_dp
   p7ratrad=0.0_dp
   p8tconj=0.0_dp
   p8period=0.0_dp
   p8t0=0.0_dp
   p8ecos=0.0_dp
   p8esin=0.0_dp
   p8incl=0.0_dp
   p8omega=0.0_dp
   p8q=0.0_dp
   p8ratrad=0.0_dp
!
   DO i=1,8
      dwavex(i,3)=0.635_dp
      dwavey(i,3)=0.130_dp
   END DO
!
   DO i=1,8
      dwavex(i,4)=0.635_dp
      dwavey(i,4)=0.130_dp
   END DO
!
   DO i=1,8
      dwavex(i,5)=0.635_dp
      dwavey(i,5)=0.130_dp
   END DO
!
   OPEN(UNIT=1,FILE='ELCbody3.inp',STATUS='unknown')
!
   WRITE(1,120)nalph3
   WRITE(1,130)nbet3
   WRITE(1,10)itconj
   WRITE(1,20)it1
   WRITE(1,30)it2
   WRITE(1,40)it3
   WRITE(1,50)it4
   WRITE(1,60)tertconj
   WRITE(1,140)tertperiod
   WRITE(1,150)tertt0
   WRITE(1,160)tertecos
   WRITE(1,170)tertesin
   WRITE(1,180)tertincl
   WRITE(1,190)tertomega
   WRITE(1,200)tertq
   DO i=1,8
      WRITE(1,210)dwavex(i,3),dwavey(i,3)
   END DO
   WRITE(1,70)tertratrad
   WRITE(1,80)hh
   WRITE(1,90)sw72
   WRITE(1,100)sw73
   WRITE(1,220)p2tconj
   WRITE(1,230)p2period
   WRITE(1,240)p2t0
   WRITE(1,250)p2ecos
   WRITE(1,260)p2esin
   WRITE(1,270)p2incl
   WRITE(1,280)p2omega
   WRITE(1,290)p2q
   WRITE(1,300)p2ratrad
   WRITE(1,310)p3tconj
   WRITE(1,320)p3period
   WRITE(1,330)p3t0
   WRITE(1,340)p3ecos
   WRITE(1,350)p3esin
   WRITE(1,360)p3incl
   WRITE(1,370)p3omega
   WRITE(1,380)p3q
   WRITE(1,390)p3ratrad
   WRITE(1,400)p4tconj
   WRITE(1,410)p4period
   WRITE(1,420)p4t0
   WRITE(1,430)p4ecos
   WRITE(1,440)p4esin
   WRITE(1,450)p4incl
   WRITE(1,460)p4omega
   WRITE(1,470)p4q
   WRITE(1,480)p4ratrad
   WRITE(1,490)p5tconj
   WRITE(1,500)p5period
   WRITE(1,510)p5t0
   WRITE(1,520)p5ecos
   WRITE(1,530)p5esin
   WRITE(1,540)p5incl
   WRITE(1,550)p5omega
   WRITE(1,560)p5q
   WRITE(1,570)p5ratrad
   WRITE(1,580)p6tconj
   WRITE(1,590)p6period
   WRITE(1,600)p6t0
   WRITE(1,610)p6ecos
   WRITE(1,620)p6esin
   WRITE(1,630)p6incl
   WRITE(1,640)p6omega
   WRITE(1,650)p6q
   WRITE(1,660)p6ratrad
   WRITE(1,670)p7tconj
   WRITE(1,680)p7period
   WRITE(1,690)p7t0
   WRITE(1,700)p7ecos
   WRITE(1,710)p7esin
   WRITE(1,720)p7incl
   WRITE(1,730)p7omega
   WRITE(1,740)p7q
   WRITE(1,750)p7ratrad
   WRITE(1,760)p8tconj
   WRITE(1,770)p8period
   WRITE(1,780)p8t0
   WRITE(1,790)p8ecos
   WRITE(1,800)p8esin
   WRITE(1,810)p8incl
   WRITE(1,820)p8omega
   WRITE(1,830)p8q
   WRITE(1,840)p8ratrad
!
   DO i=1,8
      WRITE(1,210)dwavex(i,4),dwavey(i,4)
   END DO
!
   DO i=1,8
      WRITE(1,210)dwavex(i,5),dwavey(i,5)
   END DO
!
   CLOSE(1)
!
10 FORMAT(i1,19X,'itconj (0=T_peri, 1=T_tran, 2=T_occul)')
20 FORMAT(i1,19X,'set to 1 for logarithmic mass ratios')
30 FORMAT(i1,19X,'set to 1 for informational output file')
40 FORMAT(i1,19X,'set to 1 to treat transits and ','occultations'  &
      ,' together')
50 FORMAT(i1,19X,'set to 1 to suppress demcmcELC output files')
60 FORMAT(f16.8,4X,'tertconj             tag tj')
70 FORMAT(f4.2,16X,'tertratrad (P1 radius to star 1 radius,''TAG'  &
      ,' tb')
80 FORMAT(f16.8,4X,'h (step size for dynamical integration)')
90 FORMAT(f10.8,10X,'rk1 (apsidal constant star 1  tag a1)')
100 FORMAT(f10.8,10X,'rk2 (apsidal constant star 2  tag a2)')
110 FORMAT(a1,'I can''T FIND THE FILE ''ELCBODY3.INP''!',/'I''M M'  &
      ,'aking one up and setting default values')
120 FORMAT(i2,18X,'Nalph3')
130 FORMAT(i2,18X,'Nbet3')
140 FORMAT(f14.6,6X,'tertperiod (days)    tag tt')
150 FORMAT(f16.8,4X,'tertT0               tag tu')
160 FORMAT(f12.9,8X,'terte*cos(omega)     tag tv')
170 FORMAT(f12.9,8X,'terte*sin(omega)     tag tw')
180 FORMAT(f13.9,7X,'tertincl (degrees)   tag tx')
190 FORMAT(f13.8,7X,'tertOmega (degrees)  tag ty')
200 FORMAT(f19.7,1X,'tertQ (EB/body3)     tag tz')
210 FORMAT(2(f9.6,1X))
220 FORMAT(f13.6,7X,'P2tconj              tag uj')
230 FORMAT(f14.6,6X,'P2period (days)      tag ut')
240 FORMAT(f16.8,4X,'P2T0                 tag uu')
250 FORMAT(f12.9,8X,'P2ecos               tag uv')
260 FORMAT(f12.9,8X,'P2esin               tag uw')
270 FORMAT(f13.8,7X,'P2incl (degrees)     tag ux')
280 FORMAT(f13.8,7X,'P2Omega (degrees)    tag uy')
290 FORMAT(f19.7,1X,'P2Q (EB/body3)       tag uz')
300 FORMAT(f13.6,7X,'P2ratrad             tag ub')
310 FORMAT(f13.6,7X,'P3tconj              tag vj')
320 FORMAT(f14.6,6X,'P3period (days)      tag vt')
330 FORMAT(f16.8,4X,'P3T0                 tag vu')
340 FORMAT(f12.9,8X,'P3ecos               tag vv')
350 FORMAT(f12.9,8X,'P3esin               tag vw')
360 FORMAT(f13.8,7X,'P3incl (degrees)     tag vx')
370 FORMAT(f13.8,7X,'P3Omega (degrees)    tag vy')
380 FORMAT(f19.7,1X,'P3Q (EB/body3)       tag vz')
390 FORMAT(f13.6,7X,'P3ratrad             tag vb')
400 FORMAT(f13.6,7X,'P4tconj              tag wj')
410 FORMAT(f14.6,6X,'P4period (days)      tag wt')
420 FORMAT(f16.8,4X,'P4T0                 tag wu')
430 FORMAT(f12.9,8X,'P4ecos               tag wv')
440 FORMAT(f12.9,8X,'P4esin               tag ww')
450 FORMAT(f13.8,7X,'P4incl (degrees)     tag wx')
460 FORMAT(f13.8,7X,'P4Omega (degrees)    tag wy')
470 FORMAT(f19.7,1X,'P4Q (EB/body3)       tag wz')
480 FORMAT(f13.6,7X,'P4ratrad             tag wb')
490 FORMAT(f13.6,7X,'P5tconj              tag xj')
500 FORMAT(f14.6,6X,'P5period (days)      tag xt')
510 FORMAT(f16.8,4X,'P5T0                 tag xu')
520 FORMAT(f12.9,8X,'P5ecos               tag xv')
530 FORMAT(f12.9,8X,'P5esin               tag xw')
540 FORMAT(f13.8,7X,'P5incl (degrees)     tag xx')
550 FORMAT(f13.8,7X,'P5Omega (degrees)    tag xy')
560 FORMAT(f19.7,1X,'P5Q (EB/body3)       tag xz')
570 FORMAT(f13.6,7X,'P5ratrad             tag xb')
580 FORMAT(f13.6,7X,'P6tconj              tag sj')
590 FORMAT(f14.6,6X,'P6period (days)      tag st')
600 FORMAT(f16.8,4X,'P6T0                 tag su')
610 FORMAT(f12.9,8X,'P6ecos               tag sv')
620 FORMAT(f12.9,8X,'P6esin               tag sw')
630 FORMAT(f13.8,7X,'P6incl (degrees)     tag sx')
640 FORMAT(f13.8,7X,'P6Omega (degrees)    tag sy')
650 FORMAT(f19.7,1X,'P6Q (EB/body3)       tag sz')
660 FORMAT(f13.6,7X,'P6ratrad             tag sb')
670 FORMAT(f13.6,7X,'P7tconj              tag hj')
680 FORMAT(f14.6,6X,'P7period (days)      tag ht')
690 FORMAT(f16.8,4X,'P7T0                 tag hu')
700 FORMAT(f12.9,8X,'P7ecos               tag hv')
710 FORMAT(f12.9,8X,'P7esin               tag hw')
720 FORMAT(f13.8,7X,'P7incl (degrees)     tag hx')
730 FORMAT(f13.8,7X,'P7Omega (degrees)    tag hy')
740 FORMAT(f19.7,1X,'P7Q (EB/body3)       tag hz')
750 FORMAT(f13.6,7X,'P7ratrad             tag hb')
760 FORMAT(f13.6,7X,'P8tconj              tag kj')
770 FORMAT(f14.6,6X,'P8period (days)      tag kt')
780 FORMAT(f16.8,4X,'P8T0                 tag ku')
790 FORMAT(f12.9,8X,'P8ecos               tag kv')
800 FORMAT(f12.9,8X,'P8esin               tag kw')
810 FORMAT(f13.8,7X,'P8incl (degrees)     tag kx')
820 FORMAT(f13.8,7X,'P8Omega (degrees)    tag ky')
830 FORMAT(f19.7,1X,'P8Q (EB/body3)       tag kz')
840 FORMAT(f13.6,7X,'P8ratrad             tag kb')
!
   RETURN
!
END SUBROUTINE writebody3input
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE writedynamics(nbody,nstep,ndyn,odetime,  &
   body01posx,body01posy,body01posz,body01velx,body01vely,  &
   body01velz,body02posx,body02posy,body02posz,body02velx,  &
   body02vely,body02velz,body03posx,body03posy,body03posz,  &
   body03velx,body03vely,body03velz,body04posx,body04posy,  &
   body04posz,body04velx,body04vely,body04velz,body05posx,  &
   body05posy,body05posz,body05velx,body05vely,body05velz,  &
   body06posx,body06posy,body06posz,body06velx,body06vely,  &
   body06velz,body07posx,body07posy,body07posz,body07velx,  &
   body07vely,body07velz,body08posx,body08posy,body08posz,  &
   body09velx,body09vely,body09velz,body10posx,body10posy,  &
   body10posz,body10velx,body10vely,body10velz,body08velx,  &
   body08vely,body08velz,body09posx,body09posy,body09posz)
!
!   will write ELCdynamics.pos and ELCdynamics.vel (ELC only)
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nbody
   INTEGER, INTENT(IN)                      :: nstep
   INTEGER, INTENT(IN)                      :: ndyn
   REAL(KIND=dp), INTENT(IN)                :: odetime(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body01velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body02velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body03velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body04velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body05velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body06velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body07velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10posz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body10velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08velx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08vely(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body08velz(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09posx(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09posy(ndyn)
   REAL(KIND=dp), INTENT(IN)                :: body09posz(ndyn)
!
   INTEGER :: jjj
!
   OPEN(UNIT=92,FILE='ELCdynamics.pos',STATUS='unknown')
   OPEN(UNIT=93,FILE='ELCdynamics.vel',STATUS='unknown')

   DO jjj=1,nstep
!
      IF(nbody == 3)THEN
         WRITE(92,10)odetime(jjj),body01posx(jjj),  &
            body01posy(jjj),body01posz(jjj),body02posx(jjj),  &
            body02posy(jjj),body02posz(jjj),body03posx(jjj),  &
            body03posy(jjj),body03posz(jjj)
         WRITE(93,10)odetime(jjj),body01velx(jjj),  &
            body01vely(jjj),body01velz(jjj),body02velx(jjj),  &
            body02vely(jjj),body02velz(jjj),body03velx(jjj),  &
            body03vely(jjj),body03velz(jjj)
      END IF
!
      IF(nbody == 4)THEN
         WRITE(92,10)odetime(jjj),body01posx(jjj),  &
            body01posy(jjj),body01posz(jjj),body02posx(jjj),  &
            body02posy(jjj),body02posz(jjj),body03posx(jjj),  &
            body03posy(jjj),body03posz(jjj),body04posx(jjj),  &
            body04posy(jjj),body04posz(jjj)
         WRITE(93,10)odetime(jjj),body01velx(jjj),  &
            body01vely(jjj),body01velz(jjj),body02velx(jjj),  &
            body02vely(jjj),body02velz(jjj),body03velx(jjj),  &
            body03vely(jjj),body03velz(jjj),body04velx(jjj),  &
            body04vely(jjj),body04velz(jjj)
      END IF
!
      IF(nbody == 5)THEN
         WRITE(92,10)odetime(jjj),body01posx(jjj),  &
            body01posy(jjj),body01posz(jjj),body02posx(jjj),  &
            body02posy(jjj),body02posz(jjj),body03posx(jjj),  &
            body03posy(jjj),body03posz(jjj),body04posx(jjj),  &
            body04posy(jjj),body04posz(jjj),body05posx(jjj),  &
            body05posy(jjj),body05posz(jjj)
         WRITE(93,10)odetime(jjj),body01velx(jjj),  &
            body01vely(jjj),body01velz(jjj),body02velx(jjj),  &
            body02vely(jjj),body02velz(jjj),body03velx(jjj),  &
            body03vely(jjj),body03velz(jjj),body04velx(jjj),  &
            body04vely(jjj),body04velz(jjj),body05velx(jjj),  &
            body05vely(jjj),body05velz(jjj)
      END IF
!
      IF(nbody == 6)THEN
         WRITE(92,10)odetime(jjj),body01posx(jjj),  &
            body01posy(jjj),body01posz(jjj),body02posx(jjj),  &
            body02posy(jjj),body02posz(jjj),body03posx(jjj),  &
            body03posy(jjj),body03posz(jjj),body04posx(jjj),  &
            body04posy(jjj),body04posz(jjj),body05posx(jjj),  &
            body05posy(jjj),body05posz(jjj),body06posx(jjj),  &
            body06posy(jjj),body06posz(jjj)
         WRITE(93,10)odetime(jjj),body01velx(jjj),  &
            body01vely(jjj),body01velz(jjj),body02velx(jjj),  &
            body02vely(jjj),body02velz(jjj),body03velx(jjj),  &
            body03vely(jjj),body03velz(jjj),body04velx(jjj),  &
            body04vely(jjj),body04velz(jjj),body05velx(jjj),  &
            body05vely(jjj),body05velz(jjj),body06velx(jjj),  &
            body06vely(jjj),body06velz(jjj)
      END IF
!
      IF(nbody == 7)THEN
         WRITE(92,10)odetime(jjj),body01posx(jjj),  &
            body01posy(jjj),body01posz(jjj),body02posx(jjj),  &
            body02posy(jjj),body02posz(jjj),body03posx(jjj),  &
            body03posy(jjj),body03posz(jjj),body04posx(jjj),  &
            body04posy(jjj),body04posz(jjj),body05posx(jjj),  &
            body05posy(jjj),body05posz(jjj),body06posx(jjj),  &
            body06posy(jjj),body06posz(jjj),body07posx(jjj),  &
            body07posy(jjj),body07posz(jjj)
         WRITE(93,10)odetime(jjj),body01velx(jjj),  &
            body01vely(jjj),body01velz(jjj),body02velx(jjj),  &
            body02vely(jjj),body02velz(jjj),body03velx(jjj),  &
            body03vely(jjj),body03velz(jjj),body04velx(jjj),  &
            body04vely(jjj),body04velz(jjj),body05velx(jjj),  &
            body05vely(jjj),body05velz(jjj),body06velx(jjj),  &
            body06vely(jjj),body06velz(jjj),body07velx(jjj),  &
            body07vely(jjj),body07velz(jjj)
      END IF
!
      IF(nbody == 8)THEN
         WRITE(92,10)odetime(jjj),body01posx(jjj),  &
            body01posy(jjj),body01posz(jjj),body02posx(jjj),  &
            body02posy(jjj),body02posz(jjj),body03posx(jjj),  &
            body03posy(jjj),body03posz(jjj),body04posx(jjj),  &
            body04posy(jjj),body04posz(jjj),body05posx(jjj),  &
            body05posy(jjj),body05posz(jjj),body06posx(jjj),  &
            body06posy(jjj),body06posz(jjj),body07posx(jjj),  &
            body07posy(jjj),body07posz(jjj),body08posx(jjj),  &
            body08posy(jjj),body08posz(jjj)
         WRITE(93,10)odetime(jjj),body01velx(jjj),  &
            body01vely(jjj),body01velz(jjj),body02velx(jjj),  &
            body02vely(jjj),body02velz(jjj),body03velx(jjj),  &
            body03vely(jjj),body03velz(jjj),body04velx(jjj),  &
            body04vely(jjj),body04velz(jjj),body05velx(jjj),  &
            body05vely(jjj),body05velz(jjj),body06velx(jjj),  &
            body06vely(jjj),body06velz(jjj),body07velx(jjj),  &
            body07vely(jjj),body07velz(jjj),body08velx(jjj),  &
            body08vely(jjj),body08velz(jjj)
      END IF
!
      IF(nbody == 9)THEN
         WRITE(92,10)odetime(jjj),body01posx(jjj),  &
            body01posy(jjj),body01posz(jjj),body02posx(jjj),  &
            body02posy(jjj),body02posz(jjj),body03posx(jjj),  &
            body03posy(jjj),body03posz(jjj),body04posx(jjj),  &
            body04posy(jjj),body04posz(jjj),body05posx(jjj),  &
            body05posy(jjj),body05posz(jjj),body06posx(jjj),  &
            body06posy(jjj),body06posz(jjj),body07posx(jjj),  &
            body07posy(jjj),body07posz(jjj),body08posx(jjj),  &
            body08posy(jjj),body08posz(jjj),body09posx(jjj),  &
            body09posy(jjj),body09posz(jjj)
         WRITE(93,10)odetime(jjj),body01velx(jjj),  &
            body01vely(jjj),body01velz(jjj),body02velx(jjj),  &
            body02vely(jjj),body02velz(jjj),body03velx(jjj),  &
            body03vely(jjj),body03velz(jjj),body04velx(jjj),  &
            body04vely(jjj),body04velz(jjj),body05velx(jjj),  &
            body05vely(jjj),body05velz(jjj),body06velx(jjj),  &
            body06vely(jjj),body06velz(jjj),body07velx(jjj),  &
            body07vely(jjj),body07velz(jjj),body08velx(jjj),  &
            body08vely(jjj),body08velz(jjj),body09velx(jjj),  &
            body09vely(jjj),body09velz(jjj)
      END IF
!
      IF(nbody == 10)THEN
         WRITE(92,10)odetime(jjj),body01posx(jjj),  &
            body01posy(jjj),body01posz(jjj),body02posx(jjj),  &
            body02posy(jjj),body02posz(jjj),body03posx(jjj),  &
            body03posy(jjj),body03posz(jjj),body04posx(jjj),  &
            body04posy(jjj),body04posz(jjj),body05posx(jjj),  &
            body05posy(jjj),body05posz(jjj),body06posx(jjj),  &
            body06posy(jjj),body06posz(jjj),body07posx(jjj),  &
            body07posy(jjj),body07posz(jjj),body08posx(jjj),  &
            body08posy(jjj),body08posz(jjj),body09posx(jjj),  &
            body09posy(jjj),body09posz(jjj),body10posx(jjj),  &
            body10posy(jjj),body10posz(jjj)
         WRITE(93,10)odetime(jjj),body01velx(jjj),  &
            body01vely(jjj),body01velz(jjj),body02velx(jjj),  &
            body02vely(jjj),body02velz(jjj),body03velx(jjj),  &
            body03vely(jjj),body03velz(jjj),body04velx(jjj),  &
            body04vely(jjj),body04velz(jjj),body05velx(jjj),  &
            body05vely(jjj),body05velz(jjj),body06velx(jjj),  &
            body06vely(jjj),body06velz(jjj),body07velx(jjj),  &
            body07vely(jjj),body07velz(jjj),body08velx(jjj),  &
            body08vely(jjj),body08velz(jjj),body09velx(jjj),  &
            body09vely(jjj),body09velz(jjj),body10velx(jjj),  &
            body10vely(jjj),body10velz(jjj)
      END IF
!
   END DO
   CLOSE(92)
   CLOSE(93)
!
10 FORMAT(f16.5,2X,30(1PE25.17,1X))
!
   RETURN
!
END SUBROUTINE writedynamics
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE writedynparm(dynparm,rmass,dynqq,dynpp,tref)
!
   USE accur
!
   IMPLICIT NONE
!
   CHARACTER (LEN=1700), INTENT(OUT)        :: dynparm
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: dynqq(30)
   REAL(KIND=dp), INTENT(IN)                :: dynpp(30)
   REAL(KIND=dp), INTENT(IN)                :: tref
!
   INTEGER :: i,j,k
!
   WRITE(dynparm,10)tref,(rmass(k),k=1,10),(dynqq(j),j=1,30),(dynpp(i),i=1,30)
   dynparm=TRIM(dynparm)
!
10 FORMAT(f15.8,3X,10(1PE21.14,1X),3X,30(1PE22.15,1X),3X,  &
      30(1PE22.15,1X))
!
   RETURN
!
END SUBROUTINE writedynparm
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE writeeclipse(ncycle,ttimes,tseps,nbody,  &
   nmaxeclipse,tdur1,tdur2,iflag)
!
!   Will write the model eclipse times if in dynamics mode
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nmaxeclipse
   INTEGER, INTENT(IN)                      :: ncycle(40)
   REAL(KIND=dp), INTENT(IN)                :: ttimes(40,nmaxeclipse)
   REAL(KIND=dp), INTENT(IN)                :: tseps(40,nmaxeclipse)
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: tdur1(40,nmaxeclipse)
   REAL(KIND=dp), INTENT(IN)                :: tdur2(40,nmaxeclipse)
   INTEGER, INTENT(IN)                      :: iflag
!
   REAL(KIND=dp)  :: eb
!
   INTEGER :: icount,ij
!
   LOGICAL  :: file_exists
!
   file_exists=.false.
!
   eb=1.0_dp
   icount=0
   DO ij=1,ncycle(1)
      IF(ABS(tseps(1,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELCprimtime.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELCprimtime.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELCprimtime.dat',STATUS='old',POSITION='append')
         ELSE
            OPEN(UNIT=20,FILE='ELCprimtime.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(1)
         IF(ABS(tseps(1,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(1,ij),eb,tseps(1,ij),tdur1(1,ij),tdur2(1,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(2)
      IF(ABS(tseps(2,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELCsectime.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELCsectime.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELCsectime.dat',STATUS='old',POSITION='append')
         ELSE
            OPEN(UNIT=20,FILE='ELCsectime.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(2)
         IF(ABS(tseps(2,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(2,ij),eb,tseps(2,ij),tdur1(2,ij),tdur2(2,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
!   transits and occultations of body 3
!
   icount=0
   DO ij=1,ncycle(3)
      IF(ABS(tseps(3,ij)) <= 100.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC3tran1time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC3tran1time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC3tran1time.dat',STATUS='old',POSITION= &
                 'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC3tran1time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(3)
         IF(ABS(tseps(3,ij)) <= 100.0_dp)THEN
            WRITE(20,10)ij,ttimes(3,ij),eb,tseps(3,ij),tdur1(3,ij),tdur2(3,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(4)
      IF(ABS(tseps(4,ij)) <= 100.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC1occul3time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC1occul3time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC1occul3time.dat',STATUS='old',POSITION= &
               'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC1occul3time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(4)
         IF(ABS(tseps(4,ij)) <= 100.0_dp)THEN
            WRITE(20,10)ij,ttimes(4,ij),eb,tseps(4,ij),tdur1(4,ij),tdur2(4,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(5)
      IF(ABS(tseps(5,ij)) <= 100.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC3tran2time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC3tran2time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC3tran2time.dat',STATUS='old',POSITION= &
              'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC3tran2time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(5)
         IF(ABS(tseps(5,ij)) <= 100.0_dp)THEN
            WRITE(20,10)ij,ttimes(5,ij),eb,tseps(5,ij),tdur1(5,ij),tdur2(5,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(6)
      IF(ABS(tseps(6,ij)) <= 100.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC2occul3time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC2occul3time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC2occul3time.dat',STATUS='old',POSITION= &
               'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC2occul3time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(6)
         IF(ABS(tseps(6,ij)) <= 100.0_dp)THEN
            WRITE(20,10)ij,ttimes(6,ij),eb,tseps(6,ij),tdur1(6,ij),tdur2(6,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
!   transits and occultations of body 4
!
   IF(nbody < 4)RETURN
!
   icount=0
   DO ij=1,ncycle(7)
      IF(ABS(tseps(7,ij)) <= 100.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC4tran1time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC4tran1time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC4tran1time.dat',STATUS='old',POSITION= &
              'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC4tran1time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(7)
         IF(ABS(tseps(7,ij)) <= 100.0_dp)THEN
            WRITE(20,10)ij,ttimes(7,ij),eb,tseps(7,ij),tdur1(7,ij),tdur2(7,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(8)
      IF(ABS(tseps(8,ij)) <= 100.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC1occul4time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC1occul4time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC1occul4time.dat',STATUS='old',POSITION= &
              'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC1occul4time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(8)
         IF(ABS(tseps(8,ij)) <= 100.0_dp)THEN
            WRITE(20,10)ij,ttimes(8,ij),eb,tseps(8,ij),tdur1(8,ij),tdur2(8,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(9)
      IF(ABS(tseps(9,ij)) <= 100.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC4tran2time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC4tran2time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC4tran2time.dat',STATUS='old',POSITION= &
               'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC4tran2time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(9)
         IF(ABS(tseps(9,ij)) <= 100.0_dp)THEN
            WRITE(20,10)ij,ttimes(9,ij),eb,tseps(9,ij),tdur1(9,ij),tdur2(9,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(10)
      IF(ABS(tseps(10,ij)) <= 100.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC2occul4time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC2occul4time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC2occul4time.dat',STATUS='old',POSITION= &
              'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC2occul4time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(10)
         IF(ABS(tseps(10,ij)) <= 100.0_dp)THEN
            WRITE(20,10)ij,ttimes(10,ij),eb,tseps(10,ij),tdur1(10,ij), &
              tdur2(10,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(35)
      IF(ABS(tseps(35,ij)) <= 5.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC4tran3time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC4tran3time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC4tran3time.dat',STATUS='old',POSITION= &
               'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC4tran3time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(35)
         IF(ABS(tseps(35,ij)) <= 5.0_dp)THEN
            WRITE(20,10)ij,ttimes(35,ij),eb,tseps(35,ij),tdur1(35,ij), &
               tdur2(35,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(36)
      IF(ABS(tseps(36,ij)) <= 5.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC3tran4time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC3tran4time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC3tran4time.dat',STATUS='old',POSITION= &
               'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC3tran4time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(36)
         IF(ABS(tseps(36,ij)) <= 5.0_dp)THEN
            WRITE(20,10)ij,ttimes(36,ij),eb,tseps(36,ij),tdur1(36,ij),  &
                tdur2(36,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
!   transits and occultations of body 5
!
   IF(nbody < 5)RETURN
!
   icount=0
   DO ij=1,ncycle(11)
      IF(ABS(tseps(11,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC5tran1time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC5tran1time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC5tran1time.dat',STATUS='old',POSITION= &
              'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC5tran1time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(11)
         IF(ABS(tseps(11,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(11,ij),eb,tseps(11,ij),tdur1(11,ij),  &
               tdur2(11,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(12)
      IF(ABS(tseps(12,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC1occul5time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC1occul5time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC1occul5time.dat',STATUS='old',POSITION= &
              'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC1occul5time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(12)
         IF(ABS(tseps(12,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(12,ij),eb,tseps(12,ij),tdur1(12,ij), &
               tdur2(12,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(13)
      IF(ABS(tseps(13,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC5tran2time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC5tran2time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC5tran2time.dat',STATUS='old',POSITION= &
              'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC5tran2time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(13)
         IF(ABS(tseps(13,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(13,ij),eb,tseps(13,ij),tdur1(13,ij), &
              tdur2(13,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(14)
      IF(ABS(tseps(14,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC2occul5time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC2occul5time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC2occul5time.dat',STATUS='old',POSITION= &
               'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC2occul5time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(14)
         IF(ABS(tseps(14,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(14,ij),eb,tseps(14,ij),tdur1(14,ij),  &
               tdur2(14,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(37)
      IF(ABS(tseps(37,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC5tran3time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC5tran3time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC5tran3time.dat',STATUS='old',POSITION=  &
               'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC5tran3time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(37)
         IF(ABS(tseps(37,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(37,ij),eb,tseps(37,ij),tdur1(37,ij),  &
                 tdur2(37,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(38)
      IF(ABS(tseps(38,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC3occul5time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC3occul5time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC3occul5time.dat',STATUS='old',POSITION= &
                'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC3occul5time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(38)
         IF(ABS(tseps(38,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(38,ij),eb,tseps(38,ij),tdur1(38,ij), &
               tdur2(38,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(39)
      IF(ABS(tseps(39,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC5tran4time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC5tran4time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC5tran4time.dat',STATUS='old',POSITION= &
                 'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC4occul5time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(40)
         IF(ABS(tseps(40,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(40,ij),eb,tseps(40,ij),tdur1(40,ij), &
              tdur2(40,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
!   transits and occultations of body 6
!
   IF(nbody < 6)RETURN
!
   icount=0
   DO ij=1,ncycle(15)
      IF(ABS(tseps(15,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC6tran1time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC6tran1time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC6tran1time.dat',STATUS='old',POSITION=  &
               'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC6tran1time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(16)
         IF(ABS(tseps(16,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(16,ij),eb,tseps(16,ij),tdur1(16,ij),  &
               tdur2(16,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(17)
      IF(ABS(tseps(17,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC6tran2time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC6tran2time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC6tran2time.dat',STATUS='old',POSITION= &
              'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC6tran2time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(17)
         IF(ABS(tseps(17,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(17,ij),eb,tseps(17,ij),tdur1(17,ij), &
               tdur2(17,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(18)
      IF(ABS(tseps(18,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC2occul6time.dat',STATUS='unknown')
      ELSE
         INQUIRE(FILE='ELC2occul6time.dat',EXIST=file_exists)
         IF(file_exists)THEN
            OPEN(UNIT=20,FILE='ELC2occul6time.dat',STATUS='old',POSITION= &
               'append')
         ELSE
            OPEN(UNIT=20,FILE='ELC2occul6time.dat',STATUS='unknown')
         END IF
      END IF
      DO ij=1,ncycle(18)
         IF(ABS(tseps(18,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(18,ij),eb,tseps(18,ij),tdur1(18,ij), &
              tdur2(18,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
!   transits and occultations of body 7
!
   IF(nbody < 7)RETURN
!
   icount=0
   DO ij=1,ncycle(19)
      IF(ABS(tseps(19,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC7tran1time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC7tran1time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(19)
         IF(ABS(tseps(19,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(19,ij),eb,tseps(19,ij),tdur1(19,ij),tdur2(19,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(20)
      IF(ABS(tseps(20,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC1occul7time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC1occul7time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(20)
         IF(ABS(tseps(20,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(20,ij),eb,tseps(20,ij),tdur1(20,ij),tdur2(20,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(21)
      IF(ABS(tseps(21,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC7tran2time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC7tran2time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(21)
         IF(ABS(tseps(21,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(21,ij),eb,tseps(21,ij),tdur1(21,ij),tdur2(21,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(22)
      IF(ABS(tseps(22,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC2occul7time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC2occul7time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(22)
         IF(ABS(tseps(22,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(22,ij),eb,tseps(22,ij),tdur1(22,ij),tdur2(22,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
!   transits and occultations of body 8
!
   IF(nbody < 8)RETURN
!
   icount=0
   DO ij=1,ncycle(23)
      IF(ABS(tseps(23,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC8tran1time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC8tran1time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(23)
         IF(ABS(tseps(23,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(23,ij),eb,tseps(23,ij),tdur1(23,ij),tdur2(23,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(24)
      IF(ABS(tseps(24,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC1occul8time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC1occul8time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(24)
         IF(ABS(tseps(24,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(24,ij),eb,tseps(24,ij),tdur1(24,ij),tdur2(24,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(25)
      IF(ABS(tseps(25,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC8tran2time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC8tran2time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(25)
         IF(ABS(tseps(25,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(25,ij),eb,tseps(25,ij),tdur1(25,ij),tdur2(25,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(26)
      IF(ABS(tseps(26,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC2occul8time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC2occul8time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(26)
         IF(ABS(tseps(26,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(26,ij),eb,tseps(26,ij),tdur1(26,ij),tdur2(26,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
!   transits and occultations of body 9
!
   IF(nbody < 9)RETURN
!
   icount=0
   DO ij=1,ncycle(27)
      IF(ABS(tseps(27,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC9tran1time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC9tran1time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(27)
         IF(ABS(tseps(27,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(27,ij),eb,tseps(27,ij),tdur1(27,ij),tdur2(27,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(28)
      IF(ABS(tseps(28,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC1occul9time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC1occul9time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(28)
         IF(ABS(tseps(28,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(28,ij),eb,tseps(28,ij),tdur1(28,ij),tdur2(28,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(29)
      IF(ABS(tseps(29,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC9tran2time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC9tran2time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(29)
         IF(ABS(tseps(29,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(29,ij),eb,tseps(29,ij),tdur1(29,ij),tdur2(29,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(30)
      IF(ABS(tseps(30,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC2occul9time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC2occul9time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(30)
         IF(ABS(tseps(30,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(30,ij),eb,tseps(30,ij),tdur1(30,ij),tdur2(30,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
!   transits and occultations of body 10
!
   IF(nbody < 10)RETURN
!
   icount=0
   DO ij=1,ncycle(31)
      IF(ABS(tseps(31,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC10tran1time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC10tran1time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(31)
         IF(ABS(tseps(31,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(31,ij),eb,tseps(31,ij),tdur1(31,ij),tdur2(31,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(32)
      IF(ABS(tseps(32,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC1occul10time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC1occul10time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(32)
         IF(ABS(tseps(32,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(32,ij),eb,tseps(32,ij),tdur1(32,ij),tdur2(32,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(33)
      IF(ABS(tseps(33,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC10tran2time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC10tran2time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(33)
         IF(ABS(tseps(33,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(33,ij),eb,tseps(33,ij),tdur1(33,ij),tdur2(33,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
   icount=0
   DO ij=1,ncycle(34)
      IF(ABS(tseps(34,ij)) <= 1.0_dp)icount=icount+1
   END DO
!
   IF(icount > 0)THEN
      IF(iflag == 0)THEN
         OPEN(UNIT=20,FILE='ELC2occul10time.dat',STATUS='unknown')
      ELSE
         OPEN(UNIT=20,FILE='ELC2occul10time.dat',STATUS='old',POSITION='append')
      END IF
      DO ij=1,ncycle(34)
         IF(ABS(tseps(34,ij)) <= 1.0_dp)THEN
            WRITE(20,10)ij,ttimes(34,ij),eb,tseps(34,ij),tdur1(34,ij),tdur2(34,ij)
         END IF
      END DO
      CLOSE(20)
   END IF
!
10 FORMAT(i5,2X,f20.12,2X,f3.1,2X,f16.12,3X,2(f20.12,1X))
!
   RETURN
!
END SUBROUTINE writeeclipse
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE writeinput(nalph1,nbet1,nalph2,nbet2,fill1,fill2,  &
   omega1,omega2,dphase,q,finc,teff1,teff2,tgrav1,tgrav2,  &
   betarim,rinner,router,tdisk,xi,ntheta,nradius,alb1,alb2,nref,  &
   rlx,period,fm,separ,gamma,t3,g3,sa3,density,sw1,sw2,sw3,t0,  &
   idraw,iecheck,iidint,iatm,ism1,icnu,icnb,icnv,icnr,icni,icnj,  &
   icnh,icnk,irvfilt,isw1,isw2,isw3,isw4,ilaw,wave,dbolx,dboly,  &
   dwavex,dwavey,ecc,argper,pshift,sw5,sw6,sw7,sw8,sw9,ikeep,  &
   isynch,isw5,isw6,isw7,isw8,isw9,spot1parm,spot2parm,  &
   spotdparm,primmass,primk,primrad,ratrad,frac1,frac2,ecosw,  &
   temprat,idark1,idark2,isw12,isw13,isw21,isw22,isw23,isw24,  &
   bigi,bigbeta,sw23,sw24,powercoeff,sw25,sw26,sw27,sw28,sw29,  &
   sw30,contam,tconj,beam1,beam2,isw25,isw26,isw27,isw28,isw29,  &
   isw30,isw31,isw32,isw33,isw34,ocose,osine,omegadot,contams0,  &
   contams1,contams2,contams3,sw47,sw48,sw49,sw80,sw81,sw82,  &
   sw83,sw84,sw85,sw86,sw87,sw88,sw89,isw80,isw81,isw82,isw83,  &
   isw84,isw85,isw86,isw87,isw88,isw89,sdarkint1,sdarkint2,  &
   sdarkint3,sdarkint4,sdarkint5)
!
!    will write the correctly formatted file ELC.inp and return
!    default parameters
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(OUT)                     :: nalph1
   INTEGER, INTENT(OUT)                     :: nbet1
   INTEGER, INTENT(OUT)                     :: nalph2
   INTEGER, INTENT(OUT)                     :: nbet2
   REAL(KIND=dp), INTENT(OUT)               :: fill1
   REAL(KIND=dp), INTENT(OUT)               :: fill2
   REAL(KIND=dp), INTENT(OUT)               :: omega1
   REAL(KIND=dp), INTENT(OUT)               :: omega2
   REAL(KIND=dp), INTENT(OUT)               :: dphase
   REAL(KIND=dp), INTENT(OUT)               :: q
   REAL(KIND=dp), INTENT(OUT)               :: finc
   REAL(KIND=dp), INTENT(OUT)               :: teff1
   REAL(KIND=dp), INTENT(OUT)               :: teff2
   REAL(KIND=dp), INTENT(OUT)               :: tgrav1
   REAL(KIND=dp), INTENT(OUT)               :: tgrav2
   REAL(KIND=dp), INTENT(OUT)               :: betarim
   REAL(KIND=dp), INTENT(OUT)               :: rinner
   REAL(KIND=dp), INTENT(OUT)               :: router
   REAL(KIND=dp), INTENT(OUT)               :: tdisk
   REAL(KIND=dp), INTENT(OUT)               :: xi
   INTEGER, INTENT(OUT)                     :: ntheta
   INTEGER, INTENT(OUT)                     :: nradius
   REAL(KIND=dp), INTENT(OUT)               :: alb1
   REAL(KIND=dp), INTENT(OUT)               :: alb2
   INTEGER, INTENT(OUT)                     :: nref
   REAL(KIND=dp), INTENT(OUT)               :: rlx
   REAL(KIND=dp), INTENT(OUT)               :: period
   REAL(KIND=dp), INTENT(OUT)               :: fm
   REAL(KIND=dp), INTENT(OUT)               :: separ
   REAL(KIND=dp), INTENT(OUT)               :: gamma
   REAL(KIND=dp), INTENT(OUT)               :: t3
   REAL(KIND=dp), INTENT(OUT)               :: g3
   REAL(KIND=dp), INTENT(OUT)               :: sa3
   REAL(KIND=dp), INTENT(OUT)               :: density
   REAL(KIND=dp), INTENT(OUT)               :: sw1
   REAL(KIND=dp), INTENT(OUT)               :: sw2
   REAL(KIND=dp), INTENT(OUT)               :: sw3
   REAL(KIND=dp), INTENT(OUT)               :: t0
   INTEGER, INTENT(OUT)                     :: idraw
   INTEGER, INTENT(OUT)                     :: iecheck
   INTEGER, INTENT(OUT)                     :: iidint
   INTEGER, INTENT(OUT)                     :: iatm
   INTEGER, INTENT(OUT)                     :: ism1
   INTEGER, INTENT(OUT)                     :: icnu
   INTEGER, INTENT(OUT)                     :: icnb
   INTEGER, INTENT(OUT)                     :: icnv
   INTEGER, INTENT(OUT)                     :: icnr
   INTEGER, INTENT(OUT)                     :: icni
   INTEGER, INTENT(OUT)                     :: icnj
   INTEGER, INTENT(OUT)                     :: icnh
   INTEGER, INTENT(OUT)                     :: icnk
   INTEGER, INTENT(OUT)                     :: irvfilt
   INTEGER, INTENT(OUT)                     :: isw1
   INTEGER, INTENT(OUT)                     :: isw2
   INTEGER, INTENT(OUT)                     :: isw3
   INTEGER, INTENT(OUT)                     :: isw4
   INTEGER, INTENT(OUT)                     :: ilaw
   REAL(KIND=dp), INTENT(OUT)               :: wave(8)
   REAL(KIND=dp), INTENT(OUT)               :: dbolx(8,2)
   REAL(KIND=dp), INTENT(OUT)               :: dboly(8,2)
   REAL(KIND=dp), INTENT(OUT)               :: dwavex(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: dwavey(8,10)
   REAL(KIND=dp), INTENT(OUT)               :: ecc
   REAL(KIND=dp), INTENT(OUT)               :: argper
   REAL(KIND=dp), INTENT(OUT)               :: pshift
   REAL(KIND=dp), INTENT(OUT)               :: sw5
   REAL(KIND=dp), INTENT(OUT)               :: sw6
   REAL(KIND=dp), INTENT(OUT)               :: sw7
   REAL(KIND=dp), INTENT(OUT)               :: sw8
   REAL(KIND=dp), INTENT(OUT)               :: sw9
   INTEGER, INTENT(OUT)                     :: ikeep
   INTEGER, INTENT(OUT)                     :: isynch
   INTEGER, INTENT(OUT)                     :: isw5
   INTEGER, INTENT(OUT)                     :: isw6
   INTEGER, INTENT(OUT)                     :: isw7
   INTEGER, INTENT(OUT)                     :: isw8
   INTEGER, INTENT(OUT)                     :: isw9
   REAL(KIND=dp), INTENT(OUT)               :: spot1parm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: spot2parm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: spotdparm(2,4)
   REAL(KIND=dp), INTENT(OUT)               :: primmass
   REAL(KIND=dp), INTENT(OUT)               :: primk
   REAL(KIND=dp), INTENT(OUT)               :: primrad
   REAL(KIND=dp), INTENT(OUT)               :: ratrad
   REAL(KIND=dp), INTENT(OUT)               :: frac1
   REAL(KIND=dp), INTENT(OUT)               :: frac2
   REAL(KIND=dp), INTENT(OUT)               :: ecosw
   REAL(KIND=dp), INTENT(OUT)               :: temprat
   INTEGER, INTENT(OUT)                     :: idark1
   INTEGER, INTENT(OUT)                     :: idark2
   INTEGER, INTENT(OUT)                     :: isw12
   INTEGER, INTENT(OUT)                     :: isw13
   INTEGER, INTENT(OUT)                     :: isw21
   INTEGER, INTENT(OUT)                     :: isw22
   INTEGER, INTENT(OUT)                     :: isw23
   INTEGER, INTENT(OUT)                     :: isw24
   REAL(KIND=dp), INTENT(OUT)               :: bigi
   REAL(KIND=dp), INTENT(OUT)               :: bigbeta
   REAL(KIND=dp), INTENT(OUT)               :: sw23
   REAL(KIND=dp), INTENT(OUT)               :: sw24
   REAL(KIND=dp), INTENT(OUT)               :: powercoeff(8,9)
   REAL(KIND=dp), INTENT(OUT)               :: sw25
   REAL(KIND=dp), INTENT(OUT)               :: sw26
   REAL(KIND=dp), INTENT(OUT)               :: sw27
   REAL(KIND=dp), INTENT(OUT)               :: sw28
   REAL(KIND=dp), INTENT(OUT)               :: sw29
   REAL(KIND=dp), INTENT(OUT)               :: sw30
   REAL(KIND=dp), INTENT(OUT)               :: contam
   REAL(KIND=dp), INTENT(OUT)               :: tconj
   REAL(KIND=dp), INTENT(OUT)               :: beam1
   REAL(KIND=dp), INTENT(OUT)               :: beam2
   INTEGER, INTENT(OUT)                     :: isw25
   INTEGER, INTENT(OUT)                     :: isw26
   INTEGER, INTENT(OUT)                     :: isw27
   INTEGER, INTENT(OUT)                     :: isw28
   INTEGER, INTENT(OUT)                     :: isw29
   INTEGER, INTENT(OUT)                     :: isw30
   INTEGER, INTENT(OUT)                     :: isw31
   INTEGER, INTENT(OUT)                     :: isw32
   INTEGER, INTENT(OUT)                     :: isw33
   INTEGER, INTENT(OUT)                     :: isw34
   REAL(KIND=dp), INTENT(OUT)               :: ocose
   REAL(KIND=dp), INTENT(OUT)               :: osine
   REAL(KIND=dp), INTENT(OUT)               :: omegadot
   REAL(KIND=dp), INTENT(OUT)               :: contams0
   REAL(KIND=dp), INTENT(OUT)               :: contams1
   REAL(KIND=dp), INTENT(OUT)               :: contams2
   REAL(KIND=dp), INTENT(OUT)               :: contams3
   REAL(KIND=dp), INTENT(OUT)               :: sw47
   REAL(KIND=dp), INTENT(OUT)               :: sw48
   REAL(KIND=dp), INTENT(OUT)               :: sw49
   REAL(KIND=dp), INTENT(OUT)               :: sw80
   REAL(KIND=dp), INTENT(OUT)               :: sw81
   REAL(KIND=dp), INTENT(OUT)               :: sw82
   REAL(KIND=dp), INTENT(OUT)               :: sw83
   REAL(KIND=dp), INTENT(OUT)               :: sw84
   REAL(KIND=dp), INTENT(OUT)               :: sw85
   REAL(KIND=dp), INTENT(OUT)               :: sw86
   REAL(KIND=dp), INTENT(OUT)               :: sw87
   REAL(KIND=dp), INTENT(OUT)               :: sw88
   REAL(KIND=dp), INTENT(OUT)               :: sw89
   INTEGER, INTENT(OUT)                     :: isw80
   INTEGER, INTENT(OUT)                     :: isw81
   INTEGER, INTENT(OUT)                     :: isw82
   INTEGER, INTENT(OUT)                     :: isw83
   INTEGER, INTENT(OUT)                     :: isw84
   INTEGER, INTENT(OUT)                     :: isw85
   INTEGER, INTENT(OUT)                     :: isw86
   INTEGER, INTENT(OUT)                     :: isw87
   INTEGER, INTENT(OUT)                     :: isw88
   INTEGER, INTENT(OUT)                     :: isw89
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint1(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint2(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint3(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint4(8)
   REAL(KIND=dp), INTENT(OUT)               :: sdarkint5(8)
!
   REAL(KIND=dp)  ::  www(8)
!
   INTEGER :: j,kk,jj,kkk,i
!
   CHARACTER(LEN=1) :: bell
!
   DATA www/3600.0_dp,4500.0_dp,5550.0_dp,6700.0_dp,8700.0_dp, &
      12000.0_dp,16200.0_dp,22000.0_dp/
!
   bell=CHAR(7)
   WRITE(*,1720)bell
!
   nalph1=40
   nbet1=14
   nalph2=40
   nbet2=14
   fill1=1.00_dp
   fill2=0.005_dp
   omega1=1.0_dp
   omega2=1.0_dp
   dphase=3.0_dp
   q=2.0_dp
   finc=80.0_dp
   teff1=6500.0_dp
   teff2=6500.0_dp
   tgrav1=0.25_dp
   tgrav2=0.25_dp
   betarim=2.0_dp
   rinner=0.005_dp
   router=0.75_dp
   tdisk=30000.0_dp
   xi=-0.75_dp
   ntheta=90
   nradius=60
   alb1=1.0_dp
   alb2=1.0_dp
   nref=1
   rlx=0.001_dp
   period=2.62_dp
   fm=3.0_dp
   separ=5.0_dp
   gamma=50.0_dp
   idraw=0
   iecheck=1
   iidint=1
   iatm=0
   ism1=1
   isw2=0
   ilaw=1
   icnu=1
   icnb=1
   icnv=1
   icnr=1
   icni=1
   icnj=1
   icnh=1
   icnk=1
   t3=-5000.0_dp
   g3=-5.0_dp
   sa3=-0.1_dp
   density=0.0_dp
   sw1=0.0_dp
   sw2=0.0_dp
   sw3=0.0_dp
   t0=0.0_dp
   irvfilt=3
   isw1=0
   isw2=0
   isw3=0
   isw4=0
   isw5=0
   isw6=0
   isw7=0
   isw8=0
   isw9=0
   ikeep=0
   isynch=0
   ecc=0.0_dp
   argper=90.0_dp
   pshift=0.0_dp
   sw5=0.0_dp
   sw6=0.0_dp
   sw7=0.0_dp
   sw8=0.0_dp
   sw9=0.0_dp
   dwavex=0.6_dp
   dwavey=0.0_dp
   powercoeff=0.0_dp
!
   DO  i=1,8
      wave(i)=www(i)
      dbolx(i,1)=0.635_dp
      dbolx(i,2)=0.635_dp
      dboly(i,1)=0.242_dp
      dboly(i,2)=0.242_dp
   END DO
!
   DO  i=1,4
      DO  j=1,2
         spot1parm(j,i)=-1.0_dp
         spot2parm(j,i)=-1.0_dp
         spotdparm(j,i)=-1.0_dp
      END DO
   END DO
!
   primmass=0.0_dp
   primk=0.0_dp
   primrad=0.0_dp
   ratrad=0.0_dp
   frac1=0.0_dp
   frac2=0.0_dp
   ecosw=0.0_dp
   temprat=0.0_dp
   idark1=0
   idark2=0
   isw12=0
   isw13=0
   isw21=0
   isw22=0
   isw23=0
   isw24=0
   bigi=0.0_dp
   bigbeta=0.0_dp
   sw23=0.0_dp
   sw24=0.0_dp
   sw25=0.0_dp
   sw26=0.0_dp
   sw27=0.0_dp
   sw28=0.0_dp
   sw29=0.0_dp
   sw30=0.0_dp
   contam=0.0_dp
   tconj=0.0_dp
   beam1=0.0_dp
   beam2=0.0_dp
   isw25=0
   isw26=0
   isw27=0
   isw28=0
   isw29=0
   isw30=0
   isw31=0
   isw32=0
   isw33=0
   isw34=0
   ocose=0.0_dp
   osine=0.0_dp
   omegadot=0.0_dp
   contams0=0.0_dp
   contams1=0.0_dp
   contams2=0.0_dp
   contams3=0.0_dp
   sw47=0.0_dp
   sw48=0.0_dp
   sw49=0.0_dp
   isw80=0
   isw81=0
   isw82=0
   isw83=0
   isw84=0
   isw85=0
   isw86=0
   isw87=0
   isw88=0
   isw89=0
   sw80=0.0_dp
   sw81=0.0_dp
   sw82=4.5_dp
   sw83=4.5_dp
   sw84=0.0_dp
   sw85=0.0_dp
   sw86=0.0_dp
   sw87=0.0_dp
   sw88=0.0_dp
   sw89=0.0_dp
!
   DO kk=1,8
      sdarkint1(kk)=0.0_dp
      sdarkint2(kk)=0.0_dp
      sdarkint3(kk)=0.0_dp
      sdarkint4(kk)=0.0_dp
      sdarkint5(kk)=0.0_dp
   END DO
!
   OPEN(UNIT=1,FILE='ELC.inp',STATUS='unknown')
!
   WRITE(1,60)nalph1
   WRITE(1,70)nbet1
   WRITE(1,80)nalph2
   WRITE(1,90)nbet2
   WRITE(1,100)fill1
   WRITE(1,110)fill2
   WRITE(1,120)omega1
   WRITE(1,130)omega2
   WRITE(1,140)dphase
   WRITE(1,150)q
   WRITE(1,160)finc
   WRITE(1,170)teff1
   WRITE(1,180)teff2
   WRITE(1,190)tgrav1
   WRITE(1,200)tgrav2
   WRITE(1,210)betarim
   WRITE(1,220)rinner
   WRITE(1,230)router
   WRITE(1,240)tdisk
   WRITE(1,250)xi
   WRITE(1,260)ntheta
   WRITE(1,270)nradius
   WRITE(1,280)alb1
   WRITE(1,290)alb2
   WRITE(1,300)nref
   WRITE(1,310)rlx
   WRITE(1,320)period
   WRITE(1,330)fm
   WRITE(1,340)separ
   WRITE(1,350)gamma
   WRITE(1,360)t3
   WRITE(1,370)g3
   WRITE(1,380)sa3
   WRITE(1,390)density
   WRITE(1,400)sw1
   WRITE(1,410)sw2
   WRITE(1,420)sw3
   WRITE(1,430)t0
   WRITE(1,440)idraw
   WRITE(1,450)iecheck
   WRITE(1,460)iidint
   WRITE(1,470)iatm
   WRITE(1,480)ism1
   WRITE(1,490)icnu,icnb,icnv,icnr,icni,icnj,icnh,icnk
   WRITE(1,500)irvfilt
   WRITE(1,510)isw1
   WRITE(1,520)isw2
   WRITE(1,530)isw3
   WRITE(1,540)isw4
   WRITE(1,550)ilaw
!
   DO  i=1,8
      WRITE(1,560)wave(i),dbolx(i,1),dboly(i,1),dbolx(i,2),  &
         dboly(i,2),dwavex(i,1),dwavey(i,1),dwavex(i,2),dwavey(i,2)
   END DO
!
   WRITE(1,570)ecc
   WRITE(1,580)argper
   WRITE(1,590)pshift
   WRITE(1,600)sw5
   WRITE(1,610)sw6
   WRITE(1,620)sw7
   WRITE(1,630)sw8
   WRITE(1,640)sw9
   WRITE(1,650)ikeep
   WRITE(1,660)isynch
   WRITE(1,670)isw5
   WRITE(1,680)isw6
   WRITE(1,690)isw7
   WRITE(1,700)isw8
   WRITE(1,710)isw9
   WRITE(1,720)spot1parm(1,1)
   WRITE(1,730)spot1parm(1,2)
   WRITE(1,740)spot1parm(1,3)
   WRITE(1,750)spot1parm(1,4)
   WRITE(1,760)spot1parm(2,1)
   WRITE(1,770)spot1parm(2,2)
   WRITE(1,780)spot1parm(2,3)
   WRITE(1,790)spot1parm(2,4)
   WRITE(1,800)spot2parm(1,1)
   WRITE(1,810)spot2parm(1,2)
   WRITE(1,820)spot2parm(1,3)
   WRITE(1,830)spot2parm(1,4)
   WRITE(1,840)spot2parm(2,1)
   WRITE(1,850)spot2parm(2,2)
   WRITE(1,860)spot2parm(2,3)
   WRITE(1,870)spot2parm(2,4)
   WRITE(1,880)spotdparm(1,1)
   WRITE(1,890)spotdparm(1,2)
   WRITE(1,900)spotdparm(1,3)
   WRITE(1,910)spotdparm(1,4)
   WRITE(1,920)spotdparm(2,1)
   WRITE(1,930)spotdparm(2,2)
   WRITE(1,940)spotdparm(2,3)
   WRITE(1,950)spotdparm(2,4)
   WRITE(1,960)primmass
   WRITE(1,970)primk
   WRITE(1,980)primrad
   WRITE(1,990)ratrad
   WRITE(1,1000)frac1
   WRITE(1,1010)frac2
   WRITE(1,1020)ecosw
   WRITE(1,1030)temprat
   WRITE(1,1040)idark1
   WRITE(1,1050)idark2
   WRITE(1,1060)isw12
   WRITE(1,1070)isw13
   WRITE(1,1080)isw21
   WRITE(1,1090)isw22
   WRITE(1,1100)isw23
   WRITE(1,1110)isw24
!
   DO  kk=1,8
      WRITE(1,1120)(powercoeff(kk,jj),jj=1,9)
   END DO
!
   WRITE(1,1130)bigi
   WRITE(1,1140)bigbeta
   WRITE(1,1150)sw23
   WRITE(1,1160)sw24
   WRITE(1,1170)sw25
   WRITE(1,1180)sw26
   WRITE(1,1190)sw27
   WRITE(1,1200)sw28
   WRITE(1,1210)sw29
   WRITE(1,1220)sw30
   WRITE(1,1230)contam
   WRITE(1,1240)tconj
   WRITE(1,1250)beam1
   WRITE(1,1260)beam2
   WRITE(1,1270)isw25
   WRITE(1,1280)isw26
   WRITE(1,1290)isw27
   WRITE(1,1300)isw28
   WRITE(1,1310)isw29
   WRITE(1,1320)isw30
   WRITE(1,1330)isw31
   WRITE(1,1340)isw32
   WRITE(1,1350)isw33
   WRITE(1,1360)isw34
   WRITE(1,1370)ocose
   WRITE(1,1380)osine
   WRITE(1,1390)omegadot
   WRITE(1,1400)contams0
   WRITE(1,1410)contams1
   WRITE(1,1420)contams2
   WRITE(1,1430)contams3
   WRITE(1,1440)sw47
   WRITE(1,1450)sw48
   WRITE(1,1460)sw49
   WRITE(1,1520)sw80
   WRITE(1,1530)sw81
   WRITE(1,1540)sw82
   WRITE(1,1550)sw83
   WRITE(1,1560)sw84
   WRITE(1,1570)sw85
   WRITE(1,1580)sw86
   WRITE(1,1590)sw87
   WRITE(1,1600)sw88
   WRITE(1,1610)sw89
   WRITE(1,1470)(sdarkint1(kkk),kkk=1,8)
   WRITE(1,1480)(sdarkint2(kkk),kkk=1,8)
   WRITE(1,1490)(sdarkint3(kkk),kkk=1,8)
   WRITE(1,1500)(sdarkint4(kkk),kkk=1,8)
   WRITE(1,1510)(sdarkint5(kkk),kkk=1,8)
   WRITE(1,1620)isw80
   WRITE(1,1630)isw81
   WRITE(1,1640)isw82
   WRITE(1,1650)isw83
   WRITE(1,1660)isw84
   WRITE(1,1670)isw85
   WRITE(1,1680)isw86
   WRITE(1,1690)isw87
   WRITE(1,1700)isw88
   WRITE(1,1710)isw89
!
   CLOSE(1)
!
60 FORMAT(i2,18X,'Nalph1')
70 FORMAT(i2,18X,'Nbet1')
80 FORMAT(i2,18X,'Nalph2')
90 FORMAT(i2,18X,'Nbet2')
100 FORMAT(f7.4,13X,'fill1')
110 FORMAT(f7.4,13X,'fill2')
120 FORMAT(f7.2,13X,'omega1')
130 FORMAT(f7.2,13X,'omega2')
140 FORMAT(f5.2,15X,'dphase')
150 FORMAT(f5.2,15X,'Q')
160 FORMAT(f5.2,15X,'finc')
170 FORMAT(f6.1,14X,'Teff1')
180 FORMAT(f6.1,14X,'Teff2')
190 FORMAT(f5.2,15X,'Tgrav1')
200 FORMAT(f5.2,15X,'Tgrav2')
210 FORMAT(f5.2,15X,'betarim')
220 FORMAT(f6.3,14X,'rinner')
230 FORMAT(f5.2,15X,'router')
240 FORMAT(f7.1,13X,'tdisk')
250 FORMAT(f7.4,13X,'xi')
260 FORMAT(i3,17X,'Ntheta')
270 FORMAT(i3,17X,'Nradius')
280 FORMAT(f7.4,13X,'alb1')
290 FORMAT(f7.4,13X,'alb2')
300 FORMAT(i1,19X,'Nref')
310 FORMAT(f10.5,10X,'log10(Lx)')
320 FORMAT(f9.6,11X,'Period')
330 FORMAT(f6.3,14X,'fm')
340 FORMAT(f6.3,14X,'separ')
350 FORMAT(f7.2,13X,'gamma velocity (km/sec)')
360 FORMAT(f10.2,10X,'t3')
370 FORMAT(f5.2,15X,'g3')
380 FORMAT(f12.6,8X,'SA3')
390 FORMAT(f12.6,8X,'density in g/cc')
400 FORMAT(f12.6,8X,'onephase')
410 FORMAT(f12.6,8X,'usepot1')
420 FORMAT(f12.6,8X,'usepot2')
430 FORMAT(f12.6,8X,'T0')
440 FORMAT(i1,19X,'idraw')
450 FORMAT(i1,19X,'iecheck')
460 FORMAT(i1,19X,'iidint')
470 FORMAT(i1,19X,'iatm  (0 for BB, 1 for model atmospheres)')
480 FORMAT(i1,19X,'ism1  (0 for all phases, 1 for 0-180)')
490 FORMAT(8(i1,1X),4X,'icnU,icnB,icnV,icnR,icnI,icnJ,icnH,icnK')
500 FORMAT(i1,19X,'iRVfilt')
510 FORMAT(i1,19X,'ionephase')
520 FORMAT(i1,19X,'isquare')
530 FORMAT(i1,19X,'iusepot')
540 FORMAT(i1,19X,'ifixgamma')
550 FORMAT(i2,18X,'ilaw  (1=linear law, 2=logarithmic law,',' 3=s'  &
      ,'quare root law, 4=quad law, >10 for power',' series)')
560 FORMAT(f7.1,3X,8(f7.4,1X))
570 FORMAT(f11.8,9X,'eccentricity')
580 FORMAT(f13.8,7X,'argument of peristron in degrees')
590 FORMAT(f11.8,9X,'pshift')
600 FORMAT(f12.6,8X,'asini (projected semimajor axis in seconds)')
610 FORMAT(f12.6,8X,'median fit (geneticELC only)')
620 FORMAT(f12.6,8X,'sw7 (phase range when sw8>sw7>0)')
630 FORMAT(f12.6,8X,'sw8 (phase range when sw8>sw7>0)')
640 FORMAT(f12.6,8X,'time step when itime=2')
650 FORMAT(i1,19X,'ikeep (1 to put eclipse at phase 0.0)')
660 FORMAT(i1,19X,'isynch (1 to keep rotation synchronous',' at p'  &
      ,'eriastron)')
670 FORMAT(i1,19X,'ispotprof')
680 FORMAT(i1,19X,'igrav')
690 FORMAT(i1,19X,'itime')
700 FORMAT(i6,14X,'MonteCarlo (0 for interpolation, >10 ','for Mo'  &
      ,'nte Carlo)')
710 FORMAT(i6,14X,'ielite')
720 FORMAT(f10.7,10X,'Temperature factor spot 1, star 1')
730 FORMAT(f11.7,9X,'Latitude of spot 1, star 1 (degrees)')
740 FORMAT(f11.7,9X,'Longitude of spot 1, star 1 (degrees)')
750 FORMAT(f11.7,9X,'Angular radius of spot 1, star 1 (degrees)')
760 FORMAT(f10.7,10X,'Temperature factor spot 2, star 1')
770 FORMAT(f11.7,9X,'Latitude of spot 2, star 1 (degrees)')
780 FORMAT(f11.7,9X,'Longitude of spot 2, star 1 (degrees)')
790 FORMAT(f11.7,9X,'Angular radius of spot 2, star 1 (degrees)')
800 FORMAT(f10.7,10X,'Temperature factor spot 1, star 2')
810 FORMAT(f11.7,9X,'Latitude of spot 1, star 2 (degrees)')
820 FORMAT(f11.7,9X,'Longitude of spot 1, star 2 (degrees)')
830 FORMAT(f11.7,9X,'Angular radius of spot 1, star 2 (degrees)')
840 FORMAT(f10.7,10X,'Temperature factor spot 2, star 2')
850 FORMAT(f11.7,9X,'Latitude of spot 2, star 2 (degrees)')
860 FORMAT(f11.7,9X,'Longitude of spot 2, star 2 (degrees)')
870 FORMAT(f11.7,9X,'Angular radius of spot 2, star 2 (degrees)')
880 FORMAT(f10.7,10X,'Temperature factor spot 1, disk')
890 FORMAT(f11.7,9X,'Azimuth of spot 1, disk (degrees)')
900 FORMAT(f11.7,9X,'Radial cutoff of spot 1, disk (0 <= r_cut <='  &
      ,'1)')
910 FORMAT(f11.7,9X,'Angular size of spot 1, disk (degrees)')
920 FORMAT(f10.7,10X,'Temperature factor spot 2, disk')
930 FORMAT(f11.7,9X,'Azimuth of spot 2, disk (degrees)')
940 FORMAT(f11.7,9X,'Radial cutoff of spot 2, disk (0 <= r_cut <='  &
      ,'1)')
950 FORMAT(f11.7,9X,'Angular size of spot 2, disk (degrees)')
960 FORMAT(f13.9,7X,'primmass (star 1 mass in solar masses)')
970 FORMAT(f14.9,6X,'primK (K-velocity of star 1 in km/sec)')
980 FORMAT(f14.9,6X,'primrad (star 1 radius in solar radii)')
990 FORMAT(f16.9,4X,'ratrad (ratio of star 1 radius and star 2 ra'  &
      ,'dius)')
1000 FORMAT(f5.2,15X,'frac1 (fractional radius star 1: R_1/a)')
1010 FORMAT(f5.2,15X,'frac2 (fractional radius star 2: R_2/a)')
1020 FORMAT(f12.9,8X,'ecosw (phase difference between eclipses)')
1030 FORMAT(f10.7,10X,'temprat (T_1/T_2)')
1040 FORMAT(i1,19X,'idark1')
1050 FORMAT(i1,19X,'idark2')
1060 FORMAT(i6,14X,'Npoly (0 for numerical)')
1070 FORMAT(i1,19X,'ifasttrans (>0 for fast transit mode)')
1080 FORMAT(i1,19X,'ialign (1 for rotation aligned with orbit)')
1090 FORMAT(i1,19X,'set to 1 to supress optimizer screen output')
1100 FORMAT(i1,19X,'iwriteeclipse (1 to fit for eclipse times)')
1110 FORMAT(i1,19X,'frac switch (>1 to enable ELCratio.???? files)' )
1120 FORMAT(9(f8.5,1X))
1130 FORMAT(f11.7,9X,'axis_I (inclination of rotation axis if ','i'  &
      ,'align=0)')
1140 FORMAT(f11.7,9X,'axis_beta (angle of rotation axis wrt to ',''  &
      ,'orbit if ialign=0)')
1150 FORMAT(f15.7,5X,'t_start')
1160 FORMAT(f15.7,5X,'t_end')
1170 FORMAT(f10.7,9X,'asini error')
1180 FORMAT(f11.8,9X,'reference phase for disk fraction')
1190 FORMAT(f11.8,9X,'radfill1 (set to use fill1 in terms of R_ef' ,'f')
1200 FORMAT(f11.8,9X,'radfill2 (set to use fill2 in terms of R_ef' ,'f')
1210 FORMAT(f10.4,10X,'bin size for light curves (minutes)')
1220 FORMAT(f10.4,10X,'bin size for RV curves (minutes)')
1230 FORMAT(f10.7,10X,'Kepler contamination')
1240 FORMAT(f15.8,5X,'Tconj')
1250 FORMAT(f5.2,15X,'beam1 (Doppler boost factor, star 1')
1260 FORMAT(f5.2,15X,'beam2 (Doppler boost factor, star 2)')
1270 FORMAT(i1,19X,'X-ray foreshortening switch',' (1 for point so'  &
      ,'urce)')
1280 FORMAT(i1,19X,'iGR (1 for GR, 2 for tidal, 3 for both)')
1290 FORMAT(i6,14X,'Nterms for fast analytic')
1300 FORMAT(i1,19X,'set to 1 to fit for Tconj')
1310 FORMAT(i1,19X,'set to 1 to fit for e*sin(omega), ','e*cos(ome'  &
      ,'ga)')
1320 FORMAT(i1,19X,'body 3 switch')
1330 FORMAT(i1,19X,'Ngap')
1340 FORMAT(i16,4X,'jdum (seed for markovELC, geneticELC, ','rando'  &
      ,'mELC)')
1350 FORMAT(i1,19X,'mandel  (0 for Gimenez, 1 for Mandel & Agol)')
1360 FORMAT(i1,19X,'Iseason (1 for seasonal Kepler contamination)')
1370 FORMAT(f12.8,8X,'e*cos(omega)')
1380 FORMAT(f12.8,8X,'e*sin(omega)')
1390 FORMAT(f12.8,8X,'omega_dot (degrees per year)')
1400 FORMAT(f12.8,8X,'contamS0 (season 0 contamination, tag s0)')
1410 FORMAT(f12.8,8X,'contamS1 (season 1 contamination, tag s1)')
1420 FORMAT(f12.8,8X,'contamS2 (season 2 contamination, tag s2)')
1430 FORMAT(f12.8,8X,'contamS3 (season 3 contamination, tag s3)')
1440 FORMAT(f16.8,4X,'Tref for dynamical integrator')
1450 FORMAT(f12.8,8X,'threshold to write chi^2')
1460 FORMAT(f13.9,7X,'Omega_bin ','(nodal angle of binary in degre'  &
      ,'es)')
1520 FORMAT(f10.4,10X,'Teff4       tag t4')
1530 FORMAT(f10.4,10X,'Teff5       tag t5')
1540 FORMAT(f7.4,13X,'g4')
1550 FORMAT(f7.4,13X,'g5')
1560 FORMAT(f12.2,8X,'chi^2 penalty for transit')
1570 FORMAT(f5.2,15X,'impact parameter threshold for ','eclipse ch'  &
      ,'ecking')
1580 FORMAT(f5.2,15X,'sw86 (currently inactive)')
1590 FORMAT(f5.2,15X,'sw87 (currently inactive)')
1600 FORMAT(f5.2,15X,'sw88 (currently inactive)')
1610 FORMAT(f5.2,15X,'sw89 (currently inactive)')
1620 FORMAT(i1,19X,'set to 1 for binary+binary mode (use',' body3 '  &
      ,'switch=4)')
1630 FORMAT(i1,19X,'set to 1 for transit penalty')
1640 FORMAT(i1,19X,'set to 1 to exclude body 3 eclipses')
1650 FORMAT(i1,19X,'set to 1 to exclude body 4 eclipses')
1660 FORMAT(i1,19X,'set to 1 to exclude body 5 eclipses')
1670 FORMAT(i1,19X,'set to 1 to exclude secondary eclipses')
1680 FORMAT(i1,19X,'set to 1 to use fluxes (needs Nterms>0)')
1690 FORMAT(i1,19X,'set to 1 for fast binning of Kepler models')
1700 FORMAT(i3,17X,'Ndynwin')
1710 FORMAT(i1,19X,'NSC')
1470 FORMAT(8(f11.7,1X),' fluxes for star 1')
1480 FORMAT(8(f11.7,1X),' fluxes for star 2')
1490 FORMAT(8(f11.7,1X),' fluxes for star 3')
1500 FORMAT(8(f11.7,1X),' fluxes for star 4')
1510 FORMAT(8(f11.7,1X),' fluxes for star 5')
1720 FORMAT(a1,'I can''T FIND THE FILE ''ELC.INP''!  I''M MAKING',  &
      ' one up and setting default values')
!
   RETURN
!
END SUBROUTINE writeinput
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE writepoints(ialphmax1,ibetmax1,nthetamax,nsky1,  &
   xsky1,ysky1,nsky2,xsky2,ysky2,nhoriz1,xhoriz1,yhoriz1,  &
   nhoriz2,xhoriz2,yhoriz2,nskydisk,xskydisk,yskydisk,zskydisk,  &
   ntop2,xtop2horiz,ytop2horiz,ndtop,dtopx,dtopy,ndhoriz,  &
   dxhoriz,dyhoriz,nskyedge,xskyedge,yskyedge,extension,separ,  &
   teff2,iidint,ialphmax2,ibetmax2,nsky3,xsky3,ysky3,  &
   nhoriz3,xhoriz3,yhoriz3)
!
!   November 18, 1999
!
!   This routine will simply write the x,y sky coordinates of all of the
!   components for use in quick plotting routines.  The horizons will contain
!   potentially eclipsed points, but all other coordinates should contain
!   only visible points.
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax1
   INTEGER, INTENT(IN)                      :: ibetmax1
   INTEGER, INTENT(IN)                      :: ialphmax2
   INTEGER, INTENT(IN)                      :: ibetmax2
   INTEGER, INTENT(IN)                      :: nthetamax
   INTEGER, INTENT(IN)                      :: nsky1
   REAL(KIND=dp), INTENT(IN)                :: xsky1(ialphmax1*ibetmax1*4)
   REAL(KIND=dp), INTENT(IN)                :: ysky1(ialphmax1*ibetmax1*4)
   INTEGER, INTENT(IN)                      :: nsky2
   REAL(KIND=dp), INTENT(IN)                :: xsky2(ialphmax2*ibetmax2*4)
   REAL(KIND=dp), INTENT(IN)                :: ysky2(ialphmax2*ibetmax2*4)
   INTEGER, INTENT(IN)                      :: nhoriz1
   REAL(KIND=dp), INTENT(IN)                :: xhoriz1(nhoriz1)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz1(nhoriz1)
   INTEGER, INTENT(IN)                      :: nhoriz2
   REAL(KIND=dp), INTENT(IN)                :: xhoriz2(nhoriz2)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz2(nhoriz2)
   INTEGER, INTENT(IN)                      :: nskydisk
   REAL(KIND=dp), INTENT(IN)                :: xskydisk(nskydisk)
   REAL(KIND=dp), INTENT(IN)                :: yskydisk(nskydisk)
   REAL(KIND=dp), INTENT(IN)                :: zskydisk(nskydisk)
   INTEGER, INTENT(IN)                      :: ntop2
   REAL(KIND=dp), INTENT(IN)                :: xtop2horiz(ntop2)
   REAL(KIND=dp), INTENT(IN)                :: ytop2horiz(ntop2)
   INTEGER, INTENT(IN)                      :: ndtop
   REAL(KIND=dp), INTENT(IN)                :: dtopx(2*nthetamax)
   REAL(KIND=dp), INTENT(IN)                :: dtopy(2*nthetamax)
   INTEGER, INTENT(IN)                      :: ndhoriz
   REAL(KIND=dp), INTENT(IN)                :: dxhoriz(ndhoriz)
   REAL(KIND=dp), INTENT(IN)                :: dyhoriz(ndhoriz)
   INTEGER, INTENT(IN)                      :: nskyedge
   REAL(KIND=dp), INTENT(IN)                :: xskyedge(nskyedge)
   REAL(KIND=dp), INTENT(IN)                :: yskyedge(nskyedge)
   CHARACTER (LEN=9), INTENT(IN)            :: extension
   REAL(KIND=dp), INTENT(IN)                :: separ
   REAL(KIND=dp), INTENT(IN)                :: teff2
   INTEGER, INTENT(IN)                      :: iidint
   INTEGER, INTENT(IN)                      :: nsky3
   REAL(KIND=dp), INTENT(IN)                :: xsky3(nsky3)
   REAL(KIND=dp), INTENT(IN)                :: ysky3(nsky3)
   INTEGER, INTENT(IN)                      :: nhoriz3
   REAL(KIND=dp), INTENT(IN)                :: xhoriz3(nhoriz3)
   REAL(KIND=dp), INTENT(IN)                :: yhoriz3(nhoriz3)
!
   INTEGER :: i
!
   IF(nsky1 > 0)THEN
      OPEN(UNIT=40,FILE='star1coo.'//extension,STATUS='unknown')
      DO  i=1,nsky1
         WRITE(40,120)separ*xsky1(i),separ*ysky1(i)
      END DO
      CLOSE(40)
!
      OPEN(UNIT=40,FILE='star1horiz.'//extension,STATUS='unknown')
      DO  i=1,nhoriz1
         WRITE(40,120)separ*xhoriz1(i),separ*yhoriz1(i)
      END DO
      CLOSE(40)
!
!   endif Nsky1
!
   END IF
!
   IF(nsky3 > 0)THEN
      OPEN(UNIT=40,FILE='star3coo.'//extension,STATUS='unknown')
      DO  i=1,nsky3
         WRITE(40,120)separ*xsky3(i),separ*ysky3(i)
      END DO
      CLOSE(40)
!
      OPEN(UNIT=40,FILE='star3horiz.'//extension,STATUS='unknown')
      DO  i=1,nhoriz3
         WRITE(40,120)separ*xhoriz3(i),separ*yhoriz3(i)
      END DO
      CLOSE(40)
!
!   endif Nsky3
!
   END IF
!
   IF(nsky2 > 0)THEN
      IF(teff2 > 0.0_dp)THEN
         OPEN(UNIT=40,FILE='star2coo.'//extension,STATUS='unknown')
         DO  i=1,nsky2
            WRITE(40,120)separ*xsky2(i),separ*ysky2(i)
         END DO
         CLOSE(40)
!
         OPEN(UNIT=40,FILE='star2horiz.'//extension,STATUS='unknown')
         DO  i=1,nhoriz2
            WRITE(40,120)separ*xhoriz2(i),separ*yhoriz2(i)
         END DO
         CLOSE(40)
!
         IF(iidint >= 1)THEN
            OPEN(UNIT=40,FILE='star2tophor.'//extension,STATUS='unknown')
            DO  i=1,ntop2
               WRITE(40,120)separ*xtop2horiz(i),separ*ytop2horiz(i)
            END DO
            CLOSE(40)
!
!    endif iidint > 0
!
         END IF
!
!     endif teff2 > 0
!
      END IF
!
!    endif Nsky2 > 0
!
   END IF
!
   IF(iidint > 0)THEN
      IF(nskydisk > 0)THEN
         OPEN(UNIT=40,FILE='diskcoo.'//extension,STATUS='unknown')
         DO  i=1,nskydisk
            WRITE(40,130)separ*xskydisk(i),separ*yskydisk(i),zskydisk(i)
         END DO
         CLOSE(40)
      END IF
!
      IF(nskyedge > 0)THEN
         OPEN(UNIT=40,FILE='diskedge.'//extension,STATUS='unknown')
         DO  i=1,nskyedge
            WRITE(40,120)separ*xskyedge(i),separ*yskyedge(i)
         END DO
         CLOSE(40)
      END IF
!
      IF(ndtop > 0)THEN
         OPEN(UNIT=40,FILE='disktophor.'//extension,STATUS='unknown')
         DO  i=1,ndtop
            WRITE(40,120)separ*dtopx(i),separ*dtopy(i)
         END DO
         CLOSE(40)
      END IF
!
      IF(ndhoriz > 0)THEN
         OPEN(UNIT=40,FILE='diskhoriz.'//extension,STATUS='unknown')
         DO  i=1,ndhoriz
            WRITE(40,120)separ*dxhoriz(i),separ*dyhoriz(i)
         END DO
         CLOSE(40)
      END IF
!
   END IF
!
120 FORMAT(2(f15.9,5X))
130 FORMAT(3(f15.9,5X))
!
   RETURN
!
END SUBROUTINE writepoints
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE writetempgrav(ialphmax,ibetmax,nalph,nbet,ibetlim,  &
   tarray,garray,gscale,istar,xx,yy,zz,mmdx,phistart,separ)
!
!   October 6, 2000
!
!   This subroutine will output the values of the temperature and
!   gravity in physical units [i.e. log(g) in cgs] for each array element.
!   It will also output the angles for use in simple contouring programs.
!
!   UPDATE June 7, 2002
!
!   Add the x, y, and z coordinate arrays to the argument of writetempgrav
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ialphmax
   INTEGER, INTENT(IN)                      :: ibetmax
   INTEGER, INTENT(IN)                      :: nalph
   INTEGER, INTENT(IN)                      :: nbet
   INTEGER, INTENT(IN)                      :: ibetlim(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: tarray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: garray(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: gscale
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: xx(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: yy(ialphmax*ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: zz(ialphmax*ibetmax)
   INTEGER, INTENT(IN)                      :: mmdx(ialphmax,ibetmax)
   REAL(KIND=dp), INTENT(IN)                :: phistart(ialphmax)
   REAL(KIND=dp), INTENT(IN)                :: separ
!
   REAL(KIND=dp)  :: phi,contheta,rrr,dtheta,dphi,grav,conphi,theta
!
   INTEGER :: ialf,ibet,iidx,iconbet
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   dtheta=pie/REAL(nalph,KIND=dp)
!
   IF(istar == 1)THEN
      OPEN(UNIT=27,FILE='star1tempgrav.dat',STATUS='unknown')
   ELSE
      OPEN(UNIT=27,FILE='star2tempgrav.dat',STATUS='unknown')
   END IF
!
   DO  ialf=1,nalph
      theta=-0.5_dp*dtheta+dtheta*REAL(ialf,KIND=dp)
      dphi=twopie/REAL(ibetlim(ialf),KIND=dp)
      DO  ibet=1,ibetlim(ialf)
!
!   UPDATE June 11, 2003
!
!   change the 2D arrays into 1D
!
!              iidx=(ialf-1)*ibetlim(ialf)+ibet
!              iidx=kount(ialphmax,ialf,ibetlim)+ibet
!
         iidx=mmdx(ialf,ibet)
         phi=-0.5_dp*dphi+dphi*REAL(ibet,KIND=dp)
         phi=phi+phistart(ialf)
         grav=LOG10(gscale*garray(iidx))
         conphi=phi
         IF(phi > pie)conphi=phi-twopie
         contheta=theta-halfpie
         IF(ibet <= 2*nbet)THEN
            iconbet=ibet+2*nbet
         ELSE
            iconbet=ibet-2*nbet
         END IF
!
!   UPDATE June 7, 2002
!
!   Add the x, y, and z coordinates to the write statement.  Modify
!   format statement 100 below (add 3(f7.4,1x) to the end).
!
         rrr=SQRT(xx(iidx)**2+yy(iidx)**2+zz(iidx)**2)
         rrr=rrr*separ
         WRITE(27,30)tarray(iidx),grav,theta,phi,ialf,ibet,  &
            contheta,conphi,ialf,iconbet,xx(iidx),yy(iidx), &
            zz(iidx),rrr
      END DO
   END DO
   CLOSE(27)
!
30 FORMAT(f12.5,1X,f8.5,1X,2(f8.6,1X),1X,2(i3,1X),1X,f8.5,2X,f8.  &
      5,2X,2(i3,1X),3(f7.4,1X),1X,f12.6)
!
   RETURN
!
END SUBROUTINE writetempgrav
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE writetex(nbody,ribcinp,dynpp,dynqq,rmass,tref,hh,isw80)
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: nbody
   REAL(KIND=dp), INTENT(IN)                :: ribcinp(10,6)
   REAL(KIND=dp), INTENT(IN)                :: dynpp(30)
   REAL(KIND=dp), INTENT(IN)                :: dynqq(30)
   REAL(KIND=dp), INTENT(IN)                :: rmass(10)
   REAL(KIND=dp), INTENT(IN)                :: tref
   REAL(KIND=dp), INTENT(IN)                :: hh
   INTEGER, INTENT(IN)                      :: isw80
!
   REAL(KIND=dp), DIMENSION(9)  :: p_arr,ecc_arr,a_arr,ma_arr,argper_arr
   REAL(KIND=dp), DIMENSION(9)  :: tconj_arr,f_arr,inc_arr,long_arr
   REAL(KIND=dp)  :: lambda1,lambda2
!
!   DIMENSION p_arr(9),ecc_arr(9),a_arr(9),ma_arr(9),argper_arr(9)
!   DIMENSION tconj_arr(9),f_arr(9),inc_arr(9),long_arr(9)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   IF((Nbody.eq.4).and.(isw80.ge.1))THEN
      CALL newcartkepbinbin(rmass,dynQQ,dynPP,Tref,p_arr, &
         ecc_arr,a_arr,MA_arr,ArgPer_arr,inc_arr,long_arr, &
         Tconj_arr,f_arr)
   ELSE
      CALL newcartkep(nbody,rmass,dynqq,dynpp,tref,p_arr,  &
         ecc_arr,a_arr,ma_arr,argper_arr,inc_arr,long_arr,  &
         tconj_arr,f_arr)
   END IF
!
   OPEN(UNIT=94,FILE='ELCdynamics.tex',STATUS='unknown')
!
   IF(nbody == 3)THEN
      WRITE(94,10)
      WRITE(94,20)
      WRITE(94,30)
      WRITE(94,40)
      WRITE(94,50)
      WRITE(94,60)
      WRITE(94,70)
      WRITE(94,80)
      WRITE(94,90)ribcinp(1,1),ribcinp(2,1)
      WRITE(94,100)ribcinp(1,2),ribcinp(2,2)
      WRITE(94,110)ribcinp(1,3),ribcinp(2,3)
      WRITE(94,120)ribcinp(1,4),ribcinp(2,4)
      WRITE(94,130)ribcinp(1,5),ribcinp(2,5)
      WRITE(94,140)ribcinp(1,6),ribcinp(2,6)
!
!   add on semimajor axis, e, arg.per, true anomaly, mean anomaly,
!   mean longitude, inclination in deg, Omega in deg
!
      WRITE(94,150)a_arr(1),a_arr(2)
      WRITE(94,160)ecc_arr(1),ecc_arr(2)
      WRITE(94,170)argper_arr(1)*radtodeg,argper_arr(2)*radtodeg
      WRITE(94,180)f_arr(1)*radtodeg,f_arr(2)*radtodeg
      WRITE(94,190)ma_arr(1)*radtodeg,ma_arr(2)*radtodeg
      lambda1=(argper_arr(1)+f_arr(1)+ribcinp(1,5))*radtodeg
      lambda2=(argper_arr(2)+f_arr(2)+ribcinp(2,5))*radtodeg
      WRITE(94,200)lambda1,lambda2
      WRITE(94,210)ribcinp(1,4)*radtodeg,ribcinp(2,4)*radtodeg
      WRITE(94,220)ribcinp(1,5)*radtodeg,ribcinp(2,5)*radtodeg
      WRITE(94,230)
      WRITE(94,240)
      WRITE(94,250)
      WRITE(94,260)rmass(1),rmass(2),rmass(3)
      WRITE(94,270)dynqq(1),dynqq(1+nbody),dynqq(1+2*nbody)
      WRITE(94,280)dynqq(2),dynqq(2+nbody),dynqq(2+2*nbody)
      WRITE(94,290)dynqq(3),dynqq(3+nbody),dynqq(3+2*nbody)
      WRITE(94,300)dynpp(1),dynpp(1+nbody),dynpp(1+2*nbody)
      WRITE(94,310)dynpp(2),dynpp(2+nbody),dynpp(2+2*nbody)
      WRITE(94,320)dynpp(3),dynpp(3+nbody),dynpp(3+2*nbody)
      WRITE(94,330)
      WRITE(94,340)tref,hh
      WRITE(94,350)
   END IF
!
   IF(nbody == 4)THEN
      WRITE(94,360)
      WRITE(94,370)
      WRITE(94,380)
      WRITE(94,390)
      WRITE(94,400)
      WRITE(94,410)
      WRITE(94,420)
      WRITE(94,430)
      WRITE(94,440)ribcinp(1,1),ribcinp(2,1),ribcinp(3,1)
      WRITE(94,450)ribcinp(1,2),ribcinp(2,2),ribcinp(3,2)
      WRITE(94,460)ribcinp(1,3),ribcinp(2,3),ribcinp(3,3)
      WRITE(94,470)ribcinp(1,4),ribcinp(2,4),ribcinp(3,4)
      WRITE(94,480)ribcinp(1,5),ribcinp(2,5),ribcinp(3,5)
      WRITE(94,490)ribcinp(1,6),ribcinp(2,6),ribcinp(3,6)
      WRITE(94,500)
      WRITE(94,510)
      WRITE(94,520)
      WRITE(94,530)rmass(1),rmass(2),rmass(3),rmass(4)
      WRITE(94,540)dynqq(1),dynqq(4),dynqq(7),dynqq(10)
      WRITE(94,550)dynqq(2),dynqq(5),dynqq(8),dynqq(11)
      WRITE(94,560)dynqq(3),dynqq(6),dynqq(9),dynqq(12)
      WRITE(94,570)dynpp(1),dynpp(4),dynpp(7),dynpp(10)
      WRITE(94,580)dynpp(2),dynpp(5),dynpp(8),dynpp(11)
      WRITE(94,590)dynpp(3),dynpp(6),dynpp(9),dynpp(12)
      WRITE(94,600)
      WRITE(94,610)tref,hh
      WRITE(94,620)
   END IF
!
   IF(nbody == 5)THEN
      WRITE(94,630)
      WRITE(94,640)
      WRITE(94,650)
      WRITE(94,660)
      WRITE(94,670)
      WRITE(94,680)
      WRITE(94,690)
      WRITE(94,700)
      WRITE(94,710)ribcinp(1,1),ribcinp(2,1),ribcinp(3,1),ribcinp(4,1)
      WRITE(94,720)ribcinp(1,2),ribcinp(2,2),ribcinp(3,2),ribcinp(4,2)
      WRITE(94,730)ribcinp(1,3),ribcinp(2,3),ribcinp(3,3),ribcinp(4,3)
      WRITE(94,740)ribcinp(1,4),ribcinp(2,4),ribcinp(3,4),ribcinp(4,4)
      WRITE(94,750)ribcinp(1,5),ribcinp(2,5),ribcinp(3,5),ribcinp(4,5)
      WRITE(94,760)ribcinp(1,6),ribcinp(2,6),ribcinp(3,6),ribcinp(4,6)
      WRITE(94,770)
      WRITE(94,780)
      WRITE(94,790)
      WRITE(94,800)rmass(1),rmass(2),rmass(3),rmass(4),rmass(5)
      WRITE(94,810)dynqq(1),dynqq(4),dynqq(7),dynqq(10),dynqq(13)
      WRITE(94,820)dynqq(2),dynqq(5),dynqq(8),dynqq(11),dynqq(14)
      WRITE(94,830)dynqq(3),dynqq(6),dynqq(9),dynqq(12),dynqq(15)
      WRITE(94,840)dynpp(1),dynpp(4),dynpp(7),dynpp(10),dynpp(13)
      WRITE(94,850)dynpp(2),dynpp(5),dynpp(8),dynpp(11),dynpp(14)
      WRITE(94,860)dynpp(3),dynpp(6),dynpp(9),dynpp(12),dynpp(15)
      WRITE(94,870)
      WRITE(94,880)tref,hh
      WRITE(94,890)
   END IF
!
10 FORMAT('\begin{deluxetable}{rrrr}')
20 FORMAT('\rotate')
30 FORMAT('\tablecolumns{4}')
40 FORMAT('\tabletypesize{\footnotesize}')
50 FORMAT('\tablecaption{Initial Dynamical Parameters','\tableno'  &
      ,'temark{a}}')
60 FORMAT('\tablewidth{0pt}')
70 FORMAT('\tablehead{  ',/'\colhead{parameter\tablenotemark{b}}'  &
      ,' & ',/'\colhead{orbit 1}   & ',/'\colhead{orbit 2}   & ',/ '\colhead{} }')
80 FORMAT('\startdata')
90 FORMAT('Period  (days)&','$',1PE24.17,'$',' & ','$',1PE24.17,  &
      '$',' & \cr ')
100 FORMAT('$e\cos\omega$ &','$',1PE24.17,'$',' & ','$',1PE24.17,  &
      '$',' & \cr ')
110 FORMAT('$e\sin\omega$ &','$',1PE24.17,'$',' & ','$',1PE24.17,  &
      '$',' & \cr ')
120 FORMAT('$i$  (rad) &','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & \cr ')
130 FORMAT('$\Omega$  (rad) &','$',1PE24.17,'$',' & ','$',1PE24.  &
      17,'$',' & \cr ')
140 FORMAT('$T_{\rm conj}$  (days)\tablenotemark{c} &','$',1PE24.  &
      17,'$',' & ','$',1PE24.17,'$',' & \cr ')
150 FORMAT('$a$  (AU) &','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & \cr ')
160 FORMAT('$e$     &','$',1PE24.17,'$',' & ','$',1PE24.17,'$',' '  &
      ,'& \cr ')
170 FORMAT('$\omega$  (deg) &','$',1PE24.17,'$',' & ','$',1PE24.  &
      17,'$',' & \cr ')
180 FORMAT('true anomaly  (deg) &','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & \cr ')
190 FORMAT('mean anomaly  (deg) &','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & \cr ')
200 FORMAT('mean longitude  (deg) &','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & \cr ')
210 FORMAT('$i$  (deg) &','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & \cr ')
220 FORMAT('$\Omega$  (deg) &','$',1PE24.17,'$',' & ','$',1PE24.  &
      17,'$',' & \cr ')
230 FORMAT('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
240 FORMAT('\multicolumn{1}{c}{parameter\tablenotemark{d}} & ', &
      '\multicolumn{1}{c}{body 1} & ',/'\multicolumn{1}{c}',  &
      '{body',' 2}',' & ','\multicolumn{1}{c}{body 3} \cr')
250 FORMAT('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
260 FORMAT('Mass ($M_{\odot}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' \cr ')
270 FORMAT('$x$ (AU) & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & ','$',1PE24.17,'$',' \cr ')
280 FORMAT('$y$ (AU) & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & ','$',1PE24.17,'$',' \cr ')
290 FORMAT('$z$ (AU) & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & ','$',1PE24.17,'$',' \cr ')
300 FORMAT('$v_x$ (AU day$^{-1}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' \cr ')
310 FORMAT('$v_y$ (AU day$^{-1}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' \cr ')
320 FORMAT('$v_z$ (AU day$^{-1}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' \cr ')
330 FORMAT('\enddata')
340 FORMAT('\tablenotetext{a}{Reference time = ',f15.5,','/'integ'  &
      ,'ration step size = ',f7.5,' days}',/'\tablenotetext{b}{Jac'  &
      ,'obian instantaneous (Keplerian) ','elements}',/'\tablenote'  &
      ,'text{c}{Times are relative to ','BJD 2,455,000.000}',/'\ta'  &
      ,'blenotetext{d}{Barycentric Cartesian coordinates}')
350 FORMAT('\end{deluxetable}')
360 FORMAT('\begin{deluxetable}{rrrrr}')
370 FORMAT('\rotate')
380 FORMAT('\tablecolumns{5}')
390 FORMAT('\tabletypesize{\scriptsize}')
400 FORMAT('\tablecaption{Initial Dynamical Parameters','\tableno'  &
      ,'temark{a}}')
410 FORMAT('\tablewidth{0pt}')
420 FORMAT('\tablehead{  ',/'\colhead{parameter\tablenotemark{b}}'  &
      ,' & ',/'\colhead{orbit 1}   & ',/'\colhead{orbit 2}   & ',/  &
      '\colhead{orbit 3}   & ',/'\colhead{} }')
430 FORMAT('\startdata')
440 FORMAT('Period  (days) &','$',1PE24.17,'$',' & ','$',1PE24.17,  &
      '$',' & ','$',1PE24.17,'$',' & \cr ')
450 FORMAT('$e\cos\omega$ &','$',1PE24.17,'$',' & ','$',1PE24.17,  &
      '$',' & ','$',1PE24.17,'$',' & \cr ')
460 FORMAT('$e\sin\omega$ &','$',1PE24.17,'$',' & ','$',1PE24.17,  &
      '$',' & ','$',1PE24.17,'$',' & \cr ')
470 FORMAT('$i$  (rad) &','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & ','$',1PE24.17,'$',' & \cr ')
480 FORMAT('$\Omega$  (rad) &','$',1PE24.17,'$',' & ','$',1PE24.  &
      17,'$',' & ','$',1PE24.17,'$',' & \cr ')
490 FORMAT('$T_{\rm conj}$  (days)\tablenotemark{c} &','$',1PE24.  &
      17,'$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',' & \cr' ,' ')
500 FORMAT('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
510 FORMAT('\multicolumn{1}{c}{parameter\tablenotemark{d}} & ',  &
      '\multicolumn{1}{c}{body 1} & ',/'\multicolumn{1}{c}{body 2}',  &
      ' & ','\multicolumn{1}{c}{body 3} & ',/'\multicolumn{1}{c}{' ,'body 4} \cr')
520 FORMAT('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
530 FORMAT('Mass ($M_{\odot}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$','' ,'  \cr ')
540 FORMAT('$x$ (AU) & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$','  \cr ')
550 FORMAT('$y$ (AU) & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$','  \cr ')
560 FORMAT('$z$ (AU) & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$','  \cr ')
570 FORMAT('$v_x$ (AU day$^{-1}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$','' ,'  \cr ')
580 FORMAT('$v_y$ (AU day$^{-1}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$','' ,'  \cr ')
590 FORMAT('$v_z$ (AU day$^{-1}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$','' ,'  \cr ')
600 FORMAT('\enddata')
610 FORMAT('\tablenotetext{a}{Reference time = ',f15.5,','/'integ'  &
      ,'ration step size = ',f7.5,' days}',/'\tablenotetext{b}{Jac'  &
      ,'obian instantaneous (Keplerian) ','elements}',/'\tablenote'  &
      ,'text{c}{Times are relative to ','BJD 2,455,000.000}',/'\ta'  &
      ,'blenotetext{d}{Barycentric Cartesian coordinates}')
620 FORMAT('\end{deluxetable}')
630 FORMAT('\begin{deluxetable}{rrrrrr}')
640 FORMAT('\rotate')
650 FORMAT('\tablecolumns{6}')
660 FORMAT('\tabletypesize{\scriptsize}')
670 FORMAT('\tablecaption{Initial Dynamical Parameters','\tableno'  &
      ,'temark{a}}')
680 FORMAT('\tablewidth{0pt}')
690 FORMAT('\tablehead{  ',/'\colhead{parameter\tablenotemark{b}}'  &
      ,' & ',/'\colhead{orbit 1}   & ',/'\colhead{orbit 2}   & ',/  &
      '\colhead{orbit 3}   & ',/'\colhead{orbit 4}   & ',/'\colhea' ,'d{} }')
700 FORMAT('\startdata')
710 FORMAT('Period  (days) &','$',1PE24.17,'$',' & ','$',1PE24.17,  &
      '$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',' & \cr ')
720 FORMAT('$e\cos\omega$ &','$',1PE24.17,'$',' & ','$',1PE24.17,  &
      '$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',' & \cr ')
730 FORMAT('$e\sin\omega$ &','$',1PE24.17,'$',' & ','$',1PE24.17,  &
      '$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',' & \cr ')
740 FORMAT('$i$  (rad) &','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',' & \cr ')
750 FORMAT('$\Omega$  (rad) &','$',1PE24.17,'$',' & ','$',1PE24.  &
      17,'$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',' & \cr' ,' ')
760 FORMAT('$T_{\rm conj}$  (days)\tablenotemark{c} &','$',1PE24.  &
      17,'$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',' & ',''  &
      ,'$',1PE24.17,'$',' & \cr ')
770 FORMAT('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
780 FORMAT('\multicolumn{1}{c}{parameter\tablenotemark{d}} & ',  &
      '\multicolumn{1}{c}{body 1} & ',/'\multicolumn{1}{c}{body 2}',  &
      ' & ','\multicolumn{1}{c}{body 3} & ',/'\multicolumn{1}{c}{',  &
      'body 4} & ',/'\multicolumn{1}{c}{body 5} \cr')
790 FORMAT('\noalign{\vskip 2mm}\hline\noalign{\vskip 2mm}')
800 FORMAT('Mass ($M_{\odot}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',''  &
      ,' & ','$',1PE24.17,'$','  \cr ')
810 FORMAT('$x$ (AU) & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$','  \cr ')
820 FORMAT('$y$ (AU) & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$','  \cr ')
830 FORMAT('$z$ (AU) & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',  &
      ' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$','  \cr ')
840 FORMAT('$v_x$ (AU day$^{-1}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',''  &
      ,' & ','$',1PE24.17,'$','  \cr ')
850 FORMAT('$v_y$ (AU day$^{-1}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',''  &
      ,' & ','$',1PE24.17,'$','  \cr ')
860 FORMAT('$v_z$ (AU day$^{-1}$) & ','$',1PE24.17,'$',' & ','$',  &
      1PE24.17,'$',' & ','$',1PE24.17,'$',' & ','$',1PE24.17,'$',''  &
      ,' & ','$',1PE24.17,'$','  \cr ')
870 FORMAT('\enddata')
880 FORMAT('\tablenotetext{a}{Reference time = ',f15.5,','/'integ'  &
      ,'ration step size = ',f7.5,' days}',/'\tablenotetext{b}{Jac'  &
      ,'obian instantaneous (Keplerian) ','elements}',/'\tablenote'  &
      ,'text{c}{Times are relative to ','BJD 2,455,000.000}',/'\ta'  &
      ,'blenotetext{d}{Barycentric Cartesian coordinates}')
890 FORMAT('\end{deluxetable}')
!
   CLOSE(94)
!
   RETURN
!
END SUBROUTINE writetex
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE wrvmod(icount,xmod,ymod,fileout,isw7,gamma)
!
!  February 29, 2012
!
!  This routine will open the output file and record the given model
!  with the RV.
!  The value of gamma will be added
!
   USE accur
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: icount
   REAL(KIND=dp), INTENT(IN)                :: xmod(icount)
   REAL(KIND=dp), INTENT(IN)                :: ymod(icount)
   CHARACTER (LEN=*), INTENT(IN)            :: fileout
   INTEGER, INTENT(IN)                      :: isw7
   REAL(KIND=dp), INTENT(IN)                :: gamma
!
   INTEGER :: i
!
   OPEN(UNIT=20,FILE=fileout,STATUS='unknown')
!
   DO  i=1,icount
      WRITE(20,30)xmod(i),ymod(i)+gamma
   END DO
!
   IF(isw7 >= 2)THEN
      CLOSE(20)
      RETURN
   END IF
   DO  i=1,icount
      WRITE(20,30)xmod(i)+1.0_dp,ymod(i)+gamma
   END DO
!
   CLOSE(20)
!
30 FORMAT(f23.15,3X,1PE21.14)
!
   RETURN
!
END SUBROUTINE wrvmod
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE xcircle(ifront,ct1,r1,iback,ct2,r2,arcn,arci)
!
!   Given the Front body (index iFront) with center
!   coordinates Ct1 and radius r1, and the back body (index iBack)
!   with center coordinates Ct2 and radius r2, this subroutine
!   will return the arcs ArcN and ArcI
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   INTEGER, INTENT(IN)                      :: ifront
   REAL(KIND=dp), INTENT(IN)                :: ct1(2)
   REAL(KIND=dp), INTENT(IN)                :: r1
   INTEGER, INTENT(IN)                      :: iback
   REAL(KIND=dp), INTENT(IN)                :: ct2(2)
   REAL(KIND=dp), INTENT(IN)                :: r2
   REAL(KIND=dp), INTENT(OUT)               :: arcn(5)
   REAL(KIND=dp), INTENT(OUT)               :: arci(5)
!
   REAL(KIND=dp), DIMENSION(2)   :: arcin,arcout
   REAL(KIND=dp)  :: distct,phi0,w,a,b,c,phi1,ang1,tiny
!
!   Constant needed to help with round-off errors when
!   limbs of two bodies touch.
!
!   IF(PRECISION(tiny).ge.18)THEN
!     tiny=3.0E-18_dp
!   ELSE
!     tiny=3.0E-15_dp
!   END IF
!
   tiny=10.0_dp*EPSILON(tiny)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   distct=SQRT((ct1(1)-ct2(1))**2+(ct1(2)-ct2(2))**2)
!
   IF(r1+r2-tiny <= distct)THEN
!
!   no eclipse event
!
      arcn(1)=-999.0_dp
      arcn(2)=-999.0_dp
      arcn(3)=-999.0_dp
      arcn(4)=-999.0_dp
      arcn(5)=-999.0_dp
      arci(1)=-999.0_dp
      arci(2)=-999.0_dp
      arci(3)=-999.0_dp
      arci(4)=-999.0_dp
      arci(5)=-999.0_dp
      RETURN
   END IF
!
   IF(distct+r1 <= r2-tiny)THEN
!
!   C1 contained within C2
!
      arcn(1)=-999.0_dp
      arcn(2)=-999.0_dp
      arcn(3)=-997.0_dp
      arcn(4)=-997.0_dp
      arcn(5)=-997.0_dp
      arci(1)=-999.0_dp
      arci(2)=-999.0_dp
      arci(3)=-997.0_dp
      arci(4)=-997.0_dp
      arci(5)=-997.0_dp
      RETURN
   END IF
!
   IF(distct+r2 <= r1+tiny)THEN
!
!   C1 contained within C2
!
      arcn(1)=-999.0_dp
      arcn(2)=-999.0_dp
      arcn(3)=-998.0_dp
      arcn(4)=-998.0_dp
      arcn(5)=-998.0_dp
      arci(1)=-999.0_dp
      arci(2)=-999.0_dp
      arci(3)=-998.0_dp
      arci(4)=-998.0_dp
      arci(5)=-998.0_dp
      RETURN
   END IF
!
   phi0=MOD(ATAN2(ct2(2)-ct1(2),ct2(1)-ct1(1)),twopie)
   IF(phi0 < 0.0_dp)phi0=phi0+twopie
   w=(r1*r1+distct*distct-r2*r2)/(2.0_dp*r1*distct)
!
!   Trap a rare round-off error using the tiny
!
   IF(w > 1.0_dp)w=w-tiny
   IF(w < -1.0_dp)w=w+tiny
   IF(ABS(w) <= 1.0_dp)THEN
      phi1=ACOS(w)
      arcin(1)=MOD(phi0-phi1,twopie)
      IF(arcin(1) < 0.0_dp)arcin(1)=arcin(1)+twopie
      arcin(2)=2.0_dp*phi1
      a=arcin(1)
      b=arcin(2)
      c=a+b
      arci(1)=REAL(iback,KIND=dp)
      arci(2)=REAL(ifront,KIND=dp)
      arci(3)=a
      arci(4)=c-a
      arci(5)=c
   ELSE
      WRITE(*,*)'Cosine Error1'
      RETURN
   END IF
   w=(r2*r2+distct*distct-r1*r1)/(2.0_dp*r2*distct)
!
!   Trap a rare round-off error using the tiny
!
   IF(w > 1.0_dp)w=w-tiny
   IF(w < -1.0_dp)w=w+tiny
!
   IF(ABS(w) <= 1.0_dp)THEN
      phi1=pie-ACOS(w)
      ang1=MOD(phi0-phi1,twopie)
      IF(ang1 < 0.0_dp)ang1=ang1+twopie
      arcout(1)=ang1
      arcout(2)=2.0_dp*phi1
      a=arcout(1)
      b=arcout(2)
      c=a+b
      arcn(1)=REAL(iback,KIND=dp)
      arcn(2)=REAL(iback,KIND=dp)
      arcn(3)=a
      arcn(4)=c-a
      arcn(5)=c
   ELSE
      WRITE(*,*)'Cosine Error2'
      RETURN
   END IF
!
   RETURN
!
END SUBROUTINE xcircle
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE xcomp(a,b,arc)
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: a
   REAL(KIND=dp), INTENT(IN)                :: b
   REAL(KIND=dp), INTENT(OUT)               :: arc(2)
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   IF(b >= twopie)THEN
      arc(1)=b-twopie
      arc(2)=a
   ELSE
      arc(1)=b
      arc(2)=twopie+a
   END IF
!
   RETURN
!
END SUBROUTINE xcomp
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE xsect(a,b,c,d,arc)
!
!   Compute the intersection of two arcs
!   [a,b] and [c,d].  Returns the result
!   in the interval [0,4pi)
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: a
   REAL(KIND=dp), INTENT(IN)                :: b
   REAL(KIND=dp), INTENT(IN)                :: c
   REAL(KIND=dp), INTENT(IN)                :: d
   REAL(KIND=dp), INTENT(OUT)               :: arc(2,2)
!
   REAL(KIND=dp)  :: aa,bb,cp,ddp,ap,bp,tiny
!
!   IF(PRECISION(tiny).ge.18)THEN
!     tiny=10.0_dp*0.108420E-18_dp
!   ELSE
!     tiny=5.0_dp*0.222045E-15_dp
!   END IF
!
   IF(dp == 8)THEN
     tiny=5.0_dp*EPSILON(tiny)
   ELSE
     tiny=10.0_dp*EPSILON(tiny)
   END IF
!
   arc(1,1)=-999.0_dp
   arc(1,2)=-999.0_dp
   arc(2,1)=-999.0_dp
   arc(2,2)=-999.0_dp
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   aa=(a+c+ABS(a-c))/2.0_dp
   bb=(b+d-ABS(b-d))/2.0_dp
   IF(aa < bb)THEN
      arc(1,1)=aa
      arc(1,2)=bb
   END IF
   IF(b > twopie)THEN
      cp=c+twopie
      ddp=d+twopie
      aa=(a+cp+ABS(a-cp))/2.0_dp
      bb=(b+ddp-ABS(b-ddp))/2.0_dp
      IF(aa < bb)THEN
         IF(arc(1,1) < -99.9_dp)THEN
            arc(1,1)=aa
            arc(1,2)=bb
         ELSE
            arc(2,1)=aa
            arc(2,2)=bb
         END IF
      END IF
   END IF
   IF(d > twopie)THEN
      ap=a+twopie
      bp=b+twopie
      aa=(ap+c+ABS(ap-c))/2.0_dp
      bb=(bp+d-ABS(bp-d))/2.0_dp
      IF(aa < bb)THEN
         IF(arc(1,1) < -99.9_dp)THEN
            arc(1,1)=aa
            arc(1,2)=bb
         ELSE
            arc(2,1)=aa
            arc(2,2)=bb
         END IF
      END IF
   END IF
!
!   if we have an "empty" arc then return
!
   IF(arc(1,1) <= -999.0_dp)THEN
!            c=csave
      RETURN
   END IF
!
!   modify the equality statement below
!
   IF(arc(2,1) > -999.9_dp)THEN
!
!      IF(arc(1,2) == arc(2,1))THEN
!
      IF(ABS(arc(1,2) - arc(2,1)) <= tiny)THEN
         arc(1,2)=arc(2,2)
         arc(2,1)=-999.0_dp
         arc(2,2)=-999.0_dp
      END IF
   END IF
!
   IF(arc(1,1) > twopie)THEN
      arc(1,1)=arc(1,1)-twopie
      arc(1,2)=arc(1,2)-twopie
   END IF
!
   IF(arc(2,1) > twopie)THEN
      arc(2,1)=arc(2,1)-twopie
      arc(2,2)=arc(2,2)-twopie
   END IF
!
   RETURN
!
END SUBROUTINE xsect
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE xsectall(list,path2i,n,pathi,indexlist,indexpath2i,  &
   indexpathi)
!
!   For each Arc in the List this routine computes
!   the intersection with all the arcs contained in
!   Path2i.  N is the List arc #.  These intersection
!   arcs are returned in PathI with the format
!   [List arc #, Path2i arc #, Begin, length, End]
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: list(27,5)
   REAL(KIND=dp), INTENT(IN)                :: path2i(27,5)
   INTEGER, INTENT(IN)                      :: n
   REAL(KIND=dp), INTENT(OUT)               :: pathi(27,5)
   INTEGER, INTENT(IN OUT)                  :: indexlist
   INTEGER, INTENT(IN OUT)                  :: indexpath2i
   INTEGER, INTENT(OUT)                     :: indexpathi
!
   REAL(KIND=dp), DIMENSION(27,5)  :: templist,temppath
   REAL(KIND=dp), DIMENSION(2,2)   :: arc
   REAL(KIND=dp)                   :: a,b,c,d
!
   INTEGER :: i,j,k,lentwoi,lenlist
   INTEGER :: indexlisttemp
!
!   Fill PathI with -999 to make it "empty"
!
   indexlisttemp=indexlist
   indexpathi=0
   DO i=1,27
      DO j=1,5
         pathi(i,j)=-999.0_dp
      END DO
   END DO
!
   DO i=1,indexlist
      DO j=1,5
         templist(i,j)=list(i,j)
      END DO
   END DO
!
   DO i=1,indexpath2i
      DO j=1,5
         temppath(i,j)=path2i(i,j)
      END DO
   END DO

!   the subroutine strippath takes the input array and
!   puts all of the "nonempty" rows at the top.  The row
!   number of the last nonempty row is returned as index.
!
   lentwoi=indexpath2i
   lenlist=indexlist
!
!   The variable List is declared real*8, so turn the
!   second column into an integer.
!
   i=nint(templist(1,2))
   j=1
   DO WHILE(j <= lenlist)
      c=templist(j,3)
      d=templist(j,5)
      DO k=1,lentwoi
         a=temppath(k,3)
         b=temppath(k,5)
!
!  Here Arc is a 2x2 matrix.
!
         CALL xsect(a,b,c,d,arc)
!
!  If Arc has -999.0 values, it is "empty"
!
         IF(arc(1,1) <= -999.0_dp)THEN
            c=-999.0_dp
            d=-999.0_dp
            GO TO 10
         END IF
!
!  If the second row of Arc has -999.0 values,
!  it has only one valid row, so length(Arc(:,1)) is 1
!
         IF(arc(2,1) <= -999.0_dp)THEN
            c=arc(1,1)
            d=arc(1,2)
         ELSE
            c=arc(1,1)
            d=arc(1,2)
!
!  "strip List" to find the row with the
!  last valid entry and add another row with
!  values N, i, Arc(2,1), Arc(2,2)-Arc(2,1), Arc(2,2)
!
            templist(indexlist+1,1)=REAL(n,KIND=dp)
            templist(indexlist+1,2)=REAL(i,KIND=dp)
            templist(indexlist+1,3)=arc(2,1)
            templist(indexlist+1,4)=arc(2,2)-arc(2,1)
            templist(indexlist+1,5)=arc(2,2)
            indexlist=indexlist+1
         END IF
!
!   end the k=1,LenTwoi loop
!
!10            CONTINUE
!
      END DO
!
!  If c has a value greater than -999.0, then it is not
!  "empty".  If nonempty, find the last valid row and
!  add another row with values N, i, c, d-c, d
!
      IF(c > -999.0_dp)THEN
!
         pathi(indexpathi+1,1)=REAL(n,KIND=dp)
         pathi(indexpathi+1,2)=REAL(i,KIND=dp)
         pathi(indexpathi+1,3)=c
         pathi(indexpathi+1,4)=d-c
         pathi(indexpathi+1,5)=d
         indexpathi=indexpathi+1
      END IF
10    j=j+1
!
      lenlist=indexlist
!
!   end the while loop
!
   END DO
!
   indexlist=indexlisttemp
!
   RETURN
!
END SUBROUTINE xsectall
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION xtran(xx,yy,phase,q,istar,bdist)
!
!   will return the coordinate of a point (xx,yy,zz) projected on the sky
!
!   (xx,yy,zz) refers to the coordinates in the rotating system
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: xx
   REAL(KIND=dp), INTENT(IN)                :: yy
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: q
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: bdist
!
   REAL(KIND=dp)  :: phaser, qphaser,overq,xtran
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   overq=q
   IF(istar == 2)overq=1.0_dp/q
   phaser=phase*degtorad
   qphaser=((phaser))
   xtran=-(xx*SIN(qphaser)+yy*COS(qphaser))+bdist*(overq/(1._dp  &
      +overq))*SIN(qphaser)
   RETURN
!
END FUNCTION xtran
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE xyztokep(tref,m1,m2,posx,posy,posz,velx,vely,velz,  &
   periodout,eccout,aout,mnanom,argperout,inclout,longout,  &
   trueout,tconjout)
!
!    Converts Cartesian x,y,z to Keplerian
!
   USE accur
   USE getpie
   USE constants
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: tref
   REAL(KIND=dp), INTENT(IN)                :: m1
   REAL(KIND=dp), INTENT(IN)                :: m2
   REAL(KIND=dp), INTENT(IN)                :: posx
   REAL(KIND=dp), INTENT(IN)                :: posy
   REAL(KIND=dp), INTENT(IN)                :: posz
   REAL(KIND=dp), INTENT(IN)                :: velx
   REAL(KIND=dp), INTENT(IN)                :: vely
   REAL(KIND=dp), INTENT(IN)                :: velz
   REAL(KIND=dp), INTENT(OUT)               :: periodout
   REAL(KIND=dp), INTENT(OUT)               :: eccout
   REAL(KIND=dp), INTENT(OUT)               :: aout
   REAL(KIND=dp), INTENT(OUT)               :: mnanom
   REAL(KIND=dp), INTENT(OUT)               :: argperout
   REAL(KIND=dp), INTENT(OUT)               :: inclout
   REAL(KIND=dp), INTENT(OUT)               :: longout
   REAL(KIND=dp), INTENT(OUT)               :: trueout
   REAL(KIND=dp), INTENT(OUT)               :: tconjout
!
   REAL(KIND=dp)  :: m,trueatomeana,fmod,angmx,angmy,angmz,lenam,lenpos
   REAL(KIND=dp)  :: lenvel,mu,p,c,cwf,swf,wf,f,e,aa,bb
!
!  Get the constants.
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!   CALL constants(earthmasstosolar,auinsolarrad,solarrad,gmsun,  &
!      coeff,solarmass,secinday,speedlightkm,speedlightm,gsun,  &
!      gnewton,gnewtoncgs,stefan,g,auperdaytompersec,au,  &
!      speedauperday,earthradinsolar,earthcm,earthgram,daysinyear)
!
   mu=g*(m1+m2)
!
!   Find the direction of the angular momentum
!   vector.
!
   angmx=posy*velz-posz*vely
   angmy=posz*velx-posx*velz
   angmz=posx*vely-posy*velx
   lenam=SQRT(angmx**2+angmy**2+angmz**2)
   lenpos=SQRT(posx**2+posy**2+posz**2)
   lenvel=SQRT(velx**2+vely**2+velz**2)
   p=lenam**2/mu
   c=lenvel**2/2.0_dp-mu/lenpos
!
!   Semimajor axis in AU.
!
   aout=-mu/(2.0_dp*c)
!
!   Period in days from Kepler's Third Law
!
   periodout=SQRT(4.0_dp*pie*pie*aout**3/mu)
!
!   eccentricity.
!
   eccout=SQRT(1.0_dp-p/aout)
!
!   inclination.
!
   inclout=ACOS(angmz/lenam)
!
!   Omega.
!
   IF(ABS(angmy) > EPSILON(angmy))THEN
      longout=ATAN(-angmx/angmy)
   ELSE
      IF(angmx < 0.0_dp)THEN
         longout=halfpie
      ELSE
         longout=-halfpie
      END IF
   END IF
!
   cwf=(posx*COS(longout)+posy*SIN(longout))/lenpos
   swf=(posz/SIN(inclout))/lenpos
   wf=ATAN2(swf,cwf)
   aa=lenam**2/(mu*lenpos)-1.0_dp
   bb=(lenam*(posx*velx+posy*vely+posz*velz))/(mu*lenpos)
!
!    true anomaly.
!
   f=ATAN2(bb,aa)
   trueout=f
   argperout=wf-f
   fmod=MOD(f,twopie)
   IF(fmod < 0.0_dp)fmod=fmod+twopie
   IF(fmod > pie)THEN
      e=-ACOS((1.0_dp-lenpos/aout)/eccout)
   ELSE
      e=ACOS((1.0_dp-lenpos/aout)/eccout)
   END IF
!
!    mean anomaly.
!
   mnanom=e-eccout*SIN(e)
!
!    get Tconj.
!
   m=trueatomeana(halfpie-argperout,eccout)
   tconjout=tref+(m-mnanom)*periodout/twopie
!
   IF(mnanom < 0.0_dp)mnanom=mnanom+twopie
   IF(trueout < 0.0_dp)trueout=trueout+twopie
   IF(argperout < 0.0_dp)argperout=argperout+twopie
!
   RETURN
!
END SUBROUTINE xyztokep
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION ytran(xx,yy,zz,phase,fincr,q,istar,bdist)
!
!   will return the coordinate of a point (xx,yy,zz) projected on the sky
!
!   (xx,yy,zz) refers to the coordinates in the rotating system
!
   USE accur
   USE getpie
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: xx
   REAL(KIND=dp), INTENT(IN)                :: yy
   REAL(KIND=dp), INTENT(IN)                :: zz
   REAL(KIND=dp), INTENT(IN)                :: phase
   REAL(KIND=dp), INTENT(IN)                :: fincr
   REAL(KIND=dp), INTENT(IN)                :: q
   INTEGER, INTENT(IN)                      :: istar
   REAL(KIND=dp), INTENT(IN)                :: bdist
!
   REAL(KIND=dp)  :: phaser,qphaser,overq,ytran
!
!   CALL getpie(pie,twopie,halfpie,degtorad,radtodeg)
!
   overq=q
   IF(istar == 2)overq=1.0_dp/q
   phaser=phase*degtorad
   qphaser=((phaser))
   ytran=-(-xx*COS(fincr)*COS(qphaser)+yy*COS(fincr)*  &
      SIN(qphaser)-zz*SIN(fincr))+bdist*(-(overq/(1.0_dp+overq))*  &
      COS(fincr)*COS(qphaser))
   RETURN
!
END FUNCTION ytran
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION zdiff(xa,ya,xb,yb,rout,ttt)
!
!   November 2, 1999
!
!   When given two grid points xA,yA,zA and xB,yB,zB, parametric equations
!   in ttt can be written that give the x,y,z coordinates of points along
!   the line joining the two grid points.
!   This function computes the difference between the radius of the
!   x,y coordinates
!   of a point given by ttt
!   on a line joining grid points xA,yA,zA and xB,yB,zB and
!   the radius rout.
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: xa
   REAL(KIND=dp), INTENT(IN)                :: ya
   REAL(KIND=dp), INTENT(IN)                :: xb
   REAL(KIND=dp), INTENT(IN)                :: yb
   REAL(KIND=dp), INTENT(IN)                :: rout
   REAL(KIND=dp), INTENT(IN)                :: ttt
!
   REAL(KIND=dp)  :: t1,t2,t3,zdiff
!
   t1=(xa+(xb-xa)*ttt-xb)**2
   t2=(ya+(yb-ya)*ttt)**2
   t3=0.0_dp
   zdiff=SQRT(t1+t2+t3)-rout
!
   RETURN
!
END FUNCTION zdiff
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
SUBROUTINE zheight(xa,ya,za,xb,yb,zb,rout,zcross)
!
!   This program assumes there are two stars in the normal coordinate
!   frame, and that there is a disk of radius r_outer centered on
!   star 2.  Given a point on star 1 (xA,yA,zA), and on star 2 (xB,yB,zB),
!   this routine determines the z-value of where the line joining the two
!   points crosses the disk edge.
!
!   Use Newton's method to find the t such that dziff=0
!
   USE accur
!
   IMPLICIT NONE
!
   REAL(KIND=dp), INTENT(IN)                :: xa
   REAL(KIND=dp), INTENT(IN)                :: ya
   REAL(KIND=dp), INTENT(IN)                :: za
   REAL(KIND=dp), INTENT(IN)                :: xb
   REAL(KIND=dp), INTENT(IN)                :: yb
   REAL(KIND=dp), INTENT(IN)                :: zb
   REAL(KIND=dp), INTENT(IN)                :: rout
   REAL(KIND=dp), INTENT(OUT)               :: zcross
!
   REAL(KIND=dp) :: tnew,t,z,zprimediff,zdiff
!
   INTEGER :: i
!
   t=0.5_dp
   DO  i=1,6
      tnew=t-zdiff(xa,ya,xb,yb,rout,t)/zprimediff(xa,ya,xb,yb,t)
      t=tnew
   END DO
!
   z=za+(zb-za)*t
!
   zcross=z
!
   RETURN
!
END SUBROUTINE zheight
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
FUNCTION zprimediff(xa,ya,xb,yb,ttt)
!
!   November 2, 1999
!
!   The derivitive wrt to ttt of zdiff given above.
!
   USE accur
!
   IMPLICIT NONE

   REAL(KIND=dp), INTENT(IN)                :: xa
   REAL(KIND=dp), INTENT(IN)                :: ya
   REAL(KIND=dp), INTENT(IN)                :: xb
   REAL(KIND=dp), INTENT(IN)                :: yb
   REAL(KIND=dp), INTENT(IN)                :: ttt
!
   REAL(KIND=dp)   :: t1,t2,t3,t4,t5,t6,zprimediff
!
   t1=(xa+(xb-xa)*ttt-xb)**2
   t2=(ya+(yb-ya)*ttt)**2
   t3=0.0_dp
!
   t4=2.0_dp*(xa+(xb-xa)*ttt-xb)*(xb-xa)
   t5=2.0_dp*(ya+(yb-ya)*ttt)*(yb-ya)
   t6=0.0_dp
!
   zprimediff=0.5_dp*(t4+t5+t6)/SQRT(t1+t2+t3)
!
   RETURN
!
END FUNCTION zprimediff
!
!   !@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()!@#$%^&*()
!
